!function(I){var g={};function n(e){if(g[e])return g[e].exports;var l=g[e]={i:e,l:!1,exports:{}};return I[e].call(l.exports,l,l.exports,n),l.l=!0,l.exports}n.m=I,n.c=g,n.d=function(I,g,e){n.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:e})},n.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},n.t=function(I,g){if(1&g&&(I=n(I)),8&g)return I;if(4&g&&"object"==typeof I&&I&&I.__esModule)return I;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:I}),2&g&&"string"!=typeof I)for(var l in I)n.d(e,l,function(g){return I[g]}.bind(null,l));return e},n.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return n.d(g,"a",g),g},n.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},n.p="",n(n.s=23)}([function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxvQkFBb0I7QUFDbkMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0EiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiAnQG1lZGlhICcgKyBpdGVtWzJdICsgJ3snICsgY29udGVudCArICd9JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW2ldOyAvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuICAgICAgLy8gd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuICAgICAgLy8gSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXG4gICAgICBpZiAoaXRlbVswXSA9PSBudWxsIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSAnKCcgKyBpdGVtWzJdICsgJykgYW5kICgnICsgbWVkaWFRdWVyeSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJztcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcbiAgcmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve "head" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }\n                // }\n                if (typeof target === \'function\') {\n                        return target();\n                }\n                if (typeof memo[target] === "undefined") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(7);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === "object" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error("[Style Loader]\\n\\n Invalid value for parameter \'insertAt\' (\'options.insertAt\') found.\\n Must be \'top\', \'bottom\', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === \'function\'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxDQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQSxLQUFLLEtBQXdDLEVBQUUsRUFFN0M7O0FBRUYsUUFBUSxzQkFBaUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCA/IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpIFxuXHRcdCA6IG9wdGlvbnMudHJhbnNmb3JtLmRlZmF1bHQob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.7\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n  function isUndef (v) {\n    return v === undefined || v === null\n  }\n\n  function isDef (v) {\n    return v !== undefined && v !== null\n  }\n\n  function isTrue (v) {\n    return v === true\n  }\n\n  function isFalse (v) {\n    return v === false\n  }\n\n  /**\n   * Check if value is primitive.\n   */\n  function isPrimitive (value) {\n    return (\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      // $flow-disable-line\n      typeof value === 'symbol' ||\n      typeof value === 'boolean'\n    )\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject (obj) {\n    return obj !== null && typeof obj === 'object'\n  }\n\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType (value) {\n    return _toString.call(value).slice(8, -1)\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject (obj) {\n    return _toString.call(obj) === '[object Object]'\n  }\n\n  function isRegExp (v) {\n    return _toString.call(v) === '[object RegExp]'\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex (val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val)\n  }\n\n  function isPromise (val) {\n    return (\n      isDef(val) &&\n      typeof val.then === 'function' &&\n      typeof val.catch === 'function'\n    )\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString (val) {\n    return val == null\n      ? ''\n      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n        ? JSON.stringify(val, null, 2)\n        : String(val)\n  }\n\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber (val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap (\n    str,\n    expectsLowerCase\n  ) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase\n      ? function (val) { return map[val.toLowerCase()]; }\n      : function (val) { return map[val]; }\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array.\n   */\n  function remove (arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1)\n      }\n    }\n  }\n\n  /**\n   * Check whether an object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn (obj, key) {\n    return hasOwnProperty.call(obj, key)\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached (fn) {\n    var cache = Object.create(null);\n    return (function cachedFn (str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str))\n    })\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase()\n  });\n\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n  function polyfillBind (fn, ctx) {\n    function boundFn (a) {\n      var l = arguments.length;\n      return l\n        ? l > 1\n          ? fn.apply(ctx, arguments)\n          : fn.call(ctx, a)\n        : fn.call(ctx)\n    }\n\n    boundFn._length = fn.length;\n    return boundFn\n  }\n\n  function nativeBind (fn, ctx) {\n    return fn.bind(ctx)\n  }\n\n  var bind = Function.prototype.bind\n    ? nativeBind\n    : polyfillBind;\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray (list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend (to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject (arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res\n  }\n\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n  function noop (a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function (a, b, c) { return false; };\n\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n  var identity = function (_) { return _; };\n\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n  function genStaticKeys (modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || [])\n    }, []).join(',')\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual (a, b) {\n    if (a === b) { return true }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i])\n          })\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime()\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key])\n          })\n        } else {\n          /* istanbul ignore next */\n          return false\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b)\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n  function looseIndexOf (arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) { return i }\n    }\n    return -1\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once (fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    }\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = [\n    'component',\n    'directive',\n    'filter'\n  ];\n\n  var LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch'\n  ];\n\n  /*  */\n\n\n\n  var config = ({\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  });\n\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n  var unicodeLetters = 'a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved (str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F\n  }\n\n  /**\n   * Define a property.\n   */\n  function def (obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = new RegExp((\"[^\" + unicodeLetters + \".$_\\\\d]\"));\n  function parsePath (path) {\n    if (bailRE.test(path)) {\n      return\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\n  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = ({}).watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', ({\n        get: function get () {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      })); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative (Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n  }\n\n  var hasSymbol =\n    typeof Symbol !== 'undefined' && isNative(Symbol) &&\n    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/(function () {\n      function Set () {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has (key) {\n        return this.set[key] === true\n      };\n      Set.prototype.add = function add (key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear () {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }());\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = (noop); // work around flow check\n  var formatComponentName = (noop);\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function (str) { return str\n      .replace(classifyRE, function (c) { return c.toUpperCase(); })\n      .replace(/[-_]/g, ''); };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && (!config.silent)) {\n        console.error((\"[Vue warn]: \" + msg + trace));\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && (!config.silent)) {\n        console.warn(\"[Vue tip]: \" + msg + (\n          vm ? generateComponentTrace(vm) : ''\n        ));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>'\n      }\n      var options = typeof vm === 'function' && vm.cid != null\n        ? vm.options\n        : vm._isVue\n          ? vm.$options || vm.constructor.options\n          : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (\n        (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n        (file && includeFile !== false ? (\" at \" + file) : '')\n      )\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) { res += str; }\n        if (n > 1) { str += str; }\n        n >>= 1;\n      }\n      return res\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree\n          .map(function (vm, i) { return (\"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n              ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n              : formatComponentName(vm))); })\n          .join('\\n')\n      } else {\n        return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep () {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub (sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub (sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify () {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) { return a.id - b.id; });\n    }\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget (target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget () {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n\n  /*  */\n\n  var VNode = function VNode (\n    tag,\n    data,\n    children,\n    text,\n    elm,\n    context,\n    componentOptions,\n    asyncFactory\n  ) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance\n  };\n\n  Object.defineProperties( VNode.prototype, prototypeAccessors );\n\n  var createEmptyVNode = function (text) {\n    if ( text === void 0 ) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node\n  };\n\n  function createTextVNode (val) {\n    return new VNode(undefined, undefined, undefined, String(val))\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode (vnode) {\n    var cloned = new VNode(\n      vnode.tag,\n      vnode.data,\n      // #7975\n      // clone children array to avoid mutating original in case of cloning\n      // a child.\n      vnode.children && vnode.children.slice(),\n      vnode.text,\n      vnode.elm,\n      vnode.context,\n      vnode.componentOptions,\n      vnode.asyncFactory\n    );\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n\n  var methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n  ];\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break\n        case 'splice':\n          inserted = args.slice(2);\n          break\n      }\n      if (inserted) { ob.observeArray(inserted); }\n      // notify change\n      ob.dep.notify();\n      return result\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n  var shouldObserve = true;\n\n  function toggleObserving (value) {\n    shouldObserve = value;\n  }\n\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n  var Observer = function Observer (value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk (obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment (target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment (target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe (value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (\n      shouldObserve &&\n      !isServerRendering() &&\n      (Array.isArray(value) || isPlainObject(value)) &&\n      Object.isExtensible(value) &&\n      !value._isVue\n    ) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive$$1 (\n    obj,\n    key,\n    val,\n    customSetter,\n    shallow\n  ) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter () {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value\n      },\n      set: function reactiveSetter (newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || (newVal !== newVal && value !== value)) {\n          return\n        }\n        /* eslint-enable no-self-compare */\n        if (customSetter) {\n          customSetter();\n        }\n        // #7981: for accessor properties without setter\n        if (getter && !setter) { return }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set (target, key, val) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n        'at runtime - declare it upfront in the data option.'\n      );\n      return val\n    }\n    if (!ob) {\n      target[key] = val;\n      return val\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del (target, key) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid deleting properties on a Vue instance or its root $data ' +\n        '- just set it to null.'\n      );\n      return\n    }\n    if (!hasOwn(target, key)) {\n      return\n    }\n    delete target[key];\n    if (!ob) {\n      return\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray (value) {\n    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\n          \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n          'creation with the `new` keyword.'\n        );\n      }\n      return defaultStrat(parent, child)\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData (to, from) {\n    if (!from) { return to }\n    var key, toVal, fromVal;\n\n    var keys = hasSymbol\n      ? Reflect.ownKeys(from)\n      : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      // in case the object is already observed...\n      if (key === '__ob__') { continue }\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (\n        toVal !== fromVal &&\n        isPlainObject(toVal) &&\n        isPlainObject(fromVal)\n      ) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal\n      }\n      if (!parentVal) {\n        return childVal\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn () {\n        return mergeData(\n          typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n        )\n      }\n    } else {\n      return function mergedInstanceDataFn () {\n        // instance merge\n        var instanceData = typeof childVal === 'function'\n          ? childVal.call(vm, vm)\n          : childVal;\n        var defaultData = typeof parentVal === 'function'\n          ? parentVal.call(vm, vm)\n          : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData)\n        } else {\n          return defaultData\n        }\n      }\n    }\n  }\n\n  strats.data = function (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn(\n          'The \"data\" option should be a function ' +\n          'that returns a per-instance value in component ' +\n          'definitions.',\n          vm\n        );\n\n        return parentVal\n      }\n      return mergeDataOrFn(parentVal, childVal)\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm)\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook (\n    parentVal,\n    childVal\n  ) {\n    var res = childVal\n      ? parentVal\n        ? parentVal.concat(childVal)\n        : Array.isArray(childVal)\n          ? childVal\n          : [childVal]\n      : parentVal;\n    return res\n      ? dedupeHooks(res)\n      : res\n  }\n\n  function dedupeHooks (hooks) {\n    var res = [];\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n    return res\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal)\n    } else {\n      return res\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) { parentVal = undefined; }\n    if (childVal === nativeWatch) { childVal = undefined; }\n    /* istanbul ignore if */\n    if (!childVal) { return Object.create(parentVal || null) }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent\n        ? parent.concat(child)\n        : Array.isArray(child) ? child : [child];\n    }\n    return ret\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props =\n  strats.methods =\n  strats.inject =\n  strats.computed = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) { extend(ret, childVal); }\n    return ret\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined\n      ? parentVal\n      : childVal\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents (options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName (name) {\n    if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeLetters + \"]*$\")).test(name)) {\n      warn(\n        'Invalid component name: \"' + name + '\". Component names ' +\n        'should conform to valid custom element name in html5 specification.'\n      );\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + name\n      );\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps (options, vm) {\n    var props = options.props;\n    if (!props) { return }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val)\n          ? val\n          : { type: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(props)) + \".\",\n        vm\n      );\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject (options, vm) {\n    var inject = options.inject;\n    if (!inject) { return }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val)\n          ? extend({ from: key }, val)\n          : { from: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(inject)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives (options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n        if (typeof def$$1 === 'function') {\n          dirs[key] = { bind: def$$1, update: def$$1 };\n        }\n      }\n    }\n  }\n\n  function assertObjectType (name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\n        \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n        \"but got \" + (toRawType(value)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions (\n    parent,\n    child,\n    vm\n  ) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField (key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset (\n    options,\n    type,\n    id,\n    warnMissing\n  ) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) { return assets[id] }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (warnMissing && !res) {\n      warn(\n        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n        options\n      );\n    }\n    return res\n  }\n\n  /*  */\n\n\n\n  function validateProp (\n    key,\n    propOptions,\n    propsData,\n    vm\n  ) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue (vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      warn(\n        'Invalid default value for prop \"' + key + '\": ' +\n        'Props with type Object/Array must use a factory function ' +\n        'to return the default value.',\n        vm\n      );\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData &&\n      vm.$options.propsData[key] === undefined &&\n      vm._props[key] !== undefined\n    ) {\n      return vm._props[key]\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function'\n      ? def.call(vm)\n      : def\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp (\n    prop,\n    name,\n    value,\n    vm,\n    absent\n  ) {\n    if (prop.required && absent) {\n      warn(\n        'Missing required prop: \"' + name + '\"',\n        vm\n      );\n      return\n    }\n    if (value == null && !prop.required) {\n      return\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(\n        getInvalidTypeMessage(name, value, expectedTypes),\n        vm\n      );\n      return\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn(\n          'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n          vm\n        );\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType (value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    }\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType (fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : ''\n  }\n\n  function isSameType (a, b) {\n    return getType(a) === getType(b)\n  }\n\n  function getTypeIndex (type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  function getInvalidTypeMessage (name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n    message += \", got \" + receivedType + \" \";\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n    return message\n  }\n\n  function styleValue (value, type) {\n    if (type === 'String') {\n      return (\"\\\"\" + value + \"\\\"\")\n    } else if (type === 'Number') {\n      return (\"\" + (Number(value)))\n    } else {\n      return (\"\" + value)\n    }\n  }\n\n  function isExplicable (value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n  }\n\n  function isBoolean () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n  }\n\n  /*  */\n\n  function handleError (err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n      if (vm) {\n        var cur = vm;\n        while ((cur = cur.$parent)) {\n          var hooks = cur.$options.errorCaptured;\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n                if (capture) { return }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling (\n    handler,\n    context,\n    args,\n    vm,\n    info\n  ) {\n    var res;\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n      if (res && !res._isVue && isPromise(res)) {\n        // issue #9511\n        // reassign to res to avoid catch triggering multiple times when nested calls\n        res = res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n    return res\n  }\n\n  function globalHandleError (err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info)\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError (err, vm, info) {\n    {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n\n  /*  */\n\n  var isUsingMicroTask = false;\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n  var timerFunc;\n\n  // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function () {\n      p.then(flushCallbacks);\n      // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Techinically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (\n      perf &&\n      perf.mark &&\n      perf.measure &&\n      perf.clearMarks &&\n      perf.clearMeasures\n    ) {\n      mark = function (tag) { return perf.mark(tag); };\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        // perf.clearMeasures(name)\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap(\n      'Infinity,undefined,NaN,isFinite,isNaN,' +\n      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n      'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\n        \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n        'referenced during render. Make sure that this property is reactive, ' +\n        'either in the data option, or for class-based components, by ' +\n        'initializing the property. ' +\n        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n        target\n      );\n    };\n\n    var warnReservedPrefix = function (target, key) {\n      warn(\n        \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n        'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n        'prevent conflicts with Vue internals' +\n        'See: https://vuejs.org/v2/api/#data',\n        target\n      );\n    };\n\n    var hasProxy =\n      typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set (target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n            return false\n          } else {\n            target[key] = value;\n            return true\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has (target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) ||\n          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n        if (!has && !isAllowed) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return has || !isAllowed\n      }\n    };\n\n    var getHandler = {\n      get: function get (target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return target[key]\n      }\n    };\n\n    initProxy = function initProxy (vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped\n          ? getHandler\n          : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse (val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse (val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n      return\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) { _traverse(val[i], seen); }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) { _traverse(val[keys[i]], seen); }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    }\n  });\n\n  function createFnInvoker (fns, vm) {\n    function invoker () {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n      }\n    }\n    invoker.fns = fns;\n    return invoker\n  }\n\n  function updateListeners (\n    on,\n    oldOn,\n    add,\n    remove$$1,\n    createOnceHandler,\n    vm\n  ) {\n    var name, def$$1, cur, old, event;\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      if (isUndef(cur)) {\n        warn(\n          \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n          vm\n        );\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook (def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook () {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData (\n    data,\n    Ctor,\n    tag\n  ) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (\n            key !== keyInLowerCase &&\n            attrs && hasOwn(attrs, keyInLowerCase)\n          ) {\n            tip(\n              \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n              (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n              \" \\\"\" + key + \"\\\". \" +\n              \"Note that HTML attributes are case-insensitive and camelCased \" +\n              \"props need to use their kebab-case equivalents when using in-DOM \" +\n              \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n            );\n          }\n        }\n        checkProp(res, props, key, altKey, true) ||\n        checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res\n  }\n\n  function checkProp (\n    res,\n    hash,\n    key,\n    altKey,\n    preserve\n  ) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren (children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children)\n      }\n    }\n    return children\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren (children) {\n    return isPrimitive(children)\n      ? [createTextVNode(children)]\n      : Array.isArray(children)\n        ? normalizeArrayChildren(children)\n        : undefined\n  }\n\n  function isTextNode (node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n  }\n\n  function normalizeArrayChildren (children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') { continue }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) &&\n            isDef(c.tag) &&\n            isUndef(c.key) &&\n            isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  function initProvide (vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function'\n        ? provide.call(vm)\n        : provide;\n    }\n  }\n\n  function initInjections (vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\n              \"Avoid mutating an injected value directly since the changes will be \" +\n              \"overwritten whenever the provided component re-renders. \" +\n              \"injection being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject (inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        // #6574 in case the inject object is observed...\n        if (key === '__ob__') { continue }\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function'\n              ? provideDefault.call(vm)\n              : provideDefault;\n          } else {\n            warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n          }\n        }\n      }\n      return result\n    }\n  }\n\n  /*  */\n\n\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots (\n    children,\n    context\n  ) {\n    if (!children || !children.length) {\n      return {}\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) &&\n        data && data.slot != null\n      ) {\n        var name = data.slot;\n        var slot = (slots[name] || (slots[name] = []));\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots\n  }\n\n  function isWhitespace (node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' '\n  }\n\n  /*  */\n\n  function normalizeScopedSlots (\n    slots,\n    normalSlots,\n    prevSlots\n  ) {\n    var res;\n    var isStable = slots ? !!slots.$stable : true;\n    var key = slots && slots.$key;\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized\n    } else if (\n      isStable &&\n      prevSlots &&\n      prevSlots !== emptyObject &&\n      key === prevSlots.$key &&\n      Object.keys(normalSlots).length === 0\n    ) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots\n    } else {\n      res = {};\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    }\n    // expose normal slots on scopedSlots\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (slots && Object.isExtensible(slots)) {\n      (slots)._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    return res\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function () {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && typeof res === 'object' && !Array.isArray(res)\n        ? [res] // single vnode\n        : normalizeChildren(res);\n      return res && res.length === 0\n        ? undefined\n        : res\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n    return normalized\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () { return slots[key]; }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n    if (!isDef(ret)) {\n      ret = [];\n    }\n    (ret)._isVList = true;\n    return ret\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn(\n            'slot v-bind without argument expects an Object',\n            this\n          );\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes)\n    } else {\n      return nodes\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  }\n\n  /*  */\n\n  function isKeyNotMatch (expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1\n    } else {\n      return expect !== actual\n    }\n  }\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInKeyCode,\n    eventKeyName,\n    builtInKeyName\n  ) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName)\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps (\n    data,\n    tag,\n    value,\n    asProp,\n    isSync\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function ( key ) {\n          if (\n            key === 'class' ||\n            key === 'style' ||\n            isReservedAttribute(key)\n          ) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n          }\n          var camelizedKey = camelize(key);\n          if (!(key in hash) && !(camelizedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[(\"update:\" + camelizedKey)] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop( key );\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic (\n    index,\n    isInFor\n  ) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n      return tree\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(\n      this._renderProxy,\n      null,\n      this // for render fns generated for functional component templates\n    );\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  }\n\n  function markStatic (\n    tree,\n    key,\n    isOnce\n  ) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners (data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn(\n          'v-on without argument expects an Object value',\n          this\n        );\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  function resolveScopedSlots (\n    fns, // see flow/vnode\n    res,\n    // the following are added in 2.6\n    hasDynamicKeys,\n    contentHashKey\n  ) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n        res[slot.key] = slot.fn;\n      }\n    }\n    if (contentHashKey) {\n      (res).$key = contentHashKey;\n    }\n    return res\n  }\n\n  /*  */\n\n  function bindDynamicKeys (baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a speical value for explicitly removing a binding\n        warn(\n          (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n          this\n        );\n      }\n    }\n    return baseObj\n  }\n\n  // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n  function prependModifier (value, symbol) {\n    return typeof value === 'string' ? symbol + value : value\n  }\n\n  /*  */\n\n  function installRenderHelpers (target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext (\n    data,\n    props,\n    children,\n    parent,\n    Ctor\n  ) {\n    var this$1 = this;\n\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent);\n      // $flow-disable-line\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent;\n      // $flow-disable-line\n      parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(\n          data.scopedSlots,\n          this$1.$slots = resolveSlots(children, parent)\n        );\n      }\n      return this$1.$slots\n    };\n\n    Object.defineProperty(this, 'scopedSlots', ({\n      enumerable: true,\n      get: function get () {\n        return normalizeScopedSlots(data.scopedSlots, this.slots())\n      }\n    }));\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode\n      };\n    } else {\n      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent (\n    Ctor,\n    propsData,\n    data,\n    contextVm,\n    children\n  ) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n      if (isDef(data.props)) { mergeProps(props, data.props); }\n    }\n\n    var renderContext = new FunctionalRenderContext(\n      data,\n      props,\n      children,\n      contextVm,\n      Ctor\n    );\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n      return res\n    }\n  }\n\n  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone\n  }\n\n  function mergeProps (to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  // inline hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init (vnode, hydrating) {\n      if (\n        vnode.componentInstance &&\n        !vnode.componentInstance._isDestroyed &&\n        vnode.data.keepAlive\n      ) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(\n          vnode,\n          activeInstance\n        );\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n\n    prepatch: function prepatch (oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n      );\n    },\n\n    insert: function insert (vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy (vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent (\n    Ctor,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    if (isUndef(Ctor)) {\n      return\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n      }\n      return\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(\n          asyncFactory,\n          data,\n          context,\n          children,\n          tag\n        )\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children)\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\n      (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n      data, undefined, undefined, undefined, context,\n      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n      asyncFactory\n    );\n\n    return vnode\n  }\n\n  function createComponentInstanceForVnode (\n    vnode, // we know it's MountedComponentVNode but flow doesn't\n    parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options)\n  }\n\n  function installComponentHooks (data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1 (f1, f2) {\n    var merged = function (a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n    merged._merged = true;\n    return merged\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel (options, data) {\n    var prop = (options.model && options.model.prop) || 'value';\n    var event = (options.model && options.model.event) || 'input'\n    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n    if (isDef(existing)) {\n      if (\n        Array.isArray(existing)\n          ? existing.indexOf(callback) === -1\n          : existing !== callback\n      ) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType,\n    alwaysNormalize\n  ) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType)\n  }\n\n  function _createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType\n  ) {\n    if (isDef(data) && isDef((data).__ob__)) {\n      warn(\n        \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n        'Always create fresh vnode data objects in each render!',\n        context\n      );\n      return createEmptyVNode()\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode()\n    }\n    // warn against non-primitive key\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n    ) {\n      {\n        warn(\n          'Avoid using non-primitive value as key, ' +\n          'use string/number value instead.',\n          context\n        );\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) &&\n      typeof children[0] === 'function'\n    ) {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(\n          config.parsePlatformTagName(tag), data, children,\n          undefined, undefined, context\n        );\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(\n          tag, data, children,\n          undefined, undefined, context\n        );\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (Array.isArray(vnode)) {\n      return vnode\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) { applyNS(vnode, ns); }\n      if (isDef(data)) { registerDeepBindings(data); }\n      return vnode\n    } else {\n      return createEmptyVNode()\n    }\n  }\n\n  function applyNS (vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (\n          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n  function registerDeepBindings (data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n\n  /*  */\n\n  function initRender (vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin (Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this)\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n          _parentVnode.data.scopedSlots,\n          vm.$slots,\n          vm.$scopedSlots\n        );\n      }\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        // There's no need to maintain a stack becaues all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      }\n      // if the returned array contains only a single node, allow it\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn(\n            'Multiple root nodes returned from render function. Render function ' +\n            'should return a single root node.',\n            vm\n          );\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode\n    };\n  }\n\n  /*  */\n\n  function ensureCtor (comp, base) {\n    if (\n      comp.__esModule ||\n      (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n    ) {\n      comp = comp.default;\n    }\n    return isObject(comp)\n      ? base.extend(comp)\n      : comp\n  }\n\n  function createAsyncPlaceholder (\n    factory,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node\n  }\n\n  function resolveAsyncComponent (\n    factory,\n    baseCtor\n  ) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp\n    }\n\n    var owner = currentRenderingInstance;\n    if (isDef(factory.owners)) {\n      // already pending\n      factory.owners.push(owner);\n    } else {\n      var owners = factory.owners = [owner];\n      var sync = true;\n\n      var forceRender = function (renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          (owners[i]).$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n\n      var reject = once(function (reason) {\n        warn(\n          \"Failed to resolve async component: \" + (String(factory)) +\n          (reason ? (\"\\nReason: \" + reason) : '')\n        );\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              setTimeout(function () {\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            setTimeout(function () {\n              if (isUndef(factory.resolved)) {\n                reject(\n                  \"timeout (\" + (res.timeout) + \"ms)\"\n                );\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading\n        ? factory.loadingComp\n        : factory.resolved\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder (node) {\n    return node.isComment && node.asyncFactory\n  }\n\n  /*  */\n\n  function getFirstComponentChild (children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents (vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add (event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1 (event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler (event, fn) {\n    var _target = target;\n    return function onceHandler () {\n      var res = fn.apply(null, arguments);\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    }\n  }\n\n  function updateComponentListeners (\n    vm,\n    listeners,\n    oldListeners\n  ) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin (Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on () {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n        return vm\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\n            \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n            (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and you cannot use \" +\n            \"v-on to listen to camelCase events when using in-DOM templates. \" +\n            \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n          );\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n      return vm\n    };\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    }\n  }\n\n  function initLifecycle (vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin (Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      restoreActiveInstance();\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent (\n    vm,\n    el,\n    hydrating\n  ) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n          vm.$options.el || el) {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'compiler is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure((\"vue \" + name + \" patch\"), startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, {\n      before: function before () {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  }\n\n  function updateChildComponent (\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(\n      (newScopedSlots && !newScopedSlots.$stable) ||\n      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n    );\n\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    var needsForceUpdate = !!(\n      renderChildren ||               // has new static slots\n      vm.$options._renderChildren ||  // has old static slots\n      hasDynamicScopedSlot\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n      toggleObserving(true);\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree (vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) { return true }\n    }\n    return false\n  }\n\n  function activateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    } else if (vm._directInactive) {\n      return\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook (vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n    popTarget();\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState () {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n  var currentFlushTimestamp = 0;\n\n  // Async edge case fix requires storing an event listener's attach timestamp.\n  var getNow = Date.now;\n\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {\n    // if the low-res timestamp which is bigger than the event timestamp\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listeners as well.\n    getNow = function () { return performance.now(); };\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue () {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) { return a.id - b.id; });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      if (watcher.before) {\n        watcher.before();\n      }\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn(\n            'You may have an infinite update loop ' + (\n              watcher.user\n                ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n                : \"in a component render function.\"\n            ),\n            watcher.vm\n          );\n          break\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks (queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent (vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks (queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher (watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return\n        }\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher (\n    vm,\n    expOrFn,\n    cb,\n    options,\n    isRenderWatcher\n  ) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\n          \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        );\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get () {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep (dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps () {\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this.deps[i];\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run () {\n    if (this.active) {\n      var value = this.get();\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate () {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend () {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy (target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter () {\n      return this[sourceKey][key]\n    };\n    sharedPropertyDefinition.set = function proxySetter (val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState (vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) { initProps(vm, opts.props); }\n    if (opts.methods) { initMethods(vm, opts.methods); }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) { initComputed(vm, opts.computed); }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps (vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n    var loop = function ( key ) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) ||\n            config.isReservedAttr(hyphenatedKey)) {\n          warn(\n            (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n            vm\n          );\n        }\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\n              \"Avoid mutating a prop directly since the value will be \" +\n              \"overwritten whenever the parent component re-renders. \" +\n              \"Instead, use a data or computed property based on the prop's \" +\n              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop( key );\n    toggleObserving(true);\n  }\n\n  function initData (vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function'\n      ? getData(data, vm)\n      : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      warn(\n        'data functions should return an object:\\n' +\n        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n        vm\n      );\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n            vm\n          );\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n          \"Use prop default value instead.\",\n          vm\n        );\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData (data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n      return data.call(vm, vm)\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {}\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed (vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (getter == null) {\n        warn(\n          (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(\n          vm,\n          getter || noop,\n          noop,\n          computedWatcherOptions\n        );\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed (\n    target,\n    key,\n    userDef\n  ) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get\n        ? shouldCache && userDef.cache !== false\n          ? createComputedGetter(key)\n          : createGetterInvoker(userDef.get)\n        : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\n          (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n          this\n        );\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter (key) {\n    return function computedGetter () {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value\n      }\n    }\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter () {\n      return fn.call(this, this)\n    }\n  }\n\n  function initMethods (vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\n            \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n            \"Did you reference the function correctly?\",\n            vm\n          );\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n            vm\n          );\n        }\n        if ((key in vm) && isReserved(key)) {\n          warn(\n            \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n            \"Avoid defining component methods that start with _ or $.\"\n          );\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch (vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher (\n    vm,\n    expOrFn,\n    handler,\n    options\n  ) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options)\n  }\n\n  function stateMixin (Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () { return this._data };\n    var propsDef = {};\n    propsDef.get = function () { return this._props };\n    {\n      dataDef.set = function () {\n        warn(\n          'Avoid replacing instance root $data. ' +\n          'Use nested data properties instead.',\n          this\n        );\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (\n      expOrFn,\n      cb,\n      options\n    ) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options)\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n        }\n      }\n      return function unwatchFn () {\n        watcher.teardown();\n      }\n    };\n  }\n\n  /*  */\n\n  var uid$3 = 0;\n\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$3++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + (vm._uid);\n        endTag = \"vue-perf-end:\" + (vm._uid);\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(\n          resolveConstructorOptions(vm.constructor),\n          options || {},\n          vm\n        );\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent (vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions (Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options\n  }\n\n  function resolveModifiedOptions (Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) { modified = {}; }\n        modified[key] = latest[key];\n      }\n    }\n    return modified\n  }\n\n  function Vue (options) {\n    if (!(this instanceof Vue)\n    ) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  /*  */\n\n  function initUse (Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initMixin$1 (Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initExtend (Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId]\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent (options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(\n        Super.options,\n        extendOptions\n      );\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub\n    };\n  }\n\n  function initProps$1 (Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1 (Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters (Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (\n        id,\n        definition\n      ) {\n        if (!definition) {\n          return this.options[type + 's'][id]\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition\n        }\n      };\n    });\n  }\n\n  /*  */\n\n\n\n  function getComponentName (opts) {\n    return opts && (opts.Ctor.options.name || opts.tag)\n  }\n\n  function matches (pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name)\n    }\n    /* istanbul ignore next */\n    return false\n  }\n\n  function pruneCache (keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry (\n    cache,\n    key,\n    keys,\n    current\n  ) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created () {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed () {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n\n    mounted: function mounted () {\n      var this$1 = this;\n\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) { return matches(val, name); });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) { return !matches(val, name); });\n      });\n    },\n\n    render: function render () {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n          // not included\n          (include && (!name || !matches(include, name))) ||\n          // excluded\n          (exclude && name && matches(exclude, name))\n        ) {\n          return vnode\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n          // same constructor may get registered as different local components\n          // so cid alone is not enough (#3269)\n          ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n          : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || (slot && slot[0])\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI (Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () { return config; };\n    {\n      configDef.set = function () {\n        warn(\n          'Do not replace the Vue.config object, set individual fields instead.'\n        );\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    // 2.6 explicit observable API\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get () {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext\n    }\n  });\n\n  // expose FunctionalRenderContext for ssr runtime helper installation\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n\n  Vue.version = '2.6.7';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function (tag, type, attr) {\n    return (\n      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n      (attr === 'selected' && tag === 'option') ||\n      (attr === 'checked' && tag === 'input') ||\n      (attr === 'muted' && tag === 'video')\n    )\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false'\n      ? 'false'\n      // allow arbitrary string value for contenteditable\n      : key === 'contenteditable' && isValidContentEditableValue(value)\n        ? value\n        : 'true'\n  };\n\n  var isBooleanAttr = makeMap(\n    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,translate,' +\n    'truespeed,typemustmatch,visible'\n  );\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : ''\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false\n  };\n\n  /*  */\n\n  function genClassForVnode (vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class)\n  }\n\n  function mergeClassData (child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class)\n        ? [child.class, parent.class]\n        : parent.class\n    }\n  }\n\n  function renderClass (\n    staticClass,\n    dynamicClass\n  ) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass))\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function concat (a, b) {\n    return a ? b ? (a + ' ' + b) : a : (b || '')\n  }\n\n  function stringifyClass (value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value)\n    }\n    if (isObject(value)) {\n      return stringifyObject(value)\n    }\n    if (typeof value === 'string') {\n      return value\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function stringifyArray (value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) { res += ' '; }\n        res += stringified;\n      }\n    }\n    return res\n  }\n\n  function stringifyObject (value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) { res += ' '; }\n        res += key;\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap(\n    'html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot'\n  );\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap(\n    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n    true\n  );\n\n  var isPreTag = function (tag) { return tag === 'pre'; };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag)\n  };\n\n  function getTagNamespace (tag) {\n    if (isSVG(tag)) {\n      return 'svg'\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math'\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement (tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true\n    }\n    if (isReservedTag(tag)) {\n      return false\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag]\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return (unknownElementCache[tag] = (\n        el.constructor === window.HTMLUnknownElement ||\n        el.constructor === window.HTMLElement\n      ))\n    } else {\n      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query (el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        warn(\n          'Cannot find element: ' + el\n        );\n        return document.createElement('div')\n      }\n      return selected\n    } else {\n      return el\n    }\n  }\n\n  /*  */\n\n  function createElement$1 (tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm\n  }\n\n  function createElementNS (namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName)\n  }\n\n  function createTextNode (text) {\n    return document.createTextNode(text)\n  }\n\n  function createComment (text) {\n    return document.createComment(text)\n  }\n\n  function insertBefore (parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild (node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild (node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode (node) {\n    return node.parentNode\n  }\n\n  function nextSibling (node) {\n    return node.nextSibling\n  }\n\n  function tagName (node) {\n    return node.tagName\n  }\n\n  function setTextContent (node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope (node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create (_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update (oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy (vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef (vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!isDef(key)) { return }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode (a, b) {\n    return (\n      a.key === b.key && (\n        (\n          a.tag === b.tag &&\n          a.isComment === b.isComment &&\n          isDef(a.data) === isDef(b.data) &&\n          sameInputType(a, b)\n        ) || (\n          isTrue(a.isAsyncPlaceholder) &&\n          a.asyncFactory === b.asyncFactory &&\n          isUndef(b.asyncFactory.error)\n        )\n      )\n    )\n  }\n\n  function sameInputType (a, b) {\n    if (a.tag !== 'input') { return true }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n  }\n\n  function createKeyToOldIdx (children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) { map[key] = i; }\n    }\n    return map\n  }\n\n  function createPatchFunction (backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt (elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n    }\n\n    function createRmCb (childElm, listeners) {\n      function remove$$1 () {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove$$1.listeners = listeners;\n      return remove$$1\n    }\n\n    function removeNode (el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1 (vnode, inVPre) {\n      return (\n        !inVPre &&\n        !vnode.ns &&\n        !(\n          config.ignoredElements.length &&\n          config.ignoredElements.some(function (ignore) {\n            return isRegExp(ignore)\n              ? ignore.test(vnode.tag)\n              : ignore === vnode.tag\n          })\n        ) &&\n        config.isUnknownElement(vnode.tag)\n      )\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm (\n      vnode,\n      insertedVnodeQueue,\n      parentElm,\n      refElm,\n      nested,\n      ownerArray,\n      index\n    ) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn(\n              'Unknown custom element: <' + tag + '> - did you ' +\n              'register the component correctly? For recursive components, ' +\n              'make sure to provide the \"name\" option.',\n              vnode.context\n            );\n          }\n        }\n\n        vnode.elm = vnode.ns\n          ? nodeOps.createElementNS(vnode.ns, tag)\n          : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true\n        }\n      }\n    }\n\n    function initComponent (vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert (parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren (vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable (vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag)\n    }\n\n    function invokeCreateHooks (vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) { i.create(emptyNode, vnode); }\n        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope (vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        i !== vnode.fnContext &&\n        isDef(i = i.$options._scopeId)\n      ) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook (vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else { // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook (vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n          idxInOld = isDef(newStartVnode.key)\n            ? oldKeyToIdx[newStartVnode.key]\n            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) { // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys (children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\n              (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n              vnode.context\n            );\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld (node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) { return i }\n      }\n    }\n\n    function patchVnode (\n      oldVnode,\n      vnode,\n      insertedVnodeQueue,\n      ownerArray,\n      index,\n      removeOnly\n    ) {\n      if (oldVnode === vnode) {\n        return\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n      ) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n      }\n    }\n\n    function invokeInsertHook (vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || (data && data.pre);\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true\n    }\n\n    function assertNodeMatch (node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || (\n          !isUnknownElement$$1(vnode, inVPre) &&\n          vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n        )\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3)\n      }\n    }\n\n    return function patch (oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n        return\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode\n              } else {\n                warn(\n                  'The client-side rendered virtual DOM tree is not matching ' +\n                  'server-rendered content. This is likely caused by incorrect ' +\n                  'HTML markup, for example nesting block-level elements inside ' +\n                  '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                  'full client-side render.'\n                );\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(\n            vnode,\n            insertedVnodeQueue,\n            // extremely rare edge case: do not insert if old element is in a\n            // leaving transition. Only happens when combining transition +\n            // keep-alive + HOCs. (#4590)\n            oldElm._leaveCb ? null : parentElm,\n            nodeOps.nextSibling(oldElm)\n          );\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm)) {\n            removeVnodes(parentElm, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm\n    }\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives (vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives (oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update (oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1 (\n    dirs,\n    vm\n  ) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res\n  }\n\n  function getRawDirName (dir) {\n    return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n  }\n\n  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n      }\n    }\n  }\n\n  var baseModules = [\n    ref,\n    directives\n  ];\n\n  /*  */\n\n  function updateAttrs (oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr (el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n          ? 'true'\n          : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr (el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (\n        isIE && !isIE9 &&\n        el.tagName === 'TEXTAREA' &&\n        key === 'placeholder' && value !== '' && !el.__ieph\n      ) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass (oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (\n      isUndef(data.staticClass) &&\n      isUndef(data.class) && (\n        isUndef(oldData) || (\n          isUndef(oldData.staticClass) &&\n          isUndef(oldData.class)\n        )\n      )\n    ) {\n      return\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters (exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n      } else if (\n        c === 0x7C && // pipe\n        exp.charCodeAt(i + 1) !== 0x7C &&\n        exp.charCodeAt(i - 1) !== 0x7C &&\n        !curly && !square && !paren\n      ) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22: inDouble = true; break         // \"\n          case 0x27: inSingle = true; break         // '\n          case 0x60: inTemplateString = true; break // `\n          case 0x28: paren++; break                 // (\n          case 0x29: paren--; break                 // )\n          case 0x5B: square++; break                // [\n          case 0x5D: square--; break                // ]\n          case 0x7B: curly++; break                 // {\n          case 0x7D: curly--; break                 // }\n        }\n        if (c === 0x2f) { // /\n          var j = i - 1;\n          var p = (void 0);\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') { break }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter () {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression\n  }\n\n  function wrapFilter (exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n    }\n  }\n\n  /*  */\n\n\n\n  /* eslint-disable no-unused-vars */\n  function baseWarn (msg, range) {\n    console.error((\"[Vue compiler]: \" + msg));\n  }\n  /* eslint-enable no-unused-vars */\n\n  function pluckModuleFunction (\n    modules,\n    key\n  ) {\n    return modules\n      ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n      : []\n  }\n\n  function addProp (el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  function addAttr (el, name, value, range, dynamic) {\n    var attrs = dynamic\n      ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n      : (el.attrs || (el.attrs = []));\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr (el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n  }\n\n  function addDirective (\n    el,\n    name,\n    rawName,\n    value,\n    arg,\n    isDynamicArg,\n    modifiers,\n    range\n  ) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker (symbol, name, dynamic) {\n    return dynamic\n      ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n      : symbol + name // mark the event as captured\n  }\n\n  function addHandler (\n    el,\n    name,\n    value,\n    modifiers,\n    important,\n    warn,\n    range,\n    dynamic\n  ) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\n      warn &&\n      modifiers.prevent && modifiers.passive\n    ) {\n      warn(\n        'passive and prevent can\\'t be used together. ' +\n        'Passive handler can\\'t prevent default event.',\n        range\n      );\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr (\n    el,\n    name\n  ) {\n    return el.rawAttrsMap[':' + name] ||\n      el.rawAttrsMap['v-bind:' + name] ||\n      el.rawAttrsMap[name]\n  }\n\n  function getBindingAttr (\n    el,\n    name,\n    getStatic\n  ) {\n    var dynamicValue =\n      getAndRemoveAttr(el, ':' + name) ||\n      getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue)\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue)\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr (\n    el,\n    name,\n    removeFromMap\n  ) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val\n  }\n\n  function getAndRemoveAttrByRegex (\n    el,\n    name\n  ) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr\n      }\n    }\n  }\n\n  function rangeSetItem (\n    item,\n    range\n  ) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n    return item\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression =\n        \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: (\"(\" + value + \")\"),\n      expression: JSON.stringify(value),\n      callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode (\n    value,\n    assignment\n  ) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return (value + \"=\" + assignment)\n    } else {\n      return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\n  function parseModel (val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        }\n      } else {\n        return {\n          exp: val,\n          key: null\n        }\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    }\n  }\n\n  function next () {\n    return str.charCodeAt(++index$1)\n  }\n\n  function eof () {\n    return index$1 >= len\n  }\n\n  function isStringStart (chr) {\n    return chr === 0x22 || chr === 0x27\n  }\n\n  function parseBracket (chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue\n      }\n      if (chr === 0x5B) { inBracket++; }\n      if (chr === 0x5D) { inBracket--; }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break\n      }\n    }\n  }\n\n  function parseString (chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model (\n    el,\n    dir,\n    _warn\n  ) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n          \"File inputs are read only. Use a v-on:change listener instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"v-model is not supported on this element type. \" +\n        'If you are working with contenteditable, it\\'s recommended to ' +\n        'wrap a library dedicated for that purpose inside a custom component.',\n        el.rawAttrsMap['v-model']\n      );\n    }\n\n    // ensure runtime directive metadata\n    return true\n  }\n\n  function genCheckboxModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked',\n      \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n    );\n    addHandler(el, 'change',\n      \"var $$a=\" + value + \",\" +\n          '$$el=$event.target,' +\n          \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n      'if(Array.isArray($$a)){' +\n        \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n            '$$i=_i($$a,$$v);' +\n        \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n        \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n      \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n      null, true\n    );\n  }\n\n  function genRadioModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n    addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" +\n      \".call($event.target.options,function(o){return o.selected})\" +\n      \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n      \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + (genAssignmentCode(value, assignment));\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(\n          binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n          'because the latter already expands to a value binding internally',\n          el.rawAttrsMap[binding]\n        );\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy\n      ? 'change'\n      : type === 'range'\n        ? RANGE_TOKEN\n        : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', (\"(\" + value + \")\"));\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents (on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1 (event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler () {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    }\n  }\n\n  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1 (\n    name,\n    handler,\n    capture,\n    passive\n  ) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n      handler = original._wrapper = function (e) {\n        if (\n          // no bubbling, should always fire.\n          // this is just a safety net in case event.timeStamp is unreliable in\n          // certain weird environments...\n          e.target === e.currentTarget ||\n          // event is fired after handler attachment\n          e.timeStamp >= attachedTimestamp ||\n          // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState\n          e.timeStamp === 0 ||\n          // #9448 bail if event is fired in another document in a multi-page\n          // electron/nw.js app, since event.timeStamp will be using a different\n          // starting reference\n          e.target.ownerDocument !== document\n        ) {\n          return original.apply(this, arguments)\n        }\n      };\n    }\n    target$1.addEventListener(\n      name,\n      handler,\n      supportsPassive\n        ? { capture: capture, passive: passive }\n        : capture\n    );\n  }\n\n  function remove$2 (\n    name,\n    handler,\n    capture,\n    _target\n  ) {\n    (_target || target$1).removeEventListener(\n      name,\n      handler._wrapper || handler,\n      capture\n    );\n  }\n\n  function updateDOMListeners (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (isUndef(props[key])) {\n        elm[key] = '';\n      }\n    }\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) { vnode.children.length = 0; }\n        if (cur === oldProps[key]) { continue }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if (\n        // skip the update if old and new VDOM state is the same.\n        // `value` is handled separately because the DOM value may be temporarily\n        // out of sync with VDOM state due to focus, composition and modifiers.\n        // This  #4521 by skipping the unnecesarry `checked` update.\n        cur !== oldProps[key]\n      ) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue (elm, checkVal) {\n    return (!elm.composing && (\n      elm.tagName === 'OPTION' ||\n      isNotInFocusAndDirty(elm, checkVal) ||\n      isDirtyWithModifiers(elm, checkVal)\n    ))\n  }\n\n  function isNotInFocusAndDirty (elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try { notInFocus = document.activeElement !== elm; } catch (e) {}\n    return notInFocus && elm.value !== checkVal\n  }\n\n  function isDirtyWithModifiers (elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal)\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim()\n      }\n    }\n    return value !== newVal\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData (data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle\n      ? extend(data.staticStyle, style)\n      : style\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding (bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle)\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle)\n    }\n    return bindingStyle\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle (vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (\n          childNode && childNode.data &&\n          (styleData = normalizeStyleData(childNode.data))\n        ) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if ((styleData = normalizeStyleData(vnode.data))) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while ((parentNode = parentNode.parent)) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && (prop in emptyStyle)) {\n      return prop\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name\n      }\n    }\n  });\n\n  function updateStyle (oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) &&\n      isUndef(oldData.staticStyle) && isUndef(oldData.style)\n    ) {\n      return\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__)\n      ? extend({}, style)\n      : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition (def$$1) {\n    if (!def$$1) {\n      return\n    }\n    /* istanbul ignore else */\n    if (typeof def$$1 === 'object') {\n      var res = {};\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n      extend(res, def$$1);\n      return res\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1)\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: (name + \"-enter\"),\n      enterToClass: (name + \"-enter-to\"),\n      enterActiveClass: (name + \"-enter-active\"),\n      leaveClass: (name + \"-leave\"),\n      leaveToClass: (name + \"-leave-to\"),\n      leaveActiveClass: (name + \"-leave-active\")\n    }\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined &&\n      window.onwebkittransitionend !== undefined\n    ) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined &&\n      window.onwebkitanimationend !== undefined\n    ) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser\n    ? window.requestAnimationFrame\n      ? window.requestAnimationFrame.bind(window)\n      : setTimeout\n    : /* istanbul ignore next */ function (fn) { return fn(); };\n\n  function nextFrame (fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass (el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass (el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds (\n    el,\n    expectedType,\n    cb\n  ) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) { return cb() }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo (el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0\n        ? transitionTimeout > animationTimeout\n          ? TRANSITION\n          : ANIMATION\n        : null;\n      propCount = type\n        ? type === TRANSITION\n          ? transitionDurations.length\n          : animationDurations.length\n        : 0;\n    }\n    var hasTransform =\n      type === TRANSITION &&\n      transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    }\n  }\n\n  function getTimeout (delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i])\n    }))\n  }\n\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n  function toMs (s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000\n  }\n\n  /*  */\n\n  function enter (vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      transitionNode = transitionNode.parent;\n      context = transitionNode.context;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return\n    }\n\n    var startClass = isAppear && appearClass\n      ? appearClass\n      : enterClass;\n    var activeClass = isAppear && appearActiveClass\n      ? appearActiveClass\n      : enterActiveClass;\n    var toClass = isAppear && appearToClass\n      ? appearToClass\n      : enterToClass;\n\n    var beforeEnterHook = isAppear\n      ? (beforeAppear || beforeEnter)\n      : beforeEnter;\n    var enterHook = isAppear\n      ? (typeof appear === 'function' ? appear : enter)\n      : enter;\n    var afterEnterHook = isAppear\n      ? (afterAppear || afterEnter)\n      : afterEnter;\n    var enterCancelledHook = isAppear\n      ? (appearCancelled || enterCancelled)\n      : enterCancelled;\n\n    var explicitEnterDuration = toNumber(\n      isObject(duration)\n        ? duration.enter\n        : duration\n    );\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb\n        ) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave (vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm()\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(\n      isObject(duration)\n        ? duration.leave\n        : duration\n    );\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave () {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return\n      }\n      // record leaving element\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration (val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\n        \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n        \"got \" + (JSON.stringify(val)) + \".\",\n        vnode.context\n      );\n    } else if (isNaN(val)) {\n      warn(\n        \"<transition> explicit \" + name + \" duration is NaN - \" +\n        'the duration expression might be incorrect.',\n        vnode.context\n      );\n    }\n  }\n\n  function isValidDuration (val) {\n    return typeof val === 'number' && !isNaN(val)\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength (fn) {\n    if (isUndef(fn)) {\n      return false\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(\n        Array.isArray(invokerFns)\n          ? invokerFns[0]\n          : invokerFns\n      )\n    } else {\n      return (fn._length || fn.length) > 1\n    }\n  }\n\n  function _enter (_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1 (vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [\n    attrs,\n    klass,\n    events,\n    domProps,\n    style,\n    transition\n  ];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted (el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated (el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple\n            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected (el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected (el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\n        \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n        \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n        vm\n      );\n      return\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption (value, options) {\n    return options.every(function (o) { return !looseEqual(o, value); })\n  }\n\n  function getValue (option) {\n    return '_value' in option\n      ? option._value\n      : option.value\n  }\n\n  function onCompositionStart (e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd (e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) { return }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger (el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode (vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n      ? locateNode(vnode.componentInstance._vnode)\n      : vnode\n  }\n\n  var show = {\n    bind: function bind (el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay =\n        el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update (el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (!value === !oldValue) { return }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind (\n      el,\n      binding,\n      vnode,\n      oldVnode,\n      isDestroy\n    ) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild (vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children))\n    } else {\n      return vnode\n    }\n  }\n\n  function extractTransitionData (comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data\n  }\n\n  function placeholder (h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      })\n    }\n  }\n\n  function hasParentTransition (vnode) {\n    while ((vnode = vnode.parent)) {\n      if (vnode.data.transition) {\n        return true\n      }\n    }\n  }\n\n  function isSameChild (child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag\n  }\n\n  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\n  var isVShowDirective = function (d) { return d.name === 'show'; };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render (h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n      if (!children.length) {\n        return\n      }\n\n      // warn multiple elements\n      if (children.length > 1) {\n        warn(\n          '<transition> can only be used on a single element. Use ' +\n          '<transition-group> for lists.',\n          this.$parent\n        );\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (mode && mode !== 'in-out' && mode !== 'out-in'\n      ) {\n        warn(\n          'invalid <transition> mode: ' + mode,\n          this.$parent\n        );\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild)\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + (this._uid) + \"-\";\n      child.key = child.key == null\n        ? child.isComment\n          ? id + 'comment'\n          : id + child.tag\n        : isPrimitive(child.key)\n          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n          : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (\n        oldChild &&\n        oldChild.data &&\n        !isSameChild(child, oldChild) &&\n        !isAsyncPlaceholder(oldChild) &&\n        // #6687 component root is a comment node\n        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n      ) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild)\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild\n          }\n          var delayedLeave;\n          var performLeave = function () { delayedLeave(); };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n        }\n      }\n\n      return rawChild\n    }\n  };\n\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    beforeMount: function beforeMount () {\n      var this$1 = this;\n\n      var update = this._update;\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1);\n        // force removing pass\n        this$1.__patch__(\n          this$1._vnode,\n          this$1.kept,\n          false, // hydrating\n          true // removeOnly (!important, avoids unnecessary moves)\n        );\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n\n    render: function render (h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c\n            ;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n            warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children)\n    },\n\n    updated: function updated () {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n            if (e && e.target !== el) {\n              return\n            }\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove (el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return (this._hasMove = info.hasTransform)\n      }\n    }\n  };\n\n  function callPendingCbs (c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition (c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation (c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating)\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log'](\n            'Download the Vue Devtools extension for a better development experience:\\n' +\n            'https://github.com/vuejs/vue-devtools'\n          );\n        }\n      }\n      if (config.productionTip !== false &&\n        typeof console !== 'undefined'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          \"You are running Vue in development mode.\\n\" +\n          \"Make sure to turn on production mode when deploying for production.\\n\" +\n          \"See more tips at https://vuejs.org/guide/deployment.html\"\n        );\n      }\n    }, 0);\n  }\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n  });\n\n\n\n  function parseText (\n    text,\n    delimiters\n  ) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while ((match = tagRE.exec(text))) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push((\"_s(\" + exp + \")\"));\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    }\n  }\n\n  /*  */\n\n  function transformNode (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\n          \"class=\\\"\" + staticClass + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n          el.rawAttrsMap['class']\n        );\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData (el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + (el.staticClass) + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + (el.classBinding) + \",\";\n    }\n    return data\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1 (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\n            \"style=\\\"\" + staticStyle + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n            el.rawAttrsMap['style']\n          );\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1 (el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + (el.staticStyle) + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + (el.styleBinding) + \"),\";\n    }\n    return data\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode (html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent\n    }\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap(\n    'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n    'link,meta,param,source,track,wbr'\n  );\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap(\n    'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n  );\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap(\n    'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n    'title,tr,track'\n  );\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeLetters + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp((\"^<\" + qnameCapture));\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  // #7298: escape - to avoid being pased as HTML comment when inlined in page\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\n  function decodeAttr (value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) { return decodingMap[match]; })\n  }\n\n  function parseHTML (html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('--\x3e');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n              advance(commentEnd + 3);\n              continue\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n            continue\n          }\n        }\n\n        var text = (void 0), rest = (void 0), next = (void 0);\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (\n            !endTag.test(rest) &&\n            !startTagOpen.test(rest) &&\n            !comment.test(rest) &&\n            !conditionalComment.test(rest)\n          ) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) { break }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text\n              .replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n              .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return ''\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (!stack.length && options.warn) {\n          options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n        }\n        break\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance (n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag () {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match\n        }\n      }\n    }\n\n    function handleStartTag (match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n          ? options.shouldDecodeNewlinesForHref\n          : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag (tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) { start = index; }\n      if (end == null) { end = index; }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName &&\n            options.warn\n          ) {\n            options.warn(\n              (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n              { start: stack[i].start }\n            );\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.]+/g;\n\n  var slotRE = /^v-slot(:|$)|^#/;\n\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  var emptySlotScopeToken = \"_empty_\";\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement (\n    tag,\n    attrs,\n    parent\n  ) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    }\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse (\n    template,\n    options\n  ) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n    maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce (msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement (element) {\n      trimEndingWhitespace(element);\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      }\n      // tree management\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\",\n            { start: element.start }\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"'\n            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n\n      // final children cleanup\n      // filter out scoped slots\n      element.children = element.children.filter(function (c) { return !(c).slotScope; });\n      // remove trailing whitespace node again\n      trimEndingWhitespace(element);\n\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace (el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n        while (\n          (lastNode = el.children[el.children.length - 1]) &&\n          lastNode.type === 3 &&\n          lastNode.text === ' '\n        ) {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints (el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\n          \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n          'contain multiple nodes.',\n          { start: el.start }\n        );\n      }\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce(\n          'Cannot use v-for on stateful component root element because ' +\n          'it renders multiple elements.',\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start (tag, attrs, unary, start$1) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated\n            }, {});\n          }\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\n                \"Invalid dynamic argument expression: attribute names cannot contain \" +\n                \"spaces, quotes, <, >, / or =.\",\n                {\n                  start: attr.start + attr.name.indexOf(\"[\"),\n                  end: attr.start + attr.name.length\n                }\n              );\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2(\n            'Templates should only be responsible for mapping the state to the ' +\n            'UI. Avoid placing tags with side-effects in your templates, such as ' +\n            \"<\" + tag + \">\" + ', as they will not be parsed.',\n            { start: element.start }\n          );\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end (tag, start, end$1) {\n        var element = stack[stack.length - 1];\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n        closeElement(element);\n      },\n\n      chars: function chars (text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce(\n                'Component template requires a root element, rather than just text.',\n                { start: start }\n              );\n            } else if ((text = text.trim())) {\n              warnOnce(\n                (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n                { start: start }\n              );\n            }\n          }\n          return\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text\n        ) {\n          return\n        }\n        var children = currentParent.children;\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n        if (text) {\n          if (whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n          var res;\n          var child;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment (text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root\n  }\n\n  function processPre (el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs (el) {\n    var list = el.attrsList;\n    var len = list.length;\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement (\n    element,\n    options\n  ) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = (\n      !element.key &&\n      !element.scopedSlots &&\n      !element.attrsList.length\n    );\n\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element\n  }\n\n  function processKey (el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\n            \"<template> cannot be keyed. Place the key on real elements instead.\",\n            getRawBindingAttr(el, 'key')\n          );\n        }\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\n              \"Do not use v-for index as key on <transition-group> children, \" +\n              \"this is the same as not using keys.\",\n              getRawBindingAttr(el, 'key'),\n              true /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef (el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor (el) {\n    var exp;\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\n          (\"Invalid v-for expression: \" + exp),\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n  }\n\n\n\n  function parseFor (exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) { return }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res\n  }\n\n  function processIf (el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions (el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\n        \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n        \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n        el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n      );\n    }\n  }\n\n  function findPrevElement (children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i]\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\n            \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n            \"will be ignored.\",\n            children[i]\n          );\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition (el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce (el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n  function processSlotContent (el) {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          el.rawAttrsMap['scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          el.rawAttrsMap['slot-scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n\n    // slot=\"xxx\"\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    }\n\n    // 2.6 v-slot syntax\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\n                \"<template v-slot> can only appear at the root level inside \" +\n                \"the receiving the component\",\n                el\n              );\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\n                \"v-slot can only be used on components or <template>.\",\n                slotBinding$1\n              );\n            }\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.scopedSlots) {\n              warn$2(\n                \"To avoid scope ambiguity, the default slot should also use \" +\n                \"<template> syntax when there are other named slots.\",\n                slotBinding$1\n              );\n            }\n          }\n          // add the component's children to its default slot\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n          // remove children as they are returned from scopedSlots now\n          el.children = [];\n          // mark el non-plain so data gets generated\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName (binding) {\n    var name = binding.name.replace(slotRE, '');\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\n          \"v-slot shorthand syntax requires a slot name.\",\n          binding\n        );\n      }\n    }\n    return dynamicArgRE.test(name)\n      // dynamic [name]\n      ? { name: name.slice(1, -1), dynamic: true }\n      // static name\n      : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n  }\n\n  // handle <slot/> outlets\n  function processSlotOutlet (el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (el.key) {\n        warn$2(\n          \"`key` does not work on <slot> because slots are abstract outlets \" +\n          \"and can possibly expand into multiple elements. \" +\n          \"Use the key on a wrapping element instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n    }\n  }\n\n  function processComponent (el) {\n    var binding;\n    if ((binding = getBindingAttr(el, 'is'))) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs (el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name.replace(dirRE, ''));\n        // support .foo shorthand syntax for the .prop modifier\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) { // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          if (\n            value.trim().length === 0\n          ) {\n            warn$2(\n              (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n            );\n          }\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n              if (name === 'innerHtml') { name = 'innerHTML'; }\n            }\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n              if (!isDynamic) {\n                addHandler(\n                  el,\n                  (\"update:\" + (camelize(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(\n                    el,\n                    (\"update:\" + (hyphenate(name))),\n                    syncGen,\n                    null,\n                    false,\n                    warn$2,\n                    list[i]\n                  );\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(\n                  el,\n                  (\"\\\"update:\\\"+(\" + name + \")\"),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i],\n                  true // dynamic\n                );\n              }\n            }\n          }\n          if ((modifiers && modifiers.prop) || (\n            !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n          )) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) { // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else { // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(\n              name + \"=\\\"\" + value + \"\\\": \" +\n              'Interpolation inside attributes has been removed. ' +\n              'Use v-bind or the colon shorthand instead. For example, ' +\n              'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n              list[i]\n            );\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]);\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component &&\n            name === 'muted' &&\n            platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor (el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true\n      }\n      parent = parent.parent;\n    }\n    return false\n  }\n\n  function parseModifiers (name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) { ret[m.slice(1)] = true; });\n      return ret\n    }\n  }\n\n  function makeAttrsMap (attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\n        map[attrs[i].name] && !isIE && !isEdge\n      ) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag (el) {\n    return el.tag === 'script' || el.tag === 'style'\n  }\n\n  function isForbiddenTag (el) {\n    return (\n      el.tag === 'style' ||\n      (el.tag === 'script' && (\n        !el.attrsMap.type ||\n        el.attrsMap.type === 'text/javascript'\n      ))\n    )\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug (attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res\n  }\n\n  function checkForAliasModel (el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n          \"You are binding v-model directly to a v-for iteration alias. \" +\n          \"This will not be able to modify the v-for source array because \" +\n          \"writing to the alias is like modifying a function local variable. \" +\n          \"Consider using an array of objects and use v-model on an object property instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  function preTransformNode (el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (!map['v-model']) {\n        return\n      }\n\n      var typeBinding;\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + (map['v-bind']) + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0\n      }\n    }\n  }\n\n  function cloneASTElement (el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [\n    klass$1,\n    style$1,\n    model$1\n  ];\n\n  /*  */\n\n  function text (el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  /*  */\n\n  function html (el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize (root, options) {\n    if (!root) { return }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1 (keys) {\n    return makeMap(\n      'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n      (keys ? ',' + keys : '')\n    )\n  }\n\n  function markStatic$1 (node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (\n        !isPlatformReservedTag(node.tag) &&\n        node.tag !== 'slot' &&\n        node.attrsMap['inline-template'] == null\n      ) {\n        return\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots (node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(\n        node.children.length === 1 &&\n        node.children[0].type === 3\n      )) {\n        node.staticRoot = true;\n        return\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic (node) {\n    if (node.type === 2) { // expression\n      return false\n    }\n    if (node.type === 3) { // text\n      return true\n    }\n    return !!(node.pre || (\n      !node.hasBindings && // no dynamic bindings\n      !node.if && !node.for && // not v-if or v-for or v-else\n      !isBuiltInTag(node.tag) && // not a built-in\n      isPlatformReservedTag(node.tag) && // not a component\n      !isDirectChildOfTemplateFor(node) &&\n      Object.keys(node).every(isStaticKey)\n    ))\n  }\n\n  function isDirectChildOfTemplateFor (node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false\n      }\n      if (node.for) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n  // KeyboardEvent.keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // KeyboardEvent.key aliases\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers (\n    events,\n    isNative\n  ) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n    staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n    } else {\n      return prefix + staticHandlers\n    }\n  }\n\n  function genHandler (handler) {\n    if (!handler) {\n      return 'function(){}'\n    }\n\n    if (Array.isArray(handler)) {\n      return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value\n      }\n      return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = (handler.modifiers);\n          genModifierCode += genGuard(\n            ['ctrl', 'shift', 'alt', 'meta']\n              .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n              .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n              .join('||')\n          );\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath\n        ? (\"return \" + (handler.value) + \"($event)\")\n        : isFunctionExpression\n          ? (\"return (\" + (handler.value) + \")($event)\")\n          : isFunctionInvocation\n            ? (\"return \" + (handler.value))\n            : handler.value;\n      return (\"function($event){\" + code + handlerCode + \"}\")\n    }\n  }\n\n  function genKeyFilter (keys) {\n    return (\n      // make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" +\n      (keys.map(genFilterCode).join('&&')) + \")return null;\"\n    )\n  }\n\n  function genFilterCode (key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return (\"$event.keyCode!==\" + keyVal)\n    }\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return (\n      \"_k($event.keyCode,\" +\n      (JSON.stringify(key)) + \",\" +\n      (JSON.stringify(keyCode)) + \",\" +\n      \"$event.key,\" +\n      \"\" + (JSON.stringify(keyName)) +\n      \")\"\n    )\n  }\n\n  /*  */\n\n  function on (el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n  }\n\n  /*  */\n\n  function bind$1 (el, dir) {\n    el.wrapData = function (code) {\n      return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n\n\n\n\n  var CodegenState = function CodegenState (options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n\n\n  function generate (\n    ast,\n    options\n  ) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: (\"with(this){return \" + code + \"}\"),\n      staticRenderFns: state.staticRenderFns\n    }\n  }\n\n  function genElement (el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state)\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state)\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state)\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0'\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state)\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n        if (!el.plain || (el.pre && state.maybeComponent(el))) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic (el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    var originalPreState = state.pre;\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n    state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n    state.pre = originalPreState;\n    return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n  }\n\n  // v-once\n  function genOnce (el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        state.warn(\n          \"v-once can only be used inside v-for that is keyed. \",\n          el.rawAttrsMap['v-once']\n        );\n        return genElement(el, state)\n      }\n      return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n    } else {\n      return genStatic(el, state)\n    }\n  }\n\n  function genIf (\n    el,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n  }\n\n  function genIfConditions (\n    conditions,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    if (!conditions.length) {\n      return altEmpty || '_e()'\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n    } else {\n      return (\"\" + (genTernaryExp(condition.block)))\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp (el) {\n      return altGen\n        ? altGen(el, state)\n        : el.once\n          ? genOnce(el, state)\n          : genElement(el, state)\n    }\n  }\n\n  function genFor (\n    el,\n    state,\n    altGen,\n    altHelper\n  ) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n    var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n    if (state.maybeComponent(el) &&\n      el.tag !== 'slot' &&\n      el.tag !== 'template' &&\n      !el.key\n    ) {\n      state.warn(\n        \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n        \"v-for should have explicit keys. \" +\n        \"See https://vuejs.org/guide/list.html#key for more info.\",\n        el.rawAttrsMap['v-for'],\n        true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" +\n      \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n        \"return \" + ((altGen || genElement)(el, state)) +\n      '})'\n  }\n\n  function genData$2 (el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) { data += dirs + ','; }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + (el.key) + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + (el.ref) + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:\" + (genProps(el.props)) + \",\";\n    }\n    // event handlers\n    if (el.events) {\n      data += (genHandlers(el.events, false)) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += (genHandlers(el.nativeEvents, true)) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + (el.slotTarget) + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data\n  }\n\n  function genDirectives (el, state) {\n    var dirs = el.directives;\n    if (!dirs) { return }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']'\n    }\n  }\n\n  function genInlineTemplate (el, state) {\n    var ast = el.children[0];\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn(\n        'Inline-template components must have exactly one child element.',\n        { start: el.start }\n      );\n    }\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n    }\n  }\n\n  function genScopedSlots (\n    el,\n    slots,\n    state\n  ) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return (\n        slot.slotTargetDynamic ||\n        slot.if ||\n        slot.for ||\n        containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      )\n    });\n\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    var needsKey = !!el.if;\n\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n      while (parent) {\n        if (\n          (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n          parent.for\n        ) {\n          needsForceUpdate = true;\n          break\n        }\n        if (parent.if) {\n          needsKey = true;\n        }\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots)\n      .map(function (key) { return genScopedSlot(slots[key], state); })\n      .join(',');\n\n    return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n    while(i) {\n      hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0\n  }\n\n  function containsSlotChild (el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true\n      }\n      return el.children.some(containsSlotChild)\n    }\n    return false\n  }\n\n  function genScopedSlot (\n    el,\n    state\n  ) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\")\n    }\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot)\n    }\n    var slotScope = el.slotScope === emptySlotScopeToken\n      ? \"\"\n      : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" +\n      \"return \" + (el.tag === 'template'\n        ? el.if && isLegacySyntax\n          ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n          : genChildren(el, state) || 'undefined'\n        : genElement(el, state)) + \"}\";\n    // reverse proxy v-slot without scope on this.$slots\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n  }\n\n  function genChildren (\n    el,\n    state,\n    checkSkip,\n    altGenElement,\n    altGenNode\n  ) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot'\n      ) {\n        var normalizationType = checkSkip\n          ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n          : \"\";\n        return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n      }\n      var normalizationType$1 = checkSkip\n        ? getNormalizationType(children, state.maybeComponent)\n        : 0;\n      var gen = altGenNode || genNode;\n      return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType (\n    children,\n    maybeComponent\n  ) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue\n      }\n      if (needsNormalization(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n        res = 2;\n        break\n      }\n      if (maybeComponent(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n        res = 1;\n      }\n    }\n    return res\n  }\n\n  function needsNormalization (el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n  }\n\n  function genNode (node, state) {\n    if (node.type === 1) {\n      return genElement(node, state)\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node)\n    } else {\n      return genText(node)\n    }\n  }\n\n  function genText (text) {\n    return (\"_v(\" + (text.type === 2\n      ? text.expression // no need for () because already wrapped in _s()\n      : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n  }\n\n  function genComment (comment) {\n    return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n  }\n\n  function genSlot (el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n    var attrs = el.attrs || el.dynamicAttrs\n      ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n          // slot props are camelized\n          name: camelize(attr.name),\n          value: attr.value,\n          dynamic: attr.dynamic\n        }); }))\n      : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')'\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent (\n    componentName,\n    el,\n    state\n  ) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n  }\n\n  function genProps (props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n      if (prop.dynamic) {\n        dynamicProps += (prop.name) + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n      }\n    }\n    staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n    if (dynamicProps) {\n      return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n    } else {\n      return staticProps\n    }\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines (text) {\n    return text\n      .replace(/\\u2028/g, '\\\\u2028')\n      .replace(/\\u2029/g, '\\\\u2029')\n  }\n\n  /*  */\n\n\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + (\n    'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n    'super,throw,while,yield,delete,export,import,return,switch,default,' +\n    'extends,finally,continue,debugger,function,arguments'\n  ).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + (\n    'delete,typeof,void'\n  ).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors (ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode (node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            var range = node.rawAttrsMap[name];\n            if (name === 'v-for') {\n              checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            } else {\n              checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent (exp, text, warn, range) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\n        \"avoid using JavaScript unary operator as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n        range\n      );\n    }\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor (node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier (\n    ident,\n    type,\n    text,\n    warn,\n    range\n  ) {\n    if (typeof ident === 'string') {\n      try {\n        new Function((\"var \" + ident + \"=_\"));\n      } catch (e) {\n        warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n      }\n    }\n  }\n\n  function checkExpression (exp, text, warn, range) {\n    try {\n      new Function((\"return \" + exp));\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        warn(\n          \"avoid using JavaScript keyword as property name: \" +\n          \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n          range\n        );\n      } else {\n        warn(\n          \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n          \"    \" + exp + \"\\n\\n\" +\n          \"  Raw expression: \" + (text.trim()) + \"\\n\",\n          range\n        );\n      }\n    }\n  }\n\n  /*  */\n\n  var range = 2;\n\n  function generateCodeFrame (\n    source,\n    start,\n    end\n  ) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = source.length;\n\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) { continue }\n          res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n          var lineLength = lines[j].length;\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break\n      }\n    }\n    return res.join('\\n')\n  }\n\n  function repeat$1 (str, n) {\n    var result = '';\n    if (n > 0) {\n      while (true) { // eslint-disable-line\n        if (n & 1) { result += str; }\n        n >>>= 1;\n        if (n <= 0) { break }\n        str += str;\n      }\n    }\n    return result\n  }\n\n  /*  */\n\n\n\n  function createFunction (code, errors) {\n    try {\n      return new Function(code)\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop\n    }\n  }\n\n  function createCompileToFunctionFn (compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions (\n      template,\n      options,\n      vm\n    ) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1(\n              'It seems you are using the standalone build of Vue.js in an ' +\n              'environment with Content Security Policy that prohibits unsafe-eval. ' +\n              'The template compiler cannot work in this environment. Consider ' +\n              'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n              'templates into render functions.'\n            );\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters\n        ? String(options.delimiters) + template\n        : template;\n      if (cache[key]) {\n        return cache[key]\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\n                \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n                generateCodeFrame(template, e.start, e.end),\n                vm\n              );\n            });\n          } else {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n              compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n              vm\n            );\n          }\n        }\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n          } else {\n            compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n          }\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors)\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\n            \"Failed to generate render function:\\n\\n\" +\n            fnGenErrors.map(function (ref) {\n              var err = ref.err;\n              var code = ref.code;\n\n              return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n          }).join('\\n'),\n            vm\n          );\n        }\n      }\n\n      return (cache[key] = res)\n    }\n  }\n\n  /*  */\n\n  function createCompilerCreator (baseCompile) {\n    return function createCompiler (baseOptions) {\n      function compile (\n        template,\n        options\n      ) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function (msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function (msg, range, tip) {\n              var data = { msg: msg };\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n              (tip ? tips : errors).push(data);\n            };\n          }\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules =\n              (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(\n              Object.create(baseOptions.directives || null),\n              options.directives\n            );\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      }\n    }\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile (\n    template,\n    options\n  ) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    }\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode (href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      warn(\n        \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n      );\n      return this\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (!template) {\n              warn(\n                (\"Template element not found or is empty: \" + (options.template)),\n                this\n              );\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile end');\n          measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating)\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML (el) {\n    if (el.outerHTML) {\n      return el.outerHTML\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0), __webpack_require__(4).setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzP2JhNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLFNBQ2lEO0FBQ25ELENBQUMsb0JBQW9COztBQUVyQjs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZELHdCQUF3QixpQkFBaUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDLEVBQUU7QUFDdkYsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyx5Q0FBeUMsd0JBQXdCLEVBQUU7QUFDbkUsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQixFQUFFO0FBQ3ZEO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVMscUJBQXFCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHNDQUFzQztBQUN0QztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MscUNBQXFDLEVBQUU7QUFDdEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyx5Q0FBeUMsRUFBRTtBQUNqRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNEQUFzRCxFQUFFO0FBQzlGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxpQ0FBaUM7QUFDckUsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQWlDO0FBQ3JFLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUNBQXVDLGdFQUFnRTtBQUN2RztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLCtCQUErQjtBQUM3RCw4QkFBOEIsK0JBQStCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUZBQXVGO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQixFQUFFOztBQUV0RDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRCx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLDJCQUEyQixFQUFFO0FBQ3pFLE9BQU87QUFDUDtBQUNBLDRDQUE0Qyw0QkFBNEIsRUFBRTtBQUMxRSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHNCQUFzQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQsT0FBTztBQUNQLDBDQUEwQyxrQkFBa0I7QUFDNUQsT0FBTztBQUNQLDBDQUEwQywwQkFBMEI7QUFDcEUsT0FBTztBQUNQLDBDQUEwQyxpQkFBaUI7QUFDM0QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyw2Q0FBNkM7QUFDN0MsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZSxFQUFFLHVCQUF1QixVQUFVLEVBQUU7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCw2Q0FBNkM7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkM7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxLQUFLO0FBQ0wsMkNBQTJDO0FBQzNDOztBQUVBLG1DQUFtQyx3Q0FBd0M7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0Qyx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkYsOEJBQThCO0FBQzlCO0FBQ0EsNkJBQTZCO0FBQzdCLDBCQUEwQixpRUFBaUU7QUFDM0YsY0FBYywwRkFBMEY7QUFDeEcsUUFBUSxLQUFLLDBDQUEwQztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakUsd0JBQXdCLCtDQUErQztBQUN2RSxtREFBbUQ7O0FBRW5EO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0IsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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KiBWdWUuanMgdjIuNi43XG4gKiAoYykgMjAxNC0yMDE5IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyogICovXG5cbiAgdmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbiAgLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4gIC8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG4gIGZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gICAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICAgIHJldHVybiB2ID09PSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICAgKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gICAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICAgKi9cbiAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG4gIH1cblxuICAvKipcbiAgICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICAgKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gIH1cblxuICBmdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICAgIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG4gIH1cblxuICBmdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICAgIHJldHVybiAoXG4gICAgICBpc0RlZih2YWwpICYmXG4gICAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAqL1xuICBmdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgICA/ICcnXG4gICAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgICAgOiBTdHJpbmcodmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICAgKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gICAqIGlzIGluIHRoYXQgbWFwLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZU1hcCAoXG4gICAgc3RyLFxuICAgIGV4cGVjdHNMb3dlckNhc2VcbiAgKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAgICovXG4gIHZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gICAqL1xuICB2YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICAgKi9cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gICAqL1xuICB2YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbiAgdmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gICAqL1xuICB2YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuICB9KTtcblxuICAvKipcbiAgICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAgICovXG4gIHZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG4gIHZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAgICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gICAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gICAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZXR1cm4gbFxuICAgICAgICA/IGwgPiAxXG4gICAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgICA6IGZuLmNhbGwoY3R4KVxuICAgIH1cblxuICAgIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICByZXR1cm4gYm91bmRGblxuICB9XG5cbiAgZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICAgIHJldHVybiBmbi5iaW5kKGN0eClcbiAgfVxuXG4gIHZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgICA/IG5hdGl2ZUJpbmRcbiAgICA6IHBvbHlmaWxsQmluZDtcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICAgIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0b1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICAgKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAgICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuICAvKipcbiAgICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICovXG4gIHZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICovXG4gIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gICAgfSwgW10pLmpvaW4oJywnKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICAgKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gICAqL1xuICBmdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gICAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICAgKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxuICB2YXIgQVNTRVRfVFlQRVMgPSBbXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2RpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcidcbiAgXTtcblxuICB2YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCcsXG4gICAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAgICdzZXJ2ZXJQcmVmZXRjaCdcbiAgXTtcblxuICAvKiAgKi9cblxuXG5cbiAgdmFyIGNvbmZpZyA9ICh7XG4gICAgLyoqXG4gICAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAgICovXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICAgKi9cbiAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICAgKi9cbiAgICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAgICovXG4gICAgZGV2dG9vbHM6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgICAqL1xuICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAgICovXG4gICAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAgICovXG4gICAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICAgKi9cbiAgICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgICAqL1xuICAgIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAgICovXG4gICAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgbXVzdFVzZVByb3A6IG5vLFxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAgICovXG4gICAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1NcbiAgfSk7XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAgICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAgICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICAgKi9cbiAgdmFyIHVuaWNvZGVMZXR0ZXJzID0gJ2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQnO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAgICovXG4gIGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICAgIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbCxcbiAgICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gICAqL1xuICB2YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgdW5pY29kZUxldHRlcnMgKyBcIi4kX1xcXFxkXVwiKSk7XG4gIGZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICAgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuICB2YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuICAvLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG4gIHZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG4gIHZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbiAgdmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG4gIHZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbiAgdmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuICB2YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuICB2YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbiAgdmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG4gIHZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuICAvLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG4gIHZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbiAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4gIC8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG4gIHZhciBfaXNTZXJ2ZXI7XG4gIHZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9pc1NlcnZlclxuICB9O1xuXG4gIC8vIGRldGVjdCBkZXZ0b29sc1xuICB2YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbiAgfVxuXG4gIHZhciBoYXNTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuICB2YXIgX1NldDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICAgIF9TZXQgPSBTZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICAgIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICAgIH07XG4gICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZXQ7XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciB3YXJuID0gbm9vcDtcbiAgdmFyIHRpcCA9IG5vb3A7XG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG4gIHZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG4gIHtcbiAgICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgICAgPyB2bS5vcHRpb25zXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgICAgOiB2bTtcbiAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICAgIClcbiAgICB9O1xuXG4gICAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICAgIHZhciByZXMgPSAnJztcbiAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICAgIG4gPj49IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciB1aWQgPSAwO1xuXG4gIC8qKlxuICAgKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAgICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAgICovXG4gIHZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICAgIHRoaXMuaWQgPSB1aWQrKztcbiAgICB0aGlzLnN1YnMgPSBbXTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gICAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBEZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAvLyBvcmRlclxuICAgICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbiAgLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4gIC8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuICBEZXAudGFyZ2V0ID0gbnVsbDtcbiAgdmFyIHRhcmdldFN0YWNrID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICAgIHRhcmdldFN0YWNrLnBvcCgpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICB0ZXh0LFxuICAgIGVsbSxcbiAgICBjb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgYXN5bmNGYWN0b3J5XG4gICkge1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5lbG0gPSBlbG07XG4gICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICAgIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gICAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICAgIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG4gIH1cblxuICAvLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuICAvLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4gIC8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuICAvLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuICBmdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICAgIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgICB2bm9kZS50YWcsXG4gICAgICB2bm9kZS5kYXRhLFxuICAgICAgLy8gIzc5NzVcbiAgICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgICAgLy8gYSBjaGlsZC5cbiAgICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgICB2bm9kZS50ZXh0LFxuICAgICAgdm5vZGUuZWxtLFxuICAgICAgdm5vZGUuY29udGV4dCxcbiAgICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgICApO1xuICAgIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICAgIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICAgIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gICAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICAgIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gICAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICAgIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgLypcbiAgICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gICAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICAgKi9cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgdmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbiAgdmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAgICdwdXNoJyxcbiAgICAncG9wJyxcbiAgICAnc2hpZnQnLFxuICAgICd1bnNoaWZ0JyxcbiAgICAnc3BsaWNlJyxcbiAgICAnc29ydCcsXG4gICAgJ3JldmVyc2UnXG4gIF07XG5cbiAgLyoqXG4gICAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICAgKi9cbiAgbWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICAgIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0pO1xuICB9KTtcblxuICAvKiAgKi9cblxuICB2YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuICAvKipcbiAgICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gICAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAgICovXG4gIHZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuICBmdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gICAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICAgKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gICAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gICAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICAgKi9cbiAgdmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gICAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAgICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICB9XG5cbiAgLyoqXG4gICAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gICAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gICAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gICAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG9iO1xuICAgIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgICAgb2IgPSB2YWx1ZS5fX29iX187XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICAgIXZhbHVlLl9pc1Z1ZVxuICAgICkge1xuICAgICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgICAgb2Iudm1Db3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gb2JcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gICAgb2JqLFxuICAgIGtleSxcbiAgICB2YWwsXG4gICAgY3VzdG9tU2V0dGVyLFxuICAgIHNoYWxsb3dcbiAgKSB7XG4gICAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICAgIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gICAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgICBpZiAoY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgICBkZXAubm90aWZ5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gICAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAgICogYWxyZWFkeSBleGlzdC5cbiAgICovXG4gIGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICAgIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICAgICkge1xuICAgICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICAgICk7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIGlmICghb2IpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIGZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgICApIHtcbiAgICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIGlmICghb2IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAgICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBlID0gdmFsdWVbaV07XG4gICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gICAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gICAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICAgKi9cbiAgdmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAgICovXG4gIHtcbiAgICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICAgIGlmICghdm0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICAgIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICAgIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgICApIHtcbiAgICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvXG4gIH1cblxuICAvKipcbiAgICogRGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtXG4gICkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICAgIH1cbiAgICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgICAgfVxuICAgICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtXG4gICkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG4gIH07XG5cbiAgLyoqXG4gICAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsXG4gICkge1xuICAgIHZhciByZXMgPSBjaGlsZFZhbFxuICAgICAgPyBwYXJlbnRWYWxcbiAgICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICAgIDogW2NoaWxkVmFsXVxuICAgICAgOiBwYXJlbnRWYWw7XG4gICAgcmV0dXJuIHJlc1xuICAgICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgICA6IHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBc3NldHNcbiAgICpcbiAgICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICAgKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gICAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH1cblxuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBXYXRjaGVycy5cbiAgICpcbiAgICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICAgKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAgICovXG4gIHN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm0sXG4gICAga2V5XG4gICkge1xuICAgIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gICAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgICB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgICB2YXIgcmV0ID0ge307XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgICB9XG4gICAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9O1xuXG4gIC8qKlxuICAgKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICAgKi9cbiAgc3RyYXRzLnByb3BzID1cbiAgc3RyYXRzLm1ldGhvZHMgPVxuICBzdHJhdHMuaW5qZWN0ID1cbiAgc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgICByZXR1cm4gcmV0XG4gIH07XG4gIHN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuICAvKipcbiAgICogRGVmYXVsdCBzdHJhdGVneS5cbiAgICovXG4gIHZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHBhcmVudFZhbFxuICAgICAgOiBjaGlsZFZhbFxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICAgIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArIHVuaWNvZGVMZXR0ZXJzICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIG5hbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICAgKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBpLCB2YWwsIG5hbWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgICA/IHZhbFxuICAgICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gICAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICAgIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gICAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICAgIHZhciBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gICAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICAgIHBhcmVudCxcbiAgICBjaGlsZCxcbiAgICB2bVxuICApIHtcbiAgICB7XG4gICAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICB9XG5cbiAgICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gICAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAgIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gICAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICAgIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFzc2V0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAgICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgICBvcHRpb25zLFxuICAgIHR5cGUsXG4gICAgaWQsXG4gICAgd2Fybk1pc3NpbmdcbiAgKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICAgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICAgIGlmICh3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAgICBrZXksXG4gICAgcHJvcE9wdGlvbnMsXG4gICAgcHJvcHNEYXRhLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gICAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gICAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gICAgfVxuICAgIHtcbiAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gICAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAgIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICAgIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICAgIH1cbiAgICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAgIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICAgID8gZGVmLmNhbGwodm0pXG4gICAgICA6IGRlZlxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICAgIHByb3AsXG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICB2bSxcbiAgICBhYnNlbnRcbiAgKSB7XG4gICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgd2FybihcbiAgICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuICBmdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICAgIHZhciB2YWxpZDtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogdmFsaWQsXG4gICAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gICAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICAgKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICAgIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgICByZXR1cm4gaVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICAgIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICAgIHZhciByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIHZhciBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyBleHBlY3RlZFZhbHVlO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IFwiLCBnb3QgXCIgKyByZWNlaXZlZFR5cGUgKyBcIiBcIjtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiICsgcmVjZWl2ZWRWYWx1ZSArIFwiLlwiO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZVxuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICAgIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gICAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHZtKSB7XG4gICAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICAgIGhhbmRsZXIsXG4gICAgY29udGV4dCxcbiAgICBhcmdzLFxuICAgIHZtLFxuICAgIGluZm9cbiAgKSB7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAgIC8vIHJlYXNzaWduIHRvIHJlcyB0byBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICAgIHJlcyA9IHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbiAgLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbiAgLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbiAgLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4gIC8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuICAvLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbiAgLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuICAvLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3NcbiAgLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4gIC8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbiAgLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAgIC8vIFRlY2hpbmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBtYXJrO1xuICB2YXIgbWVhc3VyZTtcblxuICB7XG4gICAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHBlcmYgJiZcbiAgICAgIHBlcmYubWFyayAmJlxuICAgICAgcGVyZi5tZWFzdXJlICYmXG4gICAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICAgICkge1xuICAgICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxuICB2YXIgaW5pdFByb3h5O1xuXG4gIHtcbiAgICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgICApO1xuXG4gICAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMnICtcbiAgICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgaGFzUHJveHkgPVxuICAgICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gICAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gICAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICAgIHZhciBpLCBrZXlzO1xuICAgIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgb25jZTogb25jZSQkMSxcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgICBwYXNzaXZlOiBwYXNzaXZlXG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICByZXR1cm4gaW52b2tlclxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgICBvbixcbiAgICBvbGRPbixcbiAgICBhZGQsXG4gICAgcmVtb3ZlJCQxLFxuICAgIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICB9XG4gICAgdmFyIGludm9rZXI7XG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICAgIGRlZltob29rS2V5XSA9IGludm9rZXI7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgICBkYXRhLFxuICAgIEN0b3IsXG4gICAgdGFnXG4gICkge1xuICAgIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gICAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gICAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGlwKFxuICAgICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Byb3AgKFxuICAgIHJlcyxcbiAgICBoYXNoLFxuICAgIGtleSxcbiAgICBhbHRLZXksXG4gICAgcHJlc2VydmVcbiAgKSB7XG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuICAvLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuICAvL1xuICAvLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuICAvLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4gIC8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuICAvLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIC8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4gIC8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuICAvLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbiAgLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4gIC8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbiAgLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgICAgLy8gIG5lc3RlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gICAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICAgIGlmIChwcm92aWRlKSB7XG4gICAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgICAgOiBwcm92aWRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICAgIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICAgIGlmIChpbmplY3QpIHtcbiAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0XG4gICkge1xuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICAgIHZhciBzbG90cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgICB9XG4gICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90c1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gICAgc2xvdHMsXG4gICAgbm9ybWFsU2xvdHMsXG4gICAgcHJldlNsb3RzXG4gICkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiB0cnVlO1xuICAgIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICAgIGlmICghc2xvdHMpIHtcbiAgICAgIHJlcyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgICAgcmV0dXJuIHNsb3RzLl9ub3JtYWxpemVkXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGlzU3RhYmxlICYmXG4gICAgICBwcmV2U2xvdHMgJiZcbiAgICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgICAgcmV0dXJuIHByZXZTbG90c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gICAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gICAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICAgIH1cbiAgICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgICAgcmV0dXJuIHJlcyAmJiByZXMubGVuZ3RoID09PSAwXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogcmVzXG4gICAgfTtcbiAgICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgICBpZiAoZm4ucHJveHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNsb3RzW2tleV07IH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gICAgdmFsLFxuICAgIHJlbmRlclxuICApIHtcbiAgICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICB9XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gICAgbmFtZSxcbiAgICBmYWxsYmFjayxcbiAgICBwcm9wcyxcbiAgICBiaW5kT2JqZWN0XG4gICkge1xuICAgIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgICB2YXIgbm9kZXM7XG4gICAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgICAgfVxuICAgICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gICAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICAgKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICAgIGV2ZW50S2V5Q29kZSxcbiAgICBrZXksXG4gICAgYnVpbHRJbktleUNvZGUsXG4gICAgZXZlbnRLZXlOYW1lLFxuICAgIGJ1aWx0SW5LZXlOYW1lXG4gICkge1xuICAgIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gICAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gICAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gICAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICAgIGRhdGEsXG4gICAgdGFnLFxuICAgIHZhbHVlLFxuICAgIGFzUHJvcCxcbiAgICBpc1N5bmNcbiAgKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2g7XG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpICYmICEoY2FtZWxpemVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGNhbWVsaXplZEtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICAgIGluZGV4LFxuICAgIGlzSW5Gb3JcbiAgKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gICAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICAgIHJldHVybiB0cmVlXG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgICBudWxsLFxuICAgICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICAgICk7XG4gICAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gICAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICAgKi9cbiAgZnVuY3Rpb24gbWFya09uY2UgKFxuICAgIHRyZWUsXG4gICAgaW5kZXgsXG4gICAga2V5XG4gICkge1xuICAgIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgICB0cmVlLFxuICAgIGtleSxcbiAgICBpc09uY2VcbiAgKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gICAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gICAgbm9kZS5rZXkgPSBrZXk7XG4gICAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gICAgcmVzLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICAgIGhhc0R5bmFtaWNLZXlzLFxuICAgIGNvbnRlbnRIYXNoS2V5XG4gICkge1xuICAgIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCByZXMsIGhhc0R5bmFtaWNLZXlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgICAgaWYgKHNsb3QucHJveHkpIHtcbiAgICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRlbnRIYXNoS2V5KSB7XG4gICAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmREeW5hbWljS2V5cyAoYmFzZU9iaiwgdmFsdWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgICB9IGVsc2UgaWYgKGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlT2JqXG4gIH1cblxuICAvLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbiAgLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3RcbiAgLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuICBmdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICAgIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gICAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gICAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICAgIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gICAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gICAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICAgIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICAgIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gICAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICAgIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhcmVudCxcbiAgICBDdG9yXG4gICkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAgIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgICB2YXIgY29udGV4dFZtO1xuICAgIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gICAgfVxuICAgIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gICAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgICBpZiAoaXNDb21waWxlZCkge1xuICAgICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgICBDdG9yLFxuICAgIHByb3BzRGF0YSxcbiAgICBkYXRhLFxuICAgIGNvbnRleHRWbSxcbiAgICBjaGlsZHJlblxuICApIHtcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgICBkYXRhLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNvbnRleHRWbSxcbiAgICAgIEN0b3JcbiAgICApO1xuXG4gICAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICAgIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcbiAgICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAgIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAgIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICAgIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHtcbiAgICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lXG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICAvLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxuICB2YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0ICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICAgICkge1xuICAgICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGFjdGl2ZUluc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICAgIEN0b3IsXG4gICAgZGF0YSxcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIHRhZ1xuICApIHtcbiAgICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAgIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICAgIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgICB9XG5cbiAgICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gICAgLy8gcmVqZWN0LlxuICAgIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGFzeW5jIGNvbXBvbmVudFxuICAgIHZhciBhc3luY0ZhY3Rvcnk7XG4gICAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIHRhZ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gICAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAgIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBwcm9wc1xuICAgIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gICAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAgIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gICAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgICBhc3luY0ZhY3RvcnlcbiAgICApO1xuXG4gICAgcmV0dXJuIHZub2RlXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gICAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICApIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgICBwYXJlbnQ6IHBhcmVudFxuICAgIH07XG4gICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICAgIHZhciBleGlzdGluZyA9IGhvb2tzW2tleV07XG4gICAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayQxKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICAgIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgICAgZjEoYSwgYik7XG4gICAgICBmMihhLCBiKTtcbiAgICB9O1xuICAgIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkXG4gIH1cblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4gIC8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICAgIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICAgIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICAgIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICAgIGlmIChcbiAgICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgICApIHtcbiAgICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG4gIHZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuICAvLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuICAvLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gICAgY29udGV4dCxcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICBub3JtYWxpemF0aW9uVHlwZSxcbiAgICBhbHdheXNOb3JtYWxpemVcbiAgKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICAgIGNvbnRleHQsXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgbm9ybWFsaXphdGlvblR5cGVcbiAgKSB7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICB9XG4gICAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICAgIHRhZyA9IGRhdGEuaXM7XG4gICAgfVxuICAgIGlmICghdGFnKSB7XG4gICAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gICAgfVxuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICAgICkge1xuICAgICAge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgdmFyIHZub2RlLCBucztcbiAgICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBDdG9yO1xuICAgICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgICB2bm9kZS5ucyA9IG5zO1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgICBucyA9IHVuZGVmaW5lZDtcbiAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVmICM1MzE4XG4gIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4gIC8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICAgIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gICAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gICAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gICAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gICAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gICAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gICAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gICAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gICAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAgIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAgIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgICAgLy8gcmVuZGVyIHNlbGZcbiAgICAgIHZhciB2bm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgcGFyZW50XG4gICAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICAgIGlmIChcbiAgICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICAgICkge1xuICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgICA6IGNvbXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICAgIGZhY3RvcnksXG4gICAgZGF0YSxcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIHRhZ1xuICApIHtcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgICBmYWN0b3J5LFxuICAgIGJhc2VDdG9yXG4gICkge1xuICAgIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgICB9XG5cbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gICAgfVxuXG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgIH1cblxuICAgIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgIFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICAgIHJldHVybiBjXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldDtcblxuICBmdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgICB2bSxcbiAgICBsaXN0ZW5lcnMsXG4gICAgb2xkTGlzdGVuZXJzXG4gICkge1xuICAgIHRhcmdldCA9IHZtO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gICAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgb24uZm4gPSBmbjtcbiAgICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAvLyBhbGxcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bVxuICAgICAgfVxuICAgICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgIGlmICghY2JzKSB7XG4gICAgICAgIHJldHVybiB2bVxuICAgICAgfVxuICAgICAgaWYgKCFmbikge1xuICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bVxuICAgICAgfVxuICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgdmFyIGNiO1xuICAgICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjYiA9IGNic1tpXTtcbiAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAge1xuICAgICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgICBpZiAoY2JzKSB7XG4gICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgICB9XG5cbiAgICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICAgIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgICB2bS4kcmVmcyA9IHt9O1xuXG4gICAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICAgIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZXNcbiAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgIGlmIChwcmV2RWwpIHtcbiAgICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHZtLiRlbCkge1xuICAgICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgICAgfVxuICAgICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgICB9XG4gICAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgICAgfVxuICAgICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgICAgdm0uJG9mZigpO1xuICAgICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgICB2bSxcbiAgICBlbCxcbiAgICBoeWRyYXRpbmdcbiAgKSB7XG4gICAgdm0uJGVsID0gZWw7XG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgICB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICAgIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gICAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gICAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAgIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gICAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICAgIHZtLFxuICAgIHByb3BzRGF0YSxcbiAgICBsaXN0ZW5lcnMsXG4gICAgcGFyZW50Vm5vZGUsXG4gICAgcmVuZGVyQ2hpbGRyZW5cbiAgKSB7XG4gICAge1xuICAgICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAgIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICAgIHZhciBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpXG4gICAgKTtcblxuICAgIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cbiAgICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgICApO1xuXG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICAgIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgICB9XG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICAgIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAgIC8vIHVwZGF0ZSBwcm9wc1xuICAgIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgICAgfVxuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAgIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gICAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICAgIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgICBpZiAoZGlyZWN0KSB7XG4gICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gICAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xuICB2YXIgaGFzID0ge307XG4gIHZhciBjaXJjdWxhciA9IHt9O1xuICB2YXIgd2FpdGluZyA9IGZhbHNlO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gICAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIGhhcyA9IHt9O1xuICAgIHtcbiAgICAgIGNpcmN1bGFyID0ge307XG4gICAgfVxuICAgIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQXN5bmMgZWRnZSBjYXNlICM2NTY2IHJlcXVpcmVzIHNhdmluZyB0aGUgdGltZXN0YW1wIHdoZW4gZXZlbnQgbGlzdGVuZXJzIGFyZVxuICAvLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbiAgLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbiAgLy8gZXZlcnkgdGltZSB0aGUgc2NoZWR1bGVyIGZsdXNoZXMgYW5kIHVzZSB0aGF0IGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gIC8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxuICB2YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuICAvLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxuICB2YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbiAgLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbiAgLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcbiAgLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4gIC8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbiAgaWYgKGluQnJvd3NlciAmJiBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xuICAgIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXG4gICAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICAgIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gICAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gICAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgICB9XG4gICAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgICBoYXNbaWRdID0gbnVsbDtcbiAgICAgIHdhdGNoZXIucnVuKCk7XG4gICAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICAgIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gICAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gICAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgICAvLyBkZXZ0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gICAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAgIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICAgKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAgICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgICB9XG4gICAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICAgIGlmICghd2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgdmFyIHVpZCQyID0gMDtcblxuICAvKipcbiAgICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gICAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICAgKi9cbiAgdmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgICB2bSxcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnMsXG4gICAgaXNSZW5kZXJXYXRjaGVyXG4gICkge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgfVxuICAgIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAgIC8vIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYiA9IGNiO1xuICAgIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIHZtID0gdGhpcy52bTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgICB2YXIgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICAgIHRtcCA9IHRoaXMuZGVwcztcbiAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgdGhpcy5kZWVwXG4gICAgICApIHtcbiAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBub29wLFxuICAgIHNldDogbm9vcFxuICB9O1xuXG4gIGZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICAgIH07XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICAgIHZtLl93YXRjaGVycyA9IFtdO1xuICAgIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gICAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICAgIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICBpbml0RGF0YSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICAgIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICAgIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gICAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICAgIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICAgIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgICAgOiBkYXRhIHx8IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgd2FybihcbiAgICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAge1xuICAgICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgICAgcmV0dXJuIHt9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgICB2bSxcbiAgICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgICBub29wLFxuICAgICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgdXNlckRlZlxuICApIHtcbiAgICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgICA6IG5vb3A7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBoYW5kbGVyLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gICAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICAgIHtcbiAgICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICAgIGV4cE9yRm4sXG4gICAgICBjYixcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgdWlkJDMgPSAwO1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgLy8gYSB1aWRcbiAgICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgfVxuXG4gICAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgfVxuICAgICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgICAgaW5pdFN0YXRlKHZtKTtcbiAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICAgIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICAgIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoQ3Rvci5zdXBlcikge1xuICAgICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gICAgdmFyIG1vZGlmaWVkO1xuICAgIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gICAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZFxuICB9XG5cbiAgZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgICApIHtcbiAgICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIGluaXRNaXhpbihWdWUpO1xuICBzdGF0ZU1peGluKFZ1ZSk7XG4gIGV2ZW50c01peGluKFZ1ZSk7XG4gIGxpZmVjeWNsZU1peGluKFZ1ZSk7XG4gIHJlbmRlck1peGluKFZ1ZSk7XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gICAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cblxuICAgICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICAgKi9cbiAgICBWdWUuY2lkID0gMDtcbiAgICB2YXIgY2lkID0gMTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAgICovXG4gICAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICAgICk7XG4gICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICAgIH1cbiAgICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgICB9KTtcbiAgICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgICB9XG5cbiAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgICByZXR1cm4gU3ViXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gICAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICAgIGlkLFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gICAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICAgIGNhY2hlLFxuICAgIGtleSxcbiAgICBrZXlzLFxuICAgIGN1cnJlbnRcbiAgKSB7XG4gICAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gIH1cblxuICB2YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbiAgdmFyIEtlZXBBbGl2ZSA9IHtcbiAgICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICBwcm9wczoge1xuICAgICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB9LFxuXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICAgIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gICAgLy8gY29uZmlnXG4gICAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICAgIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gICAge1xuICAgICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAgIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAgIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAgIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gICAgVnVlLnV0aWwgPSB7XG4gICAgICB3YXJuOiB3YXJuLFxuICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICAgIH07XG5cbiAgICBWdWUuc2V0ID0gc2V0O1xuICAgIFZ1ZS5kZWxldGUgPSBkZWw7XG4gICAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIG9ic2VydmUob2JqKTtcbiAgICAgIHJldHVybiBvYmpcbiAgICB9O1xuXG4gICAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgICBpbml0VXNlKFZ1ZSk7XG4gICAgaW5pdE1peGluJDEoVnVlKTtcbiAgICBpbml0RXh0ZW5kKFZ1ZSk7XG4gICAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG4gIH1cblxuICBpbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gICAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICAgIH1cbiAgfSk7XG5cbiAgLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbiAgfSk7XG5cbiAgVnVlLnZlcnNpb24gPSAnMi42LjcnO1xuXG4gIC8qICAqL1xuXG4gIC8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuICAvLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbiAgdmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuICAvLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG4gIHZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbiAgdmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICAgIHJldHVybiAoXG4gICAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICAgIClcbiAgfTtcblxuICB2YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG4gIHZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbiAgdmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgPyAnZmFsc2UnXG4gICAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiAndHJ1ZSdcbiAgfTtcblxuICB2YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbiAgKTtcblxuICB2YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuICB2YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xuICB9O1xuXG4gIHZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xuICB9O1xuXG4gIHZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gICAgc3RhdGljQ2xhc3MsXG4gICAgZHluYW1pY0NsYXNzXG4gICkge1xuICAgIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICAgIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgICByZXMgKz0ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbmFtZXNwYWNlTWFwID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbiAgfTtcblxuICB2YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAgICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAgICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuICApO1xuXG4gIC8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuICAvLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxuICB2YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAgICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgICB0cnVlXG4gICk7XG5cbiAgdmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxuICB2YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gICAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICAgIHJldHVybiAnc3ZnJ1xuICAgIH1cbiAgICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgICByZXR1cm4gJ21hdGgnXG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3Nlcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICAgIH1cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICAgICkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgICB9XG4gIH1cblxuICB2YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm4gZWxtXG4gICAgfVxuICAgIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gICAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gICAgfVxuICAgIHJldHVybiBlbG1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG4gIH1cblxuICBmdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG4gIH1cblxuICBmdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG4gIH1cblxuICB2YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gICAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gICAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gICAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gICAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciByZWYgPSB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gICAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gICAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gICAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAgKlxuICAgKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAgICpcbiAgICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICAgKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAgICovXG5cbiAgdmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuICB2YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuICBmdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgICAgKFxuICAgICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICAgICkgfHwgKFxuICAgICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICAgIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgdmFyIGk7XG4gICAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICAgIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICB2YXIgaSwga2V5O1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgY2JzID0ge307XG5cbiAgICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgcmV0dXJuIHJlbW92ZSQkMVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAhaW5WUHJlICYmXG4gICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAhKFxuICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgICAgfSlcbiAgICAgICAgKSAmJlxuICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgICApXG4gICAgfVxuXG4gICAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgICB2bm9kZSxcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgIHBhcmVudEVsbSxcbiAgICAgIHJlZkVsbSxcbiAgICAgIG5lc3RlZCxcbiAgICAgIG93bmVyQXJyYXksXG4gICAgICBpbmRleFxuICAgICkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgIH1cblxuICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAgIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgICB2YXIgaSwgajtcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgICB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgICAgb2xkVm5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgIG93bmVyQXJyYXksXG4gICAgICBpbmRleCxcbiAgICAgIHJlbW92ZU9ubHlcbiAgICApIHtcbiAgICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgICApIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gICAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAgIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAgIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICAgIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICAgIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgICAge1xuICAgICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICAgIHJldHVybiB2bm9kZS5lbG1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgZGlyZWN0aXZlcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gICAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gICAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgICBpZiAoIW9sZERpcikge1xuICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gICAgZGlycyxcbiAgICB2bVxuICApIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIWRpcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgICB2YXIgaSwgZGlyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICB9XG4gICAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZU1vZHVsZXMgPSBbXG4gICAgcmVmLFxuICAgIGRpcmVjdGl2ZXNcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1ciwgb2xkO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICA6IGtleTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXG4gICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0cnMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICAgIGlmIChcbiAgICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gICAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjbGFzc1xuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgICB9XG4gIH1cblxuICB2YXIga2xhc3MgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbiAgZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gICAgdmFyIGN1cmx5ID0gMDtcbiAgICB2YXIgc3F1YXJlID0gMDtcbiAgICB2YXIgcGFyZW4gPSAwO1xuICAgIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgcHJldiA9IGM7XG4gICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICAgKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgICBwdXNoRmlsdGVyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uXG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICAgIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIGZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gICAgbW9kdWxlcyxcbiAgICBrZXlcbiAgKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNcbiAgICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgICAgOiBbXVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAgIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICB2YXIgYXR0cnMgPSBkeW5hbWljXG4gICAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG4gIGZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgICBlbCxcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnMsXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICByZXR1cm4gZHluYW1pY1xuICAgICAgPyAoXCJfcChcIiArIG5hbWUgKyBcIixcXFwiXCIgKyBzeW1ib2wgKyBcIlxcXCIpXCIpXG4gICAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICAgIGVsLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzLFxuICAgIGltcG9ydGFudCxcbiAgICB3YXJuLFxuICAgIHJhbmdlLFxuICAgIGR5bmFtaWNcbiAgKSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHdhcm4gJiZcbiAgICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gICAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICAgIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcbiAgICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICBnZXRTdGF0aWNcbiAgKSB7XG4gICAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbiAgLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4gIC8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbiAgZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICByZW1vdmVGcm9tTWFwXG4gICkge1xuICAgIHZhciB2YWw7XG4gICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGF0dHJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICAgIGl0ZW0sXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICAgIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICAgIGVsLm1vZGVsID0ge1xuICAgICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gICAgdmFsdWUsXG4gICAgYXNzaWdubWVudFxuICApIHtcbiAgICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gICAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICAgKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAgICpcbiAgICogUG9zc2libGUgY2FzZXM6XG4gICAqXG4gICAqIC0gdGVzdFxuICAgKiAtIHRlc3Rba2V5XVxuICAgKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAgICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gICAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICAgKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAgICpcbiAgICovXG5cbiAgdmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAgIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAgIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgbGVuID0gdmFsLmxlbmd0aDtcblxuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4cDogdmFsLFxuICAgICAgICAgIGtleTogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyID0gdmFsO1xuICAgIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICBjaHIgPSBuZXh0KCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG4gIH1cblxuICBmdW5jdGlvbiBlb2YgKCkge1xuICAgIHJldHVybiBpbmRleCQxID49IGxlblxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gICAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4MjdcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gICAgdmFyIGluQnJhY2tldCA9IDE7XG4gICAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gICAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgIGNociA9IG5leHQoKTtcbiAgICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHdhcm4kMTtcblxuICAvLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4gIC8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG4gIHZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xuICB2YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuICBmdW5jdGlvbiBtb2RlbCAoXG4gICAgZWwsXG4gICAgZGlyLFxuICAgIF93YXJuXG4gICkge1xuICAgIHdhcm4kMSA9IF93YXJuO1xuICAgIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICB2YXIgdGFnID0gZWwudGFnO1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gICAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gICAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICAgKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgICAgbnVsbCwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICAgIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gICAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gICAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4gICkge1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gICAge1xuICAgICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gICAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gICAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICAgIHZhciBldmVudCA9IGxhenlcbiAgICAgID8gJ2NoYW5nZSdcbiAgICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICAgIDogJ2lucHV0JztcblxuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgICB9XG4gICAgaWYgKG51bWJlcikge1xuICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gICAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICAgIH1cblxuICAgIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gICAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbiAgLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuICAvLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gIC8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldCQxO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuICAvLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4gIC8vIHNhZmUgdG8gZXhjbHVkZS5cbiAgdmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbiAgZnVuY3Rpb24gYWRkJDEgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIHBhc3NpdmVcbiAgKSB7XG4gICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gICAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgICAgLy8gIzk0NjIgYmFpbCBmb3IgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAgIGUudGltZVN0YW1wID09PSAwIHx8XG4gICAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgbmFtZSxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgICA6IGNhcHR1cmVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIF90YXJnZXRcbiAgKSB7XG4gICAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBuYW1lLFxuICAgICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgICAgY2FwdHVyZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gICAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICAgIHRhcmdldCQxID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGV2ZW50cyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBzdmdDb250YWluZXI7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIga2V5LCBjdXI7XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gICAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICAgIH1cblxuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgICBlbG1ba2V5XSA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICAgKSB7XG4gICAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbiAgZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICAgKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgICAvLyAjNjE1N1xuICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICAgIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxuICB9XG5cbiAgZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gICAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICAgIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgICB9XG4gICAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxuICB9XG5cbiAgdmFyIGRvbVByb3BzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gICAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNcbiAgfSk7XG5cbiAgLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbiAgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gICAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAgIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gICAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgICAgOiBzdHlsZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuICBmdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdTdHlsZVxuICB9XG5cbiAgLyoqXG4gICAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAgICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgc3R5bGVEYXRhO1xuXG4gICAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgICApIHtcbiAgICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGNzc1ZhclJFID0gL14tLS87XG4gIHZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuICB2YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG4gIHZhciBlbXB0eVN0eWxlO1xuICB2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgICAgcmV0dXJuIHByb3BcbiAgICB9XG4gICAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyLCBuYW1lO1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICAgIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gICAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAgIC8vIHRvIG11dGF0ZSBpdC5cbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICAgIDogc3R5bGU7XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3R5bGUgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuICAvKipcbiAgICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgICBpZiAoY3VyKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgICBpZiAoIWRlZiQkMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgICB9XG4gICAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gICAgfVxuICB9XG5cbiAgdmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xuICB2YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbiAgdmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4gIC8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbiAgdmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xuICB2YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xuICB2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbiAgaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxuICB2YXIgcmFmID0gaW5Ccm93c2VyXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgICA6IHNldFRpbWVvdXRcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuICBmdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gICAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJhZihmbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gIH1cblxuICBmdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICAgIGVsLFxuICAgIGV4cGVjdGVkVHlwZSxcbiAgICBjYlxuICApIHtcbiAgICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICAgIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICAgIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHZhciBlbmRlZCA9IDA7XG4gICAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICAgIGNiKCk7XG4gICAgfTtcbiAgICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgICBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gICAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgdGltZW91dCA9IDA7XG4gICAgdmFyIHByb3BDb3VudCA9IDA7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICA6IG51bGw7XG4gICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiAwO1xuICAgIH1cbiAgICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gICAgfSkpXG4gIH1cblxuICAvLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4gIC8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbiAgLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3RpbmdcbiAgLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuICBmdW5jdGlvbiB0b01zIChzKSB7XG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBlbC5fbGVhdmVDYigpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICAgIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICAgIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICAgIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICAgIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gICAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICAgIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICAgIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gICAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAgIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gICAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gICAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgICA/IGFwcGVhckNsYXNzXG4gICAgICA6IGVudGVyQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICAgID8gYXBwZWFyVG9DbGFzc1xuICAgICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICAgIDogYmVmb3JlRW50ZXI7XG4gICAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgICA6IGVudGVyO1xuICAgIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgICAgOiBhZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICAgIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgICB9KTtcblxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgICApIHtcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gICAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm4gcm0oKVxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gICAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICAgIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICAgIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gICAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gICAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICAgIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICB9XG4gICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG4gIGZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gICAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICAgKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAgICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAgIC8vIGludm9rZXJcbiAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBlbnRlcih2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gICAgY3JlYXRlOiBfZW50ZXIsXG4gICAgYWN0aXZhdGU6IF9lbnRlcixcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gOiB7fTtcblxuICB2YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICAgIGF0dHJzLFxuICAgIGtsYXNzLFxuICAgIGV2ZW50cyxcbiAgICBkb21Qcm9wcyxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uXG4gIF07XG5cbiAgLyogICovXG5cbiAgLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4gIC8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gIHZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbiAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbiAgLyoqXG4gICAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICAgKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5KSB7XG4gICAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlID0ge1xuICAgIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgLy8gIzY5MDNcbiAgICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgICA6IG9wdGlvbi52YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICAgIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgLyogICovXG5cbiAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuICBmdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgICA6IHZub2RlXG4gIH1cblxuICB2YXIgc2hvdyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgICAgZWwsXG4gICAgICBiaW5kaW5nLFxuICAgICAgdm5vZGUsXG4gICAgICBvbGRWbm9kZSxcbiAgICAgIGlzRGVzdHJveVxuICAgICkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICBtb2RlbDogZGlyZWN0aXZlLFxuICAgIHNob3c6IHNob3dcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgY3NzOiBCb29sZWFuLFxuICAgIG1vZGU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZW50ZXJDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxuICB9O1xuXG4gIC8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuICAvLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuICBmdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgICAvLyBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICAgIH1cbiAgICAvLyBldmVudHMuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gICAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gICAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG4gIH1cblxuICB2YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbiAgdmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbiAgdmFyIFRyYW5zaXRpb24gPSB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICAgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgICBpZiAobW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICAgKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgICAvLyBtYXJrIHYtc2hvd1xuICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgICApIHtcbiAgICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG4gIGRlbGV0ZSBwcm9wcy5tb2RlO1xuXG4gIHZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgICB9LFxuXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgICB9XG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgICAgYy5lbG0uX21vdmVDYigpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gICAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gICAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxuICB9O1xuXG4gIC8qICAqL1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcbiAgVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG4gIFZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuICBWdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuICBleHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuICBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuICAvLyBwdWJsaWMgbW91bnQgbWV0aG9kXG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbiAgfTtcblxuICAvLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuICB2YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbiAgdmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gICAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxuICB9KTtcblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgICB0ZXh0LFxuICAgIGRlbGltaXRlcnNcbiAgKSB7XG4gICAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gICAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgICAgfVxuICAgICAgLy8gdGFnIHRva2VuXG4gICAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICAgIHRva2VuczogcmF3VG9rZW5zXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gICAgfVxuICAgIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgICB2YXIgZGF0YSA9ICcnO1xuICAgIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgdmFyIGtsYXNzJDEgPSB7XG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICAgIHZhciBkYXRhID0gJyc7XG4gICAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHZhciBzdHlsZSQxID0ge1xuICAgIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YSQxXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGRlY29kZXI7XG5cbiAgdmFyIGhlID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuICApO1xuXG4gIC8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuICAvLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbiAgKTtcblxuICAvLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4gIC8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICB2YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAgICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAgICd0aXRsZSx0cix0cmFjaydcbiAgKTtcblxuICAvKipcbiAgICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gICAqL1xuXG4gIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4gIHZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuICB2YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArIHVuaWNvZGVMZXR0ZXJzICsgXCJdKlwiO1xuICB2YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xuICB2YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG4gIHZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG4gIHZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbiAgdmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbiAgLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxuICB2YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbiAgdmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4gIC8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuICB2YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciByZUNhY2hlID0ge307XG5cbiAgdmFyIGRlY29kaW5nTWFwID0ge1xuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJiMxMDsnOiAnXFxuJyxcbiAgICAnJiM5Oyc6ICdcXHQnLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG4gIHZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbiAgdmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuICAvLyAjNTk5MlxuICB2YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gICAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICAgIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICAgIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gICAgd2hpbGUgKGh0bWwpIHtcbiAgICAgIGxhc3QgPSBodG1sO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gICAgcGFyc2VFbmRUYWcoKTtcblxuICAgIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICAgIGluZGV4ICs9IG47XG4gICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgICBwb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIG9uUkUgPSAvXkB8XnYtb246LztcbiAgdmFyIGRpclJFID0gL152LXxeQHxeOi87XG4gIHZhciBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuICB2YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbiAgdmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG4gIHZhciBkeW5hbWljQXJnUkUgPSAvXlxcWy4qXFxdJC87XG5cbiAgdmFyIGFyZ1JFID0gLzooLiopJC87XG4gIHZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG4gIHZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbiAgdmFyIHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG4gIHZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG4gIHZhciB3aGl0ZXNwYWNlUkUkMSA9IC9cXHMrL2c7XG5cbiAgdmFyIGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5cbiAgdmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuICB2YXIgZW1wdHlTbG90U2NvcGVUb2tlbiA9IFwiX2VtcHR5X1wiO1xuXG4gIC8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxuICB2YXIgd2FybiQyO1xuICB2YXIgZGVsaW1pdGVycztcbiAgdmFyIHRyYW5zZm9ybXM7XG4gIHZhciBwcmVUcmFuc2Zvcm1zO1xuICB2YXIgcG9zdFRyYW5zZm9ybXM7XG4gIHZhciBwbGF0Zm9ybUlzUHJlVGFnO1xuICB2YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbiAgdmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuICB2YXIgbWF5YmVDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gICAgdGFnLFxuICAgIGF0dHJzLFxuICAgIHBhcmVudFxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMSxcbiAgICAgIHRhZzogdGFnLFxuICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgcmF3QXR0cnNNYXA6IHt9LFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICAgIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAgIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuXG4gICAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICAgIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICAgIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICAgIHZhciB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xuICAgIHZhciByb290O1xuICAgIHZhciBjdXJyZW50UGFyZW50O1xuICAgIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB3YXJuT25jZSAobXNnLCByYW5nZSkge1xuICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgd2FybiQyKG1zZywgcmFuZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCIsXG4gICAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgICAvLyBmaWx0ZXIgb3V0IHNjb3BlZCBzbG90c1xuICAgICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXG4gICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcbiAgICAgIGlmICghaW5QcmUpIHtcbiAgICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJ1xuICAgICAgICApIHtcbiAgICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJyxcbiAgICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICAgIHdhcm46IHdhcm4kMixcbiAgICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCQxKSB7XG4gICAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGVuZDogZnVuY3Rpb24gZW5kICh0YWcsIHN0YXJ0LCBlbmQkMSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBwb3Agc3RhY2tcbiAgICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LicsXG4gICAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcm9vdFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgICAgZWwucHJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIGlmIChsZW4pIHtcbiAgICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICAgIG5hbWU6IGxpc3RbaV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgICAgZWwucGxhaW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgICBlbGVtZW50LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAgICFlbGVtZW50LmtleSAmJlxuICAgICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgICApO1xuXG4gICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgfVxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgXCIgK1xuICAgICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwua2V5ID0gZXhwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gICAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gICAgaWYgKHJlZikge1xuICAgICAgZWwucmVmID0gcmVmO1xuICAgICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICAgIHZhciBleHA7XG4gICAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cCksXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICAgIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICAgIGlmIChleHApIHtcbiAgICAgIGVsLmlmID0gZXhwO1xuICAgICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgICAgZXhwOiBleHAsXG4gICAgICAgIGJsb2NrOiBlbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgICBpZiAoZWxzZWlmKSB7XG4gICAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gICAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgICBibG9jazogZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICAgIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gICAgfVxuICAgIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbiAgLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG4gIGZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cblxuICAgIC8vIHNsb3Q9XCJ4eHhcIlxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICAgIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgICAgdmFyIHJlZiQxID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmckMSk7XG4gICAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lJDFdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmckMS52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICAgIGJpbmRpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxuICB9XG5cbiAgLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuICBmdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgICBpZiAoZWwua2V5KSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gICAgdmFyIGJpbmRpbmc7XG4gICAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgICB9XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gICAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgICApIHtcbiAgICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgICAgfVxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuICBmdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gICAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG4gIH1cblxuICBmdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICApKVxuICAgIClcbiAgfVxuXG4gIHZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuICB2YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgICB2YXIgX2VsID0gZWw7XG4gICAgd2hpbGUgKF9lbCkge1xuICAgICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgX2VsID0gX2VsLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICAgIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlQmluZGluZztcbiAgICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAzLiBvdGhlclxuICAgICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxuICB9XG5cbiAgdmFyIG1vZGVsJDEgPSB7XG4gICAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxuICB9O1xuXG4gIHZhciBtb2R1bGVzJDEgPSBbXG4gICAga2xhc3MkMSxcbiAgICBzdHlsZSQxLFxuICAgIG1vZGVsJDFcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgICBtb2RlbDogbW9kZWwsXG4gICAgdGV4dDogdGV4dCxcbiAgICBodG1sOiBodG1sXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGJhc2VPcHRpb25zID0ge1xuICAgIGV4cGVjdEhUTUw6IHRydWUsXG4gICAgbW9kdWxlczogbW9kdWxlcyQxLFxuICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gICAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICAgIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICAgIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1N0YXRpY0tleTtcbiAgdmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuICB2YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4gIC8qKlxuICAgKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICAgKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gICAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gICAqXG4gICAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICAgKlxuICAgKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gICAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAgICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gICAqL1xuICBmdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICAgIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICAgIG1hcmtTdGF0aWMkMShyb290KTtcbiAgICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gICAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICAgIHJldHVybiBtYWtlTWFwKFxuICAgICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgICAgaWYgKFxuICAgICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgICB9XG4gICAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICAgICkpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICAgICkpXG4gIH1cblxuICBmdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xuICB2YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xuICB2YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuICAvLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xuICB2YXIga2V5Q29kZXMgPSB7XG4gICAgZXNjOiAyNyxcbiAgICB0YWI6IDksXG4gICAgZW50ZXI6IDEzLFxuICAgIHNwYWNlOiAzMixcbiAgICB1cDogMzgsXG4gICAgbGVmdDogMzcsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGRvd246IDQwLFxuICAgICdkZWxldGUnOiBbOCwgNDZdXG4gIH07XG5cbiAgLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xuICB2YXIga2V5TmFtZXMgPSB7XG4gICAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXG4gICAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgICB0YWI6ICdUYWInLFxuICAgIGVudGVyOiAnRW50ZXInLFxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gICAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAgIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gICAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICAgIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gICAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXG4gIH07XG5cbiAgLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbiAgLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuICAvLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG4gIHZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG4gIHZhciBtb2RpZmllckNvZGUgPSB7XG4gICAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICAgIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICAgIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gICAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gICAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gICAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gICAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gICAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbiAgfTtcblxuICBmdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gICAgZXZlbnRzLFxuICAgIGlzTmF0aXZlXG4gICkge1xuICAgIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gICAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgICB2YXIgZHluYW1pY0hhbmRsZXJzID0gXCJcIjtcbiAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgICBkeW5hbWljSGFuZGxlcnMgKz0gbmFtZSArIFwiLFwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRpY0hhbmRsZXJzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIgKyAoc3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgICB9XG5cbiAgICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gICAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIHZhciBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gICAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaXNGdW5jdGlvbkludm9jYXRpb24gPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpIDogaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgICB9XG4gICAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpXG4gICAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgICAgXCJpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJlwiICtcbiAgICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gICAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIGlmIChrZXlWYWwpIHtcbiAgICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICAgIH1cbiAgICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gICAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgICBcIiRldmVudC5rZXksXCIgK1xuICAgICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgICAgXCIpXCJcbiAgICApXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICAgIGlmIChkaXIubW9kaWZpZXJzKSB7XG4gICAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgICB9XG4gICAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gICAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gICAgb246IG9uLFxuICAgIGJpbmQ6IGJpbmQkMSxcbiAgICBjbG9hazogbm9vcFxuICB9O1xuXG4gIC8qICAqL1xuXG5cblxuXG5cbiAgdmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICAgIHRoaXMub25jZUlkID0gMDtcbiAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICAgIHRoaXMucHJlID0gZmFsc2U7XG4gIH07XG5cblxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgICBhc3QsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICAgIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgICBpZiAoZWwucGFyZW50KSB7XG4gICAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgICB9XG5cbiAgICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICAgIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICAgIHZhciBjb2RlO1xuICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoIWVsLnBsYWluIHx8IChlbC5wcmUgJiYgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpKSkge1xuICAgICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgICB9XG4gICAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbiAgZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAgIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAgIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gICAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgc3RhdGUucHJlID0gZWwucHJlO1xuICAgIH1cbiAgICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICAgIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH1cblxuICAvLyB2LW9uY2VcbiAgZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gICAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gICAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgICB2YXIga2V5ID0gJyc7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgc3RhdGUud2FybihcbiAgICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ11cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5JZiAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEVtcHR5XG4gICkge1xuICAgIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gICAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICAgIGNvbmRpdGlvbnMsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEVtcHR5XG4gICkge1xuICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgICB9XG5cbiAgICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICAgIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gICAgfVxuXG4gICAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICAgIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgICByZXR1cm4gYWx0R2VuXG4gICAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBlbC5vbmNlXG4gICAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkZvciAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEhlbHBlclxuICApIHtcbiAgICB2YXIgZXhwID0gZWwuZm9yO1xuICAgIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICAgIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgICBpZiAoc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAhZWwua2V5XG4gICAgKSB7XG4gICAgICBzdGF0ZS53YXJuKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICApO1xuICAgIH1cblxuICAgIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICAgJ30pJ1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgICB2YXIgZGF0YSA9ICd7JztcblxuICAgIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gICAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAgIC8vIGtleVxuICAgIGlmIChlbC5rZXkpIHtcbiAgICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyByZWZcbiAgICBpZiAoZWwucmVmKSB7XG4gICAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgICB9XG4gICAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgICB9XG4gICAgLy8gcHJlXG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICAgIH1cbiAgICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICAgIH1cbiAgICAvLyBhdHRyaWJ1dGVzXG4gICAgaWYgKGVsLmF0dHJzKSB7XG4gICAgICBkYXRhICs9IFwiYXR0cnM6XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBET00gcHJvcHNcbiAgICBpZiAoZWwucHJvcHMpIHtcbiAgICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKGVsLmV2ZW50cykge1xuICAgICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIHNsb3QgdGFyZ2V0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICAgIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIHNjb3BlZCBzbG90c1xuICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gICAgaWYgKGVsLm1vZGVsKSB7XG4gICAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gICAgfVxuICAgIC8vIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAgIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAgIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgICBkYXRhID0gXCJfYihcIiArIGRhdGEgKyBcIixcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gICAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gICAgfVxuICAgIC8vIHYtb24gZGF0YSB3cmFwXG4gICAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICAgIGlmICghZGlycykgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICAgIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICAgIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZGlyID0gZGlyc1tpXTtcbiAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNSdW50aW1lKSB7XG4gICAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gICAgaWYgKGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMSkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gICAgZWwsXG4gICAgc2xvdHMsXG4gICAgc3RhdGVcbiAgKSB7XG4gICAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cbiAgICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gT2JqZWN0LmtleXMoc2xvdHMpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgc2xvdC5zbG90VGFyZ2V0RHluYW1pYyB8fFxuICAgICAgICBzbG90LmlmIHx8XG4gICAgICAgIHNsb3QuZm9yIHx8XG4gICAgICAgIGNvbnRhaW5zU2xvdENoaWxkKHNsb3QpIC8vIGlzIHBhc3NpbmcgZG93biBzbG90IGZyb20gcGFyZW50IHdoaWNoIG1heSBiZSBkeW5hbWljXG4gICAgICApXG4gICAgfSk7XG5cbiAgICAvLyAjOTUzNDogaWYgYSBjb21wb25lbnQgd2l0aCBzY29wZWQgc2xvdHMgaXMgaW5zaWRlIGEgY29uZGl0aW9uYWwgYnJhbmNoLFxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gICAgLy8gY29tcGlsZWQgc2xvdCBjb250ZW50LiBUbyBhdm9pZCB0aGF0LCB3ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYmFzZWQgb25cbiAgICAvLyB0aGUgZ2VuZXJhdGVkIGNvZGUgb2YgYWxsIHRoZSBzbG90IGNvbnRlbnRzLlxuICAgIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90IG9yIHYtZm9yICh0aGUgcmVhY3Rpdml0eSBtYXkgYmVcbiAgICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXG4gICAgLy8gIzk0MzgsICM5NTA2XG4gICAgLy8gVE9ETzogdGhpcyBjYW4gYmUgZnVydGhlciBvcHRpbWl6ZWQgYnkgcHJvcGVybHkgYW5hbHl6aW5nIGluLXNjb3BlIGJpbmRpbmdzXG4gICAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxuICAgIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwYXJlbnQuc2xvdFNjb3BlICYmIHBhcmVudC5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHx8XG4gICAgICAgICAgcGFyZW50LmZvclxuICAgICAgICApIHtcbiAgICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQuaWYpIHtcbiAgICAgICAgICBuZWVkc0tleSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVkU2xvdHMgPSBPYmplY3Qua2V5cyhzbG90cylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSk7IH0pXG4gICAgICAuam9pbignLCcpO1xuXG4gICAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIGdlbmVyYXRlZFNsb3RzICsgXCJdXCIgKyAobmVlZHNGb3JjZVVwZGF0ZSA/IFwiLG51bGwsdHJ1ZVwiIDogXCJcIikgKyAoIW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyAoXCIsbnVsbCxmYWxzZSxcIiArIChoYXNoKGdlbmVyYXRlZFNsb3RzKSkpIDogXCJcIikgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgdmFyIGhhc2ggPSA1MzgxO1xuICAgIHZhciBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShpKSB7XG4gICAgICBoYXNoID0gKGhhc2ggKiAzMykgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaCA+Pj4gMFxuICB9XG5cbiAgZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gICAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gICAgZWwsXG4gICAgc3RhdGVcbiAgKSB7XG4gICAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgXCJudWxsXCIpXG4gICAgfVxuICAgIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gICAgfVxuICAgIHZhciBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW5cbiAgICAgID8gXCJcIlxuICAgICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgc2xvdFNjb3BlICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgICAgPyAoXCIoXCIgKyAoZWwuaWYpICsgXCIpP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAgIC8vIHJldmVyc2UgcHJveHkgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICB2YXIgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gXCJcIiA6IFwiLHByb3h5OnRydWVcIjtcbiAgICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGNoZWNrU2tpcCxcbiAgICBhbHRHZW5FbGVtZW50LFxuICAgIGFsdEdlbk5vZGVcbiAgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBlbCQxLmZvciAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCQxKSA/IFwiLDFcIiA6IFwiLDBcIlxuICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICAgIH1cbiAgICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSQxID0gY2hlY2tTa2lwXG4gICAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgICA6IDA7XG4gICAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gICAgfVxuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuICAvLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuICAvLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4gIC8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbiAgZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICAgIGNoaWxkcmVuLFxuICAgIG1heWJlQ29tcG9uZW50XG4gICkge1xuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgICAgcmVzID0gMjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG4gIH1cblxuICBmdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICAgIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gICAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgICB9KTsgfSkpXG4gICAgICA6IG51bGw7XG4gICAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gICAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICAgIHJlcyArPSBcIixudWxsXCI7XG4gICAgfVxuICAgIGlmIChhdHRycykge1xuICAgICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gICAgfVxuICAgIGlmIChiaW5kJCQxKSB7XG4gICAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcyArICcpJ1xuICB9XG5cbiAgLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuICBmdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICAgIGNvbXBvbmVudE5hbWUsXG4gICAgZWwsXG4gICAgc3RhdGVcbiAgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgICB2YXIgc3RhdGljUHJvcHMgPSBcIlwiO1xuICAgIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIGR5bmFtaWNQcm9wcyArPSAocHJvcC5uYW1lKSArIFwiLFwiICsgdmFsdWUgKyBcIixcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgICBpZiAoZHluYW1pY1Byb3BzKSB7XG4gICAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gICAgfVxuICB9XG5cbiAgLy8gIzM4OTUsICM0MjY4XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4gIC8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbiAgdmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbiAgKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuICAvLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xuICB2YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuICApLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuICAvLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG4gIHZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbiAgZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgICBpZiAoYXN0KSB7XG4gICAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgICBpZGVudCxcbiAgICB0eXBlLFxuICAgIHRleHQsXG4gICAgd2FybixcbiAgICByYW5nZVxuICApIHtcbiAgICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpLCByYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgICAgIHJhbmdlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgcmFuZ2UgPSAyO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgICBzb3VyY2UsXG4gICAgc3RhcnQsXG4gICAgZW5kXG4gICkge1xuICAgIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0ID0gMDtcbiAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgeyBjb250aW51ZSB9XG4gICAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbignXFxuJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGVhdCQxIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgaWYgKG4gPiAwKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICAgIG4gPj4+PSAxO1xuICAgICAgICBpZiAobiA8PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgc3RyICs9IHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICAgIHJldHVybiBub29wXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICAgIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHZtXG4gICAgKSB7XG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBjYWNoZVxuICAgICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgICAgOiB0ZW1wbGF0ZTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBpbGVcbiAgICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgICAge1xuICAgICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgICB9KTtcblxuICAgICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICAgIHRlbXBsYXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciB0aXBzID0gW107XG5cbiAgICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHZhciBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICAgIHtcbiAgICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgICAgfVxuICAgICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgICByZXR1cm4gY29tcGlsZWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuICAvLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4gIC8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxuICB2YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzdDogYXN0LFxuICAgICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9XG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbiAgdmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xuICB2YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4gIC8qICAqL1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG4gIHZhciBkaXY7XG4gIGZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICAgIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gICAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbiAgfVxuXG4gIC8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG4gIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbiAgLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxuICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbiAgLyogICovXG5cbiAgdmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gICAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxuICB9KTtcblxuICB2YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcbiAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgZWwsXG4gICAgaHlkcmF0aW5nXG4gICkge1xuICAgIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICAgIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICAgKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgICB9XG4gIH1cblxuICBWdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuICByZXR1cm4gVnVlO1xuXG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(5);\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLENBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(0), __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(9);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(2)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvZ2xvYmVsLmNzcz9kNGFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxjQUFjLG1CQUFPLENBQUMsQ0FBdUQ7O0FBRTdFLDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxDQUFnRDs7QUFFckU7O0FBRUEsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JlbC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmVsLmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZ2xvYmVsLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(1)(false);\n// Module\nexports.push([module.i, "/*vue披风*/\\n[v-cloak] {\\n    display: none;\\n}\\n\\nhtml,body{\\n    height: 100%;\\n}\\n\\ninput::-webkit-outer-spin-button,\\ninput::-webkit-inner-spin-button {\\n    -webkit-appearance: none;\\n}\\n\\n\\ninput[type=\\"number\\"] {\\n    -webkit-appearance: none;\\n    -moz-appearance: none;\\n    appearance: none;\\n}\\n\\n*{\\n    margin: 0;\\n    padding: 0;\\n    box-sizing: border-box;\\n}\\nul,li{\\n    cursor: pointer;\\n    margin: 0;\\n    padding: 0;\\n    list-style: none;\\n}", ""]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvZ2xvYmVsLmNzcz9iNDBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQWdEO0FBQ25GO0FBQ0EsY0FBYyxRQUFTLHlCQUF5QixvQkFBb0IsR0FBRyxjQUFjLG1CQUFtQixHQUFHLHlFQUF5RSwrQkFBK0IsR0FBRyw4QkFBOEIsK0JBQStCLDRCQUE0Qix1QkFBdUIsR0FBRyxNQUFNLGdCQUFnQixpQkFBaUIsNkJBQTZCLEdBQUcsUUFBUSxzQkFBc0IsZ0JBQWdCLGlCQUFpQix1QkFBdUIsR0FBRyIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKnZ1ZeaKq+mjjiovXFxuW3YtY2xvYWtdIHtcXG4gICAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuaHRtbCxib2R5e1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxufVxcblxcbmlucHV0Ojotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxcbmlucHV0Ojotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcXG4gICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG5cXG5pbnB1dFt0eXBlPVxcXCJudW1iZXJcXFwiXSB7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgICBhcHBlYXJhbmNlOiBub25lO1xcbn1cXG5cXG4qe1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxufVxcbnVsLGxpe1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIG1hcmdpbjogMDtcXG4gICAgcGFkZGluZzogMDtcXG4gICAgbGlzdC1zdHlsZTogbm9uZTtcXG59XCIsIFwiXCJdKTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9\n')},,,,,,,,,,,,,,function(module,exports,__webpack_require__){"use strict";eval("\n\n__webpack_require__(24);\n\n__webpack_require__(8);\n\n__webpack_require__(25);\n\n__webpack_require__(27);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9tYWluU2hvcC5qcz85MjEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQ0E7O0FBR0E7O0FBQ0E7O0FBR0EiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvL+W8leWFpWpzXG5pbXBvcnQgJy4vZnVuY3Rpb25QYWNrYWdlL3Nob3AuanMnXG5cbi8v5byV5YWlY3NzXG5pbXBvcnQgJy4uL2Nzcy9nbG9iZWwuY3NzJ1xuaW1wb3J0ICcuLi9jc3Mvc2hvcC5jc3MnXG5cbi8vXG5pbXBvcnQgJy4uL2ltYWdlL3RpbWctcHh6MDIuanBlZyciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _vue = __webpack_require__(3);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//购物车\nvar shopCar = new _vue2.default({\n    el: '#shopCar',\n    data: {\n        goods: [{\n            name: '330ml红罐可乐',\n            price: 3.0,\n            stock: 100,\n            id: '000001',\n            inCar: 0,\n            allP: 0,\n            addNum: 1,\n            img: '../image/timg-pxz02.jpeg'\n        }, {\n            name: '芝士蛋糕',\n            price: 28.0,\n            stock: 50,\n            id: '000002',\n            inCar: 0,\n            allP: 0,\n            addNum: 1,\n            img: '../image/timg-pxz02.jpeg'\n        }, {\n            name: '大理石面包',\n            price: 10.0,\n            stock: 200,\n            id: '000003',\n            inCar: 0,\n            allP: 0,\n            addNum: 1,\n            img: '../image/timg-pxz02.jpeg'\n        }, {\n            name: 'macbook Pro',\n            price: 18888.0,\n            stock: 5,\n            id: '000004',\n            inCar: 0,\n            allP: 0,\n            addNum: 1,\n            img: '../image/timg-pxz02.jpeg'\n        }, {\n            name: '猪肉脯',\n            price: 5.0,\n            stock: 500,\n            id: '000005',\n            inCar: 0,\n            allP: 0,\n            addNum: 1,\n            img: '../image/timg-pxz02.jpeg'\n        }, {\n            name: '餐巾纸',\n            price: 2.0,\n            stock: 2000,\n            id: '000006',\n            inCar: 0,\n            allP: 0,\n            addNum: 1,\n            img: '../image/timg-pxz02.jpeg'\n        }],\n        sumPrice: 0\n    },\n    methods: {\n        addGoods: function addGoods(good) {\n            if (good.stock - good.addNum < 0) {\n                alert('库存不足');\n                return;\n            }\n            good.stock -= good.addNum;\n            good.inCar += good.addNum;\n        },\n        subGoods: function subGoods(good) {\n            if (good.inCar - good.addNum < 0) {\n                alert('您没有购买该商品');\n                return;\n            }\n            good.stock += good.addNum;\n            good.inCar -= good.addNum;\n        },\n        clean: function clean(inCar) {\n            inCar.stock += inCar.inCar;\n            inCar.inCar = 0;\n        },\n        clearAll: function clearAll() {\n            var goods = this.goods;\n            for (var i = 0; i < goods.length; i++) {\n                goods[i].inCar = 0;\n            }\n        }\n    },\n    computed: {\n        sum: function sum() {\n            var a = 0;\n            var goods = this.goods;\n            for (var i = 0; i < goods.length; i++) {\n                var num = goods[i].inCar;\n                var singlePrice = goods[i].price;\n                a += num * singlePrice;\n            }\n            this.sumPrice = a;\n            sessionStorage.setItem('sumPrice', a);\n            return a;\n        }\n    }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9mdW5jdGlvblBhY2thZ2Uvc2hvcC5qcz9iYjkwIl0sIm5hbWVzIjpbInNob3BDYXIiLCJWdWUiLCJlbCIsImRhdGEiLCJnb29kcyIsIm5hbWUiLCJwcmljZSIsInN0b2NrIiwiaWQiLCJpbkNhciIsImFsbFAiLCJhZGROdW0iLCJpbWciLCJzdW1QcmljZSIsIm1ldGhvZHMiLCJhZGRHb29kcyIsImdvb2QiLCJhbGVydCIsInN1Ykdvb2RzIiwiY2xlYW4iLCJjbGVhckFsbCIsImkiLCJsZW5ndGgiLCJjb21wdXRlZCIsInN1bSIsImEiLCJudW0iLCJzaW5nbGVQcmljZSIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7Ozs7O0FBRUE7QUFDQSxJQUFJQSxVQUFVLElBQUlDLGFBQUosQ0FBUTtBQUNsQkMsUUFBRyxVQURlO0FBRWxCQyxVQUFLO0FBQ0RDLGVBQU0sQ0FDRjtBQUNJQyxrQkFBSyxXQURUO0FBRUlDLG1CQUFNLEdBRlY7QUFHSUMsbUJBQU0sR0FIVjtBQUlJQyxnQkFBRyxRQUpQO0FBS0lDLG1CQUFNLENBTFY7QUFNSUMsa0JBQUssQ0FOVDtBQU9JQyxvQkFBTyxDQVBYO0FBUUlDLGlCQUFJO0FBUlIsU0FERSxFQVdGO0FBQ0lQLGtCQUFLLE1BRFQ7QUFFSUMsbUJBQU0sSUFGVjtBQUdJQyxtQkFBTSxFQUhWO0FBSUlDLGdCQUFHLFFBSlA7QUFLSUMsbUJBQU0sQ0FMVjtBQU1JQyxrQkFBSyxDQU5UO0FBT0lDLG9CQUFPLENBUFg7QUFRSUMsaUJBQUk7QUFSUixTQVhFLEVBcUJGO0FBQ0lQLGtCQUFLLE9BRFQ7QUFFSUMsbUJBQU0sSUFGVjtBQUdJQyxtQkFBTSxHQUhWO0FBSUlDLGdCQUFHLFFBSlA7QUFLSUMsbUJBQU0sQ0FMVjtBQU1JQyxrQkFBSyxDQU5UO0FBT0lDLG9CQUFPLENBUFg7QUFRSUMsaUJBQUk7QUFSUixTQXJCRSxFQStCRjtBQUNJUCxrQkFBSyxhQURUO0FBRUlDLG1CQUFNLE9BRlY7QUFHSUMsbUJBQU0sQ0FIVjtBQUlJQyxnQkFBRyxRQUpQO0FBS0lDLG1CQUFNLENBTFY7QUFNSUMsa0JBQUssQ0FOVDtBQU9JQyxvQkFBTyxDQVBYO0FBUUlDLGlCQUFJO0FBUlIsU0EvQkUsRUF5Q0Y7QUFDSVAsa0JBQUssS0FEVDtBQUVJQyxtQkFBTSxHQUZWO0FBR0lDLG1CQUFNLEdBSFY7QUFJSUMsZ0JBQUcsUUFKUDtBQUtJQyxtQkFBTSxDQUxWO0FBTUlDLGtCQUFLLENBTlQ7QUFPSUMsb0JBQU8sQ0FQWDtBQVFJQyxpQkFBSTtBQVJSLFNBekNFLEVBbURGO0FBQ0lQLGtCQUFLLEtBRFQ7QUFFSUMsbUJBQU0sR0FGVjtBQUdJQyxtQkFBTSxJQUhWO0FBSUlDLGdCQUFHLFFBSlA7QUFLSUMsbUJBQU0sQ0FMVjtBQU1JQyxrQkFBSyxDQU5UO0FBT0lDLG9CQUFPLENBUFg7QUFRSUMsaUJBQUk7QUFSUixTQW5ERSxDQURMO0FBK0REQyxrQkFBUztBQS9EUixLQUZhO0FBbUVsQkMsYUFBUTtBQUNKQyxrQkFBUyxrQkFBVUMsSUFBVixFQUFnQjtBQUNyQixnQkFBR0EsS0FBS1QsS0FBTCxHQUFhUyxLQUFLTCxNQUFsQixHQUEyQixDQUE5QixFQUFnQztBQUM1Qk0sc0JBQU0sTUFBTjtBQUNBO0FBQ0g7QUFDREQsaUJBQUtULEtBQUwsSUFBY1MsS0FBS0wsTUFBbkI7QUFDQUssaUJBQUtQLEtBQUwsSUFBY08sS0FBS0wsTUFBbkI7QUFDSCxTQVJHO0FBU0pPLGtCQUFTLGtCQUFVRixJQUFWLEVBQWdCO0FBQ3JCLGdCQUFHQSxLQUFLUCxLQUFMLEdBQWFPLEtBQUtMLE1BQWxCLEdBQTJCLENBQTlCLEVBQWdDO0FBQzVCTSxzQkFBTSxVQUFOO0FBQ0E7QUFDSDtBQUNERCxpQkFBS1QsS0FBTCxJQUFjUyxLQUFLTCxNQUFuQjtBQUNBSyxpQkFBS1AsS0FBTCxJQUFjTyxLQUFLTCxNQUFuQjtBQUNILFNBaEJHO0FBaUJKUSxlQUFNLGVBQVVWLEtBQVYsRUFBaUI7QUFDbkJBLGtCQUFNRixLQUFOLElBQWVFLE1BQU1BLEtBQXJCO0FBQ0FBLGtCQUFNQSxLQUFOLEdBQWMsQ0FBZDtBQUNILFNBcEJHO0FBcUJKVyxrQkFBUyxvQkFBWTtBQUNqQixnQkFBTWhCLFFBQVEsS0FBS0EsS0FBbkI7QUFDQSxpQkFBSSxJQUFJaUIsSUFBSSxDQUFaLEVBQWNBLElBQUlqQixNQUFNa0IsTUFBeEIsRUFBK0JELEdBQS9CLEVBQW1DO0FBQy9CakIsc0JBQU1pQixDQUFOLEVBQVNaLEtBQVQsR0FBaUIsQ0FBakI7QUFDSDtBQUNKO0FBMUJHLEtBbkVVO0FBK0ZsQmMsY0FBUztBQUNMQyxhQUFLLGVBQVk7QUFDYixnQkFBSUMsSUFBSSxDQUFSO0FBQ0EsZ0JBQU1yQixRQUFRLEtBQUtBLEtBQW5CO0FBQ0EsaUJBQUksSUFBSWlCLElBQUksQ0FBWixFQUFjQSxJQUFJakIsTUFBTWtCLE1BQXhCLEVBQStCRCxHQUEvQixFQUFtQztBQUMvQixvQkFBSUssTUFBTXRCLE1BQU1pQixDQUFOLEVBQVNaLEtBQW5CO0FBQ0Esb0JBQUlrQixjQUFjdkIsTUFBTWlCLENBQU4sRUFBU2YsS0FBM0I7QUFDQW1CLHFCQUFLQyxNQUFNQyxXQUFYO0FBQ0g7QUFDRCxpQkFBS2QsUUFBTCxHQUFnQlksQ0FBaEI7QUFDQUcsMkJBQWVDLE9BQWYsQ0FBdUIsVUFBdkIsRUFBa0NKLENBQWxDO0FBQ0EsbUJBQU9BLENBQVA7QUFDSDtBQVpJO0FBL0ZTLENBQVIsQ0FBZCIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSAndnVlJ1xuXG4vL+i0reeJqei9plxudmFyIHNob3BDYXIgPSBuZXcgVnVlKHtcbiAgICBlbDonI3Nob3BDYXInLFxuICAgIGRhdGE6e1xuICAgICAgICBnb29kczpbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTonMzMwbWznuqLnvZDlj6/kuZAnLFxuICAgICAgICAgICAgICAgIHByaWNlOjMuMCxcbiAgICAgICAgICAgICAgICBzdG9jazoxMDAsXG4gICAgICAgICAgICAgICAgaWQ6JzAwMDAwMScsXG4gICAgICAgICAgICAgICAgaW5DYXI6MCxcbiAgICAgICAgICAgICAgICBhbGxQOjAsXG4gICAgICAgICAgICAgICAgYWRkTnVtOjEsXG4gICAgICAgICAgICAgICAgaW1nOicuLi9pbWFnZS90aW1nLXB4ejAyLmpwZWcnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6J+iKneWjq+ibi+ezlScsXG4gICAgICAgICAgICAgICAgcHJpY2U6MjguMCxcbiAgICAgICAgICAgICAgICBzdG9jazo1MCxcbiAgICAgICAgICAgICAgICBpZDonMDAwMDAyJyxcbiAgICAgICAgICAgICAgICBpbkNhcjowLFxuICAgICAgICAgICAgICAgIGFsbFA6MCxcbiAgICAgICAgICAgICAgICBhZGROdW06MSxcbiAgICAgICAgICAgICAgICBpbWc6Jy4uL2ltYWdlL3RpbWctcHh6MDIuanBlZydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTon5aSn55CG55+z6Z2i5YyFJyxcbiAgICAgICAgICAgICAgICBwcmljZToxMC4wLFxuICAgICAgICAgICAgICAgIHN0b2NrOjIwMCxcbiAgICAgICAgICAgICAgICBpZDonMDAwMDAzJyxcbiAgICAgICAgICAgICAgICBpbkNhcjowLFxuICAgICAgICAgICAgICAgIGFsbFA6MCxcbiAgICAgICAgICAgICAgICBhZGROdW06MSxcbiAgICAgICAgICAgICAgICBpbWc6Jy4uL2ltYWdlL3RpbWctcHh6MDIuanBlZydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTonbWFjYm9vayBQcm8nLFxuICAgICAgICAgICAgICAgIHByaWNlOjE4ODg4LjAsXG4gICAgICAgICAgICAgICAgc3RvY2s6NSxcbiAgICAgICAgICAgICAgICBpZDonMDAwMDA0JyxcbiAgICAgICAgICAgICAgICBpbkNhcjowLFxuICAgICAgICAgICAgICAgIGFsbFA6MCxcbiAgICAgICAgICAgICAgICBhZGROdW06MSxcbiAgICAgICAgICAgICAgICBpbWc6Jy4uL2ltYWdlL3RpbWctcHh6MDIuanBlZydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTon54yq6IKJ6ISvJyxcbiAgICAgICAgICAgICAgICBwcmljZTo1LjAsXG4gICAgICAgICAgICAgICAgc3RvY2s6NTAwLFxuICAgICAgICAgICAgICAgIGlkOicwMDAwMDUnLFxuICAgICAgICAgICAgICAgIGluQ2FyOjAsXG4gICAgICAgICAgICAgICAgYWxsUDowLFxuICAgICAgICAgICAgICAgIGFkZE51bToxLFxuICAgICAgICAgICAgICAgIGltZzonLi4vaW1hZ2UvdGltZy1weHowMi5qcGVnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOifppJDlt77nurgnLFxuICAgICAgICAgICAgICAgIHByaWNlOjIuMCxcbiAgICAgICAgICAgICAgICBzdG9jazoyMDAwLFxuICAgICAgICAgICAgICAgIGlkOicwMDAwMDYnLFxuICAgICAgICAgICAgICAgIGluQ2FyOjAsXG4gICAgICAgICAgICAgICAgYWxsUDowLFxuICAgICAgICAgICAgICAgIGFkZE51bToxLFxuICAgICAgICAgICAgICAgIGltZzonLi4vaW1hZ2UvdGltZy1weHowMi5qcGVnJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgc3VtUHJpY2U6MCxcbiAgICB9LFxuICAgIG1ldGhvZHM6e1xuICAgICAgICBhZGRHb29kczpmdW5jdGlvbiAoZ29vZCkge1xuICAgICAgICAgICAgaWYoZ29vZC5zdG9jayAtIGdvb2QuYWRkTnVtIDwgMCl7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ+W6k+WtmOS4jei2sycpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdvb2Quc3RvY2sgLT0gZ29vZC5hZGROdW07XG4gICAgICAgICAgICBnb29kLmluQ2FyICs9IGdvb2QuYWRkTnVtO1xuICAgICAgICB9LFxuICAgICAgICBzdWJHb29kczpmdW5jdGlvbiAoZ29vZCkge1xuICAgICAgICAgICAgaWYoZ29vZC5pbkNhciAtIGdvb2QuYWRkTnVtIDwgMCl7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ+aCqOayoeaciei0reS5sOivpeWVhuWTgScpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdvb2Quc3RvY2sgKz0gZ29vZC5hZGROdW07XG4gICAgICAgICAgICBnb29kLmluQ2FyIC09IGdvb2QuYWRkTnVtO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhbjpmdW5jdGlvbiAoaW5DYXIpIHtcbiAgICAgICAgICAgIGluQ2FyLnN0b2NrICs9IGluQ2FyLmluQ2FyO1xuICAgICAgICAgICAgaW5DYXIuaW5DYXIgPSAwO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhckFsbDpmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBnb29kcyA9IHRoaXMuZ29vZHM7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwO2kgPCBnb29kcy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICBnb29kc1tpXS5pbkNhciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOntcbiAgICAgICAgc3VtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgICAgICBjb25zdCBnb29kcyA9IHRoaXMuZ29vZHM7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwO2kgPCBnb29kcy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgbnVtID0gZ29vZHNbaV0uaW5DYXI7XG4gICAgICAgICAgICAgICAgdmFyIHNpbmdsZVByaWNlID0gZ29vZHNbaV0ucHJpY2U7XG4gICAgICAgICAgICAgICAgYSArPSBudW0gKiBzaW5nbGVQcmljZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3VtUHJpY2UgPSBhO1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgnc3VtUHJpY2UnLGEpO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICB9XG59KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n")},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(26);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(2)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3Mvc2hvcC5jc3M/YTIwNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQXFEOztBQUUzRSw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsQ0FBZ0Q7O0FBRXJFOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc2hvcC5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc2hvcC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3Nob3AuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(1)(false);\n// Module\nexports.push([module.i, "gray{\\n    color: gray;\\n}\\n\\nbody{\\n    width: 100%;\\n}\\n\\n#goods,#car,#pay{\\n    width: 100%;\\n    padding: 15px;\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n\\n.singleGoodBlock{\\n    width: 10%;\\n    height: auto;\\n    padding: 5px;\\n    margin: 0 10px;\\n}\\n\\n#addGoods,#subGoods,#clearSingleGood,#clearAll,#buy{\\n    border-radius: 5px;\\n    outline: none;\\n    padding: 5px 10px;\\n}\\n\\n#clearSingleGood{\\n    margin-top: 10px;\\n}\\n\\n.goodsImg{\\n    width: 100%;\\n    height: 0;\\n    margin-bottom: 120%;\\n}\\n\\n.goodsImg img{\\n    border-radius: 5px;\\n}\\n\\n#addGoods,#buy{\\n    background: orangered;\\n    color: #ffffff;\\n    border: 0px;\\n}\\n\\n.goodPrice,.goodStock{\\n    font-size: 12px;\\n    float: left;\\n}\\n\\n.goodName{\\n    font-weight: bold;\\n}\\n\\n.singleGoodCar{\\n    width: 300px;\\n    height: auto;\\n    background-color: cornflowerblue;\\n    border-radius: 5px;\\n    margin: 10px;\\n    padding: 5px;\\n    color: #ffffff;\\n}\\n\\n#operate{\\n    padding: 10px;\\n    width: 20%;\\n}\\n\\n#onceNum{\\n    width: 30px;\\n    height: 20px;\\n    outline: none;\\n    border: 1px solid #b5c0d6;\\n}", ""]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3Mvc2hvcC5jc3M/OTIwZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFnRDtBQUNuRjtBQUNBLGNBQWMsUUFBUyxRQUFRLGtCQUFrQixHQUFHLFNBQVMsa0JBQWtCLEdBQUcscUJBQXFCLGtCQUFrQixvQkFBb0Isb0JBQW9CLHNCQUFzQixHQUFHLHFCQUFxQixpQkFBaUIsbUJBQW1CLG1CQUFtQixxQkFBcUIsR0FBRyx3REFBd0QseUJBQXlCLG9CQUFvQix3QkFBd0IsR0FBRyxxQkFBcUIsdUJBQXVCLEdBQUcsY0FBYyxrQkFBa0IsZ0JBQWdCLDBCQUEwQixHQUFHLGtCQUFrQix5QkFBeUIsR0FBRyxtQkFBbUIsNEJBQTRCLHFCQUFxQixrQkFBa0IsR0FBRywwQkFBMEIsc0JBQXNCLGtCQUFrQixHQUFHLGNBQWMsd0JBQXdCLEdBQUcsbUJBQW1CLG1CQUFtQixtQkFBbUIsdUNBQXVDLHlCQUF5QixtQkFBbUIsbUJBQW1CLHFCQUFxQixHQUFHLGFBQWEsb0JBQW9CLGlCQUFpQixHQUFHLGFBQWEsa0JBQWtCLG1CQUFtQixvQkFBb0IsZ0NBQWdDLEdBQUciLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcImdyYXl7XFxuICAgIGNvbG9yOiBncmF5O1xcbn1cXG5cXG5ib2R5e1xcbiAgICB3aWR0aDogMTAwJTtcXG59XFxuXFxuI2dvb2RzLCNjYXIsI3BheXtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIHBhZGRpbmc6IDE1cHg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtd3JhcDogd3JhcDtcXG59XFxuXFxuLnNpbmdsZUdvb2RCbG9ja3tcXG4gICAgd2lkdGg6IDEwJTtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIG1hcmdpbjogMCAxMHB4O1xcbn1cXG5cXG4jYWRkR29vZHMsI3N1Ykdvb2RzLCNjbGVhclNpbmdsZUdvb2QsI2NsZWFyQWxsLCNidXl7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgcGFkZGluZzogNXB4IDEwcHg7XFxufVxcblxcbiNjbGVhclNpbmdsZUdvb2R7XFxuICAgIG1hcmdpbi10b3A6IDEwcHg7XFxufVxcblxcbi5nb29kc0ltZ3tcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTIwJTtcXG59XFxuXFxuLmdvb2RzSW1nIGltZ3tcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbn1cXG5cXG4jYWRkR29vZHMsI2J1eXtcXG4gICAgYmFja2dyb3VuZDogb3JhbmdlcmVkO1xcbiAgICBjb2xvcjogI2ZmZmZmZjtcXG4gICAgYm9yZGVyOiAwcHg7XFxufVxcblxcbi5nb29kUHJpY2UsLmdvb2RTdG9ja3tcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBmbG9hdDogbGVmdDtcXG59XFxuXFxuLmdvb2ROYW1le1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLnNpbmdsZUdvb2RDYXJ7XFxuICAgIHdpZHRoOiAzMDBweDtcXG4gICAgaGVpZ2h0OiBhdXRvO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjb3JuZmxvd2VyYmx1ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgICBtYXJnaW46IDEwcHg7XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgY29sb3I6ICNmZmZmZmY7XFxufVxcblxcbiNvcGVyYXRle1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICB3aWR0aDogMjAlO1xcbn1cXG5cXG4jb25jZU51bXtcXG4gICAgd2lkdGg6IDMwcHg7XFxuICAgIGhlaWdodDogMjBweDtcXG4gICAgb3V0bGluZTogbm9uZTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2I1YzBkNjtcXG59XCIsIFwiXCJdKTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n')},function(module,exports){eval('module.exports = "data:image/jpeg;base64,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"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbWFnZS90aW1nLXB4ejAyLmpwZWc/YTA1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQ0FBa0MiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwvOWovNEFBUVNrWkpSZ0FCQVFBQUFRQUJBQUQvMndCREFBTUNBZ01DQWdNREF3TUVBd01FQlFnRkJRUUVCUW9IQndZSURBb01EQXNLQ3dzTkRoSVFEUTRSRGdzTEVCWVFFUk1VRlJVVkRBOFhHQllVR0JJVUZSVC8yd0JEQVFNRUJBVUVCUWtGQlFrVURRc05GQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJUL3dBQVJDQU1tQXJ3REFTSUFBaEVCQXhFQi84UUFIUUFBQUFjQkFRRUFBQUFBQUFBQUFBQUFBQUVDQXdRRkJnY0lDZi9FQUU0UUFBSUJBZ1VDQlFJRUF3WUVCQVFBRHdFQ0F3QVJCQVVTSVRFR1FRY1RJbEZoTW5FSUZFS0JJNUdoRlZKaXNjSFJGaVF6Y2tPQzRmQUpGeVh4TkZOem9oZ21LSU9TTlVSVlk3SmsvOFFBR3dFQUFRVUJBUUFBQUFBQUFBQUFBQUFBQUFFQ0F3UUZCZ2YveEFBd0VRQUNBZ0VFQVFRQkJBSUNBZ01CQUFBQUFRSVJBd1FTSVRFRkV5SkJVVElHUW1GeEZDTVZNeFpESkZMQjBmL2FBQXdEQVFBQ0VRTVJBRDhBK2JvYS9vR3l0dHBOQTdBVzcwQmRybXc5TzlFTG43bmkxQUI4SDJwYXNBTDN1S2JIQnVTVDNGS1gwcVNCY0h0UUE0V0dqU2JBYzJIdlRrY21sRWpBQUN0Y2s4OFZIVkxDeFBOTERBS1Z0WWU5QUQ4a1JsUTJGd0NSUjRsN3ZCcHNMUkFHaHI5Q2FCcHQ2Vi8zcFV5cXlQcElGaHY5dmIrZEFFZVVBbGZUdmZrMDA1YU56c0MxL3dDVlB2R1J0cEIyRnlEZXg5NlRNQzV2ZlVVSFB2UUEwR3R4eDcrOURnM3RiNG9yM093NDMvZWdwdVR0dWFBQnhjL1Y5KzFIWVAzdFNWWmI3M3ZTamY4QVNMajVvQUpEcEczOUtOVDZ2VHRTTGhVc0JSbmtYMnNMMEFMSEpvTURJYjgyN0NrQTZyZk5EZTl6c2UxcUFGYXRnTGkzdFJzcEIydVI4R2lJL3U3Zk5FdHhlN0QrVkFDeXhCRnJxZm1pM2I2bU42THZ0Ujk5aHQ4MEFIcCtMZmVrdHRSSDZyQ2xQdTV0UUFRUU1iOC9GR1RwMjJGdXdvQTIydDNwSkFERUhkRHZ0NzBBS0RkZ0xGZDcwQVRjK28wUWJUMjAvUE5FYjBBSDlZdlJXdnRSS1FkK0xVdjNKRmgySU5BQmkreSsxSzBrVWk5N051UG1qUWE3MklJKzlBQ2o5Tmw0TzlKYjFDd05qUm93RzFFMngrYUFIWW1Ed2xiQUVmcUlwcVI3cUN0eVBrV29JL2x5QlFkdVRTNTlwTDJ1RzNGQURZTnhRRjlYQUlvRUZWdU42SnRJRnphNW9BVXR6dHRlL2FsRGhodlNMa3VBUFR0Ui9TYmU5QUI2RDlRWVVvRm0ra2d0M29Kc3ArOUFnSG52KzFBQ2wySEhxOXZha3FDTGtteE5EYlJlMWwrKzlCaU5JM29BRGNiRzlDNHN1azZkK2FOeHBzRHRmaWtsVDcvTkFCaHJYdUxHOTcrOUZlMnk5OTZNbG1KTithS3hzQmZlZ0E3bnpCZmZhaVZOS2hlTGIwWkFBRndRYUlYUHpRQVpheWFsRmdUUWJnYi9BRmRxSmdiaTNGRVFMM0lvQVZhOWhzTFVkclhGZ1JUWnRjMlUvd0E2VUJmMG0ybnVwdmU5QUJqNU9taHBCSktrZXJmVWVhU1MxeVFBTFVGYnV5bmVnQUxxdGJrTDdDZ3BzZjd2dURRVVdTMXJmdlNSYlQ2dDZBRk42amZVVkh4UUp0Zm0zeDNvQmR2OUtCTnR4ejJvQUlxYmVtKzRvRytrNlJ2N250UUp1cTdYZnZ2eFJNTlRBc3dZamJiYWdCUU93dTExOS9taGZiZHQvZWthZlZlMWg3VVlVTVRmajJvQUFZSnZ5YWM5UjNPNHB0VjlONmNVN1dQYm40b0FVRGMyNFgyb014QXN2RkZjMnVCWW1nNEJWYlVBT2FmK1FrQVcxM1gvQURxTVJjTmZzTk42Zk9sY0s1dVQvRUZyZmFtSFBwYjJ2dFFBWlVKYjFVblVHN1VHdGZZa3I3aWpHOTdiMm9BV09SM3BER3hJMWtEMm93Q2ZWWTJIWWJHbHV1c0xaVkF2MzVvQVF6Z3JZRnRqd08xQXR0cWJUZjNQTkxFWjBiYkxmOTZIbGdiM0Z4NzBBSWE5ZzIrKzFEbXg5Tnh0eHZUMGFxbHdOZ3d1U2FLNUFBVzE3ZDZBRUNNc1FSZmYzb3ZMYTdxZHdleDRwd0cxckhSUzdGbjlYSnAvd0E5QmpjWmdzTThFV0tlTER5RUI0bGIwdjI0cU9Jdlc0WGZzYmJDaUxNekVjdGIrVkUxazVKMzkrMU5ZQXNvWTNzRC9BSWVLTVhKR3J0dlFzR0Z0Tmo4MFdvb2ZXRkk0cEFCMnZ3Vzk2QVVFMjBtLzNvdzJseU50K1BhaXVOUHAzVThudlR3RDA2UzFqYmZrVWs2OVRXWUVYNzBxelcwY3JSQ3cvdmltQU1uVWkzRnJVQ0NvRnJXcFVaR25TZmJpa202M0FzZSs5QUJXQy9KTkFnRVdGd2ZlZ2xudVc1L3BSQTZRZWR1OUFCZ2hkdDl1S0RDNDR2UU85bUoyTkF0UUFzTUYwN1h0UzQ1Qkg5WGZZbTE2YUNhcm0rNDRwWWNwSDlPcGp6UUJJOHV4MURjVzdEbW01THJJZFM2RlBjMGhaaWdKSnZmc1RhMVBzbm5rRGE1K2xyM0MwQU1UeGhXUmw5U3NONzdiMDNja2x1V3FaakRHWlVSQ1dWVnRxSXRkdTlRbXV0MUo1M3ZRQUJZSDA3TjNwSkp2ZlViMHV3N2ZWelJhajdVQUVITFdOckMxQnJXREM5ajcwZHJnSGdXdFF0Y0VkaHhRQUJkNzM0SHRTcmczUDZUU2I2UnQvV2dGc1FkV3IvQ0tBREI5SkZBallVa0VFbnRTeXdJdHo4MEFKQU42TUczTkFEMC9GK2FCWGJtZ0JMZlVDT2FVQ0czQXUzdlNUY01DS1d5aTVGOVAyb0FGeWVUYzBtKzUvbFNnTnFBYXpjQTdXdFFBZ2NYUEhGT0VncllINHBJQVEyTzRPOXFGemYwbWdBRGI2VnVQWTBDUURkYjZqeURRVmlPYmswWTFYTzRCb0FJRWJrY2R3YVBzU0JwSW9LZFc1WFFmODZCQkgyTkFBVzJ4L3JSdU5Sc1RidUtPd0EzOTdpZ3JnbGp5YlVBSkJGcldHcW5IdkpGMzFMdnViN1VqOUtraitWTGllMGlnYlg3ZTlBRFpLcWJEanRSN3E0UEpQYWhJdmxzMFozTjlyZTFFQnQydjJvQUkrcHR0elI4L05HRzlSRnFDRG1nQllhMURVQVJjRGIzRkVMMkl2KzFCZ0N3dHZRQUNiYjgwUUszNE5IUXNDZGovQUVvQUIzdVRjbmdYN1VCeGErL3ZSa2JkeDlxSnJhZVJ6YTlBQ2d0dnZTVGU0dFFiZGlBYUpUYmFnQlRxRzJ1YjBrQUxzTC9hbEVpd042U0dBYTUyKzlBQmh3TDNOdnZST1FTTEhpaUg2eVFMWDVvM1gxYlhOQUJHNUpzTEtSejgwU2k5eURZam0vZWdwWlgyMnZ6ZW5DZzNOaUI4MEFJSjFXQTM3azBONzdpNCthTkVLZzhjKzlMWjBPd2FnQkM4Y1cvZWlVWE8xSHNUc0wvOTFCWlZDa0FBWDdpbG9BS2xnekE5KzlLSXVPTjZRWkxiM0gyTkJXYTVJdTEvYWlnQWZUdU8yOUdHVWdrZ2U5RkhIS1ZMYVdZSGluUHlzbG1MYVV0YlluZmlpZ0VFZ0M5dHFMVUNOcWVHQkpDaG5OanZTL3l0Z04vVXd2OEFha0FqaFRZKzUydlM3Z25iL3dBM3pSa0FCck1McnpTQnpjRzlBQ2hZWHRmZmcwYUE2cmordEFqYjVwT3ZTTGR6UUE0eWhzR1J3VExjL3dBcWpxTlIvdmJYdFVodDhLb0lOakp1UDJwa0xvWUx3Yld2eFFBWUdxeXFTdGwzc0xYbzBQbUVjWHZhNG9sQksyTjlWdWFDYk5ialR4YnZRQXRrM1A2eDgwQmI2U05OQzVBUHo3MFkra3JiVWY2MDVBRXphcmJYM3ZhallYbERCUUN3L2FpTndPUmNVcTVkZ1BxSE5LQVNlbjN1QmExR1JlMXlUdDcwZm1BcWJrRnp0dDdVVFJsVkhOcWFBVnlXQU5oOTZWZjFiMG14VVd2YmZtMUFrSFY2eHh6UlFBc1BjaHZjVUxsdmQ3ODZxWEdBVHViZ0RZKzlLTDNZYVVKRnQ2S0FZQlliMkk3RUdsQlF6RVc0TnhlbDdtNDR2Mm9hZlZZc0RSUUNiMzFBalRmMjdVUUJDYkw2ZUwwRUNrWDFYYmdta2dGYmtmVHlkNlFBN2diYmx2Y1VMZkxVR3VUeWR4ZmlpQ2cvL2VnQnF3dllNMTcvQUZVYXNBZXpXN25rMGxqWVhJTFhQTkhiY1hHbS93QVVBRTlsdUQzNEZFVHBYWU5idmIzcFRNcktmYi9GelNHVTJJdVJmY2ZOQUFPOXJEVXZ0M3BXK2tXQVVlM05KNEh2OXUxR1RZRG1nQXdlYkMxRVd2WUhZKzlBSFkwUU8vSDg2QUhZMDFOWUFIM3ZUeU9HSkRlbExjTDNxUEd4UWl4NW9JZFRnNzZyY2RxQUpPaFhVaU5yMkZ4YzFIWVhJREQ0dDdtbFJnbzZxRHp5TDA1UEZvSlpTVkZ1Mjk2QUk0RnJENldORUFGdjZRYU1FV0Z3R0k0TkVpNm1zZWFBQ1Uyc0R3ZTFLQU5qdFNMcWJYQjI5cVhxREEySi9lZ0JOcmpmYjcwZXJUYXd0YnVLTDY3cWQ3ZDZNZlFhQUNDbTNHM3Q3MG83S1RiaWdDTDcvd0E2TFZleDRCOTZBREJJdFlVYWpVTHNkSi96b211VHRSYW1Ya1hvQVV3c1FMMythQlVFNzcwUVluOUl0UnR0Mm9BSTJzUUJ4U1JjSGZZZkZMVUFPQ2VMVVc1MzdVQUdUYVFIU3RyYzBaVTIxSGNleTBRRmxQZjRvS2JYQTN0UUFGTFczR21pWVhVZzI1dllkNk5TRFlYSUJvZHI2cUFBVkcycHY5aFJXQU45cm5pakkzWGJhZ1ZKM0lHMUFCa2tnQzlGNlR0YmVpTzUyb3dmMk5BQmtBSDRvYWRKQkZ2MnBWd0J4ZWhZMzMvbFFBcVVoa1ZySFVEWS9OTWx1TGNWSXc3RFdWWVhCRzFNa1dka1AxQ2dCUE85cVVwUEoyb0VBQ2lCQVBjZk5BQ2xJVmliM29sSlp5QjZSN1VXazNZMzJKcFpGemZpZ0FpYlVaRjE1c08zeFIrbGJhdTRvdFNjYjdVQUVHSkh6N252UkUyRjFzUmZnZGpSc3cwblR2OEFmdFF2clVnaFJ0ZjA4M283QVZ1VzNGRVl5TDZ0Z0tScTFCQUc5UTVhOUFwSXg0WjJ2eGFsb0JTb0NQcUFvOUtMZlY2dmluSTh2eEVoQjhtMSt4TlNFeXJGS3dlOGNSUWczTzlxVkFSUU5kdEtha0hla05JNFllZ0EvZmlyekVRWXpGNG1URXpZblZOTUJyYnkxVU1CdHdMVy9ZVXl1VHd4eU1TaEQ4aG5ONlNnS2p6R0xFZnFvaHJjMzlXM3h0VjhtQmdqWUVxRkIyTEQzcFJSRkxoVHR6OTZLWUZIRmc1Wk53bHo3dHRUZ3k2VXNTU3FnZkZXY2pxRjNJQkh4U1gra0VNVUY5KzlGRGJJWXlzbDdOS29CRi9wcFM1ZkdvQU9wMVhrOFZLTTY2UmE2a25tL2FtaktBV0trc3Q5NmNPQ1hEUktMaFFCN0h2U3ZTRk9sYmZGSjFpeGJjajJwSlBmZmNYb0dDdEpKMEU2Z2VDTnJVbXdXNEZwRlBMQ2l1QVFvMUFqZTU5cU9VUnBLL2t5Tk5HMXQ1VnNiOStOcUVBUFNGQUkydllVWlp0WUpJTjl2YW0wSUZ3VkxHOTdrN0NqWWpWdjZoejlxR0tpSStsVEpackFuMG4zK0tBYjFDK3hvTjVZRVdteGtOOVM5aHZSYkU5L3ZUQndwd1N5MnNiVUNyQyszN0NpMlhlNTV0dFNqc2ZUZjJONkFGT3YvS1I4alU1SitLYUM2YkU3ZklwNlQvOEFCb0w3RTNQeFNGSkY3V1VXK284WG9BU3BMbTUzYjJGQnJDM3ZSWHVDZFJQdXdGS3RjWDRGQUNqc2dzZGpSV09pNTNQZGgzb2lnQTNHbyszY1VvbXkyRy91S0FEc3FuWUM5SnNEN2plMUs5QlJEYjFkNkc3QWVuYS92U29BbmNxQnVGUDIzb05xSXZxdjlxSzYrazI5SXVDVzk2VUxyNmIyTnJmQnB3Q1NEWVhKSSthVWxoWUJRYm45NlNISWF4NUZHb2E1SjJ0d2FYNEd0Q3hIZTF6c2V3N1VzS0FRb2JVQnlmZWtyR3diWU0zeUR0VGdpSlVGYktlNHZ6U0NCQUFLMXRoN1VoaUxkeDhVK3VFZGpjS1Q3cU9SU2x3TWpFS1ZzN0hZRTMyOTZXaDFrSGxXTzdkK2JVUnZ1QnNEYXJPREtwY1RJNlE0ZDUyVWxiUnFXdWYycTB3Zmg5bitZWWN6UTVWaUJEZXpNNENBSDk3VXltS1pnSVFDYld0dHFvL0xiKzhEV3hYdzh4VURzTVptV1RZSkxqVjUrUFhVby83VnVhUU9tK25Bemc5YlphQ0d0WmNGaUdBL2ZUdlJUQXhTdVNBT1JlKzFGcTV0cVkvTkQ2VFlDdzk2TUN6SGUzeWU5SUFXa0QxQWFqL1M5QWVvV053QjM5cVVHQTFBaTNmYWtsV01aT3hVMEFCcjg4ZjYwUjRIdjNwd1dLNmIvYjRwRHBhM2IvV2dBUmdmVndmbWdTQzIvQjVvbVh2ZjlxRjl0NkFESnR0L0tqSDFFLzBvbUFJQU80NXRRRFhheFBhZ0J4U0NDU0xmSGFwS1M2UlpoNmJXQUZReGNBaERjZk5TTU1ScFVnamRyc3BOQURNc0pVRXFTUmZnKzlGSW80TnVON2MxTGFOVzFFWDAzNXYzcGxvaXdaaUxiVUFNeVdaOVBZZTFKSjFqaXcrS1d0eXVyYTVGNklXQXN3SU4rUGVnQkNDd1lIdndLVVBidFJHNEozb210WWlnQWI3cWQ2V1J2YmtkaFFVMkFIdnZSajcwQUFYRzVvaGM4YlVDemNjMFNrM0kySHhRQVoyVTNOeDNvN2IyRy90UUYzVTBxMTk2QUVnRVh2dDdHZ0ExejZ0aHdhRGMySm9MNlR2eFFBVmlSenZScU5SQU8zdWFBTjJQWVVrdGR2dFFBWkozRnJVQURhMUt0NlFiRy8ycE4vdUQyb0FVMFpDMk42U0FSdHo5Nk1GcmVyYzBSZlQrbTlBQmdYSDI3VWR3RGNrM1BhZ2poaC9wU1NXSnQyb0FkdGI3MFVyV1lmMU5FaEF0YmV3dmFocTJOd0Q4VUFLRDZaTEsxaU53ZTFPWXBMaEpCYTdpeElQZW1XVU10dTN4VHNhZWNqeDIzdGRRT2FBSTl5cldPNW9IZXg3VXZlL0ZnTnQ2SlFXSnRZNzhHZ0FqZmUyNG8xaVoyc0Z2VDhLQlNWYXhxWkY2QjlJMjcrOUxWZ1FCZzVuNGpDMjltNXA2UExYSnVaQmM5cXNJU2x0OXJEK3RLRXVsVk43WC9WUzBKWkRHVnJwREdSeU9PS2VpeTJCQzZzdXB1MTZlYWJTeERYMG5ZVW1XY2FBU2RSNEo3MG9XT3Bob1kxRGFFVGV3TnIwOFdVSGU0QjIyNy9OUWpONkF0enA0QU5FMGpFZTl0aWZhZ1JrNE9xcnBOZ0FQcXBCeEhwQmJacWdzNFpOSzMrMUZyT29YTnhibWdRbVNUUElENnJ0Ym1pR0kwcUEycHdSdVJVUU5wM0hmbjRvZ1d2ellXdFliVUFTak9MZ0EzRjl6VGJUc1dHMTc4ZzB6cUNCUUJ5Ym1pMU1YTzlqemFpZ0ZxMjVCMHJla00zcnNHcEt1V0FONzl0KzFCUDRnS2tXdHpRQWVvRmRRRnlLUFVkQU9zQkR2YW05WVlMcUlPL2FqS1gxYmdIK2xxQmFETG14M0F0NzBtNVpDUGZlNTdVUXZ5UURialZ3YUFiYmtYSjQ5dnRTQlFDeWl5aTl6d2Iwa0JocExDeHZ4UjM5UkpzYjBDYmtnRFkrNXBRb1dkOXVIYTlIRXQvMTJZQzIzZW1uOVpXMTczdHpUbW9PYkFBS0RhdzVwQmFaSGx4QlpVajBvZ2pOcnFOMlB6U0JxRnllTzlMeEFYekQ2RGJndmYvTVVsaFlibTZqWUVVMFVJcXV4M3BTK2tDM045NkJCUzRVQ3crbzBCYlNOT3lqbTlBQ3BBU2tBT3hzU0xmZWlBdGZ2dndhZkNlY3NDcWRyRlNPOXpTMndMU0IwSUt1bTF0UGVscXdJaGE1dHFhLzlLTFltMS91S2tHRTZGTWpLTG13SVBmdlJ4NGN5blNCTklwRjdSUkZpRDgyRkx0WWxrWVNCaGExaDdubWpHb2pVTi9oZWJWZVlIb25QTXdSSmNObE9NbWhMRlJJSVRZKys1cTBUdzN6V0lMTmpKY3Z5dkR1RC9GeG1PakFHOXQxVWsvMG9waFprVmpJSklObGIzb3hFeEZpTlNqaGhleCt4NzFyaDAxMDNnSlN1WWRhWUpnQjZUbGVFa3hWdnVkcWV4QjhQTUMwU1FQMUhuVm9ydk92azRTTjNQSVZXQllBR2hMN0ZNY2NPeFBETTNhdzlJSHo3VVFpdUFoZFNlOWlMMXJvK3NzaXcrWHBIaCtoOEEyS0IyeG1OeGMwckg3cmNMZjNwT044Uzg3ZGcrRHcrVTVFUVFWT1Y0QklTU09EZTVKcHpRbkpSNFhJY2Rqb2wvTDRIRTRwRDlKamhZaHYzdFZ4aC9EelBKWXhML1o1U0VqYzRpYU9PMzgydlVITWVzZW9NNGZ6Y2RudU5ta085eE1WL290cXBKNFlwWldhUU5MSVJjbHpxdjk3MDBPVFpIb3JCNEgrSmorcU1pdzhJVyttS1Y4UktwOXRBVWIvdlJ4TDBabDh3WEVadm0rYUt4K3JLOEdtSElQdGVRbmFzYXZwSkNvcWdIYXh0WWUxTFFxdWtLQnR6Y0RjL3RSWWhxcE9xdW5NUE95d2RNUzR3STNvZkg0OWd4SFlzcWJYcEtlSW1Qd21JTDRISjhsd0xhZlF5WVRXNkQyQlluZXNxMGpXdTFpUzNQRkdMZWFObEI3Ry9OTFl0Ri9pZkVIcVRHRFFjNW5qQWJVQkVpUkcvM1VDcVhFWXZGNCtWM3htTnhHSVkzdXJ5c2IvTjcxSERwZjF2WnliRVVQTUJDMkpBRzIxRmhRVWNjY2VvSWdOK1c1Ti92U21rVmp1TEg0VzlORjFVZWtlaE5oZm1qL015cnNGVWlpeEtJeElZOTdlMUdEY0twNEJveC9ROFVTamY3VXdjSHNRUUtUWmd4OWoyN0NqVUU2ckMxRURxQXR1Q042QUFnQXZhN0VjZ1U0Zlh2YXgrYWJSUUFUd2FBRnR4ZTlBQU4wYjFEZWlhL2NEZW5tT3RRRHpUTExmazI5aFFBRkhibWpBM3VSUnFkN2dXb2lkeVJRQUJZSGtnVXBTQUNvWDV1UlJVUVlzTFhJMnRRQklWa1VjN0hhMXU5T3Jya1oxTEFoZGdvcUpZbnZmNzAraDh1Sm5XM21FMEFKVERBUnpGbUNpTlJ0M1luMnBtMnZiYllYQlBlcG10UUdEZzZpTEt5N2dmZWp6UEN3d3oyZzFGZEM3bjM3MG9FQWh1YVg4azkrS01ycE4vODZiSnRlOTl6U0FHU0MxeGVqTzlxQk4wRmh2M29Ia2l4MjcwQUczQU51S0FzQ1EyemZIRkpZN2JtZ0J0YzcvZWdCUVhUZjFBZysxQVB1QWJiaTlxQVFXdmE5dHo5cWQ4MjBLSUNyUkFFN0x1Q2FBRzJJdmUxaDhta0YrZGdRUGJlcEt6aUprZUhEcW5vMG5hK3I1SXBnUmFRR0JGaHo5NkFDdmZZVUZOeHQyK0tkOGtLMXdUUmhRU0FBQWU0b0FaM3RiVTIzRzlLMHM1SUhOT1JnTTIvcEFIZWpCMGcyb0FZRVJJdnZiNXBTeEZtMGdVN2U0Skp0OFVhU0FXTkFDUkNMRzNJcFpoQjk3VWJBMlAzN2UxSzFBM0k3VUFOVFFybzFiQUpzYis5SXZzZU5oZW56cGREcTNIYjVwanl4NnIrbjIrUlFBU1c3bTEvZWxSdHBlNHZ0N1VCWThLRGIzNzBZWStvV3NQYWdBNTE4cHhjRUJsMUMrOTZidG9JSlVnbW4wdExBVkY3eCtvL0k5cWozWm5VSXBrdnVGSE5BRGlnSzN2VXFJNmpjbXdYdFVUVmU5aHVLa3BzUUNUWnZiZWxUb2F4OVdHcTl5cEI1OTZTMXcxMVB4djJwc0cxdFJ2YWxBczRJOTZkZGlDeE12dVQyM295MWh1Ti9paUcwWWEycnR0UkQxRFk3ZHozRkFDdlNFYm5uYS9ha2h0WUl2Yi9XaHlRTDJBM0JQZWt2SUZXNHRjZjFvQVZjM0lKdVFOaUtTcExpeTdXNUhhallnbnN2dUJSRXJ2dnBQdFJRQmtYdU5oZmVnUnFiWUdrc3hzQnB1UGVpc2IrcjFENFBGQXRCNmRKTnpjZTRvTVFTT3pkalNibmJmVXQrZTlDNFlDM2MveW9zS0ZPUUNDQmNuWSs5SjE2VHNCWTdEYm1rcVRwTnZVd050UXBlZ3V4S2tYUDlLUVFJTmRpR0Z6YmloY2lOamJnZ2lqRVREblpyMkpQRk5rckg5YnF1OXQvYWxvZFliQUFYQUtzZWQrYUoyYlIvZXZiYXArRHlITk0wVlRnOHJ4K09CNGJEWVo1QWYzQXRXenlud0E4UmMxVERTcDBoajhOaGNUc21KeDJqRFJXOXl6a1VLTEN6bm9BSU9ubnNEelFHcGdOZ0Y3M3JyVWY0Y013eTNHbURxYnJQcEhwa1JyckJuelJaMlB4cGp2dlVGdWh2RGJMTUk1elB4Tm14MklSdjRjT1M1Ukk2di9BT2R5QlR0b1djMTBGclh1cEkyMnZSeEZVYTdNcTdkeUNhNk8yYytGT1U0Y0REZFBkU1oxaTFQOFNmSFpnbUZqWWY4QWFnWS90VFV2aTdrdUF4cVBrdmgzMDlnVVFYUmNZWHhadjduVWJFL0ZxS29XN09keUpFbm0zVXVDTlN1Q1F0L2tXcG05d1Myd05pQVBldFgxUDRqWjExWmhNUmhNVmhzc2d3a25ySXdXWFJRRVdOd0xxQWF5ckFzVUpOeGIrVk1ZQWE5aDJzTG0zZWowNmlMaXdHKzFFUnZZRy92UU96RzFoY0FiMDBDMHkxY3Q4cVpzd3htS2dsaUN2QkJoNGc0bDlWbTFHL3BzS3RuNml5RmNJNGd5akh2aVcvOEFHbXhnRVozM3ZHRnYvV3MxSlpYMHRwSXVDQWQrMUdaSGVOeXBOckN3V25KMEZKOW1vdy9YajRVWWxNRjAxazJHODRMWXl3bVV4cU80TE1kejNxVGl2RnpxekVZeWZGUjVwSGw3VEtxc21EaFNKYktMQUFBVmpTcFFocml4RmlQL0FFb2lReDNZS1NmYTlMdUNrdWlkaXM3ekxHU1N5WWpNOFk3U0VzMTVXQUo5N1hxQytIaEpFaFFPeDVaclVreWdoaVdackcxaFFFb0pJS0FDKzE2TndsRGdWUmRBcStvN1g1L25TbmJTNFkzUFlnRHZUQmMzdHBHa2Q2QmR3aWtzYkc5clVsZ2g4c2VOeUxjWHNLYllxYnJlNXQzN1V3MXJEVTFnZTN2UjJzd1lrQkxlbWl4UjB5SVhDbGpiMkZBeUJTRGEvd0FkNmJCMGo2Z3ZZSDVvaUFDcDc4RzNlbWdPTkp5ZElDLzFwT3M3V0kvbGFnWkEwZ3Q5UCtWSklCZXhjbjR0UUFvM3Y2MjJvaFpqY2pTbDdDL2FpSUNNRGU0OWpSaGdvSXRZazMrS0FDSkN2dFlrZC9laTAyWDNIdDNwSmM3bTEvbnRTdXg1Qm9BTjdCSEJXeFB2UURzUnNLU1dKWVgzdU43MGUvWTJvQWF1eFlrY0hhMUVXWlZMTHVEL0FFcGR1MSs5RWdzU3Q3aWdBanl3RzU1b3g2bXVOZ0JZQ2l2czErUjMrS0FHbGJqYzBBQzlxUGk5RmJmNTlxV2JBYmdVQUlKSXNhY05uVU5iMTBSKysxSnNHdUw4Qzl4UUFTaTk3OGlqUDFEZTlMWWh2VW9zTnJpbTJGbkk3MEFENW9yMjk3VUNBRHUzN1VwcnFvQU81b0FMV3R5ZDdkcUlOcHNTTis0b0FGMFlyd1BpbCtZMWlvOVFKRndWb0Fmam5TR0UraThyYmdzZnAvYW44T1YwRnBQTWFRc0NxdHd3dnZVT052S0lZS0NSM0lxWmwrTVRDbVdTU0pjUlBJbWlOM0pBalBKWUQzcGJFR01jb1NRMllFRW00OWg3VkhBdXUvMC9OU0o0ZzJxVmR5eDNIejcweWJNTndkcUdLSTBjOXIwdFNVdUFiMzk2REU3ZHZhMUFlbytyK2xJQWxsMUdqdUNMVVpBdnRzS1VBYjdoUlFBQUcwK3c3VzcwWU4ySjkrUlJHOXJBODBRSHQyb0FVV3N4MlBGcmcybzBZMnRZVzRwQk45K2UxcUFhOS84QVRtZ0J3N20vZWs2anVTTEgzb0tkV3c1K2FDc1FUdGNYb0FVMUFrVzRvamNrM3NQdFJCeGJlMS9hZ0JRSHB1QmY0bzF1Vkp1RitMVVdyaTFFZDZBRnExOXh0ZWpKWWV4SnB1KzFqKzlxTnJFbm5WUUFMRkFOUGIzb25BSkJQMWNXRksxZW5mN1VmbERUemMzc04rRFFBMWNNZHUyMUdkamIzRkpLRkJZTU5xVWQ3WDVIRnFXaExGUnkrVklwUDBrV2FsT2o0WEVNcWtBamRYSHNhYlpBZGlPZTlQTjY0RmMyOUd4djNGSURBRklKQnNHLzBweFNWM0JzZmloaG9kVXNvQjgxaUxpM1lVUlJ4SUFRd0gycGFHaHJiMCszY1VmbVd1QnNldytLUkhxdWVOSkh0Uy9KQkJhNmtXN0duSkFBZzZyWDJGRXpnMlBZZTFBTkdyYVhZYXZocXNNcnlETmMrbmFIS2NvekhNNWIvd0RUd1dFZVVrZTRzS1doTElDa3lOcUlzZllVSkcxQTJBdnh0elhTc2ovRGg0bjU1QTBtRzZKelBDeHA2bmJNa0dGQ2ozL2lFVk5pL0Q3ajRzdWx4dWJkWmRFNUVZcmlURFlqTzRwWngvNUl5YVZSRk9UeXF4RjJONysxSEpHNWF4TnI4V0Z6WFU1ZWhmREhLRXcwK1A4QUZNWnRyUDhBRnd1UjVYSTdyLzVuc0tmT2RlQitVWXREQmsvVlBWT0hGOVJ4VTZZUGYyRnIwbTFmSUhKZUZXKzQvcWFLTmZOY3F0NUdPd0NibituTmRXSGpUMFZsV0lranlQd215anltVWlQKzFzWExpSlYrVFlpOU5MK0pycmJDWlkyWDVSQmtlUjRPOTFYQTVURUpFSHNIWUUwN2JFTFpsTWw4Tk9yZW81WW84czZXenJHelNteWVYZ1pOTGY4QW0wMnJjNEQ4S3ZpUmlKaEZqc293ZlRUTnVIei9BREdMQmdqL0FNMVpEcUR4bDhST3FvSThQbTNXV2M0bkRSQzhjUzRueWxYOWt0V094MHMyWVNOSmpwNThiSXkyRW1LbGFSdjVrMDIwdUIzSjF6LzVGWkxsbjVsT3BmRm5vL0o4VGgyS25DNWZNMlBkdmNEUllYcU8rVStEV1dZR04zNm82bzZpeFlZYXNOaE1zWENSc1A4QThvN20zOHE1UXNTZ2hDdGd2OXphbkFScnNkWnQzSnBkNFVkVWw2ODhMY254c00rVGVHbUt6RUlQVW5VR2RHUldQMlJiVXJDZmlKeE9UWXFaK251aWVrY2tqY1c4b1pZdUtZZithVGV1VW84YUxmeWhjLzBwU2xoY2pZSHRTYm1GRy94bjRoUEVqRzRPWENwMVBqY3V3a2pFbkQ0QkZ3c1lCN0tGdGFzam1mVkdmNTJ1ak1jOXpMTUk0ejZVeGVMa2tBK3dKcXJMUHRleE4rRFFjbTdhamE1N1VibUxTQy9Mb1ZKWmd1ci9BQTcwa2VYcHNwTmwydHdQNVVhb0FvREVtM0ZIZllyWmJmTkphRUFDaS9TdGl1MjFFSlN2QzN1TEFHaU45VjdXTkpjRjR6dnZmdlNjSUtGVFNNVWJWYlhwcEdrb1ZCNXNLYllLdzlTdGNiRTA0d3ZZZzNGdWFSdXhRRWtQZnNhSW5WWTJ2dnhTandOK0IycElUMWZ0M29BZGtjeHpNak1MaXg0NHBxN0M1REZyY1VjNUJ4RDZ1VFlYSDJwQVp0SkY3ZXhvb0FYSU54MzVMYzBZTEg3RDRvQ3hGMUcvc2FMVnBXMzYrNDdVZ0JzTFhJK3ExRVR0dnVUUVJqMklQdmVpSkJCdDJvQU5uSUMyOStLQkdrYkcyOUFFa2dnQ3dwTEZUZnVhQUYyM0J0UkVLektCK25laUJzUU55T2IwUjNCUEJJNCthQUZGZ3hKQUJQdFFWLzRuRi9jKzFJSkJjRW5UZmJpbEFsSFlEYjk2QURMRU5mdi9BSWY5YUM3bTlybWtwdU9QM293cDVPMUFCcGN1UVNMZDZKQ1NTU0wyT3dvN0RrYjNOcVF3MG5jWE5BQmhpUXlyc1R4ZnZRQTdsVHQ4MG9FQzloKzlFRllvU0RmZmU1b0FUY0c1SUlBR3dvMXVSc0RiN1VDeEl0ZmFpMUR1Vy9acUFHaVNlNW8wc3FDaUxydllHako5UW9BVWZwMzQrS0p0UEE5Nk0yM3Q3VW5abEI1QTRvQU56WmY5YVNkZ0FkeDcwYlcyM3V2YzBGQU54L0tnQlZtSklVZCthQklGeVd2djdVWklGL2U5d2FJK3NiaTl5YUFGTmNKY0c5Lzk2RGdPUzY3RDlSTkk0SHNQYWxJYktiY2QxUGVnQklCK3JmZWhjRTdjMHAxTEtHQUZoMkI0cE9rS2RKWVhGQUFBRitiRWNpbEFxZmY5alJhUjdpaXZhZ0JZSjFiRy93QjZTYkFiOFVWNldTTkoxTGI1b0Fmd2sxOVgrSVdBRkl4S0dKZ2RyYzJvUWtCTllOeU50aDJwNnduaURzQzNiN1VBUkxiazc3OGdVU2hTT0RhbkpWTWJhT3g0UHZSQTl2YWdBS1ZVL3dDOUZmMUUvRjZOaHRmMm8xWFdGRjlSSjRGTFFCRXR0Y2NkNkEyTmdkdmVqMnQvcFJEazBnQTAyUHhTZ29VWG9rT3E0N0RtaGNrNzhVQUh6M0IrS0NraWkwM2ZuWTNwS213SmIzcGFBVmJudDduMm9EMUlkdFI5elJnRzV0UTAzQnR6UlFsaWRkN2FSY2lsZzNOelJJdHdTT1J6UjJzTlJ2cDk2S0ZEQkRIYmIzb0M0QUlzYVMwaXNSZGd0OWdMODFMd21VNHpIZ2pDWUhFNG9Mc1RGQ3pDL3dES2xvQ00xKzZnZnZUbDFDaTZDNDNCdWJWcWNENFM5WVk5VWFISXAwakxXOHlZaUpSOTduYW4vd0Q1WjRxQUVaajFEa1dXM0FMaVhHZVlSLzVWRy9GQ2l4TFJpOFVnU1d4dGM3N1VudmJpdE4xSmtPUzVmZ25ud3ZWT0d6WEhJVVZZTVBoWFZTTDduVVIyck5EWWJzQ3ZZMHJYQWlCdnBOK2ZiM3BTOHN0cktlVGVrOS9lbHFMaTE3SG1tcDBPTmgwTDBiSjFOSzAwZU13V0NqVmRMWWpIWXBJVVFYK2JrL3RXcms2QjZId09ZK1ZtL2lWbE1DS3BaamxzRXVLSmIyQkNnVythNUcwS1RzdW9qMGphNDJwU1FSSnNBZnRld3ArNGJSMVFMNE01ZEhPSnMwNnR6MlJmK20yQ3dzV0dpa0gzWTNBcG4vNWgrR21Cd1FoeS93QU01c2JpMU54aU0zeldRZ2o1V01nVnpJTkZHOXdtb3J2U3Z6SExMR0ZORzRLT3BUZmlIeGtLUUprUFEvU1hUODBWaWs4R1dpYVUyN2xwZFZSYzIvRWY0cDV6aUJNL1ZlSnk5aDZSSGxrVWVFWCtTS0s1c01TN2UybjUyb3ZOdmNhZ0Q3VW00VGFXbWNkUlo3MUhpWko4MXo3TWNmaW4rdVRFWXVSaWZ2dmFxbGN2Z2pPcXdMWHVHQUgrZEVYUmVHTEh2dlI2eVJzTFViaHlWQzNnampHcXhQYm1oY0lndkhleDIycEdzbTJ3dFJQTXpLZDloU1dLUDZpU09GRnIzOXFEekZoYlVMQWJXcU9HTEtMN0MxRllCckxhL3dBYzB1NFNpUjVucE4yUDM3MDJKUVIzUDNwRnlXUHYzOTZTVnZ1RzQ5NloyS0w4d0UyMGIzdmVqTFhiK3ROQWsvVlNxQUhDM3BPOUVwTEtiMGk5T0pZbzFPc0J5SlZzRGUzYWxPeExlKzlJalgwNlFiQWIzcFNIbS9idlNpV0VRV1RqdlJOWUFla0czelM1RGRUWmh0dlRicUdCRnhkZmFtMElnT2ZTQVB2WTAwUmNlOUxhN2VrOER2UkgxZ0c5alNEaHNNYm5jOFU1cXZZRTMrS1pZRlR6dlQ0c1FOcmtVQUFOdG9BMjcwdFZ1NFFqZWtnYVdGalkvd0NWQUV0SWd1ZVFUU29CRXozbGEyKzlON2s3QUUwSlcvaXludUdzYUFiU3BLME1BYmoxZlVmNVVDTGdrYysxR0RvYmYxVVdxeCtEU0FIWUVDOUEyUEJ0UUNnZDcwT0RRQWxVdHVUZSs5SDlPOXIwQ0NmMWFyZXc0cFFBNUZyVUFJMU1kZ2RJbzFZTnp1YVhwdmM3QzFKWWl3RnJXb0FES0NRRzNIdFJhUmZrYjlxVWVOaGMwbFRZbXkrbzl6UUFDeEJCQTQySUZHWDlSRkRWcWNBQ3lubWdSZWdCSTJGSGNIbTFBajcwVnlpSDFYM29BQTVzTnhRSUc0QzIvZWo3MFFjS1NPL2VnQWd0aHhjMFlZanNLQlc0dmY4QXJSQ08vdjhBem9BYkIwalRRL2xTckVuY3FEenRSMjFqYzBBSnRjOGcwQ2UvdFFDM3YydDdjMFpBQUZyMithQUNPeHZ4UTU0b2NtaklBTzFBQXMyL2VnZ09yZXdwTEVsdHFPM3BIdmZlZ0JXbTVOdC9taTA3RWNqM0ZBS0R5YkQzcFFOdFF2UUFsUFJ0dTQ5dmFsTkdoRitSMkZKVTJ2ZWpqT2dsdWI5dmlnQklHMXJBMHExaHdBMUNSTEFsU0NEL0FERkV2RjIzUHZRQUJzTkxjME5XeERXdjdlOURZaWpXT3d1V0ErRFFBa2JOWlRwSGU5U0ErbExYTmp3S2FqSTFudjdnOXExL1JQUXVBNnNqeHNtTjZweXpwcUxERVdPWXV4WjdtM3BWZHorMUtsWUdZZHhKRUVheXlEYXpibTFNdzRkbmtzQmUreWc5elcwNmt5VHAvcDFzYmc4czZvdy9VVVlSV2p4R0Z3MGlKSTNkZlVMaTFaSldNRGhnb0xCbFlqY2cycFhFRnlOUEhmMDZncmc3ajJvbVE0ZHRocGI2cW55NGxWekJwemhsS3NUL0FBaHN1L3RURU1hekJWWnZLVlZOZzI1b3VoV3FJK25ZN2c5OXFEQTZ0anR6WVZLQzRaU0I1eDlpQU9SUm1YQ0tickU3amNBbGhUUnRrVUw2UXhJc2Y1MFlXNGEzRlN4bWNVS2dSWU9QMDkzSlA5S0RaOWlTMTFXQ0c0dFpJclUvYUtJaHdVMDRHaUYzdnQ2VnFURmtHTWxSdjRPaEwzdktRdFJHemJGeWtuejVGWHRiYW96UEpJOTNrTWd2YjFHOS93Q3RMWWxseC9ZZ1FCcDhmaG85N2FOZHpRT0R5akRrYTgwRERpME1KTy8zTlUzbGlTeEFBN1VJMTAvYTUrMU5zS05DMG5TOE9Idzd4cm1XSnhCMStmRXhWRXZmMDZUYmkxNkwrMzhvaFluRGRPUnRZM0g1ckVHUzU5ckFEYXFGYkhTQU5qelNqdHRiVGJ2UzdoS05DT3Y4encwUy9rTUZsbVdNajZsT0h3Z0xYKzdFMG1meEg2dHhVUWpicURId3hnM0NRUytTTC9aTFZRSzlnUmJiM3BQYlppTFVsaTBMeGMwMll5ZVpqY1JKaTVUekpQSVhiK3BwQ1lkRUJzUUFPTGJVYldZWEhQdWFJTUxBYmswYm1GSVZHa1VjaWtyYzhpOUpSVGRocDI3VXBtT3dzQ09DYUl1YjJINmFTeFErZmlrbGIwbzIydDdVUTRwQUZ4UmlaWGpCQVlEVW85L2VtaEtXR3d2OFU0akdNcXd0NlQvT2lsakVjelc0TzlBRFRPMTlONlVKR0J1RzNGSVZSMzNQeFNsTjEyb0FJaFhOeUxrOTZXRjBqZTN4U2IyTndCOWpSM3YydjhVQUdBVjNBQXBURUZiRG1ralliN2o1b2NHZ0FENXBYYWk1Qm9sNzBBR1J1TjdVa051VGVqSjRvRWJ0OXR6UUFTMlo3OTZXYmR4Yys5SkkyVUViRWJudlNnTGdHZ0JKR3hzTnZmMnBLaXg1cGQ3bm5ha2NBMm9BVVNTT0RTMCtuMDdVV3hHeElvS2Jkcm1nQjRHOXdPYUFqSjUzRkNQY0VuWnFXOTdia1dwMWpCc2Jla0cyOUMvSlkzQk5FZmdiVUJzTjZVVkFiZFNDTDM0cHVVblFxRUNuZUNMZ25mdFNIajNPbm01NXB0RGhvcUFlUWJVOEgzRlJ3RHFzUlVncHVCeHRTQUJqY2NnMExIekJ6dVFMZnZSQmRWazNCSTU5cWNpMm5RN214Ry91YUFHSmwwNG1RY0RVUlJjTnZ4OFVrczBra2pIZ2t0U3dRVkZoUUFEZXhOaFNJOWliK243VXJTTk54dFJXRERuZjJvQWN1Q0wrOUpQRzNQdlJHNHR0WTBCdWI5NkFCMi94ZDdVbzdudGVpZm0zZWk0Ti93REtnQUVudFIzdUtIWUVpemV3b21GaGNVQUVOOXVMOTZNTmNiMFl0cEJ0OTZReHN4SzdtOXJVQUtKOVEzc2V4RkorcSszSGFodUNiY0RhZ3ZwMUMzcTdVQUhmVXA5NklOYyt4OTZDZ2hDVHVmZWdMNldzdC91YUFBdDIyL3lvaWZVU2FVUXF4cXd1emR4eFFObEEyb0FMK0hvQnRZMzVvL1Nkd1IvS2d4RzRBK2FMWS9GQURlbTJ3M3NMSDVwUTdBYysxRDJIRnR2dlJFN2dqZTU3VUFHQmE1L25STTExdlJMK29rL05xTzRjYkRmMm9BSUM5QUcyNUZ4U2xRanRRME1BZHFBQ1orNFd3TkZwSk43MDZrUVlibitWSlpFVVgxaTNmZWdCSkZ5UWRnTjZBSGVuQ3FGZlVEZi9BRW9LVkd3RmhRQTF1VGJ0NzBld08rL3RTbU56dFNEM05BQzFZTHRibnZSa0M5bFBxOSsxTkxaeHZ1S1dyQUhmaWdCUUFZZjYxTXcrQlhFS1A0OGFmOXhxRnBiU1FvN1VsUVA4UDdpZ0I1d2tHSWtqWWgyQjJaZUNLdU1oeDJVWWFETUV6REtKTXdlVkFNTElrM2xlUzNjbjNxaU5rOUlPM2MycDVGTDZWVUVodmJlbFhZR2x6cG9zcnhFOGVCaXdzc0x4TGRvNU5WaVJlMzNGWmw1M2JZa0Q1RlQ4emh4bVdZc1JZM0NQaFpWUUFSelFHSnJIZzJQUDNxczFmVmNXQk43amlsYmZ5SDlDZ3pOYjF0Zm5laTFuVFlyNnZlazZ4c0FiL05BRzdHK3c3VTBWdXhWZ1RhMTdkNkFHa0VlM2FrZW9NUUtVU2JOZnZRTm9Nc1NwdGNiY1VUWElXalhpZ1RZWC9hbHNVTTgwUTJKdHRmOEFwUisveFJYSHZTQ1VHRGU1c0crOUpEYXRyV3ZRVzVQRmhSb0J2N2cwQ2hHNmtXWTdVYXNkeWJtaHdwb0JoYm1nQXlhSGFnRHVEenZSRVh0djN2UUFmYTNlZ09SNzBRc1dadTNGR0J2YzhpZ0FFV0h6UVVIM0FvTUNUZTlBRzVJOXhRQWF0NjdYdVBlbDJIcStPS2JDa044VTlxc252UUFsVkduZTI5R3krYkRxSHE4ditvb0xzUGY0cGNHbFc5UXVEeVBpZ0NJQlk3Y1VGNzI0cDFrQ0VyZmFtdU5oUUFvWFViYm1qVWtBQnIzSGVraGJIWThVc0cvUE5BQUxiYkdnQ1B1YU5RTFVGVVhvQUh0Y1dvZ3BzZHVhWGE1KzFHcElJQm9BYklzT0tCQjIzc0IvV2x1aHYrOUV4QXNEelFBUUJPM2FnUnZZSGVuRnR2U0FDU1FDQjgwQUpBSUFveXRMSXZ0UkJSUUFTcUxVT3hQWVVkaUYrYVR2d09EelFCSVFqUUR6ODBZOVhGTTZ0S1dGT0J5VkZoYWdTZ3l1bmNrZmFnd3VEN1VpUTdDOUFNVHNEZWxzS0RZbFNMRDBqZWtNUzNxNHZ2UWxjS1Z2M29QWTIwN2lpeFJ2VmQvYW5nUnAxQTduYW1TMW5HMzJwNWd3dGJZbmNta0FWZFFiY0VjMFVKdEo5enNQbjNvTXV3WUM1NzB1QmRlSkNDMndKdjhBdFFCREd6UDdYL25TMUdvQzN2ZW1veGNINzA0cElGaHpRQW00dmY4QXBTd0JaUmJ2UUZyWEl0dlJGZ2VEZjdVQUtZQzU1dlNQU2ZlOUJTUWJYdmJlNW85UUd4Mko5cUFDWTZXSnBRSlk5NlFYSEpJNXRRQjNGanp4UUFwdHZnMFJ2Y0RlM3ZTbFZtVzl2aTVvaXRqUUFRQkttKzFKc1IvdlJ1RHVCN1hvMWp1QWIwQUdwQU5yNzBEelJNZ1BlM3pScU5KQUozQjNvQVF4MWNiV295QzQyMnBZQXNhTGV3N1dvQUlLZE5yYjBXaTk3MDV1RnNkanpmMm90ajlPMXhjaWdBZ0FXL2Fra1dOSzdoVHNiODA0ZzFEWVgvYWdCa3h4Z3FMM2E5L2lnUW92ZFR0eFkwUUFYdHNQMVVTQTZCZmNpNU5BQTg1UU5sRi81MG9TalRjYkdrRWR3QmVnQ1J6dlFBb3N6RFlqbnZRMVdCdVNEU0dOeUxiQVViQU1MdFFBWklLOG1pdVhCdUFiOGJVUkZCVFlVQUtZN2p2UUs3MFJzdzJvelFBT0JRdC9LaTRKb3pwSHdUd1BlZ0FtR28rbmlpSXNLVVJZWEg5YUpmVnVlYUFGcklyS2RWN1c3VVVxRkFvVlE0Tzl4Mm9sc2hZZHVLWEd4UXNoK2swQUpBREEzcXh5YkhTWUNTR2VDTlpKNDVsWUk0dURZZ2dWWHNnak80SkZyN1VjY3ZsTUdzclg1UTB2UWZCNlAvRkg0ZzV4MWxtZUNmTjhGaytKWEZZWEN6bkU1VElKQkJvaksrV1c3SGZjZTllYkdBdVFEcUEyQnR0VXFYSDJ2NU1RZ3VMTUZKc2Z2VEd4SEZ2Z2NVcmQ5aUpVTjJvMkgwMFpBMjk2RnJtOTkvYW1pZzkrNG9mYWpCQkI3VVE1dlFBb2NVa2tYczI1RzRvOVZEYTk2QURXNS9UWW5rMGtpejBZL3dDNEQ0dlEwK3E5QUNrSUlvbEgxZk5EVmZuK2xBR3czMm9BSzloWWphajJVYkFYb2dwWWMyb2JrMm9BTzE2SnY2L0ZLS1hvOUFvQUlOZVBhZ3JBazI5cUZsQ0JTT0tLOWdONy90UUFvbmFqVVgrOUdCZmJzYUlXUWtDZ0FYM3RScGNYcE50NzB0V3Z0UUFaSUoyRnFNTFpnVGFnRkpvTW83ait0QUNuUU5HcldIcUdscWlrV05xbFEyMG1JZytvWEIrYWpsQVNiYk1wc2FBRWtiNlJ6YWxyeFNPYk43bTFLVytxMUFEaXJZYjBMRDJ2UjI5K0tHa0RpNW9BRi84QTdVRkZ6YzdVT0NMODBiRW16ZHhRQUdKYXhIQXBGOVFOTE81RERZKzFJUFBBM29BVUNGdFJiRGptaWNiSDR0UXR2L3JRQXBmVWQ2TUhUODBoajdkcUs0b0FVV29yMjdiVUNiOFVXcmFnQTA5Uk45Z0tNTU94MkZERDJrZHJjRGtVOEUwOWhhZ0Jza2svU1NLVDViamhRZytLY0xIWUU3ZXdwSWE1YjQyb0FSTnFqQ2Eyc0wwYlJsVkJZbmZpbE5wOHNBN3NCYmVpQnNBR0Y5dVNhQUVNZ0JYYTkvZXBCNVVFV05xalA2cjJPNDdDcG1uWlIzSXVLZFFnZ01WTzIyM05LZ3NKUUZIcFVNdys5cVN5RW00N2JtbklRTmNwTzJtSmlQNVVqQkZkR0FRQURjMGFGbGE5Nk1BSUN3K3F3NHBhQzdEM3BCUWdHTEVXMnZlajhqMGtsanF2M3BTM1A3MFliM0YvOXFBRUxCZER1Tlgyb0ZGMjIzQXRTenRjam50UmZGaVNhQUM4aEJ1UmMwTEJkUzlyYlVyU1NkenNUU1NtbHIydlNvUnNBVnJYNFU3V29XT3BSMkFwVGJDLzlLSURkZmVrRkFXUCt0SmE5cmpnMHBoWm0ydjJvd3ZBK0tBR3hjaGI3aTl5UGVqUHJmYm05cjBzaXhBdFJhZWUzdFFBbmNuaTVvRTJvYUQ3YXFKZ2ZZMkZBQ2dibmVpS0NNWEc5QUpjWEJ2UXVOTmdRU2FBREM2aUZISnUxRkwvQUFtdHF0M29sVWJYM05qU3hHaEF1bHo3NzA2Z0k1dnVleDdVWUg5NGcvYWdmVDlXdzlxQU9vZzJBKzFOQUI0b2p5S0ROWWdXL2VnRGMwQUhzVFJPUnNTYjBEdFFCSjcwQUE3N0dpWWUrOUswZ0cvdlJIaWdBV09teWtENzBkeVJ2MjlxR3dCOUlQNzBWZ080SHhRQU5OeVNEMm9BMk50alIzMlBlaUFCQmJnaWdBeUxtMTZDZ0wzb2gySjJ2UXVDZGhlZ0EwM3NmYWpKdWIwYk5wRzR0U1Q2ZWFBRnd2clVSdnNvNE5JTVpqTmlMdGZuM0ZFVGNYdlRzYnFRWTMvOHBvQWJZWDJBNDcrOUh1UllHMUJ4YXl2OVFvOUJOQXQySnRZL0lvajdrMk5MSkIydGUxSk5pTGY1MENBMk80TkNnTERiMm9IYm1nQWY1ME8xQURlOTZOaGJmbWdBMUgvdTFBRzVQYWpCdFFIcTRvQUlHNFBhaDlJMzcrMUdCejk2Rjk2QUJwMzVIeFM3QzNGRndPeCthU0NhQUZFMm9pMndQRkFtNG9OdVFPMXFBRG9pUFQvcFFCMm9NZDAzKzlBQVU3M3RSbGhjODcwUTlYRkZ5ZHFBRkEzRjZCWFlFVUFLVWQ5dHRxQUJHM3FzYVdmVWJDbWIyTnhUeWpZRWMwQUQ2VzFEY2ppMUp4U1dZT3ZFb0IvZnZUaWl5RWZxQjNvL0w4N0RzbmREcVg1cVNrSjhrVDZRUGlnRDZyKzlFU2ZhajFFbTFoYW1NY09veEhGQmlwRjdNRFRlc0RZYzBZTzQ5WDdYK0tRUVdMbGdTYU1uK2xNcEpZSWJkdHphajliZnBJUHRRQXZYWW1pWnJrVVBKbVA2S0N3dnc5aGNVQUpXUzVveXBPKzlxYy9MZ0VDNEpGTDA3MjFXSTdDZ0NMcjlSVWIwTlI5cWZNUVVjYjN2ZWowQW5qbWdCaFdOdlR1ZUtNSTU1VTFKQ0tYTnhZV29nd1piaWdCa1J0R05STmdQYWw2cmQ5dmVsTW9DN205Tk42VkY2QUZscmo0cEpidWVLSUVrZkZMamhlY2tJbXV3MUVYdHRRQW4ydnVhRGZRZmVpTmxOaHlkL3dCcUFPMXFWQUV6ZWtleDV0VTZQMUNNQVdBWG1vTDJDNzhWT1FCUWgzSUswNFJoRkxiYmkvSnBhb0NrNTVKaFlYb3hhKzNGSmE0aXhGaFlsQ0FhVkt3UlhxTksvZnRUZ1c0MURiNHBHNUJCMkE3MHVOYjdEdFRHS0dsd0Z1TEdsS3ZPbWxJTFhzZWU5TFJiSGJmM3BCR05CTGJuNmJYdlJMOUlZN1g3ZTFPbU0yMGpaYU5ZMldOU1ZMRzlLaExHaWdKNTNvOUp2eHNQNjArRUFhN0FBbmZla0dWQmE3QUFIZTVwUUcyVTdXM3ZRQzdnVXJXcEFXUFZLYmkya2JtbjQ4UGlXVkdqd2NzaGJkVzAydjhBRkFXUnd2OEFHVUJoYmU5RkdDQllnMzlxc1Z5VE1ET3l0QkhBd0Z5SlpGQi96cHdaUXNaa0UyYTRiRDJPMWdYdis0RkZCWlcrV3pGYmJmQm9tUzE5UkczYXJGc0RnRkpMWTNFVHRiWVJSMlgrWk5CVGxjZHgrVG5uSTRlU1lBQS9hMUZDMlZxS0FHYlVOUHVONlNyUnlFYVhhUnZZRGFybHN3Z1FvRXkzQnhQYi9xYVN4KzlGL2JtTksrV2pSd29UdDVjWUg5YlVVSlpYeDRLV2Nzc0dGbmt1ZWRGU0lPbnNmTEhiOHNrVyt4bGNMUnk0L0Y0bVF2Sk5JWEIzc3hxTy93REVzSHU3QTMzTnovV2dMSmE1SzBTZ3paaGhJTmlDb3U3RSt3c0tVbUN3ZW4xWmpKZi9BQXhiVkZWakdyQldJSHNLZVdQV29ON1VvV1VZOVZtTzlKQkk3ZW1qR3gvdzBZQVptdHdLWU9FOTdkcVdGRnIzb2dCYS93QVVXbmc5cUFBUmMvRkVSYWxFMnBONzBBR3B2Ujg3VWtteDI3MFpObHVPUWJVQUFnTVR0UUtxT1FmMm83RXNmYWdwdVNlL3RRQVNHeCszdlJuYlYvU2dBZVR6UVBxSTl4UUFPZWFPOXVLTDcwVzRPL0ZBQjhqZWdmbmVpdlk3N0NnT1FDYlhvQU5iV0czZWpBczlyQzQ3MEJZTGUrOUs0dFkrcnVhQURRK2JkWDlSQjlMMGJLeW16YkgvQURwQVVCYmNDOTZkRExJQXJiTUJzZmVnQnNxTDBobDJ0YTRwd3FReERMWSsxSklKNDNIdlFBaFNXN1dwUlc1dFIyMGozb0VtOTZBQUZBb3diRy9laUhHOUhRQUtMdHR0UkVtOUdEdmJ2YTlBQVVnKys5QTdVWTJvSGczb0FNQzRwTzROcU5UeFNqUUFRRzFIYmlrODBkaVFBRFkwQUUzcElORGplMTZNeHNlLzg2QlVpZ0F6enR0U2YydFFJTGJVRlRhZ0FhamNXdFJOc3hMV3BmbGdqdlFLQUVYNG9BYkY3OXJVL2gzTFhGcVNWQVBwRnFNSFR1TnFBSDQyMU1vdHp6UnF4aGRXdGUzYjRwY2FycHNPRDNvanVRYmVvVTVNUmtiRndpSEVPcWtzckFPdndEVE5ocEo0cXd4YWhzRXBBOVVKM1B1RFVFb0FMazdmNTBqQkRrTVNzdHlBZnZUL0FKVWEzc29OTXhzRlE5ajdHblNMRzUzKzFLZ1lwUXBHblNMVWZtRGNrYjBnV1hjR2dGTnhTaVdIYzMrS0RDNEZ1Zm1rbmFnclhheEZBV0d5Z0VEazl6U1dYU2VPYVVUNnJXL2VnT1RiY1cycHJDd2xIQjVzYmIwVGJFc1Ayb3dUdVBmbWlZV1M1QnNlOUlPQVh0ZitWQ3dBc3V3cFpBVUhVT2VMVWdna2UxT29CdDJOckVpMUp0ZnRxRktuQVNKbnNmU0w3VjAzQ2VBbUtlRXlZL3E3cG5LejVhU2lLZkdndXdaUXcySGUzSTk2WGFKWnpBQVcvd0JLREJnTGk0N2JHMWFITSttc3V5ck1zRGgxNmx3ZVk0ZWRyVFQ0U05pc0F2YmUvTlZ1THd1V1JqL2xzZExpR3VRVDVkaGE1c1I3M3BLQ3l1VUZWdGJWOGc4VWRyQUgzcVRIaFZZV0VjejMzQVZEL2xVeUxKTVl5YW84dWtJQXVOWkEycEVLVkxMdmNuZjI5NnNJWmtNU2dNTFdxZU1reFlpalNRWWFKQXhJQmNFL3ZTLzdEaldUK0xtVVFRRC9BTU5OcjA0U3l0RXkyQUN0Yyt3MnBUNmlqRFpSYTNxTnFzVGxHQnNwYkZ6U3FPYkxhcGVEZ3l2QitheHk4WXRuVFN2NXB5TkgrSVVCWm1FamppSkVrcW0zS29MbW5JbEJZK1ZCUElmWVJuL090Q002T0VReHdZTENRaTJ6R0lGaCs5UjJ6ckh6cW9NNVZWM0NLQUFQdFFKWlhyZ2NZeHN1Q2tVRTZRejdDblpNbngwWXRJc01JOW1rQi95TkNTZWFVMmFWNU4rQ2RxSXhzVFlIdDMzcEFGREtncTN4R09pUWUwWUpOSWJDNEFGZGVKbm05OUlzQlJtTnR0UDFmYWdJTlIzRmo3MG9nc2ZrRlVhTUY1b0I1a2VqL1BCRG9UQ1lkYi9UNmIycHN3cW9CQU42QmlLcXhCKzE2QUZybUdNc0NrZ2pDbllLQXRGSmk4Vk5aWnNSSklTTGJzYkNqOGtGVUJHeTcvdlFDQzlqNzNvQWpOZVI3bjFEL0h2UU1SWWFkeFkzMjJxUjVRWS9idFNnaG9BaitTUytnWG96R0RkUXR5S2VJSmY0UEpvMVVkdGllNW9Hc2poV0E5UU5oMnZ1YUlSa1c1VlR3cDVxY0k5UUlJOVE3MFN4Z25jaS93QW1nY1JUQWV4dDcyNzBTUWFnTlhCTmhVeUpQTU5naGY4QTdRYVd1RG1sUzRoWWdOdDIvd0E2QUlnaElzM2NHeHBZaVkzUHZVbG9CREhhYVdPTU43dUwzcHRKc0lMcWNiRUNwdDNvQXpOdlRRR3h2NzBhYmdYNG8yOUo0dUtZUENBdmYyRkFzVlUyb2lTTmdMVWJBRkxYRjZBQ0lMY1VDTEQ1b3h0ZTFDOTkrZnZRQUFCcHRTUnR0Mk5LZllDa2xyT085QUNqc0NhTUR2M05KM1BJNE54UmduVWQ2QURMRVVSTy9HNW85bUpIY2IwVndCY20rOUFBb0hlaGZVeHRRSXNhQUFlTjdOUXZkZ1R1S0ZHU05OdUJlOUFCa2JVUXZmbTlCVHVhTThVQUdiVVdyMDlxQSsxRFRxMm9BZjhBK3VDaGJTNmk0WTl4N1V3U1F3QkdrbmtVSkFTQXJlOTZrQlJqTGduVGlGRng3TlFCSHNiMnZ0US9jVUg3NmI3RzIvSW9FYlVBQWZOSFNSZjlxVlFBVEFBWHNhQVU2ZzNhanZSM3NMYzBBRmFqSXYzbzZCRkFBS0RUUXRSODBMY1VBSjBpbEQyNG96WUFDMjlFQnZibWdBaWJiRzVOS0p1TDJ0UmdqU083VVRFMkFPMUFDYjJOTHRha2ptbEEzdlFBVFg3VUNDMXZZVVJPOUxBQlFudlFBU25VQ0tMamJ2U293QUR0dlIyOVZPUUR1RU9vNlR0VDVVYWpVTUVnZ2pZamNtcHNaRTFpTnI4R2xFWXVBaEpMT2ZRUVZONnFwRThvdWh2clUyKzlXWlVyY0ZkVk00MkNSNU9BQUFBR0pzS0tzRVJrUUJOOTc5NldiNkxEbjVwU3drS0JkVFk3Mk5QTEdDU3FoblBmU3Q3VXRDTVpqakxNVHNiQzlxQzN0ZmsrM0Zxc01MbGM4ek1GdzhseXAwaTJtNCs5UHRrMktpaUIvTHhRcVYyRWtvSkZGQ0ZScEpGNk1KN0tUOXF0bXk2QU9xeTRxRkd0dUk5NlVjcHk3UUhHWnlUbTF6RkhIWmgvdlNBVTZxeHVPRDdHaUkwdFl1b2JrYjFiQ1BLMDlTNGZFVFdGdjRoSXBZeGVDUnY0V1hScXZBMU1UWTA0ZFpTaDBCc0dMZGpwQlA4QXBVbVBMc1RLQjVlRXhEQnVMeG14cXovdHJFS2ZTRWgzc0FxQ2t0bk9OazV4Y2w3YldOdDZhTnRqTWZUbWFTYVBNd293NE93TXpnVTYzVGs2a2lYR1lTQlIzMVh2VWJ6NVpMK1pJOGh2Y2xtSnBHZ0crd0pPOXpRTFpManlmQndvZk96TFYvOEFrMHB2K3o4cTFheXMwNUJ2cU94SXBsR3NEcS9sUmthZ0IzV2l4cTdKYUpsMGYvVHdLMnZjNjIzUDNwYTQ4UnRlUER3UmtiRFNndUtpb080NU8xT3JHTFh0dWFCeElPYVl3bFc4MGcyMGdEYmFvN1lpVjBJTXI2VzJZNnR5S0p3QTVHcnZZZkZFTDNJUDJ2NzBBSnN4YTVOTEpCNEhiMm9pRDgzNTJvZDdpNStLVkNNWEc1TWpEZSttNXY3VS9mU28zSnZ6dlRBOVRXSEhGeFR5Z0lDRHZhbkRSbVhkcE80SEY2YVVGSEhlM05TTkt2OEFVZGoyRkZFZ0pPbmMzdWIwQll3SVNMRUhZN2o1cHlQYzhXSUZTWU1ITEtOU3hPNDR1Rk5ML0psQ3djckdUK3BtQW9DeUlFMnVPVFI2Q1Z0M3A5L3lxSVMrTnc2bGVWMWJuN1ZIYk04dGpVMnhEeW4yUkwwMWprRVl5YkVqWlRRS0hTaTM1M3BEWjdnMDNXQ1dYL3VOcVlmcVBnUllPTVdOL1diMGdFdDEra1hzUnlPYVd1RmtsSTB4T3hISG9OVjMvRW1QRjJqOHVLNTRXTzRxTk5uT09tWWhzVTZzZHpwTnFBTkF1V1RHTXY1WlVYMDNZMjNwdDQ0b2IrWmlJSTlQSUxnbXMxSnJuM0x5eUgvdU5BWU5pNEhsallYc3czb0F2WHhlWEtTV3hnSlA2Vlc1cHM1eGdJeHBDWWlRajRDaitkVjZaZFBZSFNFNzdubWxMbGJhL1VWNDVGQXBMbHoyTml2bDRYU2JXSmFYbitsUnBNNnhFa3RvNG9vN2R5TDBjV1Z4MjFGMlAvYWVhY2JBd2l6RzkrU0w4Q2djUmptMk1QMDRvcTN2R0xVeEpQUFA5VThrbHlPWE5UMnc4YW4wcllEa21qU01MR1NnVUt4OXFBS3dZZG5zM2wzYmNiODB0Y05OYmFPMVdCdXJOdllkcVVWYmExdUtOcSt4TEtZNlV0Mk51T2FJY0hZMExMM3BSNHBnb2hUdFkwQ053YlhOR2czTnhZMG9iTFFBR0cyMUpLMlBzUGlqSzk3MFJOenpRQVZneHNkcU94MGIwRDlWcUZ3Tmp4UUFaNEZGYWdDU04rYVdBT1JRQTNZYjBBRGJnV3YzcGJjaWtqNlYrOUFBdFpMZ1dONlUzSW9BVzNvL3FOQUNUOU5GR3U5endhVnAzbzcyb0FUK28ycFhGSklzZnZSbjZSdGVnQTdkNkFOalJDOXR2NVVvZ1dIdlFBVEE2eHRlakRGV0J2bzA4RWRqUktTQlJnM2MwQVB5QVl4U3llbWJ2N01LanJadC93Q2xLaWJRMXhjRWJnamk5T3lJdUkvamdhWDVOdUNhQUdUZnV1M2ExQzIxN2IrMUs0NzBGRjJGNkFFaGZUZXhwU3FGbzIyYmJnVVlHeHZRQW0xRzFyYkNqalhXRFM5TFcrRC9BSjBBSXNBdnpTUnpUaEFVV1kzb1dBdGJpZ0JOcjBSV3dOdHFjSTdoV3Q3Z1VyeTIwRWFiQTczSnBVQTFwc2IvQUdvajZ1OVNFZ1lJQVNpMitibWdJay9WS2R2WVU0YWhqUVJlaktuWURnYmswOFZpSkJ1elVUTkdIdUVOdllta1lyRzlJQnY3OTZYbzIwNmp2N0NsZVlBUUZVQWlnWlpDeE54KzFJaEFSNFk4TnF0OXJVN0hoU3grbitaQXBsSlhzUXpHNTk2QUJKOVZPQWZFQ3JleFFBODk2ZVh5bmowTE9RMXJycFR2VUlFamcycDNEc1ZOcjNJM29FSk9IaVU0VW5FZVkwMjlncHNDS2NQNWNKcFhDcVhVajYyTkpTTUxHR2E2TGZaUnVTTzlCeWRJSVFBVzRIZWdVYmJGK1dRVmhqUWc3V1dsTm5HSXRaSmROKzZnQ2cwa2thc3djcjZkMTlxTVRTU3VKRmpWNWRsS2hiaHZnRDNvRUd4aTVIWlE4enNEY0c1NHBwb2lHSWJjcHNOenVPMVhXVzVIanM4bUVPR3lmRk5MSTJnSENwYzM5aUR4UjQ3cG5INVppVXd1WllPWEI0cHhlT0dkU3JzbnY4aWtzQ3YxeVJ4TEU3STRJdUZKdTM3R2p3K0dYRU9yeHkrV1ZCc1NQcFArdFBZakpNVGhNVUljUXBpa0pKV0lyWnROdVI3N1VtQ0g4eEpERUlYYzZnc2FPTkxHNTVwUnk2RGVLR2FMekVZeXpMNlpVWDBqN2lveUpaZEpGeU5nUnVOK0t1TVJsY1N0SkdRMkR4RWMvbHN6bThjaW5rRDJORE9NcWZKY3kvczk0d3p0R3NoakhGbUYxMysxcVN4MUlwZEpMRTN1L3ZTaWhES3R0d0xtcDArRnc4RU1jMkhKbGpQcHVSeXc1Qy9GTUxocEhZNklwSkN4dGUzRktNSTRzUmUzRkQzTnJnNzFOL3N2RlFhUkpINVdyanpHdFRid1I0WUF5NG1CUnZ4SmZlbkNFWlZ2YXkvZW5OQXVhVStMd0tIZkdlY0NQL0NUYS90UkROOHVVRmpGaUpYUFlNRkg4cWFBWVVxUGk5S2psVXFCZTU5cWpIUDRsSk1lWEkxLy93QVk1TkE1L2kyVStWREJFUDhBc3ZhZ1VsdEN6M3RHekUvM1FUVDM1S1VxcDh0d1cra05ZQ3FtVFBNeVlXR0xhTU1kd2xnS2lTU1luRXQ2NVpwTGNIVWFBcWpUTmdXUlE3dkZGMk41QWFZTStCWGQ4V2dGL1ZwQk8zeFdmVEw1Wm5YK0U1UHVSVHNlVHp0cElqQXRmY20xQWRsc2MyeXVOamFTYVJiOEtsalRiOVE0UlFURGdwSFVIL3hYc1QvS21FeUtVbjF1aSttL042ZkdRS0ZHdWNuYjlJb0RoZGpJNmptUTNpd3NDRVhJMURVTGNXcHIrMzh3QzJURUxFYjI5Q0Nwb3lqQ2R5N1dIYzJwNU1EaFZUNkxrY0ZxQXVMNktTVEg0eVlFUGlwMit4c1A2VTBjTk5LQVNra20zY2sxcFU4cU1MYU5RQnN5NmVhZDg2L3Rmc0JRTFptbHlxV1VBbUFyN1gycDVNaXhKUWVsVVBjRTlxdlpwd1FOcm50UkdlOXdUYzN0UUkyL2dxMHlKd1BWSWkvYW5GeVdKZ0x6TmZ2YmlyQnBBUUYyc09DS0oyQUdsZHU5QXozV1EyeWpESmNXdU8xMjVwUzRTQ01zVmhYWVdwOHR4cEYycER6V045SUZBOWdrUlk3V1VlcllXSEJwakVjNlRmVmF4TlBlYmZlKzU0UHRTSnJOZXg3V0o5NkJCeFZKdzBiRUN3dU42SXJwSElQeFNNTmQ4TzRZa2hUUWtCaEkxYmh1MUFqRWtEYlRzTnlEUjJBVUUvVVJ1ZTFLc1NDUXVsUVJZSHZSR01qVjZkU25lZ1VhS252dVQycE9rRzJyYjJGUEpDNjhnMjlqUTBFM0pBSkd3b0ZHYkU3QUFqM3BRUU1BVUZsOWpUd0NFV0pzZmlqQWlHMXpRSVowUmhqcVhnZlZHMzZhUlkrb2czdjc4aWlBdXpEdnFzRzR2VHJIekxSeTIxSFlTRG1tRHhvQTJ2M3BTN0tiODBRakVkeGU0RkJ0cUFCR0wzb01xbnR2UmNpL2FoYTlBQURFSHNQaWxCaFluM293QVFCeWZla2xia2I3VUFFVzdVb0FLTFVDTERhaU8vM29BT2t2MnBRdllYRnFBNEpvQUkvVFNsNE5KQ2o5dWFPeExrVzJOQUNyRDNvejNwSTlITzlLUEJvQVR6UU45TzNONk5lQlJrMjQ1b0FSYTVOaHRSMk50alN0SjAzdFkwZGdCeVBtZ0FyaXdBNXZlaUZsMVhHeE43MG9mYWw2UklkaFpUd0Q3MDVBTkw2amE0QTlqVGtZSVlsZCsxaFJFS29zNUN0dHQzL2F1citEdjRhK3R2R2pOb01QbE9VellISzJzMG1iNDJJcENpKzR2YlgrMUo4Z2NyQ0d6ZjRlNTRINzFiNUYwYm4zVk1zTWVTNUxqc3phZHhHclllQm1RdDdYNHI2RmRFZi9BQTR1Z3Vuc3d3Mkx6M09zMTZrOHJTellTVXJIaHk0M0pzb3VWK0RYcVRKTWd5N3AzQlE0REtjdHcyV1lTQmJSdzRhSlZWUjcyQTVxZU9PUWpuWEI4d2NzL0FYNHhaamdJY1VjbndPSDFyckVPSnhTcklMOWlPeHJrbldmaGgxVDRkNDdGWVRxVEpjWmxrbUdjSThyUWt3bS9GcEJ0WTE5cUhMQnJHNGIydlVIUHNoeXpxbktjVmxXY1lHRE1jdXhTYUpzUGlFQkRBODg5L2IycVZZNHk0Rzd6NGUrVXRqdWJVUlZRTGFkWlBBdjJyMEQrSWo4STNVM2d4bTJNeDJWWUtmT2VpNUdNbUh4OEExeVFMZlpKVkc0dGZrQzFxNEF0bVc2TmZjNy93Q1lxczRpaVZzTERTRnY3ODBzT3czQjBXN0FjMGtnZzdnN1VSRmlCdVNkNlJwQUxkbmJseVBta202amR0UlA2alMxVWFRVzJKb3lxZ2VxNVUwMUNDQWdCRnFMVDZ4VGhqUEhjLzVVcEYySUFGeDNwd0RZVzk3YjBSV3h2M3A1TEtMMi9jVXBVVTNOclVBUjdYb3d1MjlQZVhjK2tmeXBTWWR6K2svdlNvQmtwdFJoUVJVZ1FrRUl4Q252dUxVaFlvd1RybGlYMzNwV0F5cXJwc2R6VDBTS3NSa2F6aTlsWCs4Zi9TaytmaFZRQnNRQ2ZkVUpOTE9Md3FDRzNuU0RTYmFCYSs5TkZIVVh6SXBHMUV5RTJ1QnRUK0RWRElFWWdNdzBLVHQ2angvV29QOEFhOFVZdW1DQlBZeU9TS2ZUT0oxai9oWWVDQ0FicytqVVNmZTlMYVM1RGJiSGhnWkZuRVJpVjU5V2d4RTNKYnYvQUwvdFdnd01VdURqaGp3N0JtZ2JXSFdPeTYvN3dQWTlxSFJtU1lyUGM4d3VIeEpZaWZWZnlSNnRBRysvYXRmTmtjY2t1TzZkT0xod09KZ0hweFpRM1NRaTRqY2QxSXQ2aHdhaWMxMGliYVZ1RzY0Nmt5aFpZOE5peGxnbFhWTElrWTFuNStDZmlyaFBHelAxd2VGZ3pZNGJQR3dvQ1FTNDNDckpLcS85eDNCckVUNGFYTDhjTWdsdzdMbVpjdk5PN0ZuUndMS2dQQkFHL3dDOVhPZFpPZnlLVHh4SXdpUlRpSFUyYzNHMzlRYVkxWTljSTJPTzZ6NlU2NXkyZkQ1cmxNaVlqV29HSkRYZUZkdU5yZ2Zhc1gxSDB4RjA3aThPSk0ybmt5bWVKMndXTWpCY1dINkw4Zy9CcW95OTVac1ZoOFJBamh3cnZJUWgwblQyK2EwL1R1TGd6YWQ4RG1rVG5wMXYrWnhNYUhlTmh1Q3ZzR094dFRVcEoyZ3BNb01IbFVjTWVGaG5lQm8ySWxqOHh5dXREc3hOK08yOUt3M215Q2VURUxoWkpKejVDb0pCcVpBMWpwWSs0MnFQbVN3NXBudUlKaGFIQ3hsdktqdi9BTkpUOUtuNHAzQ2Zrc3h6VDhoaHNJSlFZdktueE13c2tLbmxsOXZrODB2OWp0cFdaMU5tMkh4TnNZZnlpeEFLc0VNSXNrZjZTQ1AydWFvc2ZMamxNc1dLeEU3RmdHVWx2UzQvdkxXc254RW1GeGNtRXdrbm14eG5TenlEYTNaUmZ0UzF6SnBzTzJHU0pHaDBuVmhXRjQwUHVoN2Z6cVpNcnZzd2E0S1djYWY0a20yMm9rMDdCa3M5cmlFS3Y5NG5ldFMwZmtOcTlSSEk3V0h0U0FnWkNBQzNmWTFKRWJaU0owL05vSlpsVUh2ZmVuUmtOa1RWTGZhcmRFTExlNEk5cVVnVmo5T3c1dlRra00zRmRGa09HVmRUeVNOZjIycDFjbXdZRnpFelc5MnFlQVR1T0JTbUFIcUZ3dkZPcWhtNGhybCtIaTJXR01keGNYb01iTUFxTHQvaHFXMTE0Nys5TUZiZW9LRDhVMWdobGRXbGZWNmJtMXRxWC80WTczNW9MY0U2dU93SGFpMHJjM1kzTzFoVFJ3bnl3MXJnRysxNzBtYVFJcEFOcmRxQnVTQXFtMU5Za09vTmdDQ085SjJCSE11ZzNJdmVraWMyWWxlL3ZUbWk2V3Z2U1pJaVVJdlkwZ0FNN0piNDJwSXhEQTdmUzIxR1ZDcWFJUmdMWTdBVUFLTXhzRkIwZHJmNjBHZGhLTGVvKzlJMGszK042U3hERWd0YTR2dDcwQ29Va2hKM0YvYzNvMWxHazdXSVA5S1JjTUMzQUZHb2FVYUFoUHlCUlFvc1NCTyt4cEx6Zy9OT0pnTVZJZlRHeHQ3MCtNbG5YUXpnQzU3R25wQVFQTllqL0NCZWxDVDBodXg3VmFRNUV6U0taSmZTYitsUlQ4ZVF4YWIyWmlmYzB1MExvcmNGUEZDMGdZRmxZYmdjMGxwMUxNVlI5WlBMZTFYc0dWd3hhYndxV3RmZm1uMHdrY2x3c2FnazgyNG8yak54bXBDejNBallEbmluSUljU3hCQ0VLZC9WM3JSTGhERWZWdDdxZmVsbkNsOUllL2xvZHlOdjJvMmh1TTZtWFlxeEVrdHFWSGs4aHZlV3d0cU51YXVqaDlSYXdKOVd4UGI3MHRZUVcxRWVxMXI5aisxRzFEbkxnb1RsYUtDU3hlbkV3TU9rYzFjdEF3MktnbjQ5cWpwaFdLL1NCOEUwN2FNVWpBY2xma1VTcjIxV3BTa0g5dUtGaUdKcXNUaWg2UlluVUtTUXBKSU8xNkpDYm1nRnY4VUFHcHVMVWVtaXNmbjk2UFFhQUNZZTFLN0N3b3RKQU5LWFlVQUlJM3ZmYWxFWHVRTi92YWpDa0VFOGUxRVYzSklvQUpyMkYrYU1iTGE5QlJiZ2Z6b2FUWVVBSjRXM2U5SFpnYjNwV25pbGJVQUJUcFVYM3BOZ3gycFFCUDhBSzlHQVNMM1VmYWdBckhjYi93QTZDaTUwMkxINHBaUm1HeEhQZXJucGJwTE9PdE0yanl2cC9MTVRtK09kZ1BLd3NaY3FEM1lqWUNsU3NDazdBV0pCNHBaakdnM0FBSEpZOFY3RDhPZi9BSWNYVmVmWWVER2RYWjlodW1ZbkZ6ZzhIRjUrSUE5aVNRQnQ3VjN6b3I4QVhoajBqaTF4V09oeG5Vc3dBc3VZeWt4QWp1RkhQNys5UFVHSmFQbkIwajBGMUgxMWlWZzZkeVBHNXpJU0JlQ0lsQjkyNEZlbE9nZi9BSWMzWEdmbUNicWJOY0gwNWcyQVpvWWg1MDMySTRHMWZRL0pPbk1wNlh3UzRYSjhzd2VWNFliQ1BDUXJHdjhBSUNyRnRsM042a1VHdnlFczRQNGEvZ3U4TC9EZnlwemxIL0VPYVJtNHh1YS94ZHh4WkRzSzduaElJc0hBbUd3OFNZZUJSWlk0VUNLQjdXRlJNVG04V0dmZTIyOXF6T2M5Wk5DSGFKd3B2c3BOTmVTR1BrbGppbms0UnNNVGlJc0JDMGt6QUtONzFpOCs4VmNyeWZWcXhNVWR0amRoZXVUOWIrUFQ0Q0dYQ3BLa3NyTVZJWGV3cmhPWjV2Qm4rYmliR1NzVkp2Y3VRb3FobDFyZjRtM3AvR3BLOHA2SnpmOEFFS3NPT3djMkJpbnhtQjh6UmlKRVQwUmpzZFZkbjZZNm53blZXWHg0bkN5QmdSdlk4SDJQelhoYkc5YXhocE1wd3Noa3krWERHUEVRUm5iWGU2c0xkeFY5NEcrTjJJNlh6eUxKSlpnMkxra0VhQ1Zqb21COXZaaFVPRFZUaGt1WS9VNkxFOGZzWEo3aGxpanhFYlJ5b2tzYmpTOGJxQ3JqMklOZWFQSEQ4QzNSM2lMSGlNMDZWQ2RIOVFrRnY0QzN3czU5bWo0VzU3ajN2WG9mQ1o5QmlzQU1SLzA3cmNvVHdhbVlERkxpOElreW4wdGNpdDVUaGw2T2FjWlFQamQ0cGVFSFZYZzVuZjhBWjNWT1d5WUhVU0ljYW5xdytJSFlvdy95Tlk4eEZ4MnYyYi9TdnRUMVowcGtYWG1YUzVMMUhsT0d6akxwRU9xTEVSaHROK1NwN0g1RmZQajhWdjRLTVI0UjVOak9zT2tjWE5tWFNjY2hPS3krVTNtd0MzMlpXSDFvT1Bpb0pRNHNkZndlWFdqQ0QxRUQ3bm1ocmpRZ05JbGlQZmlxOHhGaTFnekx0YmU5R21FMS9wSmI1cUlRbVBpY01Edk1TZTFsdmVrdmpjT29Ha08zN1dwa1lDUzYyMGdXOTZkWExwQ0JkMUhlbW9CUDlwaGI2TU1CL3dCeHBJeDhqRWxVV1A3aTlPcGcwUDFNeHB4TUxIcHVMa1g3MDRDTWNkaWlmK3FvSCtGYlUwMDBzbDlVc2hxeVNHTlcyVVV0RUNYT2tHL3RTcEFWSWdhN0M3T1RZOFU0bUFkd2J4RDk2dFZPbmMyQk4rMUxqQVp0cmsvTkZVQlZMbHpxTGtnZnZUMFdYdHNwYlV3M0Z2WTFhUlFDWmRJSjg3OUJ0NmYzb253OHNNbHRJVmh5bjZoUU9SR3cyWFJxQ05RWlFia25jV3F5d1dKeTdEb2RVQXRKNlFiMi9jQ2xMbGMrSWdoaHc2eU5MS1FXOHBDK201MkczSnJjNVpsT0c2Y2tCem5CNGxzWkNQVERORUkwUWNpNVA2dnRVTXBLaWFDTmw0T0prWFMrYjV6bWtrc294a1dXTXVFVEZKNlRPMzBpeDlpQWFsWUh3OXhXYzRhUE1zNzhyQll4R09LanpIRHYvd0EzaTVmMWFsNEs4N2V3RlRlaFlCMURuTTNVSDlrUnpZTkZBai9Oa3NyeUVXTEEyOVJGYVhxbE15eXZFNEU0SEh3WmpNcTdZWXhlaU5lNmxod2Y5S3FicVpaVU55NE9WZFhaZmdzM3puQlloY1ovWldkeU1CK2JNZG9wSlAwdmZzcDROVnVONnBPVXRpNXBzSkJCaTFrOHJFWUs0ZFViaDlCN3JmY0g1cXg2dngrSXpvenp5d3h5UXhLRXVxZ1JnWDNBOWdEV1B3dVQvbnZ5K0l4MGdNTVNGZzJrcXpBRTJJSjJJcXdwcWlKNG1UVDFiaWNMNVp5OW9qNWtubWxSR0NGWTdFZnlGUU1abXVKR05mRnVpb0dKRWlSaXdJKzFhL0g5UDRESnMyVER4UkR5cE1CRkxGaVFOeEszY2o1NDJyVDlHZElaZm5HUGxqeGNZdzRsaDB4RnhzMG9IK1pxT1dRZERFMm1jcHowZm1va3g2bU5kYVJpWFIrazJQSXF2WEdmbW9ZY0RrOE16eXpNVWQxRjJtbFBIMlZSWGFlci9DYVRwN05jeGl3elJ6WVdIQithOGJyNmhySEJBNXNiNzF6VEhTeTlQWXpEdGdJVndmbFFzc2o0WmJ0dUxFM1B2VDR5VWlKeGtpWGt2Uk9EdzJYUzRyUDJrbWdSZ01MaDhLMThWam40S3IvZGlCdmRqM0cxRm5XWHBGcGxUTWNteXpRZ0VlWHdzWGRSZmd0YmMrOVVtWDV4K2JqME5pcDQyK2hTcjdsYjN0ZmtENEZXT0g4TVB6K0ZteHNDU3hMY2hwUVM0dU53b0hOelNYc0ZVYjZLU1RCU05LUVcxcUI1aitXYjZsUGNmUHhUQ1JHUGNDNjcyOVBQM3E3eHVSWXpJbUROTU1GSHBWd1hYVy8vQU5xZ3NYeFRtUXorcTJwa1U3dGZhOXY2MVpqTytpT1dPaUFzWkJBS2dFK3c0cHdMb0RiZDZrQ0NLTERCNUhsbGtrMmoyc0Z0M05JS2t4TmNqNmhVOFNxTm9DRXNMSGU5aFEySUora2UxT09BWHV2SGFraU03N2IzNHBCQU11czJPeTJOUTVGc28zSTloVTF5b0FiY0VHOWgzcU5Ld3V3dFlOdUtSaW9qb0xqYmVqQUJKQkIrOUh1ajJYWW5nMFZyc0xudGVtamdnd3NiQzF1S2NTeFlqMkc5NlFwQVByUE80RlNQS0NuV3dKMWJiVUpBdUNISmdmTWM2R3RjN2cwMmN2blZ1ZFZ0L3VLdFFoTDdqYTlTTUxGZVVzeDFLQnFBOS9pbkpBNU5HZlRBU1NFQXJwSGFwRVdTeU92cWNMdng3MW94aGI4Z0JiMzAwL0hFQXZxVmRQTzQ0TkcwYjZobkJrYWszSklic0J4VWlMSUlCY0VGaXU5NnVqQVZRT1NwTGJnZXdvbVFvd3NtaEEzUFkvYW5LSWI3SUNaWkNtalRHclc3ZTlTa3dVVVVKVUltdSs1cCtLQmlxMi92RXI5cWxyQ0FQcERNNEdtLzZUVGxFTnhGWEQ2VnNWQmM4MjIycUpOQ1JMcVhjamEzeFZ3WTlXOTl4dGNDOXFiOGxYYXhhN0htd282RzdpdEVJTFdDSFlYdFJMRnJVQUhUcHF6YUl4SVZZQ3pXM1RtMUlFSkRzR1VFY3JidFFNZkpIVEQ2RUpKMklzS05ZVllDMjFqdDgwK3AwRlJZK3JabTlqVHZsRlRkeU51Q0tCQ0M4UmtZMmI2VCtvYzByOHN5cFl0ZFdiWSt4OTZrSWpFYVdXK201OVBjbWxLaDlJSXRmZy9wb0hSSXk0ZlVyTHZwTzROdWFqSmhGVjIxRWhmZ1ZaaE5URVA2U1I5VjlxSjRsdTJra3B3QmJuNXBBc2hDQmhHZjFNQnNmaW1qaGtXd2ErcTIrM2VyUllRVlFFSFdCdjZxSm85QnNGMWU1SXBSYk9PZzZ4ZTJscUZKWTMzYlllOUxzQ0J0c1J0VlF0Q2ROcm05NlNxV09xbkZXd05xTzR0N21nQkpGd0xVcmJhOUFBbmNjVUhGclhvQUJzRGE1Ti9paWRlTzFxVllrYmcwWlhZQTBBRVNGMjVORXdPL1lHakcxeVJ2NzBha1c1dlMwQW0zL3dCNk1LVFJsMXZidFJlWXFiMk56eFNBQWl4c2FQUUQzb2FqYmRSUkNVbllJS0FGb3QxdFlXSXRTMVJMY0FiWElQMzNwcFZaaUEzMUhoZmYvYXZRUDRRdnc0emVPdlcwZU96YUNSZWpNcWNOakplQmlaQnVzSVBmdGUzYWxTNVNEcmtjL0RwK0QzcWZ4emppemZIU1AwOTBpcmtmblpZaUpjV080aVgyMitxdm92NFcrRm5TL2cza2tlVWRMWldtRFVBQ1hGUDZwcGlQMU01My9hdHJnOERoc3R3RUdBd1VDWVhDWWRGaWdnaVhTa2FBV0FBRks4a0x3TG1ySG91N1EzMVUrR2dQSjZRZDdEZTlWaHprQnRKSkZqYmFySmxLaS9LRVdySjVuQStIeExGQmRHMzM3VXpKTng2SFJoWm9wTTFpV0VIays5NnFjZG5qd0c0SUk5cXo4bVplUTdCaUxEZ0UxZ3V2UEVpTEpjSEswaEZ3Tm80enZWWEpxSFhKYXc0SEoxUnBPcU90OE5sc1Uwa3NvVUtMbGdlRDdWNXQ4VFBHaWJHbnk4TkpJTFgvQUljZXpQOEFmMnFwempxM011b1dlZWR6Q3BKS1IzdnFIMnFqd1BSZU16bkVpUklITTBsOVR1TGFRYW9QSTVzMjR3amdpcjdPZTV4bjJhVE8ySmxkdk5rdVIvaEh0VkhITGo4YVYzbjhzazNZR3dQMnIwRmhmQnZFRUF5NFU0aDFXOS8waW96K0ZlUHdzaUZzT05JM0FDOSsxSEVmZ2E5OG4rUnhMRHhZakswa25sbGRFUlRkdzlpQjJvWloxVGwrVlpwZ015eGNrK0Jsd2s2VHd5eXIvRG0zM0lyZjlVK0grSXhlYzVibGhnYnludTh6a1crbmV4K0s0bDE5bks1OTFaamhHdXJMOEl4d3VHakgwaFJzU0I4a1ZKamg2cEZseVN3Y3QyZlVISk1aSm1tWHcveDdRWWlMemRjZTExSTJJKzlkQjZCRWk5UHFqRmlGSjBGdWRONitiL2hUK0tuUCttT2o4SjBUaU1LY2ZpV25od3VYNWtXdDVNVEVBcklQMVd2c1JYMHQ2WHdqWURJY0pFNUpjUktXWS9xTzI5VzhFR3NxVEtPb25DZUs0b2tJRC9hZS93Q2xDZHE1TitMek9jVmxmNGV1dW84Rmc1TWZQaXN1ZkNHS0VYS1J5Yk01SHNvMy9hdXM0ZGhMalozNDAySDg2bytyTVRoc0psUFV1S3hpeHRnc0xsVTRuRW91bWpRYmhxdlNsVUdaNlN1ejR4UnhXaGo5UUtoUUJidUxjMGYwWFBGREJxSHdrWmpYUWgxRlFUYzIxR3cvbGFuQXU1djJxQVlKVmJ0eDlxZGRCZGR2VndLUW54dnZUbHJtZ0JrRzRiMGdOUnJ0dDdkaFJrQlhJSGYzb0VYTnY2anZRQUJ1UUFMRDVwWVVhU0M0SHhSS3BHN2I3SGFsclp6ZlRhNG9FWXFPSkRHeWhDNURiT3JiaW5GdzdpVDFKL1M5SVJkTWhOckRnM0ZPUXM4WVlMSVVCTzZydmVnRUwvSXEwYk5KUG9UKzczcTR5MGZtdEVDK1ZMRTdEMTRrR3lXUE9vYjFXNWNwZnpKNUJhR0lGdHhlNTlyVmM1QmdKYzN4aEVraGdoalR6Sm5qQTlLWHNFVWYzamVvNXVrVHdYMmRGeUROY1RoTU5OaXNxeHNHR2lScktZWWdOTERZMlBKcTVoeWpCNC9NbzhSbU14eHMwbDNZVHNXYVUrNXJNd1lyRDREeW9ZNE5NYW5hQlQ2WTArVDNQM3FWbC9VS1NaM0pNOGpMTmlQNGR4WWFGUENqNzFTbGZhTHFpbWQ1NkZiQnBOaElaay9NSkNMbkNvdm9nSHNvSHZ0elUzT01zangyTHgyWjRxSDhqaGczL3dDQ1JycGRnUDBqNU5TL0RxZkRaWjAxUGkyZzhqRllwVEhEQzRzekRndFdiNmhtekRyRE5JTXJ3dUhrOHVScnROcnRIQ2ljbHZjazFYYStXeWVLcDBjN3pUb3pBZFZaN09KSnhoOGxSUmlaY0RsNEpLQWNSUEo3azJ2YW1jUjA0R2lsL09aYkhQRkF3Snc5eUlsRnRrVWpmWVc1L3dCYTYvbG5ocEZua3hoMXZoTWtobFY1Y1NDVmt4VGo5S2djTDk2dHVxK2xNSCtUVEJZRERQaHNLRUpZMzFNN050ZTUrS1QxSkxvbDlPSytUaDJWZE40enFIRzRKbmd0Q21Edm9KOU1aQklYOXVLdllNcGJBNVJwOHJYS2tnTFhCQmprdnQ5NjdMMDkwNUZrblN1Qnk4d3huRkJXVXpqZHRJT29YcW96bktuem5JTXdnbFZGa1ZZZFRpdzBrM08xdi9lOURkb1l1M0ZHWTZ4em5McGNYQmdjWmlZZGVib01QS0xicU5PeHVOeHVPSzVWbkhST0t4R0luaHdtR2FRVHhDSXM1M3VGSkErNUF0WFEzNlhURlp4ZkZvVm5nS3NTb3VRRStraXRCbFJ3K056bk01cFliNGZFREQrWHFOaWppNHVQazJQTk9qS253R3kxVFBJT2M1VE5sK0lXZDRsaGhZQU5HRFp0UU50cTZWNE9kVFI0WHFBWlBQS3VLd2VOWUR5aHMrR2xPeXlEM1hzUlc3NnE4TEl6aytkUUlCaURnc1M4cFpsdVFqZW9hVDdiMXh1SHAyZU9UTGMyeVRTdUtoSW1RRStyV3JmNjhHckhxTElxYUsvcHZITGc2djFyMERqODZ6bit5Y1hoaGdtbkIvSVl5WFlGd2ZVSDlsUGJ2WEpzMzZLZzZZem5FWWJObm5XYUVGbmp3ekFXQjJBWW41cjFUMWppY0I0a2VGMkZ6ckN6ZmtaeENzMGtzdjhBL1R2d3lrZXdhdlBmaUcwMmNERDVsaW8wa0VtRkVXSlBhWmxOaTYyN1g3VXVPVzNvaWF2bG5QSjVJSkNGaERhVllxUXh2OXJIdlJQR3krV3BVS0VCMS9MRTdYL2FuRGdZWUZSSVkzTVU1WVJNMS9TdzV1TzF2bXBReTZSYlFuRVJsd1FTejdhai9LcitLYmtpbGtqUkJNWTBYSEJveEVRTFd0cDJxVXlhVHBhUDFLTE1GK2tVdEl5dGh6WVd2NzFLVlN2S0RtMjNhOVI1WS9LYmNYN0NyZ3dJZElmYyt3cGlhSWFDbGhxQnRRMEtpbzhqYzI1WHQ3MGd4V1lXRndlTFZPT0dObTBpMTlyM3BKd3BzTGVuU09lOUlodzBxQmtBNzFKQkJBREM1N2ZGR2tWd3BPOTlyMC9CQ3J2cFVuNEpGS0FtRmJQZGdUYmMvd0Fxa1lhTURFZlQ2Z05oZm1scEVkbUk5WEh3UlV2Q3dxMHdJVWFnYlh0ZW5KQ01USWhFbXExZ0J1S1hDTklMR3pLZnBVODFOeEVTb0J5THJ3ZTlNd29IS2tyWmx2YW5VUTloS0F5V0pPbjVHd29PVHIvU0Y3MCtJQXJNRGZTZlVCN21nY0VaMURScVRmdHhTQ29qQ01EU0NMS1R6eGI3Vk1URGxsMUZic2RnVk5SaStIaENyTmlGQjFXMk43VmF3UlJ6SmVCeEtuR3BUeFNwTDVBaUNNeDNBdXc5MTdHbGZsaEdtb3Q2enR2VmdNTmQ3b3BKMDJaUjIrYUthTmlpbGdDQnNMZDdVVjlEU3Rrd3VtZlNEK242ajdVMjhjZ2tBVWoxQzVROEQ0cTFiQyt0Z1FReWk1RlJ6RW9JTmpjR2ltT1VsMFFaTU8xMlJVQzhFdU9QNVVxV0pVTEp1ekN4NHFjNkR6RHBGeGIzNXBNMEdtWW9EcFczMURlaW1JNUVMeVRJbXBob0JQYm1tekh1cWtiQUhhcG9UMHVEOU94M0c5NkRLcTJzQzVZWEp0dUQycEJMSVN3Nm8wMXQvREhLMDJ3TDZTQVF0OWlvL3BWaXNLc1VzVlVhYmtuaTRwaG95dGpxc29Za2dENnFkdFF0TWpwZXgwMlpqL2xUbWhCZTdJRDgwdFZHcTRPcEZHa1dHMjlPWFZOaUZIN1UwS1p3NjRCRnQvZzhVRnNWSnZjM3Z2U0ZSaXdKMk4rRFJtRW5oZWU5VkMrR0pWM0FQM0ZEelZCQUFPOUJJU3pBRzFoUm1FaXgydmVnQWd6QWJEYWlaM1czelJpRmJYSjN2eFNsalZqeHY5NkFDTWphZDNQMnRTZDM0YzA5WUFiZ2NYNXBPa0N4QUFzS1ZjTUJJdUFSc0FPNW9CQ0Z1UmErNHAyMXlvSUJ2MkZHVnNTTC9iNG9iQWJDa2NtM3hTbGoxTmNuaWxqYzJOR0xEWW0xQUNBb0w2Ymswc0tvK29EblR2UzFqQ0FFdHVmWVhOZEo4RC9BclB2SGZxNU1seVpIdzJGanMyUHpGbC9oNGFQNzkyUFlVZE9ncStRL0Fid0N6cng4NnZUSjhyUTRYS29HRDVqbVp2NWNFZnNEM2M4QVY5WitoT2hjbzhOK2s4dDZieUhETGhjdHdVUVJWQTNrTnQzYjNKTzk2aGVGbmhqa1BoQjBmaE9uT25NSXVHd01OakpLUi9FeEVsdlZJNXR1VFdzWTZCVjZHUDhBZElobksxU0FDTEdrUHdSYzdqbWt5U2FVSjdYcWh6L3FOY3VnZUcrbkVNcDhzamZmdFVlWFBHUEE2R050cWlCbUdibkpNVkpoOFJpVk92MVJYYTEvaXN0bS9pRGhuWXhpWkZrR3dqSjlScm0zVnZoMW5QWDA3RFBPb2NSZ0ZFZ2VJWVc0L3Jlc3YxQjRJWTNEcVpZZW9NYmpZQ21nS1pQNGlEdldGUEpOdG05Q09OZHZrdC9FYnhlZ3lkWFFZMkVURUZmTGo5YjMrdzRya1dCR2U5WTR4SnpoNVpsY25RSFBiM0lxM3cvaEhnc3FtUjVuZEo3YWpQSzRHcFJ2dmV1b2RHWm4wemt1R0NZWEU0V2VSMkE4ME1EMjQ1cXUxS2I1THF5eHhyaEVmcFR3WjhpUER5NWhhU1FuVVZHNFg0cnFHQTZMd3NDalNpRFF0dHU5T1pmbWVIeE1JYUoxS25nWHFiSG1rY1FBWmdOK0t0WW94ZytUTXlacDVKVlE5aDhsd3lKWmxLNnRyQWJWRHpISm9iNlk0eGVwaVo2c3FuY1dCN1ZGeE9hcEtDd1BGK2RpZnRWcDdHSkZ6UnpQcjdJWjVNVkVtR2lXUEZZaitHSmRQQXRhOWVYdkdYOEsrYTlPWnY4QW4ra0kxekhLWjFEdmdtY2lXR1hoemM3V1BQUGV2Y0VaanhXT0U3QUtVVDlmWUdvYnBodGNoYUVNRzM5eGVxMGQyTiswczVkdVZKU1BBWGdQNEtaMzRuZUsyVlpEaU1KaXN0d21EZjhBTzVoUElOSWpqUTNBVnZja1dGZlZ2QXp4NFRMMGplUS93VkNoM05pUUJZWC9BR3JtM1NXRHdYVFdXejVsR3FZY1lnMzFJTEZpS3pIVTNYR2RkV1ovQjB4bG1FTU1NNmFzUmlKV3NZMDd0VXl6T0tjbjJRTFNiN1M2UjJySThTcllQRzRzc0Noa1loeWRpQlhJL3dBU1BVVWVTZmhpOFJzMXhETkdjd3dVMkRoYjNNcDBML25WMW0vV2VBNmV3dVY5SVpYcXpITVo5T0hDeEc1Qi9VemV3RmMvL0dwaytaWi80TUowZGtRdzAyTWFlS1dUQ3pTQkhuamg5WldLK3pQdGZUM3F4RElwcW15cmt3U3h1a3V6NXRRSVlNTkZIYTJoVkJGKzlxTWJDNUY5WGIyb1NLQVhVcVF5SFM2TnN5c0R1Q0tESGhoOUpHMVNGSnFueUVCWWhSL09sbEFDTEdpOWpleHBZRndDQjk2QkJxUStvOXg3SGlsQUN4N2p2OFVUb0ZZbG10OXFVdzN0WUJUN2IwQUVBZFkzdURUaFd4Mm9yRDAyN1VvYm5mWTBDTUpmVHlMMDlHaGtaVlFXY25UWWY1M3BJMUM2Z2dDcE9IVklvblpnd3hERUlnSDZWSDFHbFFJZmFOUDRXRlZtZUxZeU5IOVRBYzFyc2thU0RLdnprOGlDekZZbGp0WkZIQlB1MVk1Y1NrS0ZJanFtWmJrOXdwN0E5cTBTU01tSHdlWFlXRTR5UlZEcEJFTHJxSjNMdHdMZDZyNU9VV29JZnpIT1V3bUFXRUN6elByTGNsajdENXJvUGhGMFAvYUdKaHpET0VCdzZSbWFHSnV6WDVmMnQyRlpYby9wb3RqaG1EQ0xGVFIyMVRUbThNTFgvUXZjajNycW1EejRTZ1lhRERwRmg5ZXBsUTNad085L2NudFZQTExiR2pReHdiYU9qUTRpS1dkTVRpSEIwa0xoWUlqY1dITi8zcnAyVGRQd1lES2Z6bUtoOHViRU9Ba2FpN1NBOFhGWXZ3djZUTXdqemJNSTdLRGJEWVVqZHQrYTdqazJUeVl6TUh4V01ZYXRObFVDK2hmN28rYXE4eUxXUlJpek1ybFVyNDZIQ0N5WGpNcFVjSW9wak9zTEREZ1l4R0xoZCtPZmExWG1UK1pqcHM4ekZvd2p5U25EcC9nalh0VGVQampjaFpGOUVNSWV3NHYycVJSSW0rVE1ZWEJtYkZLWlcweGxRcEpIZnZXTDZqWnVtc1BuS2pYaXhOS0xoUituOUJINzEwekc0TjRoaDc3czQxV0EyRjY1NTQzNVljNGZDNWRscDE0d1FSeDRoWXpZb0hrWFExdmZtaHFxQ0V1U0ZtdlRPTmZHbk1uajA2MVQ2ZTlsRzFSWU1taWl4cGd4WDhOTVpBRlNXUDhBOEdaSDlKUHh2WGFaTWxFbVRRS0JjQkFtNXZ1b0ZjNHpicE1NOHNVOHNxNnBtT3BWK2tFYmYxcXRjc2M3Wk9xeUVuREpHUmlYTUg1ckV5TCtWeE1aVUM2anZiN2Q2ODRZcm93ZEc5ZVlmS1lzUkhKbDA4b1hXMTd3QjJPa3NPYkE4L2V2UW1CbnhPVDR5V0hFTVN5b3Y4Zmd1QngrOVpqeEs2U0hVNHcyYTVkaFB6T1pZZHRKaHZwOCtKaHNRZVJackg0SXEwbnU1UldTMnk1SnNmUnVBeTNDNW5rU1N0TGxXWTRjdE9PMFVwTm1LOTlQQnJqL0FGZjRjWmxraytYUjRERUxKR0laWW80WmlCZTQ1UElIRjk2Nm40YlorT3NzdndlSW14UGxZM0N3UGg4WHJhNUpWaUExL2U5dDZuZFpkS3k1OWdmN1F3ZGtsdzdsSklXMlNjZ1djTjkxSnBWY1ZiR09tNlBQZWE1Vm1QOEFZT1k0Yk5zbWlNSmpXWVRLNFdTTnVOUVljMzU0ckF2Z0pZOEhHWnRic2dBY3NMaGgrbHg3N2MxMFBIWm5pY2d6R2FIVXlKaFN5cmg1ejVrYngzc0VJN3JiYmFzVmlNMXd1WXplWmhEL0FHZEpJK2g4dGtONENoSnVZMjdiOWpWckJrNUttZkg3U3VhSFF2TnRRNDdDZ0lpbDFKTzloYTFUREdqa0lHQUE0M3Z2U3poeXZxWTdHdFZjbVJManNyekZwWG5uc28yRnFUTEI2QklvRElkd1NMRW4ycXpoWkVWbGoyL3hFYjFIbWdPSWpERnY0Z08xNld2c2FwRlFVS2tnYkcxLy9TaVpOR2xqZTdjQURtcDhpRHpiYWRLRGdudWFTSUdVa0I5Z2JrdHdhS1EreU1rSmJTQUNRRGU2L3dDdFNvOE1iTGUxMVlrMk5QeFIyVWs3QW5mVDNKcDZHUFdwQ0FYQnRZaWthWHdHNFlpaEtLT1N4M3R6dFUrSENzMGthSnlTRHFHeG9NQ2lPUExhYVUyampqaUhxZHlRRlZSN2sxNmU2Ty9CRG11WVpIRG1IV3ZVRFpLUEw4eDhweXhRWkVBRnlyU2svVjdnQ25yb0VuTTg0eVJ4WXBsd3NIbVl2RmZTc0dIaWFTUWtpL0NnMi9ldEwwNTRLZUlmVmt6cGszUkdhR0VXQm14NFhDb1BrYXpjajdWOURmRHJvenBqb3pwekNRZE01VGhjdnd4UWVxS01lWXh0YlV6Y2x2bXRYcmRnTmJGcmNYM3RTcU81SmlTZ285bmdyQWZnbzhUY2FzYnlZbnByTFJxRE1aTVZLN0lPNE5rc1QrOWRUNk4vQW5rV0ZJeEhWMmVZblBKTGsvbE1IL0FndnoyM05lb3JtOXovQU90RVRmbTEvZnVmdlVzY2FYWTdycEdVNmU4S09qT2xjRitVeTNwdkw0SVNReEJoVmlXOXlUdldONi8vQUFzK0gzaUJpVGpjUmxqWlZtT2tyK2J5OS9Lc1Qrb3FOamI1RmRkb0Vmc2FrYVM0U0d2ZytkM2l6NE01NzRPWmpGRm5EZm5NaWxrMDRQUDRGUGw3OEpQdDZXK2VEV0tPRU1qZ0t4SXNRdjhBZE42K24yWTVmaE0zd0UrQXgrR2l4dUFuWFJMaHAxRFJ1dnNRYThxK0xQNFJNVmxjZUp6VHc4QzR6QmdGNXVuWjNDbTMvd0R6dWVQKzAvenBqaXlLVWI2UE16NEozMkxYWUhnYmZ6cHFUQ1dkN3JaVzRZSFkxY0xCL0ZtdzdSU1liRlJIUkxoc1NoamxpYis2eW4vT2grUlNPNVVhWTFYVU5XNHY3VXhvaDVUcGxCRkNybXlxZHVOUW9wb0dWNzZlMittdEFjTnBzMTlyYVNvWGEvdlVPZkNGcmV0UU53UU9hU21GMlZKak1yS0ZHNUdtMUJBcStXeWtvNnNMZk5XY2NBTVRrankwTGMyM050cVlFRWJpeTkydHVOL3ZTVUx1SUxSWEJKVXNnQkZyQ21ac01vSHBVb2YwL3dCMEQ1cTBUREI0R1lLTlZ0SnZzcElwaU9CWklkd0dMSFNiSFlXNzAraDI5bGNzRVlYNjkyM0lVYlU3K1dOZ2JEZjR2VHJLc0JEb05OL1NDdzJvQkZJOU9waDdpbzlvL2NjQUFJRzM5YVVHMGl4M1B4Uk1TUllBZnpvYkFiSGVxQm9nKzNOR0ZMRFVEeFEwN1hvanZ2eDhDZ0FtSkxBMjI3VXNydzNQeFEwM0tuMzVIdFEzN1VBQ3cyT3cydGJ2Ulg5SXVOSys1bzF0eWVhVnEwV3ZRQUFwVkxnYlh1RFNsRmdhSXZhTWptOUt0WnViZjYwQUdOOXFVRlV0WWcvZWtxQ1NkTzU5cTNYZy93Q0VYVUhqZDFuRDA5MDlENlZJZkc0OXgvQ3drUjVkajc4MkhKb0JFendSOER1b1BIYnJHUEpNa2phSENRMmZINXF3L2hZYU8vOEFWajJGZlZqd2s4SmNnOEd1a01QMC93QlBRR09HUDFTNGg5NU1SSjNkejNQK1ZOZUQzaEhrZmdwMFRndW5NamhYVEVOV0l4WlMwbUpsUEx1ZjhoMnJjaitWVzhVTDVaSE4wNlFGOUFBM3NCNzBsdDcwcjcwMjdFZjdWYW54RWl0V1JzYzVTSWhkaWF6MHVXQ1dWNUpsTWgvVHRlcjZleHVUejgxUjU3bTBHVVlLU1dTZFVVTHRxTnQ2dzhuTEwyTi9SbCtwWjB5cU5nZEpHbll1YldyeXQ0MWZpbXczUThyWlgwNEk4enp0Z1ZrTEc2NGZibGlQOHFpZmlmOEF4SFNaWXMyU1pIamtselBFS1ZkMTMvTG9mMU44K3dyeHd6bVY1SkpIYVdWMkx2SSs1WW51VFRJWTNKN21TeWtsd3pSOVRlSWZVM1dtS1diTjgybmQ3M1VRdVZVRHZ4MnFpdzJNeFdEZUdUQzR2RXdNaDlMeHlrY2Q2YTFCYnNBQnRhM3hTVUJJK0QvU3JlMlBWRmZjMHpxM1J2NGp1c3VrM2dXV2VQTTRFdjZaNzZ6dC9ldlhRc0wrTkxIRlQrWXlncVN1NUJ2WTE1blpyRDJiM293d0wzRGpUKzlNZU9MSHJOSmRIcDF2eGxxMFBvd2s2VEc0c0VOaFZOai9BTVgrZXk0eUY4Rmh4SEdwRE9zcVgvWWI3VjUrUjJQRGFoN2RxY1BIcUlVZTNONlQwa1AvQU1tWjZzeWI4YjJHdytGamp6TEpjVCthM0Uwc2R5RDdBVmY1ZCtOSG81cFVURjRiTVlRZWJRRnRIM3RYalJHSms5Ui85UlRpN1NFZ2xSN1VpeFJib2Qva1NTcytnZlRYNGg4cDZsd1VlQjZUZiszODN4TWorVEFRWS95cTJIcWNIZ2M3MVpabk1lbW9UZ1RpcE0wNnd6WnZMQ1FUV2NsaFljYmhWUGV2QWZTZWVaejAxbXo0L0k4WkpsMk5hQm9IbmpzRG9QSXZYb2Y4RzJlUGtYanl1STZxeFR6WTdOY3JrR0N4ZU9mVlpsdXhVRThYVy84QUtxc3NhVHBtM3A5VHVoK0o2MThQT2hzRDRHZE9Zak9jOXhSelBxRm90ZUt4emk0Z0hKVlQyQXZ6WG5MeGQ4YUl2RURxdURGUk14eUxCYW80Y1d0L1hJKzVZZkFzTjYzUDRpL0dhUHJpS2ZvVHBUTWxrWEVML3dEVjh3Z0lLUVEvL2l3M2RuOXUxcTRuZ0pNSEpGSmtNOGNjWDVXUHlrVW13a1FEMC92dFZiSzFGYllzMmZIYWVVbTh1VmQ5R1g2OThQOEFEZFVYekhMQ2tXYm5keXZwaXhadHRxOW10M3JqY2tjbUhra2duaGVDYUZpc2tiaXpJZmtlM3pYZHN1eGo1YmpqazJNSlNFM09IbTV0OEdxYnJub3hlcG9XbWhSSWM4alhVckU3WWhCK2svUHo4VkxnenRlMmZSWDhuNHlHU0x5NFZ5amtJc1R5ZCtLVVFRTlBHcWcwY2tNMGtNMGJRelJuUzhUaXpLZmFuRkd0bEJHbTIrOWFxNVZvNGVTY1cwK3hxVVdaUUFHMnNiVXJRQXhJMjl4NzBjaTZTZ0EwNnRyL0FPbEtzQXhBMjdBZTFBM29JRWFyamY0SGFsQzJvNnY1VWJSK29FQWdnYi9OR0ZHc1hBMWQ3OFVBMktnZzgxaUxla0c3ZmFwVVJsbHcwaUxHbmxyYmJRVElMOGFSMythUW1KYUpDeXFGSUFBdFRzT1o0d016akVHTnJGQ3lBQTJQSUJwc25SSkNQeVRNQmxMTEdNUmlGWEI0Wm1zSE84c3dISVJlUVBrMWJ3NHlQTG9aSXNORTRoWTNFZDcySHVUM05aMkhHYUNTMnR4eWJtNVkvZXROMDVrZUo2MEVjV0JSbXhjTW9MWWVKaHFhSS9Vdzk3Yy90VmViNHRscUN0MGpWZEQ1RGl1c3A1TVJKSU10eVhDZ0dlYStrYmZwWDNKOWhYZStnK2hrbHhBZHNLeWVjVmFGRzNaWXg5S2tkaWViMVM5QWRPRE9qaDFWVmo2Y3dMQk1QRkV1K0xuSEorUUQzTmVrK2grbWx3MnFWNHdjWTU5WS91WDdmRlpzOTJTWEJzV29Sc3RlbCtuQmc0bzNsUW1UN2JJUGF0VE1ZOGx5akc0eHlBSVlYbFA3RGFwTUVBaWhXTWJ0ZmY0cWo4VHNYSGhlbFRscGIvbU0ya1hCeHhqNm5MYzIrQUJjbXIzcGJZbWR2bGt5VVZQUVVVbi9BQUpnNXBvOVV1TlI4WkpxUGRqeFVHTlh4aXZJeEt4ZWRhM2EzWlQvQUZyWTRqTEV5L0w4TGdZVHRGQXNQcDVWUjNBKzQvcldhc1A3RzBoZ0hSek5LQ1IyTzRQL0FMMnBpaTB1U1J1MjZHODdqRDUySU1NOTFYREFoanRwYzhmc1Blc2IwSjB0TDFsMTNpYy9LeXg1SmxVLzhDWjFzK1k0cFFWTG0vOEE0U2JoZmU5Vy9oNW5EK0pIVWVZeVJJSHlyQ2dSU1lpK3oyNFJQY1g3MTFQRHdKZ2NNNGdRS0kwS3JIR0xLdHVMVStPUGR5Unl5dUhESUdVWlRvd0RLMW1ZU09kaDNOWmpxSEpXRTBrcUxjbStvWDJGYi9MaG9nMkFBWWxnQjgxR3pUTGx4UlpkT3pBMythZGx3M0Rja1E0c3pVNlp4OThxaXhtVlNpVmRjaWhybGZxQjdXcmx1WDlZVDVjVzFQNWVOd016SjZ0OVpHK2svQkhhdTBKaFpNcXgrSXc4bnBpWUgxMjQ5aFhtSHhQWjhoenpQcFkxUVFMaUVta1pTZlVHVzM4NzFsUWJqS2pZU1UxYktkTXd3L1RIVldQenZKb0RQbHVJV1g4M2wwVG4rREkxanFYM1QyNXJ2blR1WkptT1I0WEdlWUo4TGpGRWN1azdBRWVsMTlpRHNhOGk0anFIRmFreDJBbVlZakQvQVBWakhGajN0M0JydGZndDEvZ2MyeVBFWlJpVDVNaFFza1I0UnVUYjk2dVY3ZVNrK09oUGlmMGlZVEJKaGxSSm9HY2xKQU5nTjlqOCsxZVZzMkw0SE1sU2RXdjU1bER1aEFJSnZZL0lyMnQxbkpoODc2WW1na041VmlaVVkvVVRiWVY0L3dDcEh4RTdRUUcwNWhMSXp5MlVuM0g3VS9EdytTRE5kRmxnV2dsUlpvd0NKQmU0SGFwWTB1cXkyMU5iaGhhMVZuUjhmNWZMM2pZRjVvRnVOL1NBU2Y1MW9IaE9sWkNwWjJGd0J4VzVGWEZHSmw3SWJ3V0txdG1BNDIzQSthWW5TNEpEQzN1QlZ1SVhJSkMzM0F1TzFFMkVMb0xnZVhiamdYcFdySzlvb253ekJDNHM2RGcrM3hUVFlVQTNObkhOajJxMGx3aktXVlZLS04ySDJvdnl2cFlxdXZXTG0zdFRhWklud1FVaGQrZGxVOFd0ZjdWWVF3dG9MSXU0RzV0dlM0Y01KYkVMY0FDd2J0VmhEQXl1VlVhUFRzUWJrL2VoUmZZa254UTdrTE5sSFVlU1k5STFjWWZId3plWTNCOVZyMitMMTlMYyt4a21QNk14OHlQZVNUQ3Q2aHlUYm05Zk5QSFlWbXdEeGdOWUZWalpmZTROZlIvcExGUll2b1RLL00vaUxMQWtaQTVQcEY2aW5MYkp4KzBYOEhNRkw2SCtoRkw5T1lTVWdxSkZEaXRDRHNUMkhlbVVXREw4R3FJZ2lnalRZZGdvcmlQakY0LzR2SytsOHdIUk9DR2FabXE2RW5rYlRDakUydmM4MnFWVGpoeHBOOGtpeHl6U3Y0T21aOTRsWkIwM21jZVg0L0h3dzRwMTFGSGtWU2crYm5hb3g4WE9sUUNUbTJHVUQzbVgvZXZtQmpvT3E4d3pITTh5Nm9qeG1PekhGU2FzUmpKZ3hCYis2Q05nQjJweGN4RUtSSjVNTXpSZXIrSVNOdlkxblQxZVJQZzFJYVhCS20yZlVES3ZGVHB6UE1ZbUZ3R1BYRlRNYldUaGZ1YTFxc2pxcktkU25peHI1OGRFZU0zVDBHQ2pndzg0eVhINlFHRXFGVVp2ZFdydC9RSGpQbCtGMGpHZFVZZVlnQWxkZDdmdFRzV3VtcGU5QnFQR3dhM1ltZW1MYlgvcFFHd050cjgxbnVtdXRzQjFKaFVtdzhnWkRzSDR2ODJyUUEzQU43L0lyWHg1Rmw1VE1MSmluamRTT1plTVhnRGtQaS9FbUtrWnNvNmdnM2d6WENxQTMvYklPSFU4V1BIYXZJdlhuaDcxUDRZWmkrSDZueTRRd1lnbFlNMXdpbDhGSUJ4cUl2NVorRy9uWDBIMGhyRWk5TVk3QVlYTThITmdzZGg0c1pnNWxLU3dUcnJSd2VRUWVha29nYVQ0UG5DMkhabFFxR1lXMTNRM1czeGJta3k1VGk4UWl2aDhMS1NUY2dSa2tEMzR0WGZQR2I4SXVjQ0diTVBDdk8yeVpuSmFUSXBMZVN3NVBsdWJsVDhjVnhCL3dpZUwyT1NGOCs2cXdXQTFpNGp4ZWIrU1ZYdllMYS8ycUtVMnZnaldENUsxY29tUlloSzBVTEc5aE5Pa1pIM3VSVmJqOGRrdVhTT01kMUJsZUZtQTlTTE9KR3QvNWIxZTR6OEgzVE9YTUplby9HZklFY216eFJPY1E2KzQrbzcwMm5nLytIVHB4WW54ZmlKbU9jeXhrbG84Qmc5SWI0Qk5xWnZaTDZTUmpwUEVEcENDY3RMbVUrS0NyOU9Ed3IyYjJBSjROWWZNdkYzUEpaNURnOFBoY0ZnUVNZOEtxWGNqL0hmY20xZHdueGY0YmNrRWN1RTZZNmp6bGlkUU9JeEpqakIrYWMvK2Z2aFhsRXhseWJ3V3ltS2VOam94R1BtOHkrMjIxTnRoR0NYd2MyeDNVMmFRZE1aTG5NSFR1SHpUQVpvSFNQRXhPekJaayt1Tm8xM1U5eDdpb0M1NzE5aTFFdUQ2UG5HSGI2ZEdVWWhoL091NWVDL2lyajgxeVh4djZnNmZ5M0o4anhtWDREQzV2bCtBRUN2aG9KUXhTVmxWdGhxWG41ckVTL2prOFJMUms5UjRhQWxBZkx3MkRVSVA1Q285ekYySGwxUllXdGMwcHJLN0hjZkZKc2YwN0doYzY5UjNGcXFsd00ra0VFZ25uOXFJYmdIamVnQ1NUZjhBcFFHd29BTU1TNTNvMU8xSlk4ZS9laXVSeFFBNlZWZmlodWJIWWo1RkVScUFhbEUzSUlvQUI0NUg3VXBWQkI1djJzTGswWGxjRUM1UGIvZXRIME4wTm5maU4xVmwvVDNUdURreFdaNHhySUFDVmpYdTduc281dlN0VXJISldXSGhiNFZaL3dDTVBXY0hUblQyRkw0dVFmeDUyQjh2Q3hmcWtjamp2WWQ2K3JuZ2Y0SjVCNEY5RjRmSWNqaVdTVXJxeG1QWlFKTVZJZHl6SG0zc08xcXJQdzgrQXVVZUEvUmtXVjRMVGljMHhRV1hNY3diNnNSSmJlMytFWE5oWFdOSUJ1QlUyS0RrN1pGa2xYQ0NDaGFPZ2Q2SGV0RkpMaEZhNzdCV0I2NzhaT252RC9xREtja3pHU1dYTWN5WUxISEN0d2dKc05SdnRjOXEzak5wTllQTStnK21oMURKbitJd2FZck05V3RIbU9yUWJXdUJWSFU1SEZWRXU0SVFiOTVvTTB4NjRlTUg5UkEvYTR2WGpMOFcvd0NJU0xwaFArSDhyL2paM01HM0xBckNCK3NqL0lWMTd4NThaOEg0ZGRLNDdIeVRwK1lWU1l4ZmRtYjZRQjN2WHpMejNQTWIxVm5HUHpuTXBHbngyTmN5TXpiYVFUc3Y3Vm1SVG55V0piWTlFT2VXZkdUeVlqRVNQaU1USTE1WjVEY3lOM05JdWJCZUxiWHZTUXAxTWI4VzcwYkM0QUhlclNmQld0L0lleDNQYWhyWWNDaktNUUxyY2p2UTAyVWIvd0E2VWErUXlwdURmYysxR0Z2cEl1QU9hUXR6d2JFY1VzQTZTTlhITktJR3EzdWZiaGI4MHBGQUpBOVYvZnRSTGZaVC9PbGhMMjNJN0FkNkJhQXR4Y2tiQTJCdnpVL0tNcXhHY1QrVGh3U29PbDVqdUFmYjcxWjlHOUY0M3JUTUdqaUFod1VIL1h4VGZTditGZmMxMlBLZW1NQmxNVVdEd2tLd3d4R3dadWYrNDFVeTZtTU9GMmRENC94TTlVMU9mQ01oa1BTV0h3ZUJlTEdPVGlGMGdSS04zQjROZEF6bm8zQTU3QmdJNUdsd1Q0QmRNYzhCczRCSEFJM0hKcXNtU0hGZGZaTkducGVLT1h6VDJkTFhCUDcxcjNtc1NxMjFnM1ArS3NqSmxrMmQzbzlGaFNlT3VDQmt1VjVaa21EL0FMUHdVWGxRYWJ2cFBxbGYrODU1Sis5VjNVT1V0S2lUNGZTazZuVVhYdmJpOVdpdktrcWdsVkxYOVJYdlQ3eGc0VWFodnZmM05WdDE5bXc4VVhEWkZkR1hnbWg2bGhqdytMYnlNZEQvQU5PY2IzUGEvd0FWSWdXYVZCaGNUL0R4VUJPbHVRNDdFZkZRTTl5aG84U21Jd3pGR1I3NlFiWEh6VmhsdVpSWmpoa2d4RnpORzFsWlQ2bFArb3F4ZHBVWmNJdU1tcEdmNmw2YnduVllDNGhmeTJhcDZmeks3M3R4cTl4WExzeHl2RlpUbUp3V01RcE9wdXBBMmNlNCtLN3ZtZUFhUWd1TFRMdGRmU0pWOTZ6K2M1TGg4OHdZdzJLT29qZUNkVDZrUDkwMWIwK29jZUpIT2VUOFVzaWVYR3VUa3VKMVJUNE9ObHUwcUdVRWJXdHNmOHFhQUFkdHR4dTMvcFUvcURMY1RsZUpHRnhjZW1hRTZWTnI2a1BzZmFvSTFDWVdhNEd3cllYdVZvNEtVWlFiakxzTlV1dlBQWTA0Z3ZxQjBpM3VLU0ZZdmUrMUwwcU56cUE3bTIxT1F4aGlJeVM2UnV1NS9ZYzBsV1Y5UkEweEtDMm9uYmIzcWRsdUZseEV2bG9sbnhJT2huNFZSdVRhcXZFeS93RExNTmZwZHRJSFkyNzFGSkZpUDRqbUlMVDRpT0ZBVmpDQ1IydllrbmdDdXJlQ3VXNG1HVnMwd3lsTVhLVERDVkc2eGpkais1OVA3MXluQjRWOHd6TENSeGJTVGtReDM0MjcxNng4TWVnNVhYRDRmREV3UmhOSXVOMlVDdy9yYy90VlBOS2xSZjA4ZWJmUjAzb2ZPc3M2Y2EyWkpERmlIT3NSWVVneHd0N2FleCsxZENsOFd1bk10L2pITTRzRGlRVktLUnRNQnlwK1R4ZXNaa1g0ZmNMK1haNTh4ay9OTUNmTTdnbW9PWS9ocHhPS2xNa1dicVNGSVNQVHlmazFTanZUNE5HYXh6N1oxbUx4NHlYRTRGSk1GZzhYaXNYSXBaRUFzbXJ0ZHZhcGZUR0V6RFBzMlRQODJhT2JHNmJZZUZUL0FBY09uK0QzUHVmazE1eXl6d3g2ODhOY1RpSXBFYk1jdG1PclRHUzNsSC9EN1Z2TWc2cHpQQkl5UGhjUkdxaTVRM3ZVN3lTM0xjUXJER0tleDhub25NTUlra0RUeVRMaG5WVC9BQjc3MjlxOGwrSi9YMHZWMmE0SG9Qb3JHVFliQXhUdGg4enpaYjNsWS9YR3JkL2svTmRYa3o3Rlo1a3NyWUxCenlZbDEwUS9tWDB4cTU0WS9Bck8rR25oZStUNDdOTXl4QWllVk5VU3hyOU9vL1ZJdnVUdlVtU2UrbEVaang3UGMrelNaZjA5alBDWEw4RG5PUzRhVEZaVERoMWh4V1dZY0ZpeUwrb0wvZjN2ODEwWHBicm5wenF6cDFzMnk3TnNQTmh4R1htU1dWVmxoYmNsWkZZaXpEdUtnNVRqc1U4VWVHaVZsYUw2bVBEQ21NMjhPZWpNem5PTnhmVG1YeVl3QXU4dmxhV2RqeVRibmp2VmpHOWhVeTFKOG1sNld6ZkRkUTlQWVBNY0twR0hsQjBFaTF4ZTE2c2RONVNPd1hpbzJHeFVNT0N3MFVieHhSb2dWVVhZS0FOZ0trWWVXUEVOSzBjaXNCNlR1RFY1VFUxVm1lNHlqSzBqSTlWNVNoTHpBRFdHdmIzRnE4aGVOV1hTNGJxL01ZbjFIQjVybFpranVQU0pJMjlTajV0WTE3bHpQQnJpb0dVajVVa2JrMTVvL0VGMFRqY3c2YWxud0Vmbll2TE1RY1NjT0I2cFlTcEVxTDhrYi90V1BteDdaV2ErbXlwcms4TDlQWjNORm9pYVJ3MGJOY2plNkhrSC9PcjdLODdmSjhkRmlZY1E2R09VTEpPaDMwSHYrM0pySnpvdUR6VnA4UDZzTTBqYUNwNUhiYjdWUGt4QURrcnBVYWROL3ZzYWxxNGtEbHpSMlBEZGJZek1zUG1PWDRuR1Ivbk5ONFowWS94TEc0Sis0cmx2V2tNV2E0VCswb1kyR0tVbVBFb1RzQ2YxRDc3MDFsK01rR0N3OGlxQkpoUFN4RzVjYzcxSW14UXhXWVl1VkNKTU5pSW1SVUd3SllDMzhxSXgydXhzNXVTb3NPam8wVEtFWlYxQ1NOUnpjN2MzL2V0Q2tSRGxUSVBRQmNBWE85WTdwenFYSzhnaGp3dU5hVUxHcTM4cVBVM2U5VzhmaWZrQ1NJSU1welRGdGMzTWdXUFVLMk1jNDdUR3lRazJ6UkxoaEhLYk5xY25WbzQrMU9SNFY1VlNQL3hDVFpEdnZXSkhpem51RnpJUFAwOWhqbFdLazhuQ3dTc0ZramMvVGR4dVQ4R3JXWE5mRVBxR0hHNVZnZWxWZ2x4Q0dEenNKZ3BaSkFEeVZZaTE2azNwRmYwWk44bHhqTXVraWRXdUdzU3BLSFVQMkk1b1FaSmk4UnREaEpuQ25oVUkyL2VsOUgrQ3ZpNW1YVDJSdzlHNWRtVWNUUlNyajRuZzB0aHAxbEtGV0xDNHVBRCs5YVAvQVBRNzhZY3l1dWZaL0JrOFVpMy9BUHFXYkxHRCsxeFVibW4wU3JDVXNYVG1NaGtrTExIaGxRQXMwa3FvQi9Palo4aXl3S2NUMUJsTUJ1V1pQekt5TmYyOU4vNVZabjhHV1I1TmIvaWp4ZDZZd0VJSDhYVGloS1IzL3ZXcGNYZ2g0SzVFa3NtSjYyeC9WcW9wWlljaHdhb3NoSEFFbTRIM29sbFVZOHNueDZXV1IxRldRK25NKzZhNnQ2b3l6SXNzenVMSFkvRVRnZVhCQXdWUUFUdjhWN044SHA4Ymora01KaUdabzRzQk5KRjVaMkw3MnZYbFBvN3IzSStpWk1CbEdUZEpZREorbDhSaXhGUG11TEhtNWlGYTlpMHZiMVdGaHR2WG9MQitPSFQvQUlZZEk0WEtzeTh5WEhTVFA1VU1LWEJ1ZHRUZHZlc3JMcUZLZG05ajBPVEJIWkpjczMzaWo0aFI1UGxzZVhSeUJjd3pCdnk4S0E5enp0OXF4blczaGptbVorR21Ld0hTMkppeS9Ob294TERMTkQ1aVNPdnEwbmJZSGo5Nnd2VnZSdWVkYjV2bHZXZVU0c1l2SDVZQzV5NXVKUWR6by94V3JvL2hYNDY0SE5zTk5nc1hCTGhKSVhNV0lnbFVoNG03aGg3VkNzamxOYitpZVdGd3gxQmMvSjVWd1hoeCtKSHF2RHVuOWw0akN3T1FwWERSeHdJd3Z1d0ovd0E2dzNpQjRMOVdlSDNWMlU0RHJPZjgzbWVZWVpzVkVZcHRlbEEyazZyY0VHdlkvd0NMckp1cGNUNFRwMUowSm5XWXhZbkJ5cThtR3l1WWo4eEN4c3dBSGNmNjF3andKNkk2b3grWlluSGRjNExFeVltZkRwK1NiSFNHU1ZJemNzR3Z4MnE1bTI3ZU96TzA4Wk9kTXc0OEljUm1VWG00YVdSZlRZcUJ0L0txcWZ3cjZnNmVuWEg0VWdUUmthR1ZiZy9jVjdMZzZSZ2pRTEhGcHNMWEF0U0orbGtXTWpTQ3BiY0VjVm04L0pyM0ZQaG5ML0M3eHJud3VKdytXNXhoemx1YVJBQmtPeVNqKzhQbjRyMVQwbjF6aHMzdzZneUFzUi9lQnJ6ejFSNGFZSE00WlpQS0huS1BSTitwZmtWVzlKZFc0anBET0Z3R2FReUlwYitIaUl2cFpPMTZkaXpQRklYTGlobmovSjdKaWxXWkF5OEdsQzQ3MWplaityc3Z6TEJvWXNkSElHNEJOYkRXSFVGVGNIdURYU1lzaXlKVWN0bHd5eFNwaXZmZm5uNXJJZUpQaFQwejRzNVArUTZqd0g1aEV1WWNURTVqbmdhMzFJNDNGYStoVTdSSFo4OXZHSDhDL1dIUnF6WmgwUk12VitXS3hiOG5PdWpHUmpubmNQOEFldUk1VjROOVo1eEVaSG55ekxYV1FxOGM4OTNoWWNxNktMcWZnMTllQXhXeEJzUnVQaXVOK01YNGY4TDExUGlNK3lCbzhxNm5LQVRFaTBHT0E0RWdINnY4VlYzaFFtOXJvK2ZVZmdSbXNrNi9uT3JjRW1IdmVZNGVOcEh0OEE4MWRZVHdOeUFRUEhpOCt6akhFRzRXRlJDdjhpVFhSc1ZGUGhjZmljQm1HVno1Vm1tRkpYRTRQRUN6Ukh0YS9LbnN3Mk5NbkN4Q1ZwNWlJb29rMXZ2eUYzSnAzcFJLL3J5dWlsNkx5ZkllaUkrdHNveXVERk1tWlpORmc4WEhQaUMrdG1sMUM1dFlla2NWVVpkMEowbGxVRFF4OU94VEF0cUxQSnFON0RhNSsxVzNTMGpabmx1TXpiRTNURVp2UCthZUVwcDBRQzZ3RC84QWh1YjFZSEJrazZFZlQyM3BJd3REWlpKSThmWDNMRCtsRVJjZXdwUXVCcjIzL1N0RU45dUxlOVpwcUFVK2c2YUNyNzcwUUZ5U05xV2VCL25RQWtiZzBkaDJvZlV1a2pibmFqRzFndGo5NkFERzRQMnBhS1FCWWJXb3I3Ykd4OTZsNWJsK0p6UEc0ZkM0U0I4VGpjUTRpZ3c4UzZtbGNuWUFVQVMrbnVuY3c2c3ovQlpMaytFa3gyYlk2UllvTUxHTGwrYjM5Z09TVDdWOVMvd3cvaHd5M3dKNlVWWFZNVjFSajBSc3d4MWdiSG55azlrRjdmTlo3OEpuNFg4TDRKNUt1YzVzaTR2clhNVUhuemtYR0VqTy9rb2V4NURIdlhwSkVWTmx0YmluWTR2SXdsTFlxRFJWVmJBQUQycFY3MEtGYXNWU3BGUnV3VWx0cVZUTTgvbEpUTWsxQWRHRjhqT054WGtRc2RWamF1WWRmZFhSNURsOGswcmhUcEoxRTJDanVTZmF0QjFMbll3OEVoTGNDd05yM3J3WCtMcnhsYk5NYk4wZmxlSkxzNmg4d25pYXdqRjlvaDhtMjlZZVNieXpwR2lvYkZiT1IrT2ZpemlQRmZxeDVGbGRjandURVlWQ041V3ZZeUg0Skd3cm5ZOUtnbmUvQm90WTBxTnZTTER0dFJrQnh1UDNCcWRKUVZJZ2srUWdMY25tak8yd0F0UTJCVWIvQUwwRGE1MWNVN3NZRXlsTEZidGZtakI0dUNhV3R0UGNDZ0NOSnR6U2lCRlJjV294SDZ4dlFjYWdCeGZtakZsdTM5M2NFOEFmN1VvdjhCMlZXSmJpdFIwTjBOaXVzc1JyMU5oOHBSclRZZzdGdjhLLzcxTDZHOFA1T3B2THh1Wk0rRnlqWXFxK21URS9DK3kvTmRrd3NNT0F3OFdIdzhTNGVDUDZZVTlLaXFHZlVxRWFoMmRaNG54RTlSSlpNcXBDOHV3V0Z3T1d4NERDUi9sOE5BdGxoRzMvQUppZTVOSk1pWWRGWjl3Q2VmMWZGUFBHVVlzVGNDM0I0cXF6TjNmK0d0aHZkTC9wSHZXSEc1eXRub0ZSd1k5c1Z3aUQwZW41L3FyTk1SS1dtZkRSTEdvWTIwNmpmbXRvaTNVNlJaaHgzRllydzNtWEd5NS9pTEY5V0xWRnQ3YWJWc2xZUm9SYzNCUHB2MnArVGgwTjBMdkZ1K3lKSTk1Tk9uVUZOKysxVG5YWGNtN2F2ZjIrS3Ezazh0MUliVU5WckNybUdRakRrRVhSZHczdlVSZWhMc3JzeHdZbGdJVlNWNEh2V0t4MGNtQXhTUENzZ0lOeUJ4ZjVybzdSK2FwWFNMZ2FoWTgxbnMreXR0R3VOWkUxYmtYNysxVFFlM3NwNnpFOXU1ZGplWFo4dWFZWlk1WFpnRGF3MkliM0ZJemZBbUJnVzljYmN1cHVEOG41cklHUjhweE1ySUg4c0hWcFB0M3JhNUhtOE9Ld0lzQVlXRnpiZmFuempYS0tXTEw2a2RrdURPNTVsZUg2aXdadzA0OHVlUDhBNlU2OWoyQnJtZVpaWGljbnhyNFRGeEdPWmVMblpoN2cxMnZOTWgvTEFOSGQxSTFMdmVzMW5PVVI1OWdSQkt5cGlJLy9BTUhZajFmYTlYOVBxTnZ0WnpubFBGNzA4a0ZUT1pSQWFnYjNIYSsxTytXUS9yMkE3WHA2ZkN5NFRFUGg1bE1jMFpzeW5nL2FtbUdvNzJ2NzFycHFTdEhCU2k0SnhsMk9waTJ3em1kR2NUaU1yR08yNHR0KzFVa2tmclNBK2xTb0xBOGdkelZsbUxpS09FUkxlVHV4Rnl2L0FHMVhXQWlrWmZWckFGeWJubmNVMThFa1g3VWRMOEFlaVIxNzEzaUpaVkVtQ3lmREdYUXBzQzV1RS9yWHRIcGJKMnl0MHhianlUSkdBRU8rbTIyOWNiL0JYMHNJT2tNYm1KVFZQbVdMMDZpUDB4amorZGVpdkVmSXNZL1JHTml5NHNtTGVQOEFodUUvVldiUG1UWnJRZEpKRW4vNWdaSGs4enc0dk1Jb21RWGtWbkFDZTJvbW9HQi9GbDRXUjRsOEpMMUJCREloc1dJSkczZTRGcThzZEQvaDU2aThTdXBKSXVyczJac3ZTWlRQQWprU1NpKzZqNHQ3MC84QWlWdzJRWkgxdGhlZ2NteW1EcHZvbktvNG54a21Dd2l5NHVReUQxekc1dTVVRFlYQXVhbXh4dFhaRm5ieHlwSTk5Wk5uT1NkWTVLbU95ckc0Yk04SE10MW5oWU1COTdjZnZXWXpuSXNMaDN1c0NNdllnZjFyeGI0U1NwTDRscm1IaEFjd3lPUEQ1UzJLbHlqTXlURmoxaC82aEl1UXBrRzQrVGF2YXZUZWNZZnE3cHZMczRnUjRzUGpJUklzY2czalBES2ZzUlRja0xmUTdIdVMzQjVkZzBNYUlvVUtEdUVGcXZvY0NrRVJXTlNnSkxiKzlRc2tnQzR3cWh1dno3MXFSZ3RVWUxHMjFQeHd0ZEVPVE00c3pDWVpBejZuY1czMk5aVHFyTmNkZzRYR0ZMYXBOaGY0cmQ0NVZ3NFlOdmYycW53bUJHWXpOSk1Ra080c2FyenZvbGkxYWJPTGRUZFg5WFJSUnBscXRvQUJtWmx2dGZ0ZW1zaDhWT3A4TmpaSVd5aVI4SXRpc3VraGllOWVnbXdlVllLRlh4S1JMRWczTGtMY2U5V3VFa3luRVFvWUh3c3F2OU9sbGJhbHhZcFA5eFlsbnh4Vk9KelBLL0ZUSHd3UnlZdkJ6STk3WDAzL0FKMVB6SE04SDFLanRIYVBFT202azhzT0szbUt5UEE0bHlIdzZGai9BSFJXTzZwNkR3OHhHSnd6dmhwNDIxSzhadGYvQUhxWEpHYVhQSlZoUEZPWENvK2UvanY0Y25wRHJqSGZrSS8rVHhvL05ReGdmOUlzZlduMkJybHNVZzFuMVdSVFlveDcvQnIyWCtJbkpaNHNUbHVZYk0wTFgxTXV6MzJJYXZNUFZQVGNTWXFmTWNBcW5DZ0swMEtEMVJPeHRzUGJlbVk1OGJXU1pJZnVSUVFZakVaWmhjRmk0VXNqeXQ1ckJkbVUvd0JMVXVlWFRJeTJzcGNpTWpZclk4LzFxNnpqSnNWa21SWWQ4SmkwT0ZoQ3lFQWxvcEZQMUx1T2Zpc3UySmJHWW1VYWdwbGJXQU9COGZ5cVVyTlVkZDZNeHZoZmhzaWpnNms2WnpmT09vNDMxcmlzTmlSRkRPb053bHJqdHlhMnYvemo4TXNqaVdmcHp3a3lxV2MyM3piRnZjSHZzR3R6WEdlbE1vR2U1amdZbk0ySUR0YVFZYzJkRUgxYis5dUs2SDAzK0h6S2VyOHdlQVl6RTQrQ1ZqTEF3Znlsa2lHeFJ5UHBrSGNmdjNxOWlrMnFSUnlKSzJ5NXgvajdnK3E4enlUSTgveVBwYnB6cHVmR3E4ejVkZ3ZNeGVGMHFXamRaRHVQVU56N1ZtYzcvRy80ajQxVEpGMXhGbFFMTW9peWpMNDBzQWR2cUI1RmJTUHdxNlI2YXpMSDV4bDJSTkFRNXdlR2ZGeXZLYmthVFpTYmRqdlVqSituOGd5WjBmTCtuc3F3MGliYW84S3JOZjN1M2MycXdveWtVcFpvUk1iMW40aWRYWmwrR3p3dXpxTE84Mm56Zk1zOXpzNDNFWU9abG14Q2pRVjFoTGJDNXJqMG1YOWM5WHYvQUI4b3ozTmtUMUsyTWtsWUo5aXhBcjA1aE9wU3NzMkNYRXh3WWJKWXpKSTBLQUJaNTNKWlZVRG5TQnhVYkZZL0Y1MU5xeGVKeE1XWFcxZVFYSlp2ay83Vld6NVlZSTNmSnRlUDBHZlhaS1VhajluRWVodkNTVEVGY1oxSkcybFdCWExZMjc5aTVISStCWFZ6aGNIZ01PeXNpeHhsZlJGR0FQMnAvTWM4dytXWWRvOEZBc0pheFZqdmNmUHNhekJYRVp4TnFaaVdaanVUL2xYT1pjOHNuWjZwcFBINGRGQ29LMlFPdW5UT2Nua3d5cjVVVHBZamczdmZVTGQ2cHVsL0VzOVY0VERkT2RTWWp5OFZCSm9qeFV0Z1pyYkxjOW1yVTR6TC93QXBHd2srbFJheDNKcmtmVStRNFo4M2xpOHBpampWNkJ1RDcxUGhhbkdtWWZsc2M4YzFtaWVzdkMvUHM0OFA4ZkJnTTh4czBlVnp5Nk1OTkl0MVQ0YnYrOWRmOFErbEMyRlhxL0paSVlNend3VnBaVkE4dkZSSFloeDdnWDNyd2psWGpuMVJoZW0weXZPVWd6dkNReGFFbm5GcFZYdGM5N2U5ZE55THE3eGQ2YjZLa3dYL0FBOWlzOHlmTU1JQkZpVWtFbzhwckVFV081cXg2VW1xb3hYcWNTcVhUZlo2a3lyeEFUTituNThHcUxoV2wwaDRrUHBQdVI3ZmFwNllWQm5DeEtwdXVIVTNQY1hyeTMwbDR1d1pJdUNoejNMc3d5bVZXQnRqSUdqMUFmUHZYZGNGNHI5UDVwaXNQUERtVU1na2lzaFZ0N2V6VTVKcCs1RldVMDVib25Ua3ltVjFEWDlCMktpa3o1TXhpS2hHMC9ORmx2VmNHS2dUeTVWMEZiZzMySXF4L3R3TkhzVkk3SDNxeDdaRk9TeUozUm1jVmtoQ2xHVWtHc2QxbDBiK1l3alRxZ2Q0bDNYdVY5cTZyaVpZY1NiaGh4YzFUWmdoaVRtOExjMVd6WWswT3haWlJuWnhucEhQc2RrZU9VWURFUklqQUFZVEVBVzU0QjdHdlEvU25pSEZqSUJoOFpnNWNKTUxic2JyK3g3MXhEcmJvaGNRajQvS2lzYzE3eVJNYkNUN2V4ckg5UDhBaXJpdWxjV3VHemJENHlPR002ZGNxNmxIemZ2VU9ITkxBNk5MTmpocVkydXoydERPczhZZFBwUEZPTHZYRXVsUEc3TGMybGlRNWpFbUgwOHUxdC90WFVlbnVwY0wxSkUwK0RtMTRkVHAxbjlSNzJyYnhhNk02VE9kemFTZU50bDRlYUYvOXFJRU1wSzdqdFE1clNYdTVSblVjcS9FSDRYSjF6MHJKbXVBakM5U1pVaG13N29MTlBHUHJoYjNCRjdleHJ5Tm1zWnpIcDNGdEZINVpsd2psUU9VR2szSDc3ZzE5RVlXMEZXdGNDMjN1SzhTK0kvU1I2QjhTczE2ZWE3NExITWN4eTdTcEpraGNuVkdCN3EycTlOYnJzaWxqM08wUWZFOFlCK3BPa3N4eTFWandPZGRKNE9lTkVGbDFRZ0lRQndPL0ZaWjFsWnJxajJQc2E2Ty9SdlVIV2ZoaDRiTGdNb2p3K1k5UEhHNWZMRGo1REZJK0dMZndtdGJ2dWJkcXJNZjRTZUlPSG4wTDA2SEdrRU5CakZLbjdiVTJHU0ZWWXllR2QyZlA5VUNqWTdVZDdnajJwUVBtRFlmMG9FYmNBRHZXVWFnbGVOeGVnUmE2NzdkcVVQcEk1dnZRNUFQdnZRQWxWTEtMalRiaW5BcDVBM28xQllIbmJZMzdVZGdvWXMxa0EzSk5yZk5BcTVCZEZVT2IrcllXRjkvdDMvOWEraC80TVB3c3IwRGdjTjF6MVJoQkoxTmlvNzVmZzVScS9JUkVmVWY4WkIvYXNGK0MzOExTWm1jSDRoZFhZUU5oWXpxeWpLWjAya2Ivd0RIeUE4ais2UG05ZTk4TW1sRmR0bXRZLzhBdi8zeFNKYnVCejlxc1hGRUlnT2JqK3RQcUxDaUcyMUtyVXd3VVlsU1RzRkM5Q2traXhxZStDSzdDYzJCSjRxZ3puTWxqVWpiYm0xV1dPeFBsUm5UejgxekxyWFAwd0dFbmtlUVJ4eGd5U3V4c0FvNXVheE5Ua2NuUm9ZWUt1VGpINGxQR1dQdy93Q2xwcG9aVCtlbi9oWUNKVHU4bjk3OWdiMTgrSnBaY1JQTGljVkkwMkp4RE5KTkl4M0xFM0pOYlh4azhUY1I0czljVFpySXgvSVlZSEQ0Q01iS0lnZnJJL3ZOZitnckM3b3pEZ2JmTkpqZ29wTWZPZDhCN0ViQzQ5NkJzdHlPYjBOaUxYSk5CejZOSU80cVZsZWc3Z2krb2cvZWpEQnZTRjNQNnZhaUpHa0E4MExsZlNEeHpRSUhjampqZ3QzcFFzdTRBUHpSTXd0OVA3MGtNdDdFV0hKYS9GSEh5S2xib1dXc2hja0wzMWUxYm5vZm9JNDlZczJ6cUpobHllcUxERVdPSi83aDJYaWk2RTZJL09pUE9jMGhQNUZDUHkrR2Ziem0vdkVmM1J6ODEwc3pHYWNhUnFMMkFBR3dBN1c5cXp0Um5hNGlkYjRyeG0rVy9NaWZCTWNTRUpWUWlBQllod2dIQUh3S21yRUk1R1UrdEhCTnZhbThNdmtLNUlDMjVTMXIwNjdXT29qK0cvYnZmNHJEYnQyejBYQkNNSWNEVHFFWmlOeVRZajQ5NnA4YWRienVRQ3FLU0c0cWJqWmd6TUZKVTIwMlgvZXFUTkpCZ01weFVzbnFHaGd2cTNHM2VyT0picEZMVlRxRFEvNFRBeGRMNGw1RVZYeEdLTDdqZXdBNzFzSkpDak5zMWh0Y0QzckwrR1VhRG9iQURjRXRJejIzM05xMFpkMWhLc3plV0R5T2FaazVreXhvK01FU0ZJSTNpWlNwWmtOd3BGVzJEbkt4TFpkMjJJdGNWVDRtWXZyY2dnbllhZHFzOG1rS3drNzdyc3RyaW9TZUV2ZFJJZU1YRjdvUWR5T0RURW1ISkIxS1NHTnd4N1ZLY2VhQmU0Y2MwQWpGUllrb1BmbTlOc3RPTzVjbUY2ank0a3ZNRjh0ZzFsWWIzSGVzWGwyWnpaUGlXSVcxZ0xiK2x0L2F1dVl6TDQydzdSbFdsRDM1TmlQaXViZFNaUW1EWWxRUVNkaWEwc0VsSlV6a3ZJNE1tT1hxNC9nMy9UV2ZRNHFFSkxvbjFEZFdHMy9zVWVlZE5Fajg1ZzVSTkVScUs4RmZ0WEpzcXgySXk1NHRFaklia1hqTmorNE5kVDZhNnRURnhxa2gxTWkydGExL3ZUY3VQYnlpWFM2dGFpR3liOXhqZXBjb2l6V011Z0M0OUVKVm1HNXJMWkYwUDFkMVVzeHlqTEo4eWpnYlRNY0xGY1JIdHFQYjdtdTFaNzB2L2FjUDV2TDA4cVlEVjVkOWorOWNteDJMekRKc1JqamdzWmk4cnhialJORkJJWXhMYmpVQWQ2djZiT3FvNXp6UGo5aTlSSVIxTDROOVo5TTVSaDhkbm1CT1hZWEVZaFVSNVo0N2trY1dCdndPYXhyUWFKc1ZHdzlZWlVXTlQySjNQMnArYkhacm1BWjUzbnhVQytrTXpGbERmWW1oa3VCbHhPWVJZZGJySWJ5T1dHcXdYazI1cTlrL0U1SEhCcHBIMEYvQ3gweEZsM1FPVXh4Z2FQOEFxYkc1TEVlcHZ0WG80NWNjVGdtaFRaV1hUcWJtdU5maDVTTEQ5RDVNQnFiL0FKZGR6NzEzbkNBTkNwQTNGVjhHUDFHNGxuVVRjS281Ky9TMEdUVHNYd3F0R1Rjc0ZzMzNySStKM2dOMEg0dVQ0UEhabzJMeXJOOE9ubGZuY3VJRWpJYmJPQ0xOeDNydVRRcEpzNmhyODZxWkdXNFRVU0lWdjlxdHgwa292MmtQK1Z1L0k1ZjRRK0J2U1hoVW1PbXlTVEc0L01NYkY1VW1ZWmdROGl4OWtRQUFLUHRXenlEcFdEcExwK1RMNHBmT2dNenpScVJiUnFOeVA1M3JSckdrYTZWUUtQZ1ZHeElEdFk4V3FiSmoycW1SeHl5YjQ2S2pLY0JveEJhMnhQRmFCZ0NvK0tidytIVkZ1T2FjN1ZMaHhiWU5rV1dXK1JUWTdBdE5NK2tYTGRxNTM0c2RUNW4wWGdzTmdzbXdVZVA2Z3pFbE1IaGpjb0NPWGUzQ2k5ZGNRZXNHbzJPeTdEWXdpU2JDSk5LRjBocmIyKzlWWmFaeTVMR0xPb3VtZlB2OFR2U09kZEwvQVBDMFBWblcrTnhYVWZVQWxubnhLdTBlQnl1RkNvMHBHdDczTDduL0FBMWgrbnNQaHMwOFRPbjhvNks4Uk0wdzJHS1E0YU9mRVN5U3hTNDltSzJDa0N5RnQ3SHRYdUR4eDhDTWw4Yk1GbDBPWVk3RjVIbWVXYS95bU93cUIvVElBSFIxUEs3RGFzYjRVL2cxeXZ3NTZzd3VmWS9xTTU4Y3UvaVlIQ3g0Uk1PZ203U056cXQyRzFRZW5zbHlUT1RselptUEQ3OFRPZGRHOVJZL28veENWY0gxTmw4djVmeVZRK1hqQWJBUEUzWmpjSFNkclh0WG91TFBvYyt5NVpJaUFIRjFBNUZjdzhYZkFMQitLK05FbVk0Tm81MmNTRE1jSTFwMGNiTHVlMXVhMlBoVDRXNGpvYkl4Z3NaanBNYVkxSVJtTzFyN2MxVG51Y3VFV3RtTlF2NU1GK0lEcGViTnVrcEVqSTh5TWF4YmcvZXZKUGlWZzQ4bmZLOHlqSWpHWVFLam91d0RLYkc5ZlFqci9LRnhHVmFDdjFJVklBdmV2QmZqUmhoTDBzdUZlNlM0YkV6UnFRdTlqeC9XMU1TdWRFdTVTeGNHVnpMTENjaDF4emxzS1cwenhoYk5DemJnbjNCM3JIOUM1SC9hdWFZeXcvTjRUSzRKTVhNa2o2SlBLQnNTbzdsZWRQeFdvNmQ2eWp4ZVc0YkdRd1J5WXJDeExEajhIT0x4ekphMTNYblQ3RWNHdW4vaDE2TzZheFhVODJZU3Fvd1dNYVZNVzg4bzh2RFFzdGxqRC8zbUpPNTdDcmVPTGIyc3o1dW90bGRrL1IrVDlQNHZCL21jMlpvNTFqZVRGNFk2RWVKcmVWaTQyN2dYS092WWpldlFYVG1SWWpJK3FJV09NajlHR1F5UndScWtXWUsvMFRrRGh3dm9KSE9tc0Q0dStBaitIM1RrbjVEVml1aVEwa3FUc2ZObnlTZHR4SkVFSHFoWWZXbSt4dnRWUDREZGE0eURNc3J5VHF3SEw0K2hZY1MrT3pEemZPR1BqbjllSGlqQXZjaFdXdzNzQWIxYlRXTGlSVlVKWitJSzJlaU9wZWdQK0lNbXc0THllWGhRc25reG9CcjdHdzdjMXlYcStUTGNpeGpZZkRxallxSTJHSHcxaUZIRjVHR3dQMnF4Njk4Y2M3NnZqZkM0S0k5TTVBTEtHUTN4ZUlYMkxENlYvd0FJRmN5eG1jWVRBWVo4TEFCSit1UWo5WDcxVHorUXIyNGpyZkdmcHZkV1hVOGZ3UExCRGxFc21KMFJlWTcrYTZMeVNSeWZlcVRNczRhVVBwSytzL1NEdUtxY3l6WnNmQ1dVa0FqYlR5TjZad0dIYVJvZ3h2Y1dKZmdHc0hKS1UzdWtkN2hVTlBIMDhVZUNWaHNPY2JONmhhSTdOYzdWY3ZEL0FHWkFGZHRETnNyTHdCOTZrNE9DVERRcXZsMlpqWWcyc1I3MG5IbzA2dUNOVFJuMHFCdFVWbWdvWEd6TTV2aW8waktsTmFIWm12dTMvczFpTXZ5NyswK3VCR2pNcTRYRHZQaUx0NlNvNEZibk5zSzZGcGo2U285dHFyT2c4cy8rblp6bVV5aG14a3Y1WkpPNVh1QjdWY3hUVUkyem45YmhlZktzZDhHR3l2cEhGNFhBUlkrZFdueXpFdHFEc3R6aHpmaC9qNXJ1ZmdmbjJiZUgyTVhwbk4zTTNUT09memNEamRSMVlPVTdoTnYwTWJmWW1uTWd5dUxETFBoRmlhWERNTEZKdm9ZY1dJcHpCUkprY2JZQ1lzMlVTUHB3ODBsbS9MSCs0ZjhBRGZnOXFsaHJIR1NaUnorQnhaY1RpK0dkNGtNOG9lTEZCWjJINkpsRHI5L1ZXTTZqOEhPaitwVEpMaXNqaXdHTEpKL041V2ZJbDM3bTJ4cWQ0ZGRUTm1NVFpIbUxXekdGZitYa2YveDRoeHYzWVZzR3dwMjFEZzcycnA0ZW5uaXBJOHQxT0hOb2N6eFNkTkhJb3ZDRE9PbDBadWxlc3NTd0F1TUhteTZ2MlYxdGE5V0dFNnQ4UWVuWXhIbTJTak1NTWcxREU0Q1VQOTdqbjNyb2s4QlZkbEJKTlJaRmVKYmk1UHRUSHBvdDhBdGZOY1BreVdEL0FCSTVYK1lURDR2RDR2THBiN0NXRmwvcmFxN3FIOFZXUTRWaEZoNHBzYTJvb3dTTjdmdVFLM0R2SkpIcFpGYmUrcDFCUDlhUkUwbUdheXdRQXZ5VmhXNXFKNkp2dGtrZklWKzA0M2kveEQ1ZithWkpNSmowdzVJSWJ5SEsvd0NWYnpJT3BNajYzZ0UwV0ppbGpLLzlGdnIreEhOYXRoT1Fva0dwRHlDb3Y4RDJ0VkJtblErVzQyZHNjSUk4cXpmVFpNZmhRRVpUOHJ3UjczcXRMUXRKdE95eGk4bXQxTlVQUDRUOU40MjArSXdLU1NQeEdEcFczdWEwdlJzdVA2RnpWWWpKSytYQUFCWFBwUmZZVm1Pa3VxcHNGbWJaQm4wa0NZMWZWQmk0MjlPSVFmcVhmWThYRmRlR1JRZFM1RUdSdlVvc0FPKzFabnBOUzU0TlAxdDY3dEhRY2t6cUhNSUVramE4YkM2MWJubTljbThQc1Jpc3F4NzVaaXdWQStrbnRYVm9tSlVBNy9OYjJqeXQrMW1ObnhxRDlvNFBtc3QxOTB5dWU1WEhpNGNPczJhWmRlWERNVlhYWThxcDdYclUwTGJpNHEva2k1eG9xd2RNOCtTNS9tc3F5dDVjT0F2WlY4eGpLMm9teEI3Q3JxSEY0dkN4aU5YbGEzSkJzQ2ZpbnZFN0tUMHJuSXpYRTVsaHNKMDdqcEZaNHNTVlFZZVJSY2tFa0VodHVPOWM4ZngvOE8xbW1pazZuZ0R4T1VPbUoyQnQzQkEzckFjSndrN05hNDdVZk0rK2pYY2s3L3BOcUlzTGtYM29LdnBTdzFEMm9oZXhCVWh2WWUxV0NtRWRodmU5S0c2NmpkVjkvYWdOeHpheHR2U3hadHZxQjIrS0FERGE3QUc3ZjNxOUMvaEkvRFUvakoxSkhuMmZZYVNMb3pLM3UzdGpwaC80U24rN3Z1ZmkxYzg4RFBCbk12Ry9ybkQ1RGdROE9YUmxaY3l4MXY4QW93MzNBUDhBZVBBcjZ3ZEZkR1piMFgwMWwrUTVSaGx3V1ZZQ01SUlFvTEE5eXgrU1NTZjNwamZ3U1JYeXk4eTNMNDhMRkRGQ2lRd3hvRWpqUlFGUkJzRkE3QVZZQmVOcUNJRVFEOXFjVVdGWGNPUDdLODVYd0FMcEZIUUcxQ3J5WHdWMkM5dWFZeEUzbG9UY1U2eEZWV2FZa3hxMmtnSDVxcHFNbTFVVDRvV3lsejdNL0toYTdBQlFkdTllTHZ4bStLejVQa1VQU2VYenZIbWVhL3hNVnBheFRENzNId1dOcTlNZGU5VjRUSU1wekRNTWRNRXdXRGlNMDBuSHBBdVFQdnNLK1lIWFBWV1orSkhWdWFkUzQ1WldmR1NreFJNRC9EaTRSUi81YXlZSnlkc3V5ZTFVakxsQUZJVzZxQnNMY1VadnFCdHRVeit4NXJxR0JGOWpxTkFaTTV1QVZWZTkycTNaWGZCRDJMRGI1cE4vVzVIQjcvRldjZVh4R011OHlxUnNMbmtVb1lYQ0lkM0NEMlBCSHRRaHZKV0ZBNDVHL0YrOUxNVWpBc1Y5STdXdFZwNW1YSWJ0L0VDOE1wc2Yyb2htdUFWa0tZWUVLU1NEYzMvZWdFaXNFVHNBTE0yKzNhM3pXdjZKNktqelIwekRNd1RnVTNpZ08zNWx2bi9EVDNTbVh5OVJGc1VjT1lNdWhiZDlBdkkzOXdmSHVhMzZ4b0dVUmtMRkdQUWdGbFVEc0twWjhtM2hIU2VNMFBxUGZrWENINXA3a0Fyc0xCVXZzZ3R3UGdWWTVKQUNaSnlxdUN1bmYvU3FjeXZpQUVKWFZjRSs5cTFHQ2pURCtYR3VvZ0M1SkhCOXhXVk44SGU0RmJTWFJJRVFaRVlXdURjZDdqdUtqenpsRHBSUnBYdjcwOGt2bEFsbTF0cUpEY0FIM3F1eHM0bG1CSktLdzJVYzZxckpXYWVUMm9pU1RpOWlDMjloVkgxbzVUSVpGVVdESDFqdmIycTZtY3JNb2JjbHIzSElGWnJydVVMZ2d5RzRackZibXJXSGlSaWFxVFdKbXQ4UHhwNk93Y2V3a3NUdDN2VjlJRmpRR1FNU3ZkTnlmdUtvK2pGVWRLNWRiVWJJYjZ0cXQzRHh0ZEh0Y1gxWHViZk5RemZ1WnE2VGpER3lCTWxvSEhxTnlXdWVSVm5rRGxJbFlnbHlEZFNlQmVxekhTcm9lVGNnM0I5eDgwLzA3SmRXWXNTQnNSM3QycHUxVllzWDd6UXV3WWtBZ3FOaGJtaEhGYzNaZVI5VitLQ0xzV2pJMzRCb0ZRVFp5VnQ3VkZScFJmQWgxWlVJSzZ3M0JJM3ZXYXozS2xkbVdRZ1gzTHF0NjFvS05HQ3BOaHRjOXFpWWlJVElVQytuM05PVTNIb3I1c1NuQnBuQ2Mxd0w0WEZ1NnVMazJGdHFjeXpNNWNOaU5TVE5FNEZpT2RWYTNxL0lSL0VraVFIYTUzNSsxYzhkeXJXSUMyTnJkLzUxdFkyc2thWjUzcXNjOUxsM1JPd2ROOVRTdEdJeXpPNjJZZ25aaDdYcTQ2djZJd1hXMlZlYkU2NGJNa3V5U3IvUU43aXVRNUpuUndtSUpVblNvNExjMTBqcG5xYjgyQ1Z1ako5Ukh0Vk54ZUdXNDZIVDVzZXN4ZWxsN09MNXJsZVk5TVlxVERZeUU0ZVhVZlNlR0h4OFZJeXJISExzNFRHNGJjU3dGVzJ1UUR6YXZRSFZQU1dWZUlHVG1MRWxreEd4aXhhRDF4Ti90OFZ3WHFMcGpHWkptRU9UNDNSRGlQWDVXS2E2d3V2WTM3RDNGYVdQTkhNcU9POGg0NmVqeTdvcmcrZy80Zk1VcmRLWlpHR0cwS0c1T3hQeFhvVEJEK0FQVnYzRmVSdncxOVFsK2pPblpIMGZ4TUtwREp1UGF2VmVSNHZ6b0wzdXg1TlRhUjdabVpxc2R4dEZ4UXZmYTFGZTlIYjMycmU3NVJoMXdFMXJiMVdtWVQ0clFwdUFkN1ZJek9WbzhNVlFFcy9wRnFyY2toOG5Fc3BKZHVTZmFzek5MM3FKZHhROW01bDJxNmZpZ3d2U2pZQWR4VGNqNmRyMWZtNmlWRTI1QnFMR2xqbW1sbEJPbSs5TzAzQzl5WTZTcGpiUXBJUFdnSkhlaUdGaTI5SS9sVHRDaDQ0dnRETjBsOGlDZ0JzQnQ5cVNWTnIvQUJ4VHRKa094STlxWktFVkhvZkZ1VXVTZzZsVHpNdWV4Tnd0eGMxODdmeER6RERkVVpqaGRlaU5sWjlJNEJKMnI2RDlTNDFjUGwwanMxZ0VQTmZPYjhRMkovTzlaWmlGQU9wRkNnODZpZHF3Vi8yRzNGU2ppT1E1YzhtRHdzbVo0ZGpESXJsSDlGMWZmZENQa1Y2cS9EeDRidG5uUTJJempCVHk5TnlUWTJkMXpWRUV1RGNJQUhneE1USFN5WE94NUc5cTg2OUJkSlpuMW5IUEJGL0J3a2VJUXlZdHgvQ3NCdVYvdk5Yb3pCU1Q1ZjBsaE9tSXN3bml5RENGNUZ3cXQ1YXp1eHU3eVcrcTV0U3ZVTEd6VTBuaWMydFhWSXNNNDZ5ejdONWhrMGk0YkJaUGhFOHVVWmRPMG1HeHcvdmhYM1FjalR1S3o2REtza3kveU1OaFlvSVlqcU1TQzI5eno3MFdNem1OQzdlWWxnb0RJaWFSY2UzeFdZeDJaQ1l5V3Zic1J6V1pQUGt5Tm5kYWJ4K20wTUZTNVJPemZxTXphUkZkVXRxdURleCsxWjZiTUpacEg5QUl0Y3VPMVJNWG1nYXlJUnEwMnNSYzFKeXJBVFlraVpwQ3NZSGZZTlViVzFXVFN6UE5La09aYmx4a1pHWkdaM3VTYjl2ZTFhN0w4dlh5MCtrQmVDVnVML2FqeW5Cd1FRYVZhTW52YjZqL0FPbFdLbnlXNEErUWRqVVVwRnpEaXBXd3BWRWVrTmU3RGNHbTVNR1V0NnZXZGdBZUI4MDRBb1VrT0RxUHFCNUZDN0dOaUxYOS93RFNvN0xyZEtpajZpUGs1Zk41Z0M2VUpCNXNiYlVqb3JMMWo2S3kyS1VseTBwZDB0emM4MVZkWVl5K1Y0dHlDeUgwNmRXNC93QnhXaDZLeGtXSzZTd01qRmRhcnBBWHRhcFhld3o0N2Y4QUlMdEpUTmlKQllsUHBYU2JCUDhBZWpsRVRySkhKR0pZblhTeU1McVJ3UWFid2FueWdwRGF6dVRVcFlna1R5U1A1S3J5NU5nQjk2aTZWR2k2SWVHanhXR1JjTkhpcGxXRncyRWtqUDhBRnd4SFlOM1d1dDlKK0plQ3puQ0poTTJtdytGeldKaEhJNnlnUjRoaHdWSFpqM1gzNHJsZUd3a21ZcUpZV2JCWUkzVjhRUmFTWWV5RHNQbWw0WHBuSThERWZ5bVZZZU9hSWgxZVM4ajZ3YmhybnZmdlY3UzZxV0dTK2psL0srSngrUWoxN2w4bmFzWm5FTVlKV0Z0U214VnUxVk9NNms4cEdXUENhdEp1TCs5Vm1RNTkvYkVFY09JY0RIZ1hMSGlUL3dCYW1UUUtsMlZkd2JzcEhCOXE2M0hsV1ZYRThhMVdrbnBNcnh6Vk1wTXo2eHpBb3hpaGhqYlZZWFc5Vk9MNnF6bHlxcGlGamIrOHExZDR2QStjMTQ0WHVmWmFycGNoeEV1bGx3MHAyMkpGaWFsNUtUaVZXSXpiTk1hb2pmR1NGaDlXZzZTYWg0bVBFenNqU3l6TzlyV01tdys5YUhEOUtadTdueXNFeTZ0OWNoRlBub0RNcGdOVHhSdDNaaVFhVGtFbGZKenpHNWNzeU5yY0ppSTdtS1VzYnhuc3dQMzdWMlB3TDhSc1hOR01CbWtpR2RUb1lsckZ2bTN6V2FIaGppV0FFK1lJdS9aYmtDb1hVSFFXSjZhdzR6ektjWkxqY2RoQnFsd3VuU1o0KzlpTjlRSEZVTlJoYjl5TmZTNTBuc2ZSNlh4VWF6WXFQRUphM3VLMjJWemZtTUVyWDJBNXJqSGhiMXRCMWZrY0U4TEZ3VkdrSGMzNElQelNQRmo4VC9TbmdkaEd3TW1ycUxxaVZiUlpMZ1hHcGZtVnYvREg5YXJhZVRoTzJXczBiWEIyek1NMHdXUzVkTmo4eXhVT0F3TUkxU1lpZHdpSVBrbXZLWGpOK1BMTDhyV2ZLdkRyQng1M2l6L0RmUE1XTkdHaVAvOEFqUzE1Q0xYdnhYbGZ4VzhidXMvR25IL251bzgzSXl4Q0REaytDWXg0T0pTT3cyMU1QZGhWZjRmK0huVVhpbm5NR1Y5SzVYK2FtRFdlV3hYRFFxUnUwalcySTdBYzFveXpXNmlVNHhFOVQ5YjlSZGM1clBtSFZHZjRuT2NTU0h2Tk1mTGp2L2RqSHBBK2JWU3QxamhjQ3hpWEhRb3ZJRi8vQUVyM1Q0Vy9nTjZaNmNYQ1kzclBHdDFQbUNDLzVORTh2QlJIdlpiM2Y5K0xWMS9OUHc5K0cyYnpSeTRyb3JKWlhqaldKVCtVVVdVY0RhMU5XT1UrUlcxSHMrTlpYU200SnZ5QlJHeldzTi9hbEFsMXU1RE1kdHRxQ2tONlFQVU5xcjBMWXVHRnBaQkdpRWFoenpXbTZkNkZ6YnFiTk11eXZMTUZKaU1mbU1naWdVRFVuTml6VzRVY2sxSzZENlhrNml4WXdlSHc1eFU4dTBRVTZUcTlnUG12b0IrRno4UDMvd0FzOHFPYjV3SThUMVBqa0ROYjZjSEYrbUpSd0c5elVVNWJlRVNSWFBKdS9BUHdYeTd3VjZId21SWU5FbHhyL3dBYkg0M1Rac1JNZWYySEFGZGNndzNscnRha1lYRHFzYWtDMXUxU2wyTlM0WU44c1NjNjRRb0M5THBJTnFQVjhWcFE0NEtvZEpaaHhTV2NYK2FSTTRWZm1tVHlLS0ZqRnNheE00aUh6YXNsbjJQc3JiODlxdDh6eFZnM3F0WVZ6dnJIUGNQbEdWWmxtT01jeFlMQlFQaVpwUDhBQXFrbTM4cXhjczNPUmZ4eFVVZVZmeHVlS0p3ZVg1ZjBmZ3BmK1l4bHNYalZVL1RFdjBxZnVkNjhsLzJtN3ZZU2s3WDM0SHhXaThXdXJKdXVldmNkMURJaENZK0dPU05UeXFBQUQvN1ZrNU1NeXpCTlFMRVhlM3ZWaUtxSkhKMnhZeDdPdHl6dC93Qng3MDM1OGhHN1h0eDhVa3NGdWV3M3RTb29XY3U0UWtBMnQ4MHBIUTAyN0gxZmNHalUrWkdRUWI5cjBaaWFQdDZPOXQ3R2p2dWRqNmVhVlczU0ZWSzdFTkZaQWJFL0hhcjdvL3BDWHEzTkhnWnZ5K0F3NjY4VmliZlNQN2kvNGplcW5ENFdYTVo0Y05oa2FURXp1RWlqSDZpYTdSbG1WcDAxazJGeXVJcnFBOHpFT3U1bGtQdjl1UDJxdG55S1BScytQMGIxTDNTNlJLYnk0VWdodzBma1lTTlJISEVwM1czdjgrOUg1Z0NCeUJlMjQ3R21KMU1NU08yOXJFRmYwMDlGRXprcXdCalZMMlVYSk4rMVprNU52azdiSEhhMUdKT3kzQWxIV1EzMU1MNmwzMDFvVnVJd1F4bFFEdUxNZm1vZUNReCtXU0ZDalkyUElxYklwZXdGeUFiYVQySDNxcE4yNk4zRERZckkySmxzcHNCNVpGeURWWExNdm1LV092YTYzNEZTY2JpRmlacmowcmZTT2QvbXExNWcxZ1BXZWIzMnBZeEdaTW53UFJhbTlRQUo1TGUxWlRyMDNpaVRXRDVqWEJ0LzczclhSdDVXcFNOVjl5T3dOWTdxNHBQbW1EZ0RuUnJYVU50bUpxZkYrUms2eDFCSTZEa2taR1VZZUpnb2FPRlBVTmdUM3FZNmI3N0tGc2Zta1laN1F4bzQ5TGU0dHNLZU4wWXFUNlNOalZlVk9SdVlWV05GZG1TczJIVmRtQlczcDdHbGRNT3E0MlJOZnFZQTM3dGJ0U2N3QWlqaUxBb0NiZ2p2VUhwNlVER3NTUXlsamJzVjNwNlh0Sys3YmxTTjdHYm9BYmk3Ylg3VUhES1cyNC9yU1l5ZEdrRzV2dXZ4VG1pMm0xMko3SHRWYzFvdmdTVDZpeFBHeHZTU21reUVHeHR3YWNLaGZVYk1yY2k5OTZiZUIyQkRFbjNJcG90bFhtV1hwaVlWamJVZ2E1Sit3NEZjbjZ2eVU0WmppSWtNYUVXWlNPRFhhL1JOWldJTmhZN1ZsT3FNblhGcTdLclJYSGNiTWF1WWNteG1INUhUTE5DMHVUaW9zakt4aUE3Ym5tdERrMmFEQ09vWFVKQWZTUng5alZWbW1GT0VuYUpyT3ludGVtSVhJZEYxTXR0K2EySmJaeE9FVXBhZklkaTZiNmtsamNQTElTaDc4RDdXclY1dGxtVTljWkpKZ014UU5FNElSdjFST2VHWDVyaVdWNDVsS3A1NU52MHNlRGV0emtYVXMrRVJWZFZleHNTcDN0L2VGWjBvYkhjVHJkUHFvYW5GNmViazZsNExSVGRJNFRLc2dteFNZakVZRldqaWxBc0pFSkpBdDcxNnQ2YnpWMVNNdVdBdDlxOGU1Um1DWnBFazBUQ0hGeDI4dVRWdXJEL2V2UlBoRDFsaE9yb2Y3T2tsOG5POE90NWNLNHQ1d0cydEQzK1JUOE9XM3lZbmtmR3lndCtMbUozTEE0MVprSGZhcGQ5UkFBM3FreTAvbG9nR0YySFB4VmhCaWhLekVpeWc4MXY0czFjTm5EWmNiVFpSZGNkWFlUcE9IRHo0MlZZWWJrc3pmSFlmTmMzNmY4Y2VuODM2cE9CeS9HVHg0cWE3aURHWVo0UXdIOTBuWTEwanJEcHFQcVNBSk5ESGlJVkc2dUFiZk5ZU2JvWlhDd0hUR0VOMWswRFVsdUxHMTZ6YzZuNm01UGcxY0hwZW1rK3pvYTlXd2FGMXI4SFFMNzFLeXZPWXM2bGJ5aW9DYkZRUVQvSVZ5ZjhBNFF6Zk5Ia3l6RTQwZmwzM2ViRDNXUmgvcFZFZnc0NVRsV0tiRjlQRE44bXpJbS81cVBIeUhVMSs0SklQOHFYMXNzbWhQUXc5WFRQUWs2bFpvenR1MWo4L2FwQTRyT2RFNVBtMlY1WUJuV0xYRjR3MkYwRmhZZHo4MW8rSzJkUGUzZDltUm5pb1NjVTdvRkNpSnR6U2RWMjlxbnRmSldwdDhDNzJxUE95eEkrbzJzTG1sVFloWXhjM052YXVlK0l2aVBsWFNFSy9ucG1iRXZ2RmhJVHFsa1AyN0Q1TlorcHpLS3BNME5McHN1YWUyRVNqOFdPbzF5M0twbERqVnB1RTd0OFY1RGJ3OVRxWFBaczR6L1U0TS9teFlJTnNSYll2WFMrcWVyTWIxWmpHbXpJaUREWFBsNFJPSS9ndDNOWlBINXdZWTVieXBwQzI5TzVCN2IxemJ6Tnk5cDZib3ZEeHg0N3pka3lZd1pVcXh4aUhEd1JyZUtDRmRLa2UxcW9Nd3p2eVdkZ3NZYis3ZTVBOXFvY3c2ZzFnQXQ2ckhkbXVheldkWitjUGhXZHBORjdFTmE3VkhHRG03WnJTMVdQVHgyeDZMUE1PcFd1UXF4TlkzWmhzQjhYck9Zck1aNTVUWUdTNTNJT3dxbmx4TW1aVElVa0Q0YjlRZmsvTnU5YVhJY25ZbFFXRE1RV3ZidDJzTzFUN0ZqVE1kNTU2cVZSSkdTWlEySmVXU2FMVENEWVgyc2Z2ODF0Y0JoSEFYekVUU09WVFlnVTFnOEJFaWF0Zm1rSDFJQllWZENDTkpkMllKYmR2YjRxck9WbTlwc0hweFZpekhFRlZWaVZBZm5lL3pTb2wwRUVqUzM2Zlkwa01xTUNpR1FEM3B6Q09UaUxzTlFZVzM0V29PelMrQllVN05jZ2c4Z2MwM2paeEZCSndTb3NCMnY4QU5TSkFOQkY3M093SnNUVlJtckJZbEIzZG1zdHVCU1VOZkpnZXU4UUk4bkNnSFdXOVJBNysxU3VpOGVrT0NUQ09vaUpTNnNEYXhxRjE2b1BrWWN5WHUrcHhlMTdlMVYrRHhrVVdKV3lTRnl2cEhzYXZxS2VNNXZKbjJhcHRuWmNEaVlKSXpMNTZSeHFnSlpqOU5TY0kwbWFoTVJpSXJRTHRoOEtCdjh1MzM5cTVsMGwxQ01majhObDB3OHpDb0dkdFBEZTNxNzExREF5YWxaMWRpdHRSTi8ycW5LTmNNM01HV09XTnhMQnBUS2hSN2hWRmxIR21tZ3E2bEpQclVhYmp1S0tNbVZTeFZoY2VrSFltbHBkbEpzb2I2YnRzTDBpWEJiNjZGeldrVldqZnlKa09xTmw1VmgzRmRQNkM2eXcvVXVEYkFZeUNPTE9vRkRXQTlPSlMzMUw4amE5Y21tWXhzTlc3SU50SjJwbU9lZURFUVk3Q3p5WWZFeGtzcnFlL3Q5cXZhYlVQQk5YMGM1NWp4V1BYNFpVdmNqdnJ1a1ZpRkZyM3VCdFVRenRLUlpBTnR3YXdUZUkrTXhtRWltRUtOTTRzMXJCYmptcXVYclRNSjVDdm1nQTg2QmNyWGFZNHFjVktKNGJxRkxUWlhpbXVVZElPSmN0ZXdBVThFODFGeE9QQmtONUVWUnV3WThWekJzN3pDZWQ3NHVUMUN3MnRiN1V4SmljWStLVXRLM2xzQ3BKUGY1RlAyRlo1RXpvK0l6TkZrS2VlTEtDU1F3NHFzYnFQREpJc241aUZJZFZqTkxJRUhIRnlmMi9lc1FtRHh1THhnMHJKS0dCTnRnRkh5ZXdyTFpyNFFONDdkYWRQNExDNXBFblQrVHN3em5IWWVRbFVCWUh5b3p3MGhGeHRlM2VvOHJqQ0JKZ2pQSk1xZkZIeHNmd256WE9PbnVoc3p3OGttWUlKWnNYaFhFb3k3WHU4YVd1QzVKSkhzRGF2UFg5b1JRdk5pNTUzTXJ0cmtsa1lzMHIzMmE1M3VhaytKUFJjM2huMS93QlI5T3p4dkdjRmlXV0l5RytxRTdvNFBjRmJFbjNydC80VWZCUEsrcWMxZzZoNmdnR05hK3ZBNENUL0FLUVVIL3F1Ty93S3lIdGlieVVwTXRQdzlmaEl6dnhma3crZGRWd3paSDB6SU5mNUVLVXhHTEh1UnNVU3ZvUjBiMFRrblFPUzRmS3NpeTZITHNIQXVsVWlXeE8xcms4ay9lcGVTWVdITDhFa1VXOWxzemUvL3BWaFYzQmpUVnNyNVo4MGdhaWVhRkNoVnhPdWlzblI4S2JzYk1TQ09SdGFseHByUUVzcURjMytCM293cExYVVhZN20xZGovQUF6ZUFlTDhhK3IwZkZ4UEQwcGxzZ2JNTVNSWXpOeUlRZTVKdGYyRlpFblViTDhZN2p1bjRJL0JMR3pRZjhlWnZENU9CY0ZjcWdjZXFYczByRDJ2eFh1REtzQ0ZqSFlIMWNjZTlWMlJaVkRsK0R3MkZ3c0tZYkN3UXJERkFpMlZFVVdBQTdDMWFMRERRZzJ0dGFvSVIzU3RqcE91QjBMb1MxR3ZOSHlLQkhGYTJPS2lreW5JRkpNbHRoU2liVWptaWM2VmdsYUFiTFVIRnpYQnFSUEpiYlliWHZWSmpzd3ZjRFlEdWU5WldYSlpiaEVyODFtMWhoWTdDMTY4aS9qZDhSV3dYU01YU0dYekZNVm1qWHhHbmJUQ3ZOL3VmOHE5TTlTWnltWDRXV1dVZ0tvTE14NFFBWEpOZk52eEc2NC80LzZ3em5PSlpYa2hsbE1XR0Y3Z1Jyc0NQdnorOVY0ZTUyV0pyYXFLcnhHNk14WFNuVVVXQ3hBWEVsc0JoY1JIK1dPb2FIalVnQTl5TDdpczdtZVNUWVdIRE5ERUpOY2VsbURDNUo3TjlxMGJadmo4VUVsYVVzWW90T3FUMWFVR3dBcC9DWmcwZUVVTkhETENEYzZrRzdINTcxY2I0b3JHTndIVGVMeEdQZ3c3UldKTm1KUEE5NnU1dWtwNFVsaWVJU09XMHJPbDlKdHovU3RIaHNXazJ0NDQ3RUN3SStvL0Jxd2o4OXNLRlp2S1hjZ01QaWtzYi9aeS9NY0g1RWl4YVdEaGIyQzdYKy9lb3NlV3VWQyt0cEwyMHFON25nQ3QvaThzZFpFYzNrakpIUGI5cXNjdHdma2dBK1MwclhjZW14QXBrc216a3Q2YkE5Uk9sMEgwUjBsRDB3N1k3Rk8wK1p1Z0VZUEVBUFAvQUpxdWNUaFpHQk1ZdTY3M0o1Rk5OaW04dTBhZ2tDN1dGcmZha25GTVUwdVRwL3VqdldWTnluSzJkOWdoRERpV09Lb2NBK3BXWWxpdW9BOEdySEo4Tkl5UnVRckJSdWdPNStLaFlkRDV0bUlleDRJK2xxMGVCd2ZsTkhkd3N3MzA5dCs0cUdib3ZhYkh2bHlUTU9kS2FYUW5WdUxpMXFUalozU0V0d2hCUHA1L2xUa2t4TVZncFk4RUUydDgxVFpwTWdqMWE3T1AxS042cnhXNW12a3FFYmJLN0hZdTVRcjZUWTMvQUhvWUZGa25kV0lBQXNvN2NWQVpoalp4RGJScDlSdnd3cTJ3OElpSVVNUVQ3Y1ZQSmJWd1pjRzhrN0pKalBrT3dGN2JYdldLekNMOHoxWmdvQW9qT29BWC9VUjNyYlNxTG5VZ3QyTGIyL2FzVGx4R0s2NlFnRUNObVlrRGtEdUtsd3Jsc3E2MzNPTWY1T213RmlmV3pURTNzUnpTaWpNbHd1Ky9KcE4zamxVb1JZaTZnOGlsb0dleTN2dmV3M3FnKzdPaFhHTkVISHVmeTBlK3BFYjc3MVRaRlBiT2NTeFpkT29ncWY2VmQ0NCtZV0MzVWtjV3NMMW1NcWNSOVN1aEFkbkEyOXQ5elZ1Q3VMTTNOS3MwV2pxS0pJcnJJclhrMGk2MjJ0MnFWNnRSWmdGN2cvdFVlQm44dERhNmhlM2NWSWhRUHFCdm9ZV3NmNTNxb3pjaXhsVnVMM0YvWTk2TjlDeGdoOXozRlBHTlpBbDNBUEZxS1VJVlpiV05yWHR6U0Qzd1JoWjFzNm4zREtMVWlmQ21XSXViTkhiY0hlMU95M3NBYkViQTJGRWdHcTFnb0E3Y1dvR3F1bWN6Nnh5TVNmOEFNS2lqUmNla1cvblhPWjhOSkZxT3dOKzNhdS81dmdWbWlaQW10WkFkVFcvOTcxeVRQc3AvSzR2RVFsQ3FnNnR4MnR6V3JneWUxSm5GZVYwV3lmcVJSUllQRmFYVUErcmE1STNGYUhEWWdNZFVlcEc3T09iMWxURThVcDB1QVJ1YjFiNERGck5HRktzcmcrbmUxV3BwUG94TVUzRjhtMHdXZlRZYWNTcEo2d0xhUU5yOXIxMExwN3FkTVRMaDVCaW53bU9oSU1XSWpObWpiM0I5ai9sWElvcE5VUHJaUmRiYVY3MUx3Mkxtd3p4K1UrNldPeDNGVXA0dWJqMmRGZzFpUzI1T1V6M040ZGVNSnpoSXNvenVjUTUzcElobUEweDRtdzkremY1MWwrdC94TTQvdzM2aE9DelRJY1Zoc05JYnhZdVVXaWxIY1hyejVrUFc4YzhTNGZITWRBTjFaVHVoSERBKzRydS9UZmlKay9WMlJwa0hYc2NPWTRLd1RDNXNVdUxuaFpCdlp1UFZ4UXB5NmJJTW5qOEt5ZXFsYVpjWlgrTlhJTVRKNU9LZ0NTZHZMT29FZmV0ZGtINGp1a004eGF3NHlMRVlBUHhLNktZLzVnM3QrMVpMTXZCMU11d2JOMDFrK1Y1amhHVVNDRHlsMWtEMmJ2ZXFQRTRQcG9ZQ2FEUCtqM3l6RUlBRE5oMTBzbjdqaXFqejU4YytYYU5mSDRqeHVweDNEdjhBdms5RllYcXpwTlpJM2h6bkErYTRCSDhTMXgvS3RGaGNkaE1lL3dEeTJJaW43MlJnYThtRHBud3R4V0dHdk1NMnk2Wmg2WlhuMUJmbTF0cXJmK0dzdHcyTWhUcGp4SXhjR0xiWkJQRTVIeHgycTlIeVRpK2taT1g5TTRacDdadE5mYVBabzdnbitkRnJBMnZ6ODE1UXdPZS9pQ3l6RUpoTUpsT0g2cXdxbmJFcXdqdXYzSnJ1M1ErSTZ2eG1BdzQ2bXl4Y0JqSEYvTGljUHBQdGNWcjQ5ZXNuVWFSeE9yOFc5TTJ0NmtiaG0xR3dHL3pVUEZ1eUl6WEtvb0paanNGQTVKTlpUcmJ4WTZmNkRRNGZHNHY4NW1wLzZlWFlUMXlrL1BaZjNyenA0ZytNMmI5Y2VaRGpwM3l2S2hlMlc0WmpkLzhBOG93K29mRk56YXlLWEhaWjhkNGZOcUpLVTFVVG92WC9BSTZyRGlKc3U2Wlg4N2lVR2w4eFlmd1kvY0tMK28zcmh1WjVtWXNTK1B4MDB1SnhjdnFmRVNIVnY3QW5jZmFzam4zaUpoOHZpTWVFQUFVYVZWQllnZXdybm1ZZFk0akVUdHB4REVQOU9xL3ByRWx2enUyZDdpL3hmR3gyeFZzNkhtM1dzSUlReUU2MU96TGU1OXhXSHgvVjhyRSthOGFLTGtLbzU5cmlzck5qY1JLU1djNmlia3ExcmZiMnFGUFBwbEJadFI0K1JVMlBEdDVabmFqeWNwZmowV3VNNm5mWDVjWTRGd3lqazFVcTgrUGQvTUx1d05pQ2U1OXFaUUYyQUxPUWIyQXJaZE45T3k0bFZsMDJFWURYYllzYWttMWpSbTQvVjFjcUM2ZDZkTEdKbTErWXA3alpSMkJyZlpkZ1B5dWc2aUNUY3NSdjl2dFNNQmdvWVZqOHlKMFZUZlYzSis5WGFKNWtLUTZic045WHdhelo1TngyT2wwcXd4UXRZQ2luVVYyWUVmTkxMcVcwS1dhVy9jYldwY2FxMGhEY2poZTVGRkpkZG1ZM080VURkYWdiTmRKQkVoT3pXNzBjR3FGZ3lyckRiOC9UOTZFWUxHekZsUGMycFVQcWNYdUJmaFJzM3dhUkRud09Nbm1TSFhzQnVDS3FjNllNY1BBYm94ZlVkUjNBcTFlN1RXVlFSM0Z1S3E4ZkZxelNHTm1PaFJxSnYycHlHVDRNQjF5UStkWWVCR0NLV0Z5NHV3dU8zdlZQalVPRHhodUdrVnU0NXExNm5sYUxxckRrbG5NY2dZTVJ3dHVhUHFHQlRqamlvajU4TDJMUzN0cFAyclFpMHFzNURVUmM1eWFJSFRVZ2k2Z09nblFzbWxFT3pYRzl2YXV6NVV6WWlCWDlJWWl6cWV4cmdjODgyQnhXRFlEU1N3TCt4dWVCODEyN0k4VUpjT0hqa0xzVnVWdllyL3ZVR29UdTBhZmlzaTVnelI0VjVXUmxMZzNHeDdMYWdzNnFTci94QVRiY2JmdFRjVElGRnVXK29tbjFUVXJmeEFRRHNyYjFYT2dJK0l0R3BYeXpwQnNENzFIbURSS1NONzhDK3dxYktDcTJRQzVPL3dBVkdLTXJGK3crb0xTWFlEL1R1Tmd3Mk1pdytMY0pnNVRwTmg5QlBlOWJJOU00YUtZTDVURnJiRURtdWR5aTYrWDVUTUhQcHZ4WGFQRHZQSStvdW5RY1FFT095OXZ5ODF4Y2xiZWx2dHpYVCtMMVQyK2xKLzBlVmZxdnhlMlMxZU5kOW1jWHBwRm1RSmhuWFVPRHVha1lmcGliRXk2WThNQWtYOFIza0lWVVVjdXpIWUtPNXJhWmhpY0prMlVZM05NeXhrR1c1UGdvOWVLeHVJYTBhS08zdVNlQW8zdWE4VGVPMzRtTXg4UzB4UFQrUXBQbEhSK3Nod0dJbnpFZGpMN0x0Y0wvQURyWm5sVU96ejNIZ2VSbG40NmVPR1hacjFIZyttdW44ZExpZWo4SGlFR2Q0dkJMcE9QR3NlWXNiR3hLS3R3T0xtdlgzUVdNNld6bm8zTDhSMEdzYWRKeWxrd2VpSXhOc2JIV0RmMUE4N212bUN4TjdBS3kvU0ZQQUZlZ1B3dGVQYy9odGd1bytuc2RGaXN3eTJXQnNiZzQ4TVFXd2pxRDVqTHFQRnR5UGlzM0plUjJiR09zUjNmOFEyVWRDNTNIRmhlbzhvdzJaNS9ERnFiR0Z5Z3dNQUgxU3VDTCt3WGMxZy93ejljNVBpc3ptL3NtTjRNQmhwL3lzYVRIMWhCdWpmWWk5Y0U4WFBGSEwrdkhqaHlERFpuaGN0a2tNK01selBFK1pOanByN0UyRmdvOXFydkI3cXc5TGRkNFl1UXVEeHRvcE5iV1ZYdjZXKy9hcXVTRXRwWnd5VHljOUgxMzZkekZjVGg0emZtcnNHNHZYSlBESHFoTWRsbUhaMzlaSUJCN2ZGZFppY1N4cVFlMTZ1YVNlNVVRYW5IdGRvWFFvVUswalBQaWIwRDBObWZpTjFobDNUV1RJV3grT2ZScUkyalFidElmWUFYTmZVL3dsOE5jcjhNK2tjdTZmeWtIOHZnMTlVNTJPSWxOdFVqZTVPLzlLNUQrRXp3RFBoVDBvMmM1emgxSFZ1Ykl2bWdnRTRPRHRHRDduazE2WHl2RGhMMkZ2OWE1K1U5N3BHdEJiVVhHRGhYWmpzYW1XMnBuRHJaUWFmcTloanhaVXlTc1VLSnozb2lhVEl3QStLc3ZJbEdpTGEyQXRZL0ZOU1NXdmFreVNhajlxcjhWaVFMK3ZSWVZuWk1wWmhpc0xINHNLcFcxejcxbmNkaWlpc1VVS2JFbGpVMmFZc0xrMW0rcGN3WEI0Vm5aaWR2K21PWFBzS290Mlg4Y1V1enoxK0tycXpFWmYwa21VUlkxNHNYbkVoaUFpTnY0UXRydWUyeEFyeVVjdHd1SERKR1F2a2tyWTdLb0hCM3JySGpIbVdJOFIvRkxPY05sazBjMDJUWVl4SmhtYXh1TjN0ODN0WE5Yd3lRWUtKSnZUUHVERTRzOTdjRUhtcHNiVVZRek5qeVAzVndWeE1rY0dNaldJZ0FLWkhWZVUrUGk5Sk9ITXNjWkJLckZzcEh0VTdDcXB3ODZzR2N5RWEyWGF3SGI3VXZETHFMa2dDd09oVzJEVk0vc3FVeGVEaktDWlN1bFpVMWdxT0Q3MWM0SEdQaGZ5NXhTaVVrVzByeUIyUDhBNlZVNFlMaGNiRXJ1RVF1QVJmY0QycWRtc2VHeTdNakJoNVBNaUoxcmI5SjdnMGpkTGttaGljMm9vbDRuR0NmRytjeUtpeDNBSUd4UGFrWWJEQkdtblZDL21td0YrTCszc0tqeGF0T21Oall0cUlJdmVucFc4cEhGbkQ2dU9MVlFuTGN6cjlMZ2hnaXVCMlZJNDJOcEdEdDZiTnVQNTBxT0ZuQ2oxS0FlUXUxRStKa2t3aVFyRXFnNzN0dmVuOFBFV1VLV05sdGZlbzMwYVA1U0orQ3crcHdDeE9yMWZCKzlhQ0tGWWxkV0paRHNHdnVLcjhxd2dqWFhabTFYQUI5dmNWSnhlS2p3eU84ajZZd3AxZTF2OXFwelRsS2pidzFoaTVzWXpuT2NObENHVEg0bFFsanNmcUE3ZmU5WVdQcTJiT1FYaVRSRGM2ZFd4dDcxUTUzbWJkYTlSZWQ1Uk1FZjhOSXdldzRKTldPQXdoeEdNVER4cVI2clBvM0IrNXE5REZHRWVUbnN1dXlhakxzeDlHaXllQXRIcTFGWFA2aWIzcStpVTJVc3V5Y2tiZ1UzaDhPdUdWWTR3b1Rna1ZJalJRVklJTnZTUnZzYXA1SmZCdFljYmlyR2NWS0Zpa2REWXFBV05xeW5TeUxpT3FzZE9XdThjWTBMeHRmYzFvODR4TDRiRFlqY3FTdjBydnErOVozb0dNNG5NTXdsMzFFQWIvM2I4WHF4alRVTnhVeis3TkdKME5HUjB1d0duZ2dIZWpWNHd4ZEZZMk52dFNGZlVxaFpBQ1BVQmJmOTZXVlk3bFNCOVYxNFAzcWlic2VWVEVZd0dSVnRxTDk3N0NzVGczV0RxNUZzUTJxOTEzREQyTmJUTUc4eEdLS1FwRzR2M3JCUGZDZFdZZm1MVTl5ZmI3VmF4OU15ZFk5czRQOEFrN0pnNU5VSzJqTEo3YzZhazZveHFkMktyeGV4c1AycXZ5dVFOaDFFWkIxN20reHJTOU1adEgwNzFGa3VlU3dpV1BCNGxaSERDNjZlR3VEenNUVU1ZYjUwYThzemhoM3hWMFY2YVpJMWFKbGxWdjd0dHFCUUE2aGN4azdONzE2cDYyL0QxMHIxY1RtT1V4LzhQWmpOYVZjVGhGdkU5OTd0SHdlZWE0aDFuNE85VzlGUmw1OENjM3l5SmZWanNDQ3h0N3RIeVB2Vm5Mb3N1UG40TS9TK2EwdXBiamRQK1RBT3BmVUVzTlcrOU5HSSthcWJFaFNBQ2FtSXNPSVV2REtzaUE2U0JzYiszeFRjOExBc3ora2djV0JJcWswck5uZkZvaHZENWtTb2ZTcW5kUWI3KzlZL3F2SnpQQkxQRUN4VFlsaGE5YlZWWFNiWHQ3MnNhWXhXSFNhNmhRYmcvWDJwOFpiWFpYMUdKWkkwemdPWjRZckt6RDFYTnlOTnQ2aW96Uk1RRHBJTjdkeFc0Nm55SnNGakpOUzNpa096ait0WkRFNEV4WW9pMnUyK3F0ZUVsSldlZTZyQkxEa1phWmRpRm5LS0dzUXUyb1dxZklqQzdiWDJzQU42emVEbmFNb2RaYjFCYm4zclZZUjRaVktzeE1pRHNQZW15VmNrMkdha3RvbUNSVVlLNVBISUc0clE1Rm5tS3lzRjQzODFSdG9mZFNQWTFSZmxtakZtdUJ6Y2l4Tkxoa0NNRnVCZHVBZjg2cnlWbW5pazhUTy9lR2ZqTmpjbkNZWEM0aFhSZnF3T0lZMkYvd0M2M2F1cFlieFF4V2N1Wlk4SGhaSlJzMkdjWFkvdWVhOGY2NEN3TW9NWnZZT2h0ZjhBbFYzaE9wczN3T0hqWEM1aVZDbTBiU2Jzb3ZVZFNYSHdUempqbnpCN1gvQjY5eVRxTElNY1QvYXZUNnd6L1V5eVJYVy84cTIrQXpQcG5DdytaaDhIZ01GQ3Q3eVNxa2R2M1BGZUtKdkUzTjUxMDRwNU1Xd0FVU0NZci9sVUhIOWI0akZLZitWVm03bVp5MS81MCtNbEg5cEJrMG1US3FsbWRmMmUxYzU4ZU9qZW15MkZ3dU4vdGZHaFF3d21YUmx3eDl0ZHRJL2V1TmVJUDRoODl6dU9lQk1URDB4bGhGbWp3N0Y4UTQ5aS9iOWhYbjNGZFdabkpFb1Y0NG8rUFNMV0ZVV094MTNacEpQTkxFZW5zZm1wWG1uazRYQTNCcE5McFh2ZnVsL0p1TVoxN2c4S3AvSlFOSk13TEhFVFhMTjhrbXNKblhVK0t4OGpzMHhqaDVLZzhWV3o0NHJxV01hZ2R0SU93cUFzTHl1ckJsSVc1UHhVY01hVHRrbWZXdWEyUVZJTEZZbDVsMUU2aXJjOXJWSGVKWXlKSEpLc0treWFNTmg1TlY3TVJZZ1h2KzFRWjVmeklDeFhPbjZpMjF2dFZpS01tVk4yMk5TenFicW9CRnJCZTk2YXcrRk03M1NNdTk3R3ArQnloOFFDMmczWlFDdzVGYkhJc2lUME9xSXlFYnMyMXZtaWVSUkhZZExrMUhCWGRNOU1vMDlwdFY5T3I2ZUszMlc1ZWtFV21QMWxTRDZqYWw0REJSd1JDSUlOUElZaXpHckpJRlZMcUFwSXNiMWx6eWIzUjJPbDBVZE5HdmtUQ3BKYlZZMjNNUjRwNUdCUzFocU5ocDQvclM3S2JnOGtBS1FPS0xTcEEwV05qWmdmODZnTk5JZmhXTkdObnVBZHdkN2Z2U0dheGI5Uys2SGMwQWdRTXVzQUQySE5LVnlBU3JhUllkdHIwMnlkZERTcVNybFFWUWpnYm05T2lGbkNzUnBJM3ZmL0FFbzdPc2RtOVVsdnNPYUNSNlpleEhJN1VxR1NkaGxqZG1RM0hKSjJCcWlkekptTXE2Tnlvc2I3QUdyaFZhTFd3WUZRU3gxRGUzc0JWTEdqUG1Nc3BXemJYSzhNUGFub2piYjRPZWRWWXEvVmVXeUZTVldXMjNjamIrVmFuTnNIUElMaEZzeERCUWxqKzU3Q3N0MUtveFhXV0hUUUl4YzJYVnNnL3dEV3RwazYvbW9QVVhWWWJBS3h2cU42dDVIVVV6Q3c0L1VuT0xPZVo4cXBpSW4xSjVhRFNTcDMyK0s2UDBkaVYvTFErWUF0MU5wT2RYdHZXSDZ3eTlFa0NSeDNKWW55K05QdmIzRmFIdyt4elBsMGtkbFlSRWFVSHFDajJOTGtWNDdJZEt2UjFMaWRLZ2NZaUN6Q3pPYjJxWkdpWDB1YmxSWVdxcncwaGtUekF3alVFV1VIZXJPQWFaRlpqNmovQUpWUytFZFFuWWMwYk5HOS9ZQzQ3MHpIT1l5Mms2OXJFRWJVKzVMdXpLU0dQY2NXcUt6Q3hHb0tTZHg3MGdvM0tna1ZsVXM0djI3VllkRFp6UDB2MWRoTVpKSEpKaFNyUjRtR0hjNGlPeDlQdHF2YXhxQzhqUmFnTFdLM0NweWFqeXBKRVk1Vmswb0JxYmY2VDJ1S2t4NUhpbXBKbExWNmFPcXd5eHlPQStPZmpWbjNpOTFKaVA3U1ZzdXluQVN0RGhNbFJpRWhBWWpWSVAxUDdrL3RYTjNMYXpmK2RkUy9FRjB1dUF6M0RkUTRPTFJnczBYeXNRRkZndUlYa24vdUZ2NjF5d0FqbGR1VDhWMU9QSjZxdG5pdXAwMHRMbGxqYTZZQ3dQcEtyemVwT1g1cEprT1pZYk1jTllUNFZyNlNMckl2NmtJN2dna0g3MUgwMk9vaTU3Q2llMXlMYzk2VmxRbTlSNWRCbDJhNmNISVpNdHhFYTRuQ3NHdlpHM0svZFRkZjJxdWtENlJhNlNBaDF1ZHdRYmplcnZLOE8yZVpmTmxpa0RHWVJXeFdCRGJCaHpKRmY1M1lmWTFScklyQU1UcVRtaDhxaDFuMEQvRFIxMy94QjA5Z2NXSldrT0lqMVNCclhTUUN6My9ldlYrUjR4WjRGM3VRQUsrWkg0VCtyMnliUE14eWQzVVJrakc0ZFNlRDlMcXY5RFgwVzZJelZjWGhZM0IySUgrVlZNVW5qeVVYY3E5VEZadUtGSmpiV3Q2VnRYUXc1Vm1NMDBZWERRQUcya0EzTlgrQmdzTG1xckNXODAzNStLdjhLaDBDdWV4eE5iSXlWR0FFMm95YkM5R1BwRkV3dUt2ZExncDhYeU5zNXQ3R20yWm11RHhUdW1pS0FiOTZobHVIWEVpU2cyMk5WMkppRG16M1BlcmwwQUhGUVpvanF2d2ZpcUUwN0xlTnI0S1RFb3puMHFRQnoyRllUeEd6akJkRjlNNXIxSGo1QkpIbDJHZWNMcUFDa0RhMStTVGF1a1lyTFhsMlZ5RjVMbmNDc1YxZjRROU45Y1lLWEM5VDROODd3WXU0aWxka1Zma0JTTC92N1UyTGZ5aTFXNVZIcytlUGdvWnNZL1ZmVmVKREdiRnpGVmNrM1V1eFpyZjByVDVyRmc4NWlDWXVGSjVsdUV4Q2kwaSs1dlU3R1pEQjBNTXg2YjZmUjVzSW1ObENUTU5pbW83RTk3RGE5TUREaUVBeUlRNEZyamo3MVN5Wkh2dUozK2wwY1phYU1Nc2JNbmorbHA4RXJUWU9ZejRNYWZXVFp4Ym00N2ltdnlTdm1VNlJSc1FTUEwyMk4rNDk5L2F0TEtRdUlqaEdxd0JMMjRiNzFwTW82OE9UNERHeHhaTGhNeXphT0wvNlpMSVFxUlA4anVSMkZXc2VvdmlSem11OFJLRDNZZWptV1pKaGNvaGpXUWxzM0xYTU1nK21Qc1Q4MW5wc1NzN3V4Wmk5cnR2dVdKOTZoWXpNc3h4R2E0bHN5YVZzeWVReTRnVEpwWUgvQUVGdmFsMnN0eUNOWTJQeFZ0cE5Xakx4eGNPSzVMN0k1V2JEU1Nrc0FDUW9adHdCVmt4OCtJa2FpeE45WU5NNFBDU1pkZ2sxUTZJaUJwa0l2cUI1cVhEREdBMWdUSGU0SU5VWnZrNlRGR1d4Q29SWmZWc1U1QkJ1YXRjSGhWbWtBS2hTZDkrUHRVYUNFa2wzSWtUYlN5dHVmaXIzQncrVEJLQ2JQY01GQjVGcWhrNlJwNGNXNTIxd1Nva2VHSXhEME55QjJQOEF0WE0rdStvSHpIR2YyVEJJeVJSbTgwa1RmVi9nKzFhUHIzcTFzbXdTNGZEMk9MeENhUUFlQWVUV002VzZlYWFZVFNFeUZiT3orNUhGU1lvYlBkSXFhM1V2SlA4QXg4UmZaUmswR0R3cTJndTdnS1dDMnRWL2djdWd3cXFZbzlCYmtXK3I3MHBieUlvRnpmY2o1cVVpaEg1T28ySlVtb3A1TnpaY3dhZU1Fa2tQUklJMkZsQzZmY1VuelFydVBVWEp1b1cxdnVhY3Y2OVJ2NVpGajcwVVNNc3B1M0Eyc09CVUJwOWNGUDFQaVd3K1d6bFY5WUZsSlBZOTZnK0hjTVl5NmFRczMvTVNrQS9hbStzSmxYTDVoSTNxMWdEYnRiaXJQb21BeDVEaG95V1NSZzBoWFR4YzdBSDdWZFQvQU5Sang5MnNOUGNOT2RNTEdOUlpoZXdKcHdIeTRoWmJCaWJyN0Ntb1ZYU0Z1YkhuVnpUN3Mra3NBbGxHd1Uxbm05Qk1pNGtKNWI2VmM3WHVlSzU1bWswcTlVWWFTK2tJdzBvKzVJcm8yTVpvWXRKNGIvV3VhZFRXaHp5T1FhajZnUFQzc2VLdVlPVXpGOGc2MnM3RmxrNWJDUmxVR3RnQ2Q5MSs5YUtPTVR3R0tXMW1GaXZhMVpqcHRyNVpFR2p1eEFJSlBxSTlqV253b09zYnFCYXgrMVFQOHVEYXhwVHhKZmFQWS9oQjFHM1ZQaDdsR0prUDhhTmZ5emkxeUNucEIvY0NwR0k4U3NseXZxekVkUDVqUEpsZU5qVldqbHhBMHdTcXcyMHR4eUNMR3VVL2hpNmhKeHViNUV6V3crZ1ltRzUzQjRhclB4L3lBTm5lUTV2SkVyNFdaVGdNUkVkd1JmVWh0OEcvODY3WFI3ZFJqNVBGL01RbG90UTBqVGRlZUFuVFBXY2ttTnc4SXlITlpiTitkd0M2US95eUQwdDk2NFAxbjRNOVY5RXRQTTJEVE84cFRjWXZBZzZ3UDhVZHJqOXEwWFRPZDlaOURaSGc4eXlpUEZZenAyWXV5TEloeFVhZ01RUWYxSngycnBIU2Y0aWNpemt3cm1QL0FOSW1iWTRoWlBNdzRiNWY5UDJQRlI1L0c0OG5LN0xPZy9VdWJUdFJsSnVQMC84QStubFNQVE9aR2lrUmRHenh1Yk12K3QvZzBCcTh0aFlOZnVSWHNIcS93ZzZROFNJaG1INWVLSEd5S2ZMemJMWEFZays5dG4vZXVHZFllQUhVL1MwVFQ0RkY2aXdjWkpENFpTSndQbE8vN1Z6dWJRNU1YS1Zub1drODdnMWRLVHBuRWMreWhzeHcwa2VnRTIxS1FkeDcxelRINWVZVElqODhXN211MXZHSjV3anMwV0pRa1BES3VpUlBncWQ2eC9WblRmNWwvUGdXMGltK3cyTlZzYzNIaG90YTNCSFBIZGpPVFBDWWhZTFlmTzFqVXJCNGt4dUNYTzVHNE50cXM4YmdRVGRtSWJzdno3VlR6NGZ5emM2ZzQ0OWhWLzhBSkhKdU1zVHMyZUV4TWVLdzRWeUcvdW5tMVI1OEFVVzhhYXJtOXdPUjcxUjVSanRFeTZuRVRhZHlUL1N0bkF3a3daWkRkV0Z4WTMzcXRQaG12Z25IT3VTbktLL3FSam9BdXdZYmcvRkprbEtvcFc1c2JxYXVjUmw4Z1lPQ2hqRmlMOG5iaW9zOEVnQ2gwNUJQTkxHWEJJNE9McEVBWXRnckRXVkpPeTA1K1lsVmQySXVPNXBicWhqUUdFbCt4dlEvS3RpU0VDdHJBMzJzQlNOaldwa1NUR0ZWc2dMTU9BNTlOUVFzdUpjNm5KQi9TcHNBUGlyV0hMR1lOcllBRHRibWhMQW1IZmNnT3ZBdHdLVlNvamVPVDVaVy9seEdialUzemV3Rk16enh3SVJxS3ZLTGJVN2pNVXBCQzdwZnNMVlh5d3ZKRXpNZlNUWUtkNzFMRjJWSnRSL0VpL3hKM0lYYlVkaTIxV0dDeXR6TURvdnFJM1p0aWZhcEdXNEQ4eTVrWkN4QXRidldyeXZKV1lLQkhkZ0xCZjhBTTBrcDdTVFQ2WjVwV3lQa21BU052b0trRzFqM0ZhL0NRZVRCWlZESU4zRnVhWGdjQ01Pc1pFU2hBTGJqZXA4RWVqU2RsSXZ6N2ZhczJjOXgxK2x3TEhFUjVaZU1NV3ZZV1l0L3BUaW9yeEh5NDdzRGJjOTZYR2dlTzhpT0YvdkViVW8yTnRLN0E3bnRVSmZFanpBMXJEUVFPOXQ2V29aMDFSaFFMRWJpaksrYkNXTDY3TjZkQXNLQ0JmUWZVRUlPM3ZTRHJGcEVZMTlYcTJBdU8xTklnRTRBMUUreDR0VGdVQkNkRE1TYmhWUEZDU1VJeEkxQitDd0hGQTBRUnFKYnRlMWllYVdxRVNpN0FycDQ1dFJyZFdJREJtVUE3anRTaUN6czhkcjIzN0NnbHBVR0VWZ1kwYjFXdUdPMi90ZXM1aG10TGlYSkllOXRtNzFlNGhrRU92U05nZlNwK09hcU1uZGx1RTB5a25kYmJXTkJESldjeTZyZDR1cklpaTZuRmlCZTdFLzdWdXVucDJHR2ViNndyZVd5OTFOYzk2dklIV1dHanNCcUl0YzJzZjhBM3RXMDZaeEg1bkNYWS94R2QxSVhlM3orOVhjMGFnbVlHbHlML0puQi9aVitJY1liQmlXMm5TMWxhOXo5dnRVVHc4eG41YWVlRVBiVnViYy9hcm5xZUZ4Z1pkb1ZLN0JuM3Q5cXl2UjhySm1yYWJzNlhVdUJTeGQ0cUlzeTlQVnBvN0JnSll0Rmc0ZGs1SkZXMEZtWU9wWmdmVHYyck81WmkzMElmTFFCbUFDanY4MW9ZbW1WbXZaRkc5VW1kUkhxeWN4TVNzR0lBSUEycVBpSTJaYkt1Z0tMRnp5YWRobExRdWhzOG8zdWQxdDIvZWhORzdJc2tyZW9EMjVwQnhBUnlZaHIxYVFTZFFHOU56YUZpSVUzVjdjOC92VW5FNkhqODNWb0gwa0R2VWR6L3dCTmdxdWV3SjRwckZTUlQ5UVpCZ2VzK25NeDZkeE1qbGNRbXVDUzMvU3hDN293L2NBSDRKcnllOE0yQ3hVMkh4U1BGaU1PNWlsamJzd05pUHRYcjNHUG9LTUFxdURjNzF4TDhRWFN3d21iWUxxbkRCUmg4eS9nNHhWNGluQUZpZjhBdUZiR2h6ZHhad1g2aTBGcGFpQnk2K2t0Y2MrMUFOd0R5VDNvNWY0Wi91bSs0RzlKc05RSU56MkY2MkR6cGk0WjVzTkxGTEE1U2FCdzZNZnBEWDIvMUg3MVA2andjSXhjT1o0TlJIbCtZZ3VpRTNNRW8vNmtaOXQ5eDhFVlhNZFhGV21Tenc0aE1SazJMZFlNTGpuRFJTdHhCaVJzcmsvM1NDUWFCbzk0Zlp3T25PdHNseDhoS3hyT0VrOVZocGIwMTlPZkNyUEd4ZVd3RzRMV3RzZHZpdmxSak1QaWNITGljTlBHMkh4c0VoU1NOeDZrY2Y4QXNmenI2Q2ZobDZ3Z3p6cFBLNUZheGtnWFV3TnhyQXN3UDhxcDUrR3BJMHNIdmc0SHJ6QnZxaEFKdTN4VWlxakk1eEpoMElOOXF1QUxqYXRmVHkzUW95Y3NmY1lyTFpoTEtDdnFYM0ZhakRIU2d2WEovREhxdVBQSU5Sa0FPeFEvcFpTSzZyaFhWb3VkNnljRXR4bzVvN1lrcWdPYWIxVXRHdVJWK0RUS05DeUwwaGxwZEdCYzFhVUkwUk1aWkxqM3Bob0JmNXFZeTBXaS9hOVFUMHlrclErTTY1SWhpTlZuVUNIRDVManBrVWEwaFlqNTJOWG1pcVhyQUZlbk13MG4xR0Z3UGc2VGFxT1RDNFJiWmUwMlRkbWl2NVBuNkNzczg3blVIYWVSaXZ6cU5MeE9FTXNEc3BGd0wyYW1zRUNZVm1mU0puTDNMRFk3bW5TWkpJR2FLTlNUdGNOL091YmZiUGJjZExIRy9vaURMb2hqcDBLRFhwREs2N2kxUTVjbGduTEV4R0dVZnVEVmk1czJGMUtZeTY3azhhUnhUaTNZeUZVSnV3dDhVMU5yb1Y0b1Q3TVoxUGsrSHhXRTgzTVk1Zk9oV3lZNkpRU0I3TU85WkROY0hnTXZ3dUVsVEVUU0xJM29sU01rR3hIcHRhdXhEUnFkQmRnUjZnVHRSUzRaUWdpaTBxcWJoZEkwZy9GVzQ2aHBVekp6ZU1oa2x1aVlIRnl5NDNDd3lzalJ4cllLcmplMzJwaUdGc1NUSEdBV1c1REU3RVhyVVo5aDlTRVNYMUJiWEk1cUJnOEZIREFJZ3daeFlzdzVBdlR0OXF5cExUdU1sRWs0YURRSXlCRzBFWXRwc2VlOUROczFoeVhMSkpwbVZZVkI4dGU1WS9OVEc4ckR4TUdZeHFCcU9vV0Z2bXVUZGFkU0hxVE5IV050T1h3ZWxWQTJZaWt4UTlTVnNOYm5Xa3g3WTlzaHh5NGpxclBQekV3SytjZE1jWS9TdGRMeXJLNDhyd1VjWVBxQXRxN1g5elZKMGhraXc0S0xFTVNwY1hXTWpnZTROYWVWekdRcmtDL3B0YSszYXBjK1JON0VWTkRwM0IrdGs3WUk0akNiaXcwaSs5UHVYTGV2bTIxcWJRamNuY2phNUZQaTVLTVR1RHlhcHRVYmNGU0NpYXcxUGZiYjdVeTVLQnloRm1ObUI3aW5RR2FWMVFqMUc1MUQvS21jUklOMmE0VWNlbitsQXI2TWgxNDRjUkJicVMxdFAyR3grOWFmSUJJdUdoU3loTEFNaHZ6YXNaMVZJSmNWQ2gvNnBrdVZQQ2l3dCs5Yi9LTkppVVhIQUFWMXR2Vm1mNG1ScC9kcVd5emlqWXFyV0YvY1U2eUI0QmNBa25rbi9TbXdoOHd1SERJRitnMDViNjdrQTI0QXFtZEpFWnhHb3dtL3EwRGptdVhkVnhhc3dLZ0Vra2trSFpkK1JYVXhNRlUvcFpyZ3RibjRybWZXVGY4QU5PNlIrWGNuMHIva2F1YVl3UEtjSkhUK2lNUjUyU3huekM3M3NXdHNGclhvQUkwWUVsdTRyRCtIY21uS0VkQUVqZFFBT1FmZXQxaHBMaXppdzdYRmpVRWw3MmJHa2Q0WXMxbmhybnNmVFhYZVNabk5LWW9WbEVVK2o5U050dlhxUHhTeUNYcVBvVE5NUEVwYkZ3cU1UQmJ1NkhVSzhiU1JuRVF2RUxJRzROZXovRFhxZGVyZWg4cXpKanFta2lFYzYvNDEyWWZ5cm92RlpLVzA4Ky9WT20zVmxYeVpId0d6aUwreDhYbHNUQUlqakZ3ZzcraDdhaGI3My9uVnIxbjRLZE1kWnlQaW13elpQbXBCdG1HV255M04vd0MrdTZ1UGdpc1AwNWhZL0QveFNPRkRsY09zN3dPcCtrd3kzYU1qNDFHMzdWM1ZodnZ2M3JvcE54OXkrVHoyQ2praFVsZEhtUE12RGp4SThITVIvYWZUT0xPWjRHUDFTcmd4cVNWUC93RExoMlAxZktXK0JXdzZLL0UvbDJaekxodW9zSEpsT0pYMFBQQ0M4WVBHNi9VbjczcnRxR3gyTnUvTlpEclh3cTZhNjlIbVpqbDRoeHdCQ1k3Q2Z3cDAvY2NqNE42SE9NMXlDeHp4TGRqWW5QT2h1amZGakxseG1Jd3VFekhXbjhQTWNHK2laTjlpR1gvSTF4VHEzOE1XZTVjN1M5T1krSE9jSnorV3g1Q1RqN01CcE5Uc2Q0STlaZUhHUGZNK2xNeU9ZUUE2aXNEQ0hGVytVUG9mNzdHcnJJL3hCWmpsa3k0UHFUTFRKT285ZWhQeStJWDd4dnMzN0dxZWJRWThpdEc1cFBPYW5TOFNmQjVLOFFlaThYa2VZT00weTdFWlJpUjZmK2FpS3h1ZmdqWS9jVnozRjRRcGRMcVFDRDZkNy9OZlVIQ2RVOUorSU9YbkN5UzRYR3dPUFZnOHdqR29mZFgvQU5LNUg0amZncjZSNnIvTVlycDNGNG5wWE01RjFMSEczbTRVdGY4QVZHZUJiKzZkcXlaYUdjSFVUYi81ZkRxT1pLbWVDc1ZCWml3SkRmSUZUOGp6MThMOWE2b2liRUU4ZmF1bjlmZmhhOFRlZzNiRVNaRkYxSmdWTmhpY2tjeUd4NFBsc0FlUGE5Y2Z4TVloeHI0WEVxK0F4aU1RMkd4S21OeHZ4WS82VkJMQzRyM0UyTFVwU3VIUjBmQllpREV4cjViSDFjSDJOU3BjTnJRZ3lxZmsydldEeXpNcGNzbThxUUZrTzZ0M1UxcUV4SlpWZVAydXplOVVKUWFaMHVMVXh5SzJXSnkyVkdCR2hrdHRlbzgyQmRiYXBORmh2WWMweWMxY0JRSkxoYkhVUnRVU2JQM0VVcWtnbGllS2J0WlpjNG9WaXJ4SnBBMUViMzFiR3FiRU0vcjFNcU5iZ205U1pNMlEyQlRWZjZSZnZWVmljWEppSlNpeEJtYTQwQmQycFlya3FaTXRxb2tXWnJzNEpGL2lwMlg1Wkppc1FpcXJKb0dyVUZ2YysxWEdRZEY0akdORytKUXJ5QkUyd1AzcmM1WGtFZUNBalFCU213djgrMU9jNjZEVDZSNVhjelA1UmtVcUF5U0ZqR1JySktnRmJHd3JUWVhCeHdONmhyWXJZTU5yZnRWbkZnbzQ3QStwdUh1T2FkOGhXUHBVQXFiaHZpcVU1N2pvOEdCUVZSSVN4b0FGTWJCdXdCNXBZWUlUNVNrdXV4SkcxU1dpWWVxeEkvdzk2RWFGWXdHN201QTVxSXVMZ1lCc2w5Skk3MEkxRWJLVmEwUkhEVXZTV1ZocUZqM1ArVkZJaEl1VGVOZXlEZWdlSkVhTklQTGNoZmM3ZjBvaXJPcWhUcDBHeFkvNlV1UUxLb2xBWkxpMXI3MFlmekFiL1N2SHZRSmFHd0JZN05MdnVUdGVoSUkzR3J5bVdNdDlLMDQ0RGtFdHBYdlNOWXNFMTZEZnR4VEIvd0FEc3FveEFXNDIySGY5NlJya2lhNjJRa2FUZWd5MmhGblZyN0JoelJxUFFRMW1BNUo1b0JFWEh1OG1GbGN2c2kyMk5WK1d1QkZmNlc3MjcxTnpNRDhuTHY4QXA5UDM3VkV3TVovSnBLZHBENlczNXBHNlExdW5aeW54TndKajZqaGQ3NmJjajNxKzhPOHdiRVlMUXJhSGpjaHRodjdiMFBGYkxuTU9EeGFJb2pqYlM0dnVRYXp2aHptVWVHekRNTUpJdmxRczQwdWQ5endLMGZ5dzJjbkplaHJ2N056bmtPdkN0RzZsR2M2ZkxCdllmZXNCbHpIQVp3Ymt4WEpEaGVSN1Ywak5CYUIyME03ajBnLzYxenJQbkdEelZKQ1FJbUFETmJrL05SWWVWUlk4aXFuR1owM3AyYzRpQ1BVdmtzb3VyRS9WV3d3N2doYm5hM3FEYjNybXZTK1BtbUtMTUJaZ0xLdjBxTzFkRHdES3NaVjd1cEd6V3NhcnpqdGRHOXBaYjRKbGhDMGFqeTFBSlBjZHFGa1J5cGtPL2M3NzBtTUJRQVJiN1ViSnFZbENHWUMrcGhzdE1MYTdJa21xTU1DQnVmV3cvd0JxanRZczNsRFNTTGEyNzFaU3hMSkFaQTE1TzlodWZ0VU40NDNZaTdLT0xrVTFqMlJubURiRlUxQWZVYXE4eXlYQjlVWlhqdW44d1h5Y1BtS2FWbFhtT1VmOU54N1dPMzJOVzNrcEd4VmZvQjNQdlVmR1lRUzJjT29hTTdoUlluLzJLZkNUaE5ORlhVNFk1c1VzY3ZrOG1acmxXT3lETXNYbGVQVHlzYmc1R2hsWGF4c2JYSDM1L2VveUhTL0ozOTY3ZDQzOUZybWVTUmRXNEtCaE5oUUlNelVEZG96OU1nSHV0clZ4Q1p1RHEyN2JWMU9MTDZrTFBGZFpwbnBjOHNiNkZnZXUzYis5MnBNaUxMcVNRNmxOaGNkdmFpVTZsMytydDgwcU1XSi9UOFZJWjNScHN4bGs2MXloODBZeC93REVPV1FySGpJMVd6WTdEcnNzL3dEM3J3M3VBRDcxMjc4SFhWTWVHd21LeWx5MnJEWW95Z0hkU2pnV0k5dDcxNXp5ck5jVGsrWjRiRzRWOU9MdzV1Z2tGMWNXc1ZZZXhGeFhZL0JsY0prM1hXRHpiSnBtVHAvUEkvSWVKajY4SGlVT294UDhjNlQzQkZSWm83b3N0NmFXeWFSOUtlbGNhc2tFUUFBQUhGYXdBa2JFZ1Z5L29YSExKaFl4cjMwajk2NlRGSVhqVTZ1MUpwOHUxRGRSajl4OHFQdysvaU14WGhqakljbnp0bnhQVDdtMGVJRnkrRCszdW4rVmUrdWpmRXFQcUhCeFluQVkyTEY0V1FCbG5pZlVwRnRxK1NpTU5URWVoaHVMKzN0VjkwbjExbi9RK09YRVpEbWsyQWNuVVlOUmFGL3V0Unp4ZnVpUHg1ZmJ0a2ZZckNaOFpWL2luMUVjRGo3MVpZWE1sWURWYjRyd0w0VGZpOHpYcUdiQzVYbVdYeXRtWkZrR0hCa0V0dWRJRzkvaXZRM1NYaS9nYzhWWklwd2VWY01iTXJBMktrZGlEVUNuT0g1RW5wd24rSjZFaW1XVVh1S2RERHNhNXpsbldjTThha1NEYy9wclQ0TFBvWFZTcmdnMW80dFR4eVZKNEs1Um9OVkFtOVE0c2ZGSmF6V05TVWtGN2hnd3E3SExGb3JlbTBMQUI3MVFkY3VFeUxGaTlqNUVodjhBK1ExZWszSWJzZHF5ZlhlS1U1ZGpvMjJDNGFVZ2ovc2FxK3FrbkIwV05KSC9BSFIvczhFWUFmOEFKSXpqMEhVYjM0dWFrNGR0WG1MNmhkU2RON2lvR0FHdks4S1NiUHAxTHZzZnZUa09KZUxWSVFIQlVnOXJHdVBsMnozR0w5a2Y2SmhqTDRhRU9ieEZnRGZZbmFrR05zUElSRzVpSDZZeHdCVGtib1ZnQlZBeE8xcm50NzBja1pCR3c0dGNnMHhsbVBSSHZNa2dSeEg2ZGd5R3hQM3BhU2xic3lpNDI5UTJwUTlWbWIwQzI0NXFKanB3RUlJdllhUUxjMGk3STV1a1Z1WllnenlTSzdySmJiMDhmYWl3MGFKR1F4QllDeEk3MzRGTllXSVN1KzU4dU0rc25zZjlhcCt2T3E0dW5jdWFPSkJMajhTTFIyYXdYL0ZhclNpNXRSK0RJejU0NmVMeVNLSHhGNnFZci9ZdURmOEFqdFlTdmY2UjdWVjlJOU9pV1pkV29Sci9BTlNRbjAzL0FONm9zanl5WE1jWXZtbG14VXh1ekhmOTY2amxPR2p3T0JTRy9HN0QzYXIrU3NNYVJ6V24zYXpPOG1Ub3NJaUFvMHhnSXE2YkRZbW1tV3hVblVUL0FJanZTM3VvdVhKVW45SkhOR0I1ckVzeEwzNHRzQldieStXZE5WcElkaUdwNzNHM1pqc2FkSWpLRmdkTzlyZXhvb3RBVmxQSnNWcFJkUnJWUmMvTkJOVmNDRVFveEliV1EzTk00NmZ6SFl2WW0xdEk0cVJMcFpGdDZUN2lxek5NUTJ6U0xZa0FEVHhiM3AwVmNxSWNzOW1Oc3gyUENZelBvMHRkU1FRRjl3SzZQbGNibkJMZGJhaHQvbFhPY3Y4QSthNm1ZMlZUR0xDdzcxMC9EUnRIR2lQcFNWVXV3VzVYOXFzWm5Tb3p2R3E4a3BEOGNhZ0RVTldoYkduR1pRQ1VSdHdPVFFqQ3RFcWxIVUtmVWU1b3BVQ2xaQUxBYldiYzFublE5a2ZFMldJc1BVekcxaWVEMjNybmZXR3VPZGdMYm5aanZ2M3JvV0kwQ0VGVk1qTUR6L3BXQjZ1VlpXbEFjNkFBMm0zQnEvcGpCOG92OVpydkMrY2pKNGwxNmxMbFRjZDY2VmhuaGVIUzZhU09SMkpyajNoaElwVklkSURYTnlwL3JYWFl3V2kvaCtramE3ZDZpeThUc3Y2Q1Y2ZUtSSXc2dXJCTEVobXNEeUFLOUMvaHF6OTU4Tm5HVFNHeXhNbUlnQkZ1UlpyZnlyemw1c21Ibjh5eE8ybmJnL3RYUS9DYnFNOU9kYzVUaXBYMHdTUCtYbUY3WERDdy9yYXJPanlQSGtSVDgxZzlmVFMvbzdQNHc1TS85b1pmbU1Xa2VhaHdzckVjT1BWR1QrKzFiam83T3Y4QWlUcGZMY3dmVUpuaUN6QnVWa1haNy91Q2YzcHZyM0pmN2E2VngrSGpUWGlJMUdJaXZ0NjBPci9UK3RaWHdkenI4ekhtR0NLNkVKWEZ4cmUvMWZXUDJOZHkvZkJNOFM1eDVuSDdPa2IzdDNvRWhWTEVnS09TZUJScUxhUjc3QS9GWkY1SnVyOC94R0ZMdkZsV0MrdEVKSG10OTZocWhOUnFJNEtTVnRtcGl4RVVqWGptVnY4QXRONmhaNzAxbFBWR0dFR2NaZGg4eGdHNEdJakRFZlk4ajlxbVFZT0RDQVJ4UktpS05nb29zVFArV3cwa3dSbktlclF2Skh0UmJYUk5GNzQrOWNuSnVwZncrWVNkWkRrR1p2aEFCcVRBNWdQT2l2N0xKOVNmZmVzbkxpdkVqd3RRU1NmbXBjQ3B0NWN2L080WCtZOWEvdnhYb2ZEVERFWWVPUUFxc2kzc2VSUzFiVUdIYmhsdHRVbnFYeEpXUXJDbnpCMGNUeVA4VCtHaGpJNmd5U1RBc2d2SmljdWY4eEg5OVAxRCtXMWFERVpsNFVlTzJFT0h6Qk1rNmdmWkJGalVWTVFnYmV3SnM2L3NhMVBVWGh6MHoxVXJmMmxrK0hhUWdqejRSNWNndjN1TzljYjYzL0NKaDgwVXpkUDUxb2xYL3B3NXZGNXRyY0FTb1ZhbGNNVTExUTlUelluM1pYZFcvZ0Q2T3pEejVlbk05emZwcG5Zc1laTk9Nd3lDMXJLcldJLy9BSWpYSzg3L0FBYStLM1QyRGpUS2Nia1hVa0tFcWdpWnNOTG83WExiWCtMbXRaRjBINDErR0RvMlZaaG00dzBYckVPR2xYTU1JUG55MjlRKzJxcmZLUHhFK0tlVGhZTTZ5UEpzMWNONnBab0o4RElSOEQ2UWFweTBjWkY3SDVQSmpkWFJ3ck92dzZlTE9Sd3h2ak9pOFJpVmZZL2tNUkhMYjdnR3FERWVGUFhjRTE4VDBQblVWemZTWUxnZnlOZTRzaC9FUWNjaUhIZEtZM0xsUE1tSHhrZUpVbnZZTFkvMXJSanhyNmNhNW1seCtIc0wvd0FiQ09QOTZnZWdpdWk5SHpVbjJ6NSs0THcyNmpNZ1dicDNNOEtiL3J3eldBclVaVDBGaThFb0s1WGpueEYrWk1LMWg5cTl6TDR1ZEpHSU8yY3hScmE5NUVjSDk5cWJQalAwVEViTjFCaGR0L3BiL2FxNzhjM3pacDRmTzQ4VmJvcG5rR0xwak1kZXM1VG1Hd3NkRURibXB6ZE41cEZNcFhJc2NTeWdCaGhqWHF1WHh2NkZnR3Qrb3NLRjRQcGJuLzhBaHFQSjQvZEF3L1YxSGh6ZjJSOXYvd0EybzM0cS9rdi9BUGxLWEVZcWp6SW5SK2Z5eWJkTjVpeDkxdzVBSXArUHc4NnFsbC9nOUxabXhQMGp5N2Y2MTZNZjhSblFLbGJaNlpPYkJjUEkxLzZVd2Z4SjlGc2RLWW5NSmJuWVI0R1Evd0JhZC93Nit4SCtxMzhSUndPUHd1NjBuRngweGpJLzArcGxGUHA0UmRjQlBUMDNpTC8zaktuKzlkN0hqOTB4cExpUE0yUUM1MFlGL3dEZW40L0hEcDE0VEo1T2FJdHZxYkF2VHY4QWlJL1pBLzFYUDlxUFBROElldFNiL3dEQzJJSkg2Zk5TMS9mbWlIaEIxeXlsaDAxTnFPeEJsUUQvQURyMFNQRzNwelVSYk1kaGMzd2pqYW84dmo3MHJHTld2SGhTZEkvNU42ZC94TVBzVC95dkovQjUvd0QvQUpMZUlFeERSOU50R2RnUzJJai9BTjZkWHdONjlDTC9BUHE4bm1FRVhPTGpyME4wZDR6WkIxejFMTGt1VlI1azJMaGg4NlNTWEJNa0tMZXd1L0FKOXEwUFdIVkdCNkw2ZnhXYlppMm1DRVdWYjJhUno5S0Q3MURQeDJLRVhKbGpCK29kVnFKZW5qaW16eHAxWDBmbmZRK0x3ZUZ6ekJyZ3NSaUVNa2NjY3l5WFVHeEp0eFZNRzh3a3ZBcWc3Z0QycTA2aHp2SDlWWi9qYzh6TmkyUHhUMzh2VmNScCttTUR0YXFwaVJwSkdtVHVSN2UxY3prVVZKcVBSNlRwbk9XRlN5OWlDUTYzQ2dhVHNMZDZjMWVnRXJadUNEU1dCODFiSFFyYjNOS2VNWEwyYm5zMVFsa3JNNUtyQjVaTGFuWTdpaERGNVVBakxLRHBCTmh6VGVmU3E0amRrZU04YVdhKzE2ZUs2WXd6Z00rZ0FCT1B1YUFLVHF2REhGNVBLc3FCa0xmU1c0c05xNDlsTS84QVpuVWhqYjBsd3A1c2grOWR0eDBabnc1dUVBc1d1UmZmaXVKZFg0RVpmbngwWEtraTVIQitLMGNEdGJUbWZMdzJ5amxSMXVWaG1HQ2lhQmhFMXIyTGVxc04xTmhIQkprQkF1Q05YSnRWemtlYXBqY3VnRE1tdVBZbzJ4SnFEbitIWXdtNTF1NDJ2K25mZ1UySzI1S0c1NXh5NFZJazlLNDB5RmRVd014dGUvMC9BQTk2NmJnSm1FS25YenNVYlkxeGJMNVdqVlpGREFOeVJzUWZldXA5Tlk2UEdKR0dsRE9paTdMdUNmazFGblZNditOemNiV2JDQmhLZ1ZiRUFiTGZuNzA0SkhWQWhJS1dzYmQvdlVhRnlZMWJSemM3YmFqVDVSNWlwMERVZjBqZ1ZWTjRWWnZMOHdLQ1RzQ0tabncxNzJKUzI0UHpTMGV3ZEN1cGw1S0FnQ25aUDRrTnRTdGJzZTFBRmJKRWRneWxtNTU1cGJRZ0VGa0hscXZiZGlmaXBHaG5JR29MYmU0L3lwSlM2azc3THdLQUtjRlErSncyTFh6OEZpa01Fc1Voc0hSaFlnL2F2TUhXdlJrM1FYVStMeU9jbkVDSzAyR21YaVdKdDFQN2NWNnR4c0xZbU9kTklHdE45VmM5OFplbEg2czZMVE1NSXBiTk1tQmtPa2VxU0czcVcveHphdEhSNTlrdHJPUS9VR2dXYkg2ME8wZWRVYlM5dUxiVThwQjU0L3ZVMUdRNmExQjBrWHVTQ2Yzb0l3REVXMjk2M1R5MlYyT3lJenFOQUFhK3hISXE3NkE2cW02UzZvd21JVUxOaHA1VWd4V0ZrM1J3VHM5djd5bmNIdGFxTlZVTnNBZTloVGVKZ0xRK1pIdTZIVmYydDIrOVJ2bEQ0UzVSOVJ2RERNTk9EaHN4YzZRTG4ydGNWMnZBWXUrRlEzcnluK0hicWIrMmVrOHF4QzNXT2JEeHRjdGM2cldOL3dCNjlLNEhHRDhzbTdEN2tWUmhLdmFhV29qZFNQaW1kd2VWSEJCNXRRQjFMY0Urbit0SkJ1ZC9UZmVndXlzS3ZHWXV6c0g0VkFQL0FKN2RHQlgweWZud1FPUUJhaDE5NGg1MzBONHhkWHZsR00wWWYrMjhYNW1Ga0Y0M0htZjBQelIvaE1RTitJSG93azN0akIvL0FLbXNwNHZndDRuOVlPVy9pTm5HS3Y3ZjlRMU8xRjQrUnNaU2pOMGVpZkRMOFRHVjU0ME9HeHIvQU5sWTgyWHlNUTNva04vMHZYb1hKK3ZJMlJmNG1nT0I5VzUvKzFmTHZad0ZZWElQMC82MzdWdCtqL0Y3cWZvZ0pGaDhZMllZSlR2aE1XeE5sOWxiY2lxTXNYMFhJNS9zK291VTlaUnpSZythcEkyTmFYQmRVUnpyNldGL2l2RS9odjhBaVN5VHFOb3NQSmlEbDJPSnNjTGl5TEUvNFg0TmR6eW5xb1ltTUZKcnQzdWROcWpWeDdKa296Vm5mRnpsVmpONU5nTGk5WTNxbk0xeEdFeHhmMUJzTE1Oai9nTloyTHFmWEdJOWRuQXZxMVhGUk1iamppY0hpMEQ2aTBFcTg5eWhwMDU3bzBMaGdvNUkvd0JuazNBcm95bURUY2ovQUJkcU9PVUl4L2hteEg3Vkh5L0VKUGhNTkM3YVNMMlBZV05PS1dhY3Fzb0Z3ZVJ0V0RLN1BXVkpMSEZFN0JNWHdrTWphZEN5a0hTZHg5NnNGWU9BcEoxOTdIYTFVR0ZtMFFTaHBkUHFHeWluWU1kNUxsV2J6VkIrcS8wMHhvdFFtbEhsbHVZd0lXMWVsdmMrMVUrYnVaWTFRRzBqa0RuZ1g1cVltZDRlZFFYNEhPL2FzcDFOMS9rK1RtU1pKUHpzNFUrVkhIYmI3MCtPT1V1aXZxTlRpeHh1YkpYVk9lNFBvN0xYbGtuVnBtRm80d04vM3JpYllqRTU5bWNtTnhNbXB5MWdqYmFSZnRTTTV6YkY5VDVuSmpNWTVuTEc0VTdCUjdBVmRaRmt2bnllV1FHM0RzMTl0TmJNTVhwUjVQUHRWcXNua011eVA0bzAzU0dYR0tKc1Urem9OS0RUdldna1lLaWtLQ3ZKWGczcVBobGpUWlBTTFd2cTRBcGZuK2RaVkRPd1lDOXRxcVRiY3JaME9uZ3NVVkJDbGQ1NGdDcEMzdVFEMnEwR0tqTmxBc3R1TzlSb29HamRMa0lHTnlML0FOS2VFWUVnRGdGeWZTeThWREpyNE5DRnhYSThGS3grbEFTZUxOeFFzUllmV2JiM05FMjVBQXRxN21qMElnUHE5ZkJBNzFHeXpYQXJaV0d2VXdHNFgzcWl6cVVMSHFDYWQ5UkRIZ0NyeVdVakNrRnlwQjIwZ0grZFpicXlmeVlkVEtQVXZwS01kejgxTGhYdktXc2UzRVFlaklQek9heVloUlllYUFvYjZiV3ViMTB5Tmd0Mkl1cmphM2FzUDBGaFFtWExPd0llUm1ZS2VPYkMxYnFJR0lsU0FWSjU3aWpQSjdoZkd3ckhZL0VER0dVTnJ0dmVrTUdaWkJxc0wzc2U5SEV3OGtJcTI4dy9VRFM1SXkwaW5Vb0FGZ0RWUTI0a0hHTUdnMFIzVmkzSTdWaGVzQTJweFppeFd4c0xBaXQzaUdZcUNBb1lnZ250V0c2cjBuV2haN3VDR0IySHhiOTZ2YWJ1akE4bXZZeHZ3MnhZZ3pPWFVQUUYyQjk3MTNERHpFd3h2SURwWWVuVnZhdlAzUk02eFpxMFpzak5wYlZ2Y0FIdFhmTU1STkRISWQvTTNERGo5NlRPdVIvaDVic1czNkhNUkU1a1Vod1Z2ZXcycVhsK0kxRXY2dlN3WVdPOXh1TGZ1S2g0dFJIaHovRUtxUDBuM29zSkswYkI3RFFSNmlEY2Z0VmVEcVNac1pvYjRPTCtUM0wwVm4wZlZIU2VVNW9uR0lnVm5CNTFENmgvTzljbXlCMjZPOFY1Y0F5ZVZoaGpKTU9yc2ZxaGw5YUUvdVNLcy93MjU2K1A2ZXgrVnViakNUQjRnT2REQyszeGVtUEd6QVBnTSt5L05JbEN0aUl4NnllWGk5UzMvYXUrMGVUMU1WSGcvbGNMMCtvbC9ET3puOVJYWndEc2Z0V1o2QWdLWURIU3R0SStLY20vc08xWGVUNDVjMnlqQTQ2TWgweEVLU0JoemNqZW9lWDRVNVBtV0xpdVd3MkliemtZOEt4NUZTVlhCa1pNZDVvWkdXNTJvQ3lnRFllNDl4UU52ajl0Nm84Nlk0bk9jcnd5eXNndTBzbWc3NlFOcWJWbHJObVdLS1pkaFZHeWl5RGkzYXFYTEVhYnFYTXA5YmVYSFpGWFZzVGJmYXJsbUFqTERzQ2FxK21rMVlKOFFmcm5rWnlmamdVOUtpdmt0NXNhaVd4K09iMDFOaUk4T3ErWTJpN1dVMnZjMDRSY1VUSUpCWmxCM3VMOWpVYjdMOGx3S3VRdnRiZlliMGpGWVdIR3hoTVZCSGlWUEN6S0dIOWFMRU9ZOFBLN2syVlNkcWdkUHZMTmw0bmxsYVZtSjAzN0xTcE5LeUNXU08vWTFaQXpEdzk2Y3pkbC9OWlJoWFplR1JTaCsyMVZrbmhCMDdwWllWeGVHMTlvOFMxaCt4cmFFa2k0QTNwRVRNMGVwMTBOOEc5UFdTU0hQRmpiL0U1MW1IZ2ZsK05WMFhPOHd3Nk50WlZSN2Z6cWx4SDRhOEpNUXc2dXpSZFA5M0RRM3RYWDJuQVl4ajFNT2JVemlzeGh3S0NURW55a3ZiVWU5SHFTUkZMRGhYYU9OWW44TFdCeE1NTVQ5WjU0STQzTG5UaDRRVzM0Tkt3LzRVY2pBWlorcGM3eFNGdFdsdkxXNDl0aFhiUVE0QkJ1cDNGUmZ6WG51VXc2K1pwTmliMkgybzlXWTVZY1QrRGsrRy9DMTBsQUFEajg0a0FON2ZtdFArVlQ0ZnczZEh4TmZWbTV1TjlXUGF1aVlyTlk4dmVKY1dqSVpYQ0lWR29YKzlUNzdVNzFaL1lrY2VGOUk1b240Zk9rbEFVSE5TT044YzlTMDhEdW5FaGFKWjgwVlNMRC9uR1ArZGRBdlFCdnh2ZW0rclA3SlBReFA0T2VTK0IrUitVRi90RE00Z0FRei9tYmJkNzMrSzR0MUJoTUhnOGZpY0prRW1JeldCNXhoOHVqeE83U3luWTJQT25VTDNOZG04VE9yNHZ5OCtTUVlqeTFFWmJHNGhkdEMydm8xZTU3MnBqd202Ri9MTW5VdVl4aEo1b3d1Qnd4V3h3MFIzTDc4TTNQdUJhclVKdU1YdUtHVEZISkxaQmNGNzRaK0g4SGh4MHUwRTAwYytaWW4vbWN4eHJEWjN0eDhJbzJIMnZYbmJ4bjhTRzhST28yZ3dMMzZmd0xGTU9sN0xQSndaajlqY0Q0cnBINGpQRW81ZmhmK0U4dG1LWXZFcURqNUltOVVVWi84TUgzSS9wWG5xVjFBL2gyVkRheUtOaGJhMzJya3ZJNnZjM0JIclA2YzhTc1VGcU1pL29VQ3JPeFVFTUxlczAxSUE1Tnk3U2czMVcydFJlYTd5cXhKUlFmcEEycFNBbGIySTNKTFg3VnpiWjM4WFloTEJncmZxR3c5cURsWGo4cjBnSGZWZnZRYThzcXNCWlFMWEd4TkZMcmpWVXNDTGo5aDk2YVNvb3MzZE1UaTBEdVJwMjlTODFNRHVDRUEyRnJNTzlRTVM1eE9kR0Y5T3BkbFBhck5yWDQ1TzFxQVhka2JFd1lsbWtrUVdBWDFhUmZuc0JYSit1c0lJNUpFS0VFSFVxQWZUN205ZHB3K3FMY0FBSC9BQmR1OWMvNnR3d3hVdUxaSTI5UkpRa2ZRS3M0cFZKR1I1REU4bU50R0g2WXhTeUlzTFdLazZ0WUhxRmFERnVNUkdnVWtDeEI5NnlHVEljSE1pczI2dGJmWlJXeXhDREVJV3VJeVJ2bytLdTVFazdPZjA3Yng3V1VHbVhDeXNGS3VHMGtDL0FBM3JXZEs1c0l2NEJCTUpjV1VmVUw5NnpPS2pXUlZaRllLdTRKNU5MeXpFSEM0bFpUSXpOcUdnZjcxSEpXaVhCazlISWQyd0dJVXFBQzExU3lxdzJ0NzFLRGFiSFVCdHR2YTlacnBiTjB4VVFVU0Q2ZE5qdnYzdWEwd3dyK1h1TC9BTndqZ2Z0V2UxVG83SEhQZWt3YWxOaUVKUHVLSmlRck1EeTN0dWFkVEFUQitBVjI0YTFMVkdpUWtoUHEySE5oVENkcW1NU0ZuVVA1ZjBqdFNWSG1oYnY2amNrVzRGUGxTemdJZlVCZGxQZWtTUnFwc281MzI3ZkZLS05raXpNTnRJdUdJMlB4VVJIWEw1NFdXSldqa1A4QUZERzRLbm00KzFTNWxlTGM2V3ZzQjdVeExNaGo5YkJGL1ViYjJweWxVdUN2bFVaeGNaZE04cytKM1J3Nko2eXhtRGhjeVpYaUQrWXdVdHJlaHR5dC9jRWtWbFNOREFIajNyc2ZqMzFCbG1ZWmRoY3RSR09ZWUxFaVJHdmNKR3czQi96cmpyQlRzTDJJdXRkTmdrNXc1UEZ0ZmhXSFVTaERwQWllM0pJVzIybmVseGxZd0FXdVNiaE81clI5SGVIbWFkYUkySXc1aXdlWEt3UTRyRUErby80RkgxVjBYQitGMkY2Znd4YUtEejVncFF6WXIxRGJmVmJzYVpQVVk4ZkJOcGZGYWpVZTVLa2RLL0NUMUdaK21UbFRXU1hMY1M4ZHRYckNQNjF1UGF2Wm1XWXNQZ29qY2NWNFc4SlVtNlU4UjhESTB2a1lmUDhBQzZBdkFhU1AzL1kxN095TEVNK1d4NlgwZ2JFSDNyT2MwNWJvbHJOZ2xoZXlYd2ZJVGEvNzdVQyttOXhjVWFXSFBIQSthUmNHNEFQTjYxbWM4dXpzbjRTV1lmaUQ2TDBpNE9NQnNCenNheW5qUzRQaWoxYm80R2I0b0JlNEhtSG10UitFMkF5ZmlGNkhWV0tBNDhiL0FQbGFzbDR2dWt2aVYxYVY5UU9iNG9hanlmNGhxZjhBOWFJMStiTVlDUHN4cFFMWDUvbFRaVUVjN2UxSHVPTmhVSThVOFlrZGRRMkc0UGNHdC8wUDQxZFM5RnRIR3VJYk5jQ3BzY0ppRzMvWnVhNS9xSTAydWQ5NlZaZFYvcUJQZjNwR2t4Nm00OUhzanc3L0FCRVpGMVhJa1J4SDluNDRiSEI0MXdDMy9hZTlkYnlycVdIRTRpSUdVRkpVY0JsM0IySXRYenk2UHc4ZUo2cnk5Skl2TkM2bjR1ZGdUVzN5RHhnNmk4Tzg5eFdHdXVaNVhETVFNSk1mVXEzdjZXNUZRU3hmS0xlTE5jbFowRXBKaEJpbzNVZWllUk9keFpqYW1teDhzYUsyc3FRZHZjL0ZIZzgydzNVV1hIT3NHclJwajVtbEVFZzNpM3VRYWJuTWVveHViRStvRy9lc3BxcFUwZWtZc2psaGpOajM5b00rRlptaWVNdWVPQnQ3aW1wOFlJd3EzWGNXc050cWFpeDhqeXVxNlhRamUvSkZyV3FpeDJOaHdrS3BMTjVZVUgwcnVkWGFsVUwrQ1BMcXZUamJZTTl6dVBMMFJYY3lXVWxWNEtrKzljeXpUR3ZqTVEvci9oZ2ZwQXNUZXJMUDh5T0prMTY3K3JUclBOVWtjU3RJdjFiM0lIK3RhdUxFa2s2T0sxbXBubmRYd1Q4cWhmV3BLNlFCNmlQYXVpWkhIRmhzdDFJaFY1Tmc1L1hXVjZZeS93QTJSV0tCMlU2cEZKM3Q3MnJacGhkYmdsaUZ0ZmZnZkZxaHp6dmd2NkRGS0szRDBlR2t4RWtiWEVOOXJBN21yYkRSZVFENmo4WHRVTkVWRjJGckcxZ1BlcGNVZHcxM1FLT0NUdjhBWTFRbHlkSmo0ZGpydHEyWlRwSXZxQXZUcWFKR1M0S20xNzMyQnB0SlM0MURZQTdqdGFsa3J0b0pZZmFvV1gwMCt4eVNSajZRTjJzTDM1cHliMUtHakpRQUFHOVIwZC9PQkE5UEp1T0tjbXZ1cElzUnVSMnB0RXUvZ1JPeFdPeElzM29KTlpEcnBqNUdIWmJtWnJwcC93QmExY2txa0tWTnlBZHV4OXF4MmZ1Y1JqOEREc1FaTlpBM3F4aDRrWmV0bGNGRTEzU2NCdzJCUldiVUZRQlFmY2UxYVFGd2RXMnd0djNGVitVeE9tRlR6TE9YOVFjRDZhdEZpREt5TXhLc2JhdTRxdmxsY3VEVzBzZHVOQ2tDaU5XQURDL0JvcEVLV2RRampjV0pwMVNMa0JmVEhzTGQ2YmVSVmQvTVZnQ050dHFoTC9ORVJtSVRrTlp0bDR0V002czFIekdkRld3SVhWeld3TVF1VWErMi93QUdzcjFQcmZEdUFiMkpVSmJmK2RXOVB3ekY4ajdzWmo4bXhQNVROY01WM1V5QlNiWHVLOUQ1R1JOaEFZemROSU42ODNoamg4VkU0MUlxU0E3bXZRUFI4dm5aWGhpSHNnVUc2NzMrOVdOUkhoTW9lRHlYS1VTOEI4K1BVVHR4eFZhcE1HSU1hbGdSeTNJdDlxdFZaZFdrcUNMSDRxdHhzWkxxVmowTUw2amZ0VkNQWjFjMXdkZC9EOTFCL1pmaURnNEdlME9PamZEU0c5dlVCZFQvQUQycnVYakhsclk3b21YRUpHSGt3Y2l6YWU1VzludCt4cnlSMHZtVXVCeHVIeG1ITnA4UE1zeXQ3S3B1ZjZYcjIvSXNIVStRRk9jTm1PRUZpT2ZXdC84QVd1czhYbCtHZVUvcWZTMUxlbDJZendOemM0N28xOENiaVRMY1M4Rmp5SWo2by82RVYwRjR4S3VsL1V2dFhFL0JYR25LZXFjYmwwdDFlU0k0ZVZXN3pRTVFQM0lQOUs3WnEvZXRyTXFrY1ZoZTZDdEFWUExHMjlRTVBsVEptc3VPa2tCWmswSWdIMGlyR2hVQ2REcDQxT20vZ2o0NVdiQllvUjdNWXpiOXhVWHAxZzJUWVhRYnFCcFAzSE5XTnUvSjlxWlREZmw5NFFFVnVVSEYvZW5YWXlXTC9hc2lKRnFJbTFJVm4xV0svdmVsbllpOU4rU3l1dVNCbmsvbDVWaWJteGROUDNKcDNMRjhqTDRFSzZXOHNYQTRxRG4xcG53TUhKZVlFZ2UxVzR2cEFBNDJGU3kvR2pQeEwxTlEySjg5RllSYWdKRDJwUjI3YzBsbEFJUDZ2NzFxV2JFQzQySEZNWERMOWNORk5rZU9WbnhHRW05T0xFcFlsdVNPMXF0TVRob3NYQ1lwVkRvZHlHRndmWTFYNXprYVprUlBDL2tZeE5ra1gvV3EvSXVvWjB4N1pSbWFsY1ZHTEk5L3FwWkxkUmt4MUQwODFpekx2cG1obVVyaHBSRmNrUm5UN2phczcwTG04T0p5MzhtN2hNYkM3RjBZMkxlcmtlOWFZN0VIbXh1RDJyTVovd0JIUjVoS2NYZ21iRFk1VHE5SnNHUCtsSUxyRm13eldiRHl2bzBzMGFUTDZvMTBoZ3dVOWo3MHI5TmpXYjZXejdFWW5GUzViam95bUxoR3hJK3IzdldrT3hBRzlCYjArZUdvanZnZ2liQzlqeGVzMTF2MVFlbnNENUdHS25NNWdQTFgvd0RGcmZlUTFiWjNuV0h5RExwTVRpQ0c3UnhqbVJ1d0ZjdHkzRFl2cnZQWGhta2FPWmpxeHM2amFCT1FxLzR1Qi9XcElSVld4Y2svMng3SGVpT2tCMUxtalk2ZFhreTdDeUZtYVFYL0FEYzErYjl3dGFueFc4UllQRHJwcVRGcjViNXJpTHg0TERIbHBMZlVmaGVUV2d6RE1NdDZONmNteGM1R0V5ckF4WDByN0RnRDVKL25YajdyanJiSCtJZlVFMmJZdFNrQkpYQ3dzYkxESGYwajcyNXJNMTJyV09MaWpxZkFlSWVvbnZ5TGhGRGlzWGlNZmlwc1ZqSm1ueHM3RnBwaWJseWVkNlljaU5Bb2NrZDdudlRqVGFYS2xUNlJ1UG1rT1VKVXNvS2tmdURYSFNrNWN0bnNjSXhoRlFncVNDVXlDSlJZa2V4b0VtUG1YZTNKNCsxSmptQUJ2cUo3Ry9GSzFySUZEUGRoK20xd2FoSmE0Q2ZhUm1CT3NEYXhwTHV6eHU3OWx0cTdYcFVmbHFHSUJMc2V3cU5pbVpZWHRHRElRZHI3QWU5QUZKbDVYR1p0SUhGM0JKTjEvd0RkcXNaaDVJVU96RUZpUG1vWFQ4aXMrSWJ6THlOdUQzTlNjVytueXcxaHZkUVBla1lzQ1VkQXdldXpBY3FwL3dBeldWejVuV085aXZxc2Q5aUsxRXJsc3VjSzJwcmkvd0RocWh6d2lmQUlDTnlRQnR4VG9PbVJaa25CcG5NTVRoVVhNWjQyTmd6VzBuajlxdFlzUnBVQmdDZElHeDRQRnFSblFEU0pJR0dwdHlRbjZxR1Y0Z1ltSnd5cmZsTkl0Y2c5NjFIekU0NUxaTm9qNGdHTUtxblF3M0dyZTE2aGdIQ3lOcGpkSk5Xclg4Kzl2YXJqRmhQTkNCZlV2MTIzdVBpb21MbUViNkN1a0x1bS9BK2FJdjdHWklmdU5WMGhtbW1CUUxTeGxyNmdMYVQzdlhWTXJ4M21JaWVaclhUNlc3aXVENUxpSHd1Sk1zY2phMk5sVmZwQisxZFB5WEhxeUtKR0s2U0F5RGU1NXZWTE10c3JSMG5qODNxdzJtM0Vxa21OaVdJTjdLZjYwaHd5eWk2V1UzSUk3MVh4WW92YzN0RVRZU0Fia2UxT1lqT0RoSWJBS1lpMmtYNVAycUNqWTNWMlN5RHRxRmllQjcwVWtiaDdYOVhzTzlaWmV2TUsyTC9MeTNpOHMyVm00Yjk2dDRzMUdLSWtqNEg2cUdxN0JaSXpmRExBbU9OZ2RpdGlHc2Y2MXk3eFA2NXd1UjVmTmg4Tk1aY2RJdW5TQ0xvcDdrZHEzZlVHZDRmcC9wM01jMnhJVHljTkNTUGQzSTlJL25Ya1ROTTF4T2M1aExQTnFUem0xa2M4KzlYdExnOVI3bWN2NXJ5UCtQRDBvZHNrWTNGWWpHWmZqOGRpV00ySW5uVU0zc0FOcWQ2UjZlWHFqUG84SE14WEJJUE94RGR5Zy9TRDJ2VFdKMVE1QXRsSVZwaGRqMzI5cTJIZzdnd1pzeGxBR3E2Umk0dUR2YzFyemZwNHJSd2VreFBVNnlNWmMzMmR4eTNCdzRIRDROSUlSQmgxUXBHaURaRjdELzN6VS9OY0g1bURNU0tORWdKSnY4VklqamxXUENob2lpV0pFWU95VTZ5RkVrdnhZRmJlOWN6SnVVdHpaN0ZqeHhoRlFpcVJqZXFvbnl6TE9rOGNzTjJ5ck5FTFdPK2gvVFhxM0tNYmgxeStJK3ROWTFoVDJ2WG1ycVRCUzVwMHBqTU5ERUdsSmpsVkNiYnF3UE5laitrZk14dlR1QmxVSnZFdHc0c1FkSXVLdVk1YmxSd1BtY0x4NTcrejVScElXREFqWW05QUVxTFhJQjVvbEdyNmVLQjQzNHJmT0JSMS93RENlMmo4UVhRd2E0LytvZ0FmK1ZxeWZpNnJSK0pQVjZNQUhUTjhVRGIvQVBLR3RaK0ZBRC85SUxvUVh1VG1TamYvQUxUV1k4WTFIL3pSNnZCMlA5c1lzTGYyRWh2VXovQkVhL05tSEJ1dDc3KzFHRFltOUJiYVI4VUNiQUMxUWp3MVlFalNDRHpSZ1dXMWp1YmkxRXBEYkUydFFWZ0JZN21nRFM5QkYxei9BQkUwWkttSERuZTI5MmEzK3RIMVZoRmp6NmZUdUpBRHp2Y2pjMU82SXd4dzJXeXpIMEhGT1JZbmNvT1A2MHZxMUFzK0duMzFpSzJxM05xUWZGV3pSZUdHS011Ull6Q016LzhBTHpDeTMvU2ZiOTZ0YzB4UXc4MjdXSTlJSjk2d25ST1lmazgva0JiVEhORHNDZG1JM0ZhRE5BbUlua2JWY3lBTTFqd2Z0VkNXUDMyZGhoMVRscDFGUG9QRjUrMElnS0VtVVhqWWtXdVBpczdtbUtrT0trdUM0WWg3WDNGTHpURXJFQ1BTemhnMjlVOGt4eEwrYXo2bTQyTnJXcWVPUDVNalVhaVUrTEdwZ1hiVXgzSE4rQlM4SEdvWWtOZFFOaURTMlRXeFBGK0I3MU93Y1pCQXNUZTIvWVZQZEZGUmNtalc5TkxISEczbWhTWFVhU3V4UDcxb2lWampJVUFMN0UzTlp6TFNrYmVXNUpUWXI3aXIyTlFnWWdFcU83RGVzM0ltNUhZYVNXM0drT2gwVkxHUnRPeHNPVFVtSmttaU9rS1I4MVdTNHhJQmR5SW00WFhzTDFIeEhVZUhDb1kzV1I3V0tJTjcweFFiTGtzOElkc3ZCaUJHUUFDeElzQU8xSy90R05KQW1vQzI3RDJyTjRiR1lyTUpPOENHL3J2Yjlxa3RFa0M3QW00MnVkNmE4WUxWYnVTNkdPMVJzVUp0OC9lbkk4WnFSbURLcFViQUM5NnorS3h3dUYxbGlSYlk4VXJENDB5T2dXT3pkN0gycE5ncTFTTGpGNGxKVXNqWGt0ZlllM042ekdIZGMwejFIUlgwS0xFN0FFMDdpc1lzU3pGbWFMVURwdnNTYUxwS0U0dDU1YldkeUZWU0JiYXBZeDJ4YktrczNyNUl3UjBYTFZXT0NEVVdpVFFkVWE3OSthc0NoV01zcHVWTzlOWWN4cXNTRno2VUFJSEZQQTJaanFQMWJHc3lUdG5ZNG9WRklOSFY3Z20yOXpha3V0d2RqNmxzTlI0cGF1aVBZTUF0cm02MG1lUlpZbVVIMUhjTjdVd21mUkJkcEdpSlpndHdRTDFtZXBGWVlXNHZxdGZTQjlRclROSTVqQjJrS2kyNHJQWjJOVUY5OVkydGVyZUorNHhkZEc4YmFPY3RIZDdnK2duY0U3MTIzdzJ4V3JKWUl5QUl3Q0FGUGV1TDVoR0VtQktnQUc3TmV1b2VGR1BKd0R4NlNkSXV2eFYzVWN3TVB4RXRtb2FPbWVaNndBQ1ZJNXRVVE1vQytIRFcxT2JuUWVkdWFsYVpFUUVOc1I2ZmE5TTVnckdFQUVsbFVsdDdiOTZ5dWp1WFZja2JLc2FnbktzUUErd1BIOC81MTdGOEI4NmJOUERuQVFPMnVmQUU0ZC9jYjNYK2xlTGNET3NlSklaUXErempleDJyMGIrR1RxRVE1dmo4cWRpMzV5RVRSLzhBY20zK1JyYTBPVGJrT004L3B2VzA3bDlGNTFQaFIwZjRyVDQ1UVJGaTNUTVk5SDFLU2RNcC9tSzdTQ0dWSFUyUnhxRnZZMXpyeG95OWY3T3dHYkJXdmhwR3dzcFhueTViRGY3RWYxclMrSCtaL3dCcWRJNEp6dExBRGgzdU9OUEg5TFYxK1hsSm5rR0I3Wk9MTkZRb1VLckZ4Z29VS0ZBZ1FGcjBHM282RkFERXVDaW1tam1aYnl4bTZ0ZW43K28rM2FoUXA5MzJOakZRdHgrUnRta0xwb1VhTDdrMGNzakxJaXFwWU1iRWp0U2lMbTVONk1iTFlHMU5CUitRcjdIYXdPeHYzck80akNqTWVzY05OREhZWUtJK1pNZUdZOEwvQUoxb1N1cTl6UVJGUUFCUU43MkE1Tk9UNElNK0JabW0vZ2lZN05ZY0JqOEhocHZRTVZxQ3QyQkhiOTZtazM5eFljbmExSmFKV1pTWWxmU0xEVUwwbjhzcHZkU1FmMDZ0cUNYYkttbXlnd2NBeDNXT0p6R0tPME1FWGxsenNKV3NBVCsxcXY1cDRzTEU4K0lrOHVHSlM3dWVGSHZTbGpDS3FSb0ZSZUFPQWE1YjRpZFlETUpqZzhNUytYWVpqNXBpUC9YbDRDQWR4ZjhBbWFsaEgxQ3JqeHJSeGFYYks3cUhQTWQxam0rRVhCeGViSkxLVXdXRkIzVWYvakg5Z0J1VFhUdWwrbm9PbHNzWEN4dUdrYTgySXhMY3lQYmR5ZXcycXA2QjZQYnAvREhHNHRRY3l4S2owdC80S2tmUVB2elhPL3hCZUtFdUVpazZWeWlVbVdWYlkvRVJ0WVJvZi9EdjduL0tvTlRxSTRZMmEzalBIejFlWmNHSDhhdkZKdXU4ek9YWmV6RElNRTVVT05oaXBCc1grVkhhdWJsaXdNV3JRRHVmYmFsVzBLcU9CcEkydFRiNjBUUmRTdmF1SHpabm1sdVo3aHBOSmowbUpZOFkwVDVyc2haZ2R1T0wwaEhPZ3hyYTRiY1czSnBlSlJZeVRxVTlyWHZTUFFwQlVrbnZZMnRWV3krdUVKMCtTVzEyc09iZHFVSFZXSUJWdGhZaWlqQUtzeFcrbzhhcVVJUnEwUmxTbzlxYUtIY09PYkVjZHQ2cTgyZHNOZ3BXY0FGajZiRzV2Vmk4aTZkSnN3dnRWUm4xbHc0VlBxdmZVYUFmNGlNb2lCd1lLbTJvWFlrVy9sUXhLcXc5QUxGZnBKUGVuY0xiOHBHSFk3SmF4N2sweEtwdUJJUXgvU1ZQRkl4OGVJa2pVSHl1WjQ3QUQ2ajM1cXR4MXBvV1FYRFNqWmp0YTFUb3BBMkNsMWtsVVZ2b08xNzdYcXJ4TW5tUk5yYmRoYjdYb1hhSXNsTkdKekVLQSttU3hVYXRqdGVxckNJVUJsaXVJM0JYN0VjbXJmTnpwQlg2UlkrbzdBMUJ5NlRTOW1YeXkzcHVPRFdvdnhPUnpLc3ZCT25pbGFBTkd3ZDFXNUoyRlZPT2xLeElXVmk3ajZnTGcvRld5UXBMcVN4Y2JqMzNxa3pKVGwwcUxJMWxLN1c3YjhVNktzaXpjUnNVbUpTS09NczdSeVh1eVdzZjJyYzlPNW80Z2pKQTA2aGNuNjdWelNiRlJ5eEZXVlVhUGdxdk5YWFNtYkNDVkV2NWtoWTNIY2V3cE0yTzQyaG1oMVhwNVVqczhPSlZJRkc3S0cySGNENXF0Nm1oZkZ3Sk1aR1JJM0FmVHhZMGpMOFdQS01pTjZMK3E0dnY3VmJpQ1BINFJvWkNKR0kxS3AyQmJ0V2IwK1R0WC9zandjd3ptSlFUR2tQa3NEcURzYms3N0dySEplcW5qS0taVUV5Z0t3VDZmM05OOVJRWWlMRnJIaWJLTjFCVmUvYXFSY1Jnc0xDWGQ5YnJmV1FiS0Q4anZWcU1mVVZIUHp5dkJscXpVK0k4ZUs2dzZGL3NqSjRIeFdPeEdNaUpnUTJ1cTNKMys1cm5YU2ZoYm5zdU1lSE1zcU9HanZwazg5dEpVZTZudld5NkU2OHdhNTA4R0l4SDVTRjQvUk1kbERqL0FDcVYxSDRzNHA4N1hMY2tCelhHU05wRUtqVUYrZmdWSkNlVEduRklyWnNHbjFlVDFweTZNdmlQQ1hBWUJKWXN3elRFVDRjeWd4cGhvdlg5cm10ajBUMFJnK2wyeDBPSGVhV05UcVE0aXhjRWplNUZhUER6WXFMQVI0bk9zUEJGaUVpWnZMQS9VTzlTOGpWamswR0pKdExOcWtrMWMzTlFTMUU1UjJzMXRKNC9UNDVyTEZjbG5obkxZV01Ba2lOYnR2YzIvd0JhV3pCZ2dRbFUvdkhjZnZRd1FMd0l5Z00yd1FLTy93QTBndTYrWkduMWx2VWx1UG1xaHRrUEZSdmlZWkVXVUxxMjFNZEtuZjNyMUIwdGdjT2Vuc0FNVVNKaENnSlVYRGVrYml4cnpmREVrdWM1ZkE2cWNQTmlJa2VNaTRzV0FOZXZNSjA3TGs4QzRSTXZ3MDhVZTBiRGIwOWhWdkJGdXppdjFCSlJuRStMcWdYWW5iMklwSjcwczdqZjBnZTlBRHZZZ2ZHOTY2Rm5taDF2OEtqS2Z4QzlDYkd6WmtQcDVCMHRXVThXSE9JOFNPcXAyMU16NXRpemYvOEFldGV0aCtFZVBWK0lyb0ZYVVcvdEs5Ly9BQ05XTzhUQnA2MTZoVUVrcm0yT3VmOEE5KzFxbi84QVdobjd6SERZVzdHaG8xWEJORVAvQUZvd08xN2ZOUWp3QlR4Y2o1QXBURmlEYmUrd0Z1YVJwMDk3L0ZXM1RHQVhOT284dXdoS2hHbDh4dFhaVjlYK2xBRzVnd3d5NlBDWVFLRDVFS294Yis4ZWY4NkxxZkJpYnA4VEloSmduVlN4N0JoYW5aaUp0VXdGaTBoWWoyM3F6d3VHR1o0VE1zRXpIVkxEcVV0d0NPS2piSFJmSnp6THBURm1NVGhkTGJpdzdpMVcyTXpKWVVaVkMrYTI5NzhWUzRaU2twWmpwMEZsSHZjYlV6S3plWmNOYzIzK2FWSlNOQlpYR05JWEk1bGtaaXdkaWRYTkx3eWlSMkdtNjkvaW1jTkMwOGorWEdRMXVUeFZ0aE1JSTRVdVFMN2svTksrQWhGeUdVdzdPTlJzVkF1RGZpclRBeGhZbE5peTN2OEF2VHNXRmFSQXhBVUVXc3c5SnAyTmpCaFdWUWJxMXdVNHFGc3RSeDdSNkpuTjVZM3U0NXVObEZIUG5iUnFZdk5aMlpRU3BiNTUrS2d5WWsrVTREQXNONzl4UlliQStaWjVwbFF1TlYyRk5xUHlUYjVyaEFtbXhHWnNOYS9aWGJhcHVGeStOMUprZlJJU0xqM29SNEdKTVFBOGdBdFlNRkpxUVlZWUZXT1RHUm9UZFF6Y21tdmo4U1dOM2N5ZGk1NDhNZ1p3b0E5RndkcmY3MVc0M1BmUGVKY090eEhjZVk0Mi9uVFFkSGpNUWtWd0wzQk8zM3ZSUjRPSlBMSm5GanRwVGNVbkQ3Sko1Vy9iRVdreXBMcmVSUVRzR1FYREdqL09Pczl4Y0JsOUFVMnQ3bW82NGRJQ05Ma1dQSzhjMHkySXRMZGRtdmEveFRsRk1qYzNEaGtqRjRna0pabVlnYk0yOTYxWFJHSEs0V0VLcERPeGE3YlczckVZdGl0a3VKQVdGclYxSHBiQ0tpUnhxQ3hDN09Uc3Q2aHpOUmcwYUhqVnZ6V3pVQWhKZEorazdYSHZUNFVCZ0xYVW42YWFSV2RWSkcrM3E3RTArRTBoMlljbTF4MnJHTy9qd2hCaUNNMmszQjdFYlV4TXhHa3hwNkZKMUQ1cVRhNjNJS3FUcEIvMXBsa1lpN214M0YvOHFRR1FuRGg5aUNBTEgyTjZwczRKa2gwcUJxdWRQK0lWYnlLNlNCU29CSUoxTWVUVmJtT0hZeEFzcU1senBPcTFXTWYyWldwaTNGbk9NY21tU1FlVXdZSFlOMnJYZUdtTGFHU1FLdDdrWDN0V1p6Wkw0a200VVh2cVBOVHVpOFMrRXhodGRvdzRCMWNDL2V0T1VYTEVjeHBaK2xxMGQ2UVhnRm0xTU9iSGlucEhXV0lyYTNaMnFOZ0hNa2NaQURoYmJEdlQwWlFHVkJjYm15MWtOYzBkK201Uk0vaW5aTXlMcTF3UVZ1NDJ0WFJmQ2ZQVzZkNnh5ckd4dHNKbGprRi8wTnNhNTduRVFFMFp2NWpIK1FIdFUvSjhXeXpnZ09ybXdXeDRJNHExaGx0a21aV3R4ZXBpbEJudm5xREs0ODd5YkdZTmxFaXlJU2cveFd1cC9uV1E4T3Nkb3gwMEpZbE1Vb1lMd0E2Yk4rOVgvaDFuZzZpNkt5Yk1OWHJmRG9ralgvV29zZjhBS3NmaklYNmM2MGtaQ0k0RW1YRVJyMjBQOVg5YTdySEwxSUk4TTFFUFJ5ditHZFA3MEtKR0VpaDEzVmhjZmFqcU9xUTlnb1VLaTVubU1PVllHWEZZZ2tSUmo5SXVXSjJBQSs5Q1Z1aHJhU3Rrc0VFZHIrMTZMN2kxYyt4UFcyWVk5MkVXbkFSMzlHa2FtSStmWTBqQzlVNXBBVDVtTldaRDJrU3BIamtsWkU4c1VkRTcwS3plVWRaeFlwVlhGS0libTNtZzNYOTYwYW02Z2dodzI0STRJOXhUTnJSSkZxWFFkQ2grOTZGSlErd1VLRkNrQ3dDZ0dQQUFOQUhlM2VzNzF6MWZCMGRrdjVvZ1Q0MmR2THdzSEJrZmUzN0RrbW54Vy9oREpTU1Zzb2ZFM3Joc3REWkZsOGhUTUpveStJbkczNWFJN2M5bUk0SHRWWjRSOUkzdzBPWllxUFZoWVdJd0VjbytyZjhBNmh2L0FFcks5QTlMWXZyYlBKcGNaTThtQmprODNINGx2cW5sSnY1S24yc1FTZXdGcTdKMVYxUmwzUW5UcytaWTFsandrQytYRkNteGtiOUtLUDhBYXBzczFoZ1E2WEZQV1pVcTRNMzR1K0ppK0hlUkQ4cmFiTzhWZE1QQmUvbCs4amY0VnJ5cE5QTzdTeXl5SEV6eXNYbGtKM2RpZHlhc09vK3BNZDFkbldKemJOSlNjUlBjTEVHMmhUdEdQZ1ZVVE1JL0tBTnl3M05jVHE5UzgwNitEMnp4UGpZNkhDdi9BTERUdVBNQThzazI0dGFqbVhWQ0dDQUwzQk5GSzBnMU1DYis0Rk5zR1pDWFptQjdBYlZtSFNMZ0tVS0pDNFViSGNXK0tZbWRMZ0tUcmJjRURZVTlJN2V1NEFVaSs1cGtLd2pNWU4rNElIRk1DdmtOMUxrT1YzdHUxdUtFSUpLQkFGQnVUYnZSQ1BmVTVzdTE3ZDZVR0VqYVZZSzZnN2NYRkFnVEVFa0d5TmZZL0ZVZWV1czJKaFhYWlNMcXZ2VjVPRmxrUzZsbEk3YlZRNWxwbHpXQUxhUFJlNVArVkFTZkZFOTFSVVM2MlZWRm1CNXFKaVU4dU55Nm1OclhWZVFhbGVjaktRRkRhV0JGL2VtWm5rSWx0NjlYNmgyK0tUc2tyMmlzQ0kzam1WeUVEclpReTdjYjFSNGpmRFNCVTh3cXd0Ym13cTd5bVV4T0VrVStYdmJXTnJuaXFLZG53OGs4QVlSdmNqVUQ4MHE0WkZOVkZtWXpsRWpNaERheTY2Z0xiR3EyTk5FeXRZaGZxdUJjZysxV2ZVYmFVS3FDTko1SjNYNHFsL3QzQzRUMHY5UkExZzdWcVJUY1RrZFEwc25MTHNoSGpTemhKVHdSNzFVWjVBam9rak1Walc0WUVYdTN2VDJGelBENGtDU0NaSGpVNlNwMnNha3ZGRGlNTkpIUFpDd0l1TjdVM2xNWk5yTEdvbU5lR1FrT0dETUwzVzFoYjNwdkJURERZMUczY01RR1pXdGVyUEg0WjRSb09yUWlnYWZjZGpXZXhVSWpsQllrTVNRYjkvYXJpVzVVWVdTVHd5VWp0ZlR1Sjh6TG9USExxQ25qa045eld2d0VtbkZqV0xBa2NmUGNWeVh3NnphVk1PMEFPdU5kakV2SSthNlhCTWtjVWNtcVQwY3YvcFdSbVcyUjMrZ3krcmhUSi9WM1RDOVM1WThjTTNrekFhZzZjMzdWNXF6ekpNNHlUSFM0UEU0ZWZXSHVXSU5uK2E5UFlYTTJqbFVyWVBzVHZ5dnZUK1p3dzVxSExSeE01SDFTS0dJSHdhZml6K21RYTN4MGRVMDkxSG1ESmVnczU2bXhzWWlobGl3eGNhOFNWc3NZOTkrYTduMHAwcmdPaG9SQmd0QnhUajE0dGx2SWZmZXJKekxoRUNtM2xMNlZTTVdCKy94VWFTVm1JQVVhdmMvNVUzTHFIazRRL1IrS3g2U050MnhyTVIrZlpjTXJhaVc4b09UemMzclJHUHlNT3NHd0tyWXQyQUh0Vk5rOFJ4T01sY0VlWEVMS1IrcCsvd0RLcmZFdTI1WnJ0eHF0VmFtYkVQNUhZZFg1VUZ6WW5jRkRhOUthZGhoMkNibTkyYS9hbUEybUNOZE5ncEI1N2UxSmxuS3Evd0NtTWcyRk5Gc2w1Zk9Hei9LSTR4WW5HUWFpZmJVSzk1K1VDQmF4Mkc5cThGZFBMSC94QmtTZ0ZtZkd4QW4vQU13cjM1R29WYmY1MXUrT3grb25aNTcrcUpwWklId2thN2NnRWQ2VFloU0FUWWpmNG8xRmh2MzMrOUdwTmlCOVBzYTBEZ2pydjRTM3QrSXpvRWduZk1oYjdhR3JGK0krSU9KNjU2bW1BM2ZOY1pxSFlmeG00clpmaFNIL0FPMFQwQVJ3TXhHMy9rYXNKMXhZOVk1K0QvOEEzSEZtL3Y4QXhXcWYvd0JhRWY1TXpoOUlIZS9OR1JZWHZRQ0hSY0Q3MGFycU5nUVQ3VkNLSEdOVmlEZS9ldGQ0ZDRaVWt6SEdPQmRZdklpWmgrb25lMzdWa0NqeVNMREVqTk83QlkxQXZxWThWMnQra1k4aHkzRFpkaEpkYXhLSHhKbEhwZVVqY3Fmamltc1JsWGlJbFZBcWdnSGwvbWtRNGg0TVhod0hhMGpLaEYvYzAvaW9aSWNMTEhNQ25ERW5qbWs0YTM1aExxRzBzR1g1MnBsV0l1eUw0bDlNRElNNkdLdzBSL3N6TVA4QXBTcVBTSlFCclQ3am0zeldQaHdmbTczMEVINnIzL2F2WW5UUFIyV2RlZURrMlZaeGhQT3dxWHhDT2ZRMGNvRnk0YjM3Vm1Pa2ZBVG9xWEhZYURINVpOaW90YXlHV1hFdDZsQTNXdzRwcW1rWFU3UE9VWncySGRCNWdiMDJjcWIyKzRyUmRQNURtT2ZMSW1VNU5qYzBpUnlGZUdCbVZnTzk3VjdXNkY2SDZTd0VNMG1BNmR5N0N3NjlhQVJCbWEyd0JKNXJkWUdiOHJBc0dGQzRhSkR0SEFnUlFQMnBrcDJUTExzNlBDVVhoNzFYaWI2T2tzMHVxMkt5UXNBRDhWWlpOK0cveEo2aElLNUl1QmdjYk5pcFFuOHh6WHQrWEdUdW92TzV0L2lwa1RrZlVUOTcweFNGbHFKTThKZUovZ3gxTjRNNVJoTTV6MFlQRllHZWI4dTBtQll5Q0Y3WEd1NEd4M0ErMWMzbTZsZUxFUitqVUgzWDBDMWZTTHFMSWNzNnZ5RE1jaXppSDh6bGVZUmVYT2c1WDJaZjhRTzRyNTgrSzNoSm1YZy8xUStUWnZxZkxKU3h5M05Rdm9tUUhZWDl3Q0xqM3FlRzJaQTg4MTBVV002cnhMd2dnRmlsd2RJQXNLckIxSElORjRBMjI1SnVhbTQ3SXBvY3NseDBrMFJRcUZCVWJ0N1ZuTkxGUU4xMzV0VXJnbzhESHFKdnN1VTZvbVFwcXcwWlMxanR1S3RzSDRoeFlRUWc1YWt1bHJIdGVzZ0JmZzZUMysxR3FrYXQ3RS81VWpnbU9ocWNrZWpvRW5pTmxzN3FyNVo1WTVKdUtiaHhzUFVFclJaWmdNVE5pZEpjeDRaUzdBRGsyRllhKzYzWGp2WGFQd200aURBZUl1YTRwNW5pa2h5aWVWQWgrcXczdi9uUXNLc2tucTV5VnRHRGdjNC9PY0xoUXJ3ekxJRzhtUUZXdDhnL05kb3lSREZFU3hGbzlqcDkvYXRENDNScG0yQjZCejFZbzVNVElqQnBvNHdKSHVCYTVISUZxcE1rUlZpT3BDc2JIWnZtcy9XcmEwa2RaNEgvQUdMZXkxaTFJaTN1UnZ0ZnRUa1JFWjFGejZ2cFU3aTlBSFFUYzNXMWhSeEtOQnVCSXY4QWQxYmlzYzdzWFl5TWJPQ0dYMCt3TlJXT28yMU14RFdJcVRJeXFnVUFBRGdlMVJpRkRqWm1WZXk3RzVwQldxSTBpeFNySXhKQnZzQ2R4VlZpblFnSWJOeVFHSHpWalA2V2RyMjBtMms4aXFqRnVHa3VObEl0Vm5IMFplZHZhWkRPSWkwelNPTkVnTzBZM0Z1eHFEazBoL3RCRVlzMmx4Y0tiS2U5WFdjZ1J5NlFUWVdzZTVxaXc4dWpFY0V1R3VMRzFhY1pYQ2prY25zeXFTTzlkTDRvTmd0UWE5aHNQYXJlWVd4YUFidGZ0dFdVNkl4UmZETWl0NXFnZ1d0YlQ4VnFzVWhadzZvZFlOOXRyMWt5WHVPL3dTM1kweXV6NUFZbWFOYklwdVNPYXFNRE5KaE1jcERFeHF5bTU1SXJUWTJKY1JBRVRZTVA1SDJOWTdGb21HbjFONWlTcVFQTEkycVNFcVpCblBZLzRhZW9FeG1WNWpsTE13MFNERlFxNTRSaDZoK3hGYlh4RXdBa2h3ZUwzdXhNRE1Cdlp0eC9Xdk9INGVlcHY3RTZ5eXlTUndzV05ZNFdTN2ZWcTcvc2E5YjV4Z3Z6K1hUd0MzcUZ3UU9DTndhNi93QWZrdUhKNUY1M1QrbG5iWFRJblMrTWZHWkpoaEtkTTBJTVVueGJqK2xxdHF5dlN1S01XTmVBaFFKMXVUZmZXdmIrVmFxcjBsVE1DTHVLQldWNjB3ZVB4OCtHYURXK0VnRjNSUnExTWVOcTFWQUFyd1NOcmJDa2k5cnNKUTNvNWQwNzAvaWM0eHNzRHJMZzQ0Q0hsZGhZbS82UmV0Y09oTXVpREdHWEVJOTl5emx3ZjJOYVAzK2VmbWoyNzdpbnl5TjlEVmhqRmNuTjh4eWFmQVlpVEN1NnNDTlZyYlNMOFdyUWRHWmxLL201ZE14Wm8xRHhsK1F2dFNlczV3TVRnNGxZQjBWdFZ1UUQ4MUM2UkxMbnRpQ2RNTFhMY2diV3FWOHhJNFBiS2piQTM5ajlxRkRiYnRRcXVXV0NoUXB1V1pZRmFTUmdrU0RVek1iQUR1YVJLM1FoR3pyT2NMa0dWejQvR3lDUER3S1hZbjlYK0VmTmNReEtacjRtOVdzaWgwbm5qMHhsdnB3T0hQTC9BQXg3RHVhbmRiNS9qdXRNNGh3bUZSbmdXVHk4RmhsRi9OWW5lVnZnVy9hdW85RjlKeGRJWlA4QWwya0VtTGxIbVl2RkhmVzMzN0tvMkZXMG80b2J2a3BjNmpKc1JJd0dBeTNvcnAyT0dJUjRYTDhERVN6dHNOdHl4OTJKOSthOHIrSjNpUE40aVp5WjBMd1pWaG0wNExEdC9XUWozOXEwM2pmNG9ucXpIdmtPVnlrNU5BNDg5a2IvQVBDSkI3SCs2SzVTOHp5cHFZRFVOaWU1cmtOZnEzT1cxTTlkOEI0ai9IeHJOa2p5K2dKSUhBMVIzNTVwRW1vMklGaDJ1S1RHeDVZN2ZGRXpoaHBGOVI0STdWaFh6Yk80NWI1Qk16RkhzYkViMjk2WjBzcWdxMjJtNUY2SjM4MUNIRGMydmExQ1FycHNCWWdXRklLQXNmcUlWN0RnMDBadkxjQldCYzdrZTFFV1YySWNXRnZla3F5eVJzQnBWaWJBM3BncWZBNHpBQWxUdWVhUFJxdjVoMlA2dTRwdUlYTEtiR3g1cGNjb0JiVW1wV0ZyKzFBblliU2hWOHh4NkdPalNPUWF6L2xyTG1zZ1lFS3Q5eWF2SnpGREliRmlMWHRWSmhmTE9KbWR4cmRtN21oZzBTdDBqOTFBdU50LzNwbFNETFltMXhmYmlwSkxrTVZaU080SnFIcVZtc1ZJTjdiZDZSRG02NEZZVmkrSUVURWk1dUR5TFZVWThyRm1FNkRTM2x0cUlPNXExalhTVktYVVdON2puZW9HUEJUTlp5VlJXa0FIeFRrVjhqYlJodXM1R2hLRUZUY2FyZy9WWE9jd1o4UVd1eFptK29rZTFkUTZ4eWZFNHFPSnNQcDh5M2wvK3RZWEg1Y3dWUFE2U3F0bUpHMjFiR0NTMjBjSDVURk41RzBpand1WlRaVzVBWUJUWTJaZWEzMlQ1K21aUVJvL2wrZDduZzF6K1dFa2h0aURlMTZQTE15ZkJUbXd0dmU1cXpPRnJneDlOcXA0cDdXZEV4cWlWU3JNV1poY20zK1Zabk44TXpJemIzSHFKTmhhcnY4QXRCWjQwbWlYU2ZMdVZ2VmZtVWNlSndaSTJrY0FHOVFRdUxwbWxxSnh5UVkxMGptQncyYUlWWW9qR3pNRDNydCtBbGFZUm0rb0ZiNlNOalhuZks4VXVCektObVVsQTFtWDNOZDI2WHhReE9UcElqZVo2cmFiN29QYXEycmpYSnNlQ3plMTQyeTlqSVdRT0FDd3VHK0I3VXFMSHlSeXRJR0ZyZlFlQ0tpU1RDSlFpbTVZOXVUVVdWWHhEbEU0VTdHKzlxeStqc2JMdDhaRm1FUWVLNnNENng3RDJxdnpCRWh3c3NvVmlSc29BM0xHcGVYWVpZbFozRzNHL1lWWHFZc3h6a3FKSEVXSEZ5TzE2S3RpeWw3YUxMTDRCZ01MRWpzRWswK1kra2QvbW56T21IWWhtWlI5UmpibjdpcXZHNDZOUVl0YkxwTzF4ZTQrOVJKOGZKalFHMVJ5RW13MzlRQXFTbVJLU1hCZTRYTVkvd0F0R1dVQU9kUUpGUmNUamZPeFVucUVpajlLN0FWQjg5aGhJRldOM2REWXNvOU52aW44SGhua3VaeUJFOXlDTnJXcGxFaWRtbDZDaC90SHJycHJCcmZVK1BqdjlodWE5N09HTHNkWVhjN0g3MTRUOElaWTVmRnJwRkVCS0RIbjkvU2E5MU9JMmRpMjV2WFUrSzJxRHM4eC9WRGNzMFQ0VGt0NkxXc3YwZ2IzSHo3VVd3SjcrNTdVWUZ2cFBORmJZMlBmZjcwODVFNnorRmRqSCtJcm9PMjlzdzQvOGpWaGVzdCtxODg0QU9QeE81Ly9BQ3JWdFB3dU0wUGo5MFF4RjlHUE54LzVHM3JGOVhDL1UrZUFEYzQrY2cvSG1OVTM3S0cvdU0vY2hkTjdnZkZGY0FnbitkQUVEWWZ2UUxlaHpjQURmZW9SeHRQQ2pMVXhmVmtlTm5YVkhnMUpqQjNIbkg2Yi9ZWHJwK0paR2trYzZnQndUdnh3ZjYxbVBEL0tvc3Q2V2lrY0taY1NUaUhtWHQyVmY1VnE4SVpKTU9qeVdCRGhDeEg3M3FOc0NvejJJS2NMaHpkNXAxTTA0UFpSOUlINzFXNVhnNWN5elZzUGgxSmFPSXlXSFlLTG1uMm5mTXNkUGpIOUxTUHBVZXlMeFY5NFlZTjQ1OGZpVkEvTllrTXFsdVBLc2IyK2Q2YTNRSkhvcndueFVjblIrSDJCU1hEZ01Pelg1cFVHWHRsMGVKakZ6SW9mVGJnZXdxcThPTUErWGRCWU9KbkxTaG0wL3dDRUE3Q3RNWmt4RVNPbkQrbHdmZXFqZTB0UjRSYjlOenF1Q1lLTldrRFk5cXZzUFA2QVIvS3NqMDYvNWI4ekYvZGNrRDRyUjRTWU5FdGoyK3FtYnJCOGsxNXJnYWFEU2krOU11d1AwMEwwL29PRU9sOWpwMkZWUFdIU21UZUlmVFdJNmY2aHdneFdXVFhJS24xd1NkcEVQWWoycXdMZXI0bzNGMUFGaDk2Vk9uWTEwenl6SCtCL0ZSZFRZTWY4VllmRWRNeFRvem1WV0UvbDM5UzZiV3VSdGV1RmVNdlFjbmhuNG05UWRPRmRHSGdtRW1HYTk5VURnTWh2OWpiOXEralFhNXVUZTNjOEczZXZNMzQ1T2poUGhPbk90SVVBUC84QUtzY3dCdVNBWGlZK3d0ZGF1Um0zMlFTUjVKWlNHTnpTazM1NW8ydGMySGYzSm9ndDN1UFRVdkNFRkJqdmVybnBIcTNOT2crb1ljNnllVkljZEFyb1BNVFVqcXkyWkdIc1JWS3JYWTczcGFuY25hOXUvdFMzOGlybzlSZGI1N0huWFF2aGJNb1dHZkZZR1RIR0ZlRkpJVWdmRjcwTXJpY1lhTWFWVUlEY2RnZmlzSDBybXVJenJwZnBXSEV0NXd5L0NuQ1FvbzNWQzE3L0FNNjZKaGJhWTBRZ2x1RDdmRlkycmx1bFo2UjRQRnN3ajNxaE4zWTNKMnNPQlQ2Z0NTLzFNZUNLYUNzWFBwMUcvcStLVU9icHNwR2svZXN4OW5XcFdLc3BCOU5pZUwwbkU3c2JxRllXOVkzdnR4U3BCNVp1RjFXSEh2VEVzaEtNMTlsM3Q3VWc2UkJ4RG1RRjNzeHZhNHFueHEzRnJYSjRxNmR5c2JlbXdZMzFlL3hWTGozODArbFNxazJGdTFXY1ptNTFTS1hORVIyS3NEZFJ2YmsxbVhBV2ZTVkFpdnVUV3R6QkEwVGFsR3RWc1pGNHJNNHFMVlBJZ1k2eUJwSTcxb1krams5VXZkWjBMb1RFbVo5R3RodmZhdWtTU2VkR0xYSUhHM2V1UGRGNG9ZZkZ3a08yays1N0N1dVpmS0pjT0EzcFp0eDl1MVVjcXBuVytQbnZ4SmZRRmlNdUZETnNRZXg3M3JMOVJSSHptY0VnZ2Jnbm41clZSUmtTU0l3YTVGN0RpcVhxRENsMEIxWDBqYlYzK0tpZzZmSmN6cTRjQ3VrYzVPRmxnSllCb1dFMFJqQjJLbTRKK2RxK2dmVE9keDlTZE81Zm1pRUZjWEFzaDl0VnJFZjUxODRja3hZdzJORWNwYU9QVUxHM2UvMDE3US9EVDFPMlk5TDQ3S1o1QTgyQW4xeER2NVRiL3dDZDYzL0haTnM5clBQdlA0Vmx3S2RjcG14bnczOW1kUU9WaTBJSEU2dU43ZzdHdGNyaVFCaDlKM3ZWSDFSR0lWdytMV1Jvd0c4dGpiWUFpMXorOXFsNUZONW1CVkMycGt1cCtSMk5kUEwzY25uVU9KVVdWQ2hRKzlWN3NuWGRDSlpVaGlaNUcwSW9KTFc0ck1ZN3FlV2Fab2NPaGdqR3dsRzVQMnB6clRIZmw0c0xoMkJJbFlzMmxyY1ZUakFITVRCSGhwWkk1cERkVzJJWDNxeENOY3NyWk1uTkRBaGFUQzNlODAwbHlRRGRpYjdWcnVuc3FiQXdIRVlrSDgxTXRpcHQ2UjJHMVNNdHlmRFpUQ0ZoakpjbjFTUDlSUGMvRlQ3QVUyY2wwaDBJTmNzRkNoUkVhaUFMMytLaUxEK3d3YkVuNDVQSDcxelhxbnExYzh4a21Bd1Jac0ZobjBPeTdtZVRzbytBYXV1dU0rWk1LMkN3dHg1aW56cG9qYXdISUZRL0R2cElZWkV6ZkV4R0ppdi9BQ3NGdGxIOTloL2VQWVZOSDI4bFNjbktTaEhvc3VoK2p2N0RXWE1NVXFuTk1Xb1hUYmFGUDdpKzE5cm40cm4vQUk1K0t2a2lmcGpLSlQ1eldqeCtKSE1TbjlDa2R6NzlxMHZqTDRucDBQbGJZTEJ5TE5udUxqdEZIMmhRN0YyOXZpdkxMU3ZLenZJOHM4anlGbmtZM0xIdWF3UElhdW5zaXowRDlQZUhVMnMrVmNmQVFqaWlJUlA0YTNObDUvbWFSS3gwK2xiRHZiYzBSYXhaUVBxTnQ2ajJlTmpjMlZUWE1TZHV6MDlLdUJUT0JwVUVJemRqVGlYVUVvTEVEays5TkVJcmxIUXNiK2swbDBERXFDeVUwY0dYYVJiRnQrZUw3MGxwRkk0NEgxSHZRVnJyZS94Yzk2UUFRb3Q5UWExSll0QksycVRZS3g5clUxTElwWFNVQmJiNlJhMUxrdUlnb0lZZ25VVFNWVmtTNEMzTEFBRG1taUNBTkRKNVk5SjRKNHZVb0RpeTJJN1ZHVGFJWE9vaS93RE9uYnV0bXZhd29GajJSOFhxUmRhQ3pjRUNxekw3czBtb0FBSFVYdno4Vk54TXpJa2hVNnJrRS83VkJ3WVJZaTlqZlVmUzNBb1lQc2tTN0JodVMyNCsxUmtkZk1IbGhpNDdQeGFuWkNIYlN4SUs4SHNLakJZdnpUZVdTdHJFajNwRUVrTGdrTFNTZWtXSnVMMy9BSlZXWjNNa2VNYzZGQktBZW9uaXJRR05UcGU0QWE1SjcrMVVmV1RxWk1DYjZXZFN1bGU0cVNLdGxUVU5SeHRqN1J4bXlnRm8yR3RpUi9sVlZtV1hMaW8yamtWRVd4M0E3SDNwckNaOFlKQkJQcXVkbFlyY0FmTldRbFhHUWwwY2JnN2plKzlTMU9MdEZLVHhaWTB6bUhWSFRUNVpNU3Foc08zMEVkdnZXVHhPR2FJRldBOU8vd0I2N2JpTVBCamNOSmhwN2tkaXczdlhOZXE4bS9zekY2TnlHRjFKNS9hdFRCbDM4U1p4dXYwSHBlK0pYWlJqU1FWTHNHdGExOWg4VlppZGhGcmF3Qk50SiszTlpLUXRCSXVxNElZYXJjMWVRWXhXdy9sVFdaQWJpUzEySHhWaWNWZkJrWThud3lEak5hU2EyVUpjK2tqZTlkTDhMcy9qbHRCT1RGS2gvaG9OOVorYTV2aWZWRVNwMUJUcHZhbk1penJGWkptVVdKZ0tob3p1WEhidlVlV0N5UUx1aTFIK1BxRS9obm9iR1NGQ0xycGNibGszc1B2VCtXNFZqSnFXTWxkT29mUHpReVo4UDFSZ284ZGg1RWVBS05hQTdnLy9BSHFSbURTdzROc05oWXlzak4vRWM3S3Z0V0E0MDZaNmZpbkhJdDZmQkh6akZzRmp3MkhJZVI5aVNkazk2Wm14TVdXNE1RWWU4ak45YkVEZW9NMlpZVExrS01mT3hJRjJZY0thenVMemllVncwYnJxWVdCUGI3VkpHREsyWFVRWFRKK0t4UnM2K3B3MjREZHFUaDhRWU1JVEVsNUNwdVQ3MVVMTVdhTlhlUXlqNnpjZXFyU0tVZW15a0JuQURjM3FYYVVvNWQ3dEYvSGl2eVdIZ1RRek9Qck85T25IeVlxZlJzVnZZSGdEYXE2REVSUEtxWW1mVWlLVkNMeUtmaVpFbEloQVplMGpIZ2YvQUhxdlJwUW1iendua01QaXAweEtBRThxWjVQc0FocjJNdlVxTUxsbHZYaWZvT1U1ZjFmbCtJVWwzUlhKY1YyTTlac3BPaG10L3dCMWF1a21vUjVQUHZQKzdPcVZuekZ2L3RTVzRORzI3QzNOK2FVUWJHMWFoeHAwMzhOSkk4YytqdFJKUDUvdDdhR3JIOVpBL3dERldlVzJINTJZMi84QU8xYXo4T1Q2UEc3bzAvVGJHa0UvK1JxeXZXWlAvRmVkaGxBdGk1UnQvd0I3VksveEczY2pQTGIxVWlYNkQvclJnYWsyQkZXWFRtVk5uT2Y1ZmdMQUNhUWF0WDkwYm4vS29XT09pOUxkUlE0YnAyZVBFaVY4YXFnR05VT201R3piY0czYXBPVTlVejVuZ3NabDJYNFBFUFBpUDRhNDdFTG9TQkRzN2tkemE5cTBYVGl3NVAwcjFUajFzNityRHhTRlJ1U2JDMzh1YXE0N1lhR1BUSGJTQUN5dDlXM0grZFJpRUhFd2lLVVlIREhXU1V3MEFVMzcySDc5NjdiME4weW1TVE5BOFlaNG9sakN0dWI5NjVkMExoVXhQaVYwOUF5YWtPSU1yZyt5b3hydk9IQWl4VTA3QVhaajZ2aW81OElrajJYV1dUcGhsMGFmUXYwcU9LQ3lOQm1zK0hYMUpKcGE1N2ZhcXNTcWNVaU05bEc0STcxWjRwaEsvbXhFWEZocXFxK1NaRnJHb1RFcElsOTdoaWF2c0JJQURFTjlIRlp5S1VGV2E1WURodmNmL2VyakFUZVc2bTkxSXRmdlViUTU4S3k0QjlGQkhOanBPL2VrQmd5YzBGYXhVVzJKcVFaZGpwRndEd0tBVy9Cb05jazMrbjJwWkEwZTFLblFEU2dsckhnYzFtZkZqcFUrSVBoVDFUMDhGRFR6WVg4eGhkN1duaTlTbitRTmFnQWhhY3crSUdGeEt5Z1gwc052Y2Q2bGpMa2phUGxkRXhlTlc5LzBuc2UvOWFNZ3R3ZC83MWIzeDU2TS93Q0FmRnZxSExFUjF3ejRnNG5EbHYxUnllb0hiNUpGWVFDM2UvelYraGdRRnIzM05GSVNJM0k5dWZhalU3MHBJamlaNFlCLzRraXJmMjNwc25TSHdweVNPM2RFNFJNSW1XWWNGby9LaEJ1QjlWd0s2REhHWW8xV3cxSzE5dVQ4MWtPbFlWaUtNMXl3VVJqNEEyclg0Wm0yQkphL0JyQjFFcmtldGVNaHR3ajBMb3JrV04xM3VPZjNwVHQ1bG5hNmhqeHBzTDBraHhMc2IrNE8xT0J2TVlJVjNiZTNZVlNObGNEWUNzbHdya0RlNHB0eHJZTW90ZmtYNXAza09kd1Y0Szk2YWZ6SEtvV0FaYmtHZ1ZrVEdDSVNOYU1xZzNWYjNGVWVJa0hsc1VBVWhqZmFyckd4T1VVSWVUdWFvOFZFMG1FWnJnN2trRGsxWnhtWnFYd1I1UDRrTWdZc0xpMXdLeVdZQlBNSlM2RUhuM3JYNFhTSXBIQkxrZm9idHRXY3pHRUppWkpDVklZQ3lyVjNHem5OWkc0cGptVU0ySGtqMHN2cTdNYlYyanA2ZHNYaG9TVlhRRjBoMTV2OXE0b0FGVkE1S0ZRTC9mNHJwZlIrSUp3eUtYQzNQS0hnOXFoenI1TkR4a3F1SnJzWEo1ZUtWOWJXR3ovSXFObWNDeUxvSURLQnF1VGJhcE9LWTRpSUVnRThiQ2tTdXh3dzFlcGxCVUtSVk5kblR5WHRvNTVJbjVUSDNzQ291ZE4rRDJOZWdQdzFkWU5rdld1QmdsYlZEbUMvbEdjamZVVGRML0Y5cTRSbnVCQW1Ma0VKYTVzYkVWYWRHWjNObCtZUVl1S1l2SmhwRmxYYTJ5bTR0V2hnbHNtcEhMNjNEdnh6eHMranVhWVA4N2dNVGgyR3BXVWpmMzVGWlRwSE1ERmpZNHk1WVNvVVpUdHBaYTBQVE9jcDFIa0dYWm5IdXVLZ1NVV1BGeHVQNTFqYzMvOEFvUFUyTFVSNnI2WjRRcHNTQ2Q3ZnZYYVk1NzRIajJvajZVNmZ3em9sQzlxYXdtSVhHWVpKby9vZFF3dlR0cmY1MUcxWEE5OGpPSndlR3htbFpvbzVWNVVTTGZidlkxRndtUllQQTRnVHdxMGNnVXFFSjJHL2FxalArbzVFa2JDNEltUFF3THpFYWdmY0N0SGhwaGljUEZPdGlKRjFYOTZrYmRVTTlzbU9iQVc3MEtGNkZqdFkyQjROUjFaTGRoaFN4MjNOWjNxWHFBNFpUaGNLMzhVaTBzd052S0ZTYzh6Y3hSeVlYRHlCSnlMTkpmWktxc2t5UnN4bUxUSC9BSlNOdnFJM2xiMysxVFJqOGxlY3ZpSW5JdW4vQU8wV2d4T0o5V0NpT3FJTnNYYjNJOXFmOFJ1dk1INGVaREpqcGdzbU5rVXJoTUlOaksvYTNzQi9sVmwxUDFObC9SbVN5NW5qM0VXSGhXd1ViR1E4QlZIOHE4azlZOVhaajF6bjgyWlpnbmw2dlRobzlYcGhUdFllL3ZXWHJkVXNTY1YyZFQ0VHhFdFZQMVpMMm9xc3p6ckZaem1tTXgrWVNOUGpzU3dlUm5iYmsrbGY3b0E0cUhJeGxYMEFxRkhQRkRFc1o1dDdjN3NLUklyWDBLMnBWRngvNjF5VXBPVHVSN0JpeHh4d1dPS3BJUTU4c0FBM2FqUlM2RUVYQjVwdXplZ2tla1hzZmMwc1N0YTl0SlBOUk1sRVBHRVZXTE5jRzVVMFVzcFovTVN4TzNwUEZKWXV1a3Y5ZDloMi9lalhRd0lmYzdmVFRiRm9Jc3Zsa0VCZTVIelNQNGlnazIxZlVCN2UxRFFTR0pBc05pYjcvRkJDRkFWaWJXK3FtaWpTcVdKSk5ndnFBK2FUTkNiQmg2WDVCOTZla1VEZzNIY2NVWmlXV3lBSC93QXhvRW9pcEdyRyt1NUcya2NYcHhyaUpVREZyRzRiL1NrdEcwYjZDUVNPMXFjMEtkaHMxcjdVQ0xncmNkYnlTeEFWanNSKzlNWVJVU0I5UTlZY2NlMVNNeWJ6SXJ1U3BBdHVSVWFBYTRnUTlyODNOREFEdEdYTnd3WFZZN2MweE5CZVVGbU1US3dJUHVLa0tXREZWQzJYOVhlbzJMV1dZWFp0UVU2cm5ZL2FrUXJkZ2pYenJzU0hONzJJNHJNK0wycUhJTW94VWN2a0dQRmFiamc3SGF0UGhtZU5YSi9Yc2JIZ1ZuUEZ5QTRud3l4OFpqTEhEeXh6Um0vc1NMLzFxemcvTkl5L0lwdlRTY1RtaDZpbHhJbE1tdUtjamRMK2svYW1wTSt4R0hDeXdPNnFEc2l0dHE3bXNyZ3N6TWtZRWhON2M4bXJDTms4cEZZaTk3N1Z0T0NaNXF0WFA0Wm84TjE5ajhQSXJUS3VJaGI2dy9JUHVLdnNaamNIMUpscGNldVpCWkNSMnJuczhTRlRja0FqdDcwNWt1YVNaYk1pdTEwSnNSMkZObGpYYVJaeDYyYy9aa2RpY3p3bWlYVHBzV0c0OXFpWUtRWWFTUkg5U2tEU2I4Vm9Nd1ZKMDgxR0xCcmlzOWlZcittNURLZHIxSXVlelB5TGJOdEV5VU1VdGNHL2U5TVJ0WndOTzNmZWt3emgxRzkyNHRTMkY3RW0zYW43YUlsM1piNUIxSG1uVGVKLytuNHhzT2pmcE82bjdpdFN2aUhuV05Sb1o1UWw5ektPWCs5WVJEZGxLMnVOdlVhdGNGUCtVbER0b2NOdDZ0eFVFNFFmd2FtbjFtYUh0VXVEVHg0NThVTHl1ek9iRWtiYlZKbWxEMlFqeWY3aXJ5VDgxQXdqSXluVkhwc1FiS1BUVTg0Y1BMNWdRNlNkbTFXMG1xelMramF4eWxKVzJPNWZGSmlKUnFVbC93QlROd1AvQUwxZnd4M3hrYXhzVzBMZlZiMGo0cXR5NW11Z3RwSk5oYzFNaXhFZ3hjdW16TVFJeVJ3TFZXa2pXd1ZGV3gvRGhoTEs2d1haUnV4RlNvSkMvd0RFTm8xdDZsSGVvV0J4Ym1CMXhBWlRJZDVBZFNqN0RtbG5DdTVIcjFRb2ZVZUN3cXU0bWhESUp6cnJhRG9tVEM0M0V6TEVabFpZd3BPb2ozcW5iOFIrSFVrQXp1UGNMV044ZE14aXhHZDVSZ1l3Rmp3K0dMbmE1SlkxemhVdVBvL3JXenA4UzJXenozeUdwY3RSTDVHMVlYSXNmVHNEU2liZzIvbFNCZmJjODcwZDdFMWNPYk9oZUFFZ1h4ZDZYazFGUitiSXNCeDZUV2M2dWZ6ZXBjOGxOaXo0dVFqYTM2MnE0OEYzTUhpVGtFcVhCU2NzTGUrZzFRNSt4a3puTVpEK3VabXVmKzRuL1dwSmZpTnIzRk1GYTloL1d0cDRaWUx5c1RqczNkdEpnVHk0Nzl5UnZiK1ZZbGphTSs5OWhYVDh1eS8reU9qOEZoZ3RzVks0YVErMnJrZnlOUXNjYmRZMHd2UU9XNGFTTXF1WVk3ejNKN3FBVHAvbldmU2N0aG9nTHFOVFg3M0Y5cTBmVWtnZ3cyVFlTTUV3NFJMdC93QnpjVmxNTk5hQmh5UTVBVTlxakExUGh5VVBpbms4Z09rK1hLZytTVU5kbXpTWllNMWt3WUpWZEkyLzFyaVBRT0lTRHI3SkdjZ0c3QmI5eVZOZFc2a3hvaDZ3S05jckpFTnoyWUFiVkhOV09USkdIbmNZaVdNRzBzZkhlOVBmMncyQ3c4aERFdWpmUTFRTXBsOHpPV25jYVIvZEhlb09ma21WN2JxOG9VRHZ6VVRpU2Z5ZFV3RXBmQVlkMkE5UURnRHY3aXJmQkF4NGpZZWphczVoOFJwa3dzTVpDb2lnV05hYUFBQUJRYnFMWHFKb2s3Ulo0Y2dqMTBzUGVVRzFnZGdLUkc0TEhidFMwRi9WMkRXcGJHMVE2QVJjazdVOG91cDlxUVFPOU94ajA3Y1VBSjAyMzVwaVZiYjc4OFZLRzF3ZUtSSW1vZjdVNks1R004cWZqZzZQaml4SFRYVmNTRytKVnNzeGJLUC9BQkY5U01mMnYvS3ZMYkFqNzk2K2lYanowWC84d2ZCZnFiSzFqMVk3QnhqTk1JeDdTUlhKL3dEelMxZk8zelJOR2tpS1FycUczclNnOXk1STJHcWhTZmVyTHBuQ0RGOVI1ZkdUcFV5YWo4MjNxc1UzdWEwM2gzZ2ppK29kWUNreFFzMjUvYW1UZnR0bG5UUjNaRWp0dlRVVmtWdHl4WFZxSTJCOXEwT0dTNEIrazdrZ25pcWpKUVlJbzRpUXlFQVhUc2F1SWxWOVByWU5lMjRybnN2TW1ld2FXT3lDU0RVRjVScVBxSis0dGFuMEo3cit3NE5JZ1VvbzdFSDFXNW8xVTZ6WTkrNXF1WHZtZ2pHbmxraVFpM0FwS2doVk96WE81dDhVc0JpNzJYWHA3anZVWHpYdW9BNTUrS0JMSWVMSldDUW4wNlpMYm50VkppV0tzdmwyMDM3VmVaa2daTko0YmU5VUdZQllZUUNkS1hOclZaeG1WcXJTb0dGakN3dnFVQXNUYzNxbHhhRXF5Z0F1b0ozOXF1Y05HVzBydWJycTVxdXpDQUJ4YStwamExV1lQbWpKenh1Q0s5ZlNZemNEV0xrT0wxcmVrY1FNTXhVdHFBYStrRGlzcUNrTWxuRERWY0EyNE5YSFRtTE9FeG1waXpOcUo5ZkZqdFN6VzZKRm9wZW5sczY3QkorWVVMY3JyRjdnZHFSRTRqa2xqM2JUc1MxUmNxbWtaRlRZaFFMRWQ2bTRsL0puVnJBaVVBWFBBTlp4MmlkcE16UFVXSFNaUmRDWEJOckgraHJMNFdjNERHUW8zOElYdVc3RUh0Vzd6akJxL25XM0Z0bUh1ZWF4R1k0SzVaTmJ0R3UxeU54VnJHekgxVVhkbzlxZmhWNnhPYjlJWTNJSjVCSmljdGw4eUVYK3FCemNmeVluK1lyY2VLV0dFT0Z3T2NJVjE0YVVRek1Sc1kzNy9ZSC9BRHJ5VCtHbnJOK2t2RW5MTmN4ZkM0dFRnNWI4V2Y2ZjVNQlh1SFBzbGp6dktNd3l5WlZaTVFqUmtuaTl0aVAzdFhYYUhKdmdyUEovTjZiYmxiaVZYUm1aREZaYzhETUJKQzExVGthVHhWdm11R3hPSXdoancwZ2pZbjFQM05jaThLK29wSThkaFB6TjQ1NDJiQlRvVFloaHRjL2F1MWM5N1cycS9OVTdNTERQMUlIUE0wd0dZWUhEbEpJV2FOYmtCVjFENzNxOTZIeDZ6WlgrVlpyU3dFK251UVRmZXRLeTJRallyM042WlhEUXBJWlZqUlNiQWxWQUovbFE1V0VNZTEzWTdZbmdYUFlWU1o1blg1WU5oNFpGODhxZFVvM0NmK3RIbldlTGhXT0hoSlo3RXV3LzhNVlc1UmtxNW1pelNmOEE0T1Rjazh1YVdLK1dPY3VkckJrMlVTNWhMNTh4L3dDVWYxdnE1a2IzK0JWM251ZFlIcGZLSnNkanBWdzJGZ1hnKy84QWRVZDZYbkdkNEhwbktwY2ZqcGt3MkN3NlhhNS8vTkE3bjRyeWw0aitKT044UTgxR0tsV1RDNVZFYlliQkZ1UjJrYi9FZjlLemRacTFpalVlem9QRStJeWF5YWJYdEM4US9FVEdlSU9jTmlNUnF3K1hSYllYQ0EzMEQrOGZjbitsWk15RlZXNUZoeGVrdTNwc1RjM3VUNzB3emxwQi9kK2E1R2VhV1NUa3oyRFQ2ZUdtaHNndUFqYldkdWQrYWJWOUpJQVBxTnFkeEZtZEJhd2JsaFNFbGFFdU5BS2thYiszelVObHBjQ0ZlUVNDNDFIZmFqUjJKUHBOaDcwQ1N4RmwyN3RlbE00MFhZbGxPeTJwdGpyRzBiVkdITEVrbnR2WVViQVNBaU02R3RjRWJYb3lxeGdnYkFpeEE3MFJWcFNsL1FJOXdmaW1palFVdHF1cHRZWEFwV3had3JEUmZZSG0xRWp4bHBPKzF3S1NDZ3RZNlNSdGVnQlRSeHZwT3JTbllIbWlWaUJwWVgxOEc5cVhNV2tXUFVGWUwvZDVxTkxNN0lvQ2JHK2hoMm9FNUZPNGdOaVRxUEZqYzAxTTNsSW90ZHY3MTZPUWdsTlh0WWdlOUl4RVJMS3BBSTU5UGI3MENFSE1sODE5S3FDZ0c1UHZUY1NhSURxMzIra2l3V25NVSt4VmdWT3E5eFFmYUlxei9YYmExREFUZGRGaXkyNzJPOVI4VUkxZy9odUdzZlVMODA2RnM2cnBCVTdYdHpVWlZVTzZXMGxmMTI1cEVJTW9kREZRU2RnUllYMnBYVkdBa3pEby9OOFBvOC9YaDJZUmcyYmJmbWx3dUVsSTJHMm8rNStLbjRQVGliNGRpeWlSU2pNVFlBRVZMamUyU1pWengzWTVSL2c4bXRobThzUzZTRnQ5cUVHTmxoc1FwZFBiMnF5akNvWmNLMXlZWkdSZzN4VlhtRUJpc1VQb2JZQUd1bStEeHZJbkMxL0pZeFl3WWhkMkMzN0UwbVdOUXJjajdpcU14SGpVZFh2M3FkQm1Va054TTEwVWZVdzJBNzBWeU5VK0xMZkE1ZzBTckJJdzBqWmJqbW5NUWlrR3kyWWIzcU5tbVU0L0tsd2JZN0E0ckx2ek1Zbnc3WWlJcUowUDBzcE94QnBVR044MUkxWmQ3SG4zRzFOY1hFbWprc2p5UkNGaVJheEYvVDNwenpSSVZRWDBhZWU0TkxsUUFrZHVhaXRyVTMxYmRnUGFsR09USmk2U050LzlLbVllUmRTcW9CWWJnR3E5SEEyQS9sUzBtTWJsaHhhMTZZeWJIS25acjhIalNvdTBUS290dUc1L2FybURUTE5INm1raVkyMDhFYmMxbHNseHFNOFNTblR6Y252VzB5dGNPU3BYMVNEYm1xV1hnNlBTVDlUaE1sNGFDRkhzZFZoZXpXdnhVckRUTGg0cEpuQklhOXR1OU1UUnk0UENNVUlUVWJBamdYUGVrNHpIU1lKRWkwREVRdDZRQjI5elZXck9naXRxNUVySUpCRkVHZVc2M1BhcGtFN00wS3NyS3U0M085VkQ1Z2szOFFqeTBPd1NNMklxVGc4ZUljTytJdUx4b3hPcmUrMjFPMld5dTlRbzdtY3A4U01ZbWFkY1pnNE9xT01KQ2x1TEFiMW4wd3lNTGhkWHpTbm5iRjRtV2N0ZG5rWjJ2M3VUUnI4TVFLMThhcU5IbnVkdkpsbElyK1R2UjZnVDcvRkMyOTZUcHZmZlk5eFR5bWJQd2tKUGlEa3FxeGpZekhZRGY2VFZObjFobkdQR200V1JoL1UxZCtFZTNpRmtSdlllYWJOMytnMVJaNFN1YzVnQU5RODF6ZnY5UnFTWDRqWCtUSXVSWmFjM3pyQ1lNTHM3M1krd0c1cnBrazV4K2VZZFl6Y2VhRkN0MnNCMi9hc240Y3IrV0daWmlVSmFDSHlZaWVTemMxcU1xdzdmOFI0UFV1bDBWUzF6ZmNtNXFGampWNTlQK2F6TEZ5dFlxcnBIcFUyM0E1cklZV1JoUGlFUEFjbmYvT3JZWWhweGpqZGRUekY3L1k3VlJuWC9BR25jY3VwdW8yM3BpQXNZczJHVTVsZ2NjMTNHSGxEQUx6dnRYWXVyOFhIbTJXNExOTUcxMkNMSmU5L1QzcmcrTWZRU2hQeVJ6dUs2YjRaWnF1WjlLeVpmaUdNandncXNaSDZDT2FKSzBLalU1ZG1vL053U1J1Q2tnQnY5eFRuVW1wWnN2TWJCeCtiUnJFL3pyS1pKaW13R0pndzdyNjRaUkdRM0FGOXExWFVDcC9hR1ZZZHYvd0FickxLT1JiYzFDU2ZCdnNteHhrRWtzaU5kZDdMdVFLMk9UWS9ENXJnNDhWaHBOY1lPaHhiZTQ5NnluVFNtUHBxYkZrYnVHWFZ4KzFNZUd1YVI0WEc0ckwyZXp5eUdTSTZ2cVB0VVVrS3BNNlJoaU5nZGgzdFVnTDZrSFlYcVBDdWxsSkl2WWg3ZGpVbFZCM0JwZzlqb0Z4dnpUOGFncFlXdlVmV0ZGK2FrUU1DdDlOcVZJUUlqYysxSkxGVHQ5cVV4QjJOSVhkamZnVTVVbU5hc2R3SWhseHFSWWdBd1RYaGxVOE1qZWxyL0FMRTE4d3VyZW41ZWsrcXM1eVNkQkZKbCtNbGdLK3dERzM5TFY5TVpTVmNFQzdYSDh2OEEzYXZFZjR3dW5QN0Q4YUpjZkhHRWh6ekNSNDRLT05lNnVmM0lxN2laRStHY1NBQmIyMzJKcmRlRm1EZjg5alp4c2hJVFYzTmplc0t4c05oZTQ3MTFMd253Z2p5NVpQcU16c2JlOU16dW9Valc4YkRmbWlqcU9XaENpaVBZRnQ5VzI5V2tDT0ptTGdPdzRBNXFKZzAwdzdDNHZ3ZWIwK2lhcEd2ZTlyZ2c3MXpzbTdQV3NVYVNKREt5T0xNTkp2Y0RuN1U0cm9wdTQwQW5tbWtQbUE3YWY4NkVjZjVrcWlkdmVtRTY1QkZFVWFTeFZyQzRJcGtxdmxxUU56dWFrUG9STHBkUVYvOEFZcGlKZk1XNUlGbElvRWFvaDRwZFNoUjZoWTNCN1ZtODBZcVZSazlJMkJCK2EwR0pDb2xyczExT29Hc3puREY0anVRWXlDcWp2VnJEelpsNnQzRWs0UmxlYXdERkxXdWUxUnBZMURXQ0J0NzN2WWluc0xpanBLbFdWakdHR24zK2FWSUpsV05SR0ZMRDZpTDFNdU9TaTF1aFRLbkZCSkMrbFNDcmJyZmFpaEp3Mk9Dck1DajJJdjcrMVNjZmhGU1lrSXdsYTE3Rzk2Z2dFcmFRRWtOdXE4VytLbFhQWm12L0FGenRIVWVtTVNId3c4cVVQdmQxSDZUN0d0QmowRHdoVlVCTm1QM3JCZEpZNUZaVEcxeEw2VDJCSXJlUlloOFUrbGtBaVcyc1ZRbWtuU090MDgzUEdtTjR5R1Q4cEUwa1VrT29hMGRoOVE3MnJHWXhBa3JvNTgxR0pONzJyYXNUTkkwRTByeUdNRVJiN0tQaXMzbldHREg2U1F1L3RTS1ZNZm1odWd6TlpIanBjQzd5WWRUR1ZjR05pZHd3NElyNlErRi9Wa2ZXdlFlVDV2R3daNW9sU2NnMzB5cUxNRDgzcjVxNHAveU9MUXg3Uk85d0cvU2E5Wi9neTY3WEVMbkhTY2tnY3F2OXBZYmZuVVFzZ0gyTnEzOUZsMnVqenJ6T25jOGU1ZG8wdlYyRi93Q0dmRlRId0FxdUh6R0grMGNPTDJHdjZYRi9lNERWMmJwM05Cbk9SNFRGOG1SQUh0MlljLzVWemY4QUVYbEREcGpMT3BzTkhmRVpIaWcwdnpoNVRvY0gzc2JHbi9BL3FOY1hoc2ZsTHRxa2lQNW1OYjN1cmMyL2NDdXFrdDhkeVBNOGN2VHkrbS9rNm5mV3UzMnJPOVM5UmpBWWFhSEQyTXdRNjVML0FFZkgzb1o5MVhCaHAzeS9Eem9jV2x2TVk3Q01INTk2cXNyeUU1L0t6NGl6WUpYdVplREtmN28rUG1vb3I1WmJsUGxxSTUwNWxFK1l0Rk5NekRDS1JmV2YrcVQ4OXhXbXpUTThGMDVsTTJOeHM2WVBBNFpidElTQUFMY0Q1Tkx6RE1jRmtPV1M0dkZ5SmdzRmhrMU81MkNBRHNPNXJ5bDRvK0pPSjhSOHlVSVd3MlE0ZGorWHd3SC9BRlA4YmZmZXMvVmFxT05VYi9pdkdUMXMxeHdJOFJQRkhHZUpPWjZ6RytIeVNNbjhyaFcvVUIrcHZrMWo5YlNDeDlScEphUXVTeWhSNyt3cHVSbWE1UVdJSEpya2NtVjVKYm1leWFmU3cwc0ZDSFNEZHQ5Z2RLOGlrZWFwQUlqTnFLUm5WRUdvSHQ5NlNHYlVTMWdBUFNSVmVUdGx0ZEJrbDF1SEFWVHRSVEV0SUZMZW5rbjVvbVJpaXVBTERrZTlOelhRYTcvR240OTZiWXREamtSa2dYSGYvdXBMWExEU1BTMzZmN3RFSTJDZW5leC9WU3lUb3Z3eDRwQW9XN3M2Q3lXSTV2M3BsSkdoa3V3RDdicmVpYVJ0SUpOcURzR1JtRzV2ZllVRDZHd1ZVRnZJS3Y4QWVpMEUyTmdOL3BOTE02eUZRd3Mzc2U5SmRuVFdGSXRzZCszeFFOZkFqVXhaU3JjR2tQSXk4THFzMndIRk9IVEhHUmJTYlhOUm5sQklVQUVrY2cwRFd4eGdidWJEMGk5cU9ReVJhQ0FOT3pHZGVQdFRBWU0ybDJPMTdtOU9TRFhoUXEzOTlKTkFMbEZmaThUNWtoQklMdHl3KzlPbnl5cWhCcUlHM3lhUzhZWFlDN2NuM29GMUtsTEVLUDd2TjZCVXZzS1pSRTJ5bjFEMzcxRlpidUE3QU0yMXZhcFU4SlpZenFBQjRBTzlRWm1WcEZWQ1pHQjcwQ0NDbWlXM09qM3FYQklzVjJVYWRXekNvZ1ZocWJhOTdFR3BHR1FCZnpERWh6Y0JCdnY3MHBFK2VEZzNYV1duTHV1TTFSYkxGTEo1NmdlekM1cks0cEM3TEdOMEhxSnJxUGpMZ1JIbWVXWSs0UDVpRHl5UjdnN0d1WkVhaVM0dTVPdzdWMG1PZTZDUEpOZmk5UFBLQkQ4dlZjOEcvZWtZdUlma3BqYzdSdDIrS3NQeTF4YzJ1RHZTcGxBZ21VRFVDaEZ2MnFWTm95OWxJK3EvUS9objAxNHNmaHY2RnlucWZMSWN3d3JaSmg5RWppMGtUQlRabGNiaTFmTURxM3BlTElNZG1FbUJ4WG40WENZdWJDU0szMVI2SkdDbjVCQTVyNnYvQUlhOFRIamZBVHcvZTVhSCt5WWtrdjdDNFA4QVN2bXI0cjlPU2RDZUsvV1BUMklSZFdDektYK0dXQkJqbC9pcmY5bkZYY3NGdFRJTWM5ck9hUlRyaUV1ZnF2Nmg4MDNNdGpkZHh4U3NiZ0d3VXZtdzNlRzJ3SDZmZzBTU3JJdGhZTnpwTlVTNG1wQnhFS3UvQUZoVG0yZ25ra1UweTZaTitiY0hpakRhckFIN2p0VEdGMFNBd1ZnUmZVTnhZMW9NbjZsYkJ1UFFIQU85OWlLemlCUUw4SDRONlVpSDBsV3VwN0dtdEtYWmN3NXBZWGNUb3JkUndaZ01ORXNtcFhPcDFPMm0xUHk0dGhOZEpFQ2hUYTU0SHpYUE1QYU9YOHdTUVFMQURpM2MxUHdPSVdVRm04emMzSU5RUEVhK0xYdWFxUm80NUVnbjNkRGNCUUFiMDExWG1uNURwdkg2QVVsY0xoeElQMVhQOUtpWUNWRmNSbExxRHNEd3Y3MVQ5ZFpnczBrV0hTTmxMc1hOenNiRHZSR0MzQ1pjMjNGSm1TVkZqalVXM1FiaXJEQlpTY3hoODBIU0w2YkUwMWhjTnFKalZUNWptd1U5elZ2ak1mRmtEcGdud3VxYU5CNXBCdU5YZXI3YU1ESEJ0V3pIMzJCK0tPOXh0c0tTdTZYUGJhd29nUTF6ZTN4U0ZGZG11OEtWQzlmWkliblMwcC8vQU5UVlBubHY3VnpDOXd3bmt0Yi9BTGpWMTRWRlArUE1tTXBJakVoSitQUWFvODFEUzVwaVVGN3lZbG94OGt2MnFTWDRqZjN0R3Q2V3c0d3VSNVlrbXl5ek5pcHlCK20zcC95cXh5V2NTWnUwak41a1RFbEpVYnVRVFkveXFSZ0UvTFJqaVJTQkVxZGdxaTFxcDhOSEZoWllKRmlRU3RNV0FqTmdSZTI0cUFjaXprdEhpSHc0SkJLQnI4YXZtbzJZTnFoMUxwOHlFZ2c4R3BPWmFZOFEwcldFZ2J5eVFOMXZ3S1EyaVVGWEFFWnVwMjN2YWloYUt6R0cwaEpGZ2U0K2EwSFJXUHhHV1l5ZkZZZHY0c1FESXJmVEl2NmxJL3lxaFpTU2lFaHBFSkJ2d1NLbFpNNFR6cHRUZWhnYkR0ZWtZMDZKamN5Z3hVc09NdzRJTDJaa0hJWWZwSXExNmg2Z2l3bVlZSEZ5eG1UQkpoeVhXTStvRW5jVmt1b01xeFdFeVI4d3kwRVlwVkV6QWNPQi9rZm1xckI1MnVmUUk2RFNRdnJpWTdxVHlUOFUyckgzd2Vuc3J6TEJZdm9ITGNSZ0Nac0ppNHpJZ0ozRnViMVJkRFlNcjFtczJzR05idW90eFhOZkNUUGN3T0RPVTJjWmZoZk5mekNEb1c3WHNEODNycVBSSWNaOFJjRXVkM0hZZTFRTldDT3NSc0VKRnRPNWJiMk5URXNRYmIycUQ5Yk1uSzIwMC9ESVhVSDZRTmpVYkoyT21ROEFYcVZCSTJuY2JWQmtjaDNzQlpPVFVtR1QrRURlOUlOSG1QZW13NFZqM0JvMmNNdTE3MDA3aFFEZmUrNG9BVGlHNFlFZ2c3RVY1MS9HMWtINS9wRHBiUHhFTDRQRk5ncFc3NkhGMUYvWUVFL3ZYb1o1cnR1b0sxaWZHbnBwZXIvQnpyRExOQ05PbUUvT1FNM0N2RVEyM3pZR3BzVXVTT1NQbmpJZEtranNyYmZOcTdaNGRZRVlmTHNHcnhncUlGSzZyN0VqL2V1S0lyNGw0RkMzYVNSTEQ3c0s5QzlPeGpDdVk5eVUyV3g1dFJxcFVqb2ZDNDd6V2FYQVhNYXNiM3Z3TzFUd29acmcvdU85UjBESkFsd1pDUGNiL2VuaEhvRGFyRmVMbm1zS1haNmhEOFJ4MFNPU3hKREhZSHRScnBpTHRxdTE3QWlpVkEwYWZMRW52dFNUNlpXMDhXMkI1cGhLaHdnT0ZRamoxSDcxSG5VQU5wRjJBNCtLV3l1NFBLV0ZqODBseXpvZXpnV0gycFFraXR4ZzBJTG91cXh1TDlxekdkcVdUMUd5TVJhM3hXbnhzMTFZRWtnYjNGWlhNWlRwMDYySUxYVlc3RDNxNWg2TVRXU3BVU01GYVRpeXRZRWh1NHA0enBHR1VzMmc3MkhhbzJDYldEWnpydGEveFUxVHF3Z2RnMjVzV0ZTc3FRZnRJazlpUzZ0NjdXRGQ3VldTYVlKSWxBSlc5N2ZOVzB5TWlGYjNjRzMzcURpMEFhTysxN2o3VXFkRmJKRlZaYjlOVFdtTWFxSXlEZTN0ODEwVEtNWjV5RUtOVnh1VDdmTmN1eWlZaWVLUjdLQ056MkZiN0lzU1VJVS9WZllnYkdxMlZjMmJXZ25jS0xtWlB5K0lpY3J5TDM5eFZmbThJbmpralk2a1lYQlR0OTZzY1YvelVObERYVTZsUCtuMnBFalJUWUtPUjB0Y1dOdHJtOXFybXJMbFVjL3pPQmZLa1dUL0FLYWthbHR1ZmFyYndzNnlidzg2NHlYUDRaREhEZ3NUYkVnZDRHc0hIOVFmMnByTzhJWTVTUXBaWEhjY2UxWjJhSXlKSWpBTXJLVk4rR3ZWL0RPbW1jcnI4Q2tuRjlIMUZ6cktNSDFkMDlqTXVsL2pZTE1jS3lCaHhwZGZxSHp3YThiOUNkU1p0MHZpcHNCcmt3K2FaUlBMZ1pzUW01S3FkTy92dFkxM2I4S1hYemRiK0UrRGd4VWdrelRKbi9Jemc4NlZBME1mdXRZZnhXOEQ4ODZoOGZzSkprdXJCWkxuZUZHSnpMSEpzSUhpSkRpdy9VNjZRSzd2U1pVNGM5SGpYa01Fb3phWGFOWDRiWlRpZXNNVjVqeXRKbE1EQnA4UzQzeEVoTnlpbnY4QU5kaXh1TXdlUTVZMkp4TWlZUEFZT05penRZQkZCM3RUV0N3V1c5SVpBc0VSVEE1VmwwRnl6R3dDQWJ1VDduMzcxNVY4V2ZGeC9FdkhuQjRWakYwM0EvOEFDaDFXYkVrZlRJdzlyQzRxbnJOVkdGbXo0anhlVFZ5akY5ZkxIZkUveFVuOFI4ZjVXSER4WkJoM3ZEQzNNeC92dC9wV0hsMVNvQ0dLSjNVY2tVMGpzeUtxc3E2T3k3QS90UlNhNW44eFd1UnRZVnh1VEs4c201SHRPbDAyUFM0MURHdWgyU1ZoNlVXK2tkOTcxSERYUU9DYkVlb0dsTTNrdnFWOVNzT2FPYUp0Y1pDalNSd0tyU0xzZXhwbUxuaTErTDBadUFwVWFpUFNhRHFvdUNwRy9CcEowZ3RxSEJxTWtGRStVeEJGdHQ2TFpqNmR3MnhQeFRiU2VzaGh0YS83VWJNUUNMV1ViaWdHS0xCNWpaOWgvZW9tY2xqWUUyRnlhSVNSYWpwdDgyb2ppRVI5V283OSsxQWxvVTh0a3N3SHg4MGJrcWdJVXFCN1UzcExXQmNtdzVOTXZJenNxRlFTUjlxQjlvVzdLdzEydVIzcG1RbEZCVmxMRTNJcEVzMGFSc0xYWGkzZW80bFVLQWRrTzYvTkJFVFpmNGdPbHZxRnQrQlVLWmRPaGd3MjJKRkcybHhwUlFwSjV2Uk82N3FBQ09EOTZBRXJLeExpNUF2WWkzSTk2ZVVnSTIxaTNwRFUyckdXTWl4VmdiZmNVOHNwMEZHVldBQnNSUUNkRVdSN1lsVmMyN0c5U0JHRnVxdURwT3hIQnBtTmlYMWtCeTF4WWoycFR5RFV1a2IvQUtnQlFMYkVlaFRJcjJERTdFZHFpejZRRkNvV0hkbHA4dVF4SkF1UmNraW96enFwWkErZ1g1dnRRSU5LeXRLRnNTdmZWVTJCTGtnaFk0eUNRYWdJTnZNMUJ5cC9uVXpBNGRpN2hBZHhmYzdHbEdmSmxmRWpKdjdWNmNjeHFza3VGa0VxajJ2elhIc1ZrOHNKT3FKa0d6Y1Y2RnpIQkxQaEpWdm84MVdXeDROK0t4YzJXTExnbmowTDVta294SXVRUlduaHo3VnRPUjhuNDFaSitvdXpsVTJCOHU5aUNDYWpQRXhTUUQrNlYvZXROajh1YkRHUmRXb0gwYjFYdmhSNWFsTFd0cC9hdEJUdWpqc3VCeGJSOVFQd2pZK1BNL3cwOUJ5cUxmOEFLdkFlMzB5RVY1Yi9BUGlDOUNZZnAzeFR5SHFxQ0pvVjZsd2p4WTI0OVA1aUd3UWsrN0ovbFhwRDhFTi8vd0JGcm80ZlZwbHhpRUhqL3J0dFZQOEFqMDZRYnFUOFBtSngwRVRUWXZJc2ZEbVVZVDIvNmNoUHhvWTFzeVc3R3FPZDVVMmo1c1lsdEthUXhCdWIyT3hxdnhMd2hrZHhZbmZ6Qi90VTdFT21vTWdDcHBHay9CcXRtMHZkbHV0dHI5aldlMGkxR1RURnFTWEIxaWJ2Y0hlaythR0lVTjJ1UlVLZjBDTmd4Vnp5UnRlbFFZcGhJWTNVTW9GNzIzcGppUzc3Wk5qZjFxdjBzZUF2ZW5sbERoZ0RabTJCN0NvNmFRQXV1ekVYQlBJcEpabGV4MUFYNVhnL05JMVJKR1hKZFFNcFZVRExjZWtnOEFkNnRjUGhJc095UE00S3Z0WUdzekRqQ2pFZzZiZzdpckhCU3F3QzZ5N0VYTnpVVGpaZnh5VjJhQmNVUVJHRkN3cnVGNzNyUFlxT1hIWTZTYVFrNlRhNTlxc1JJcGhJdnBZKy9JcVJsZVdSZVZObUdMSGw0RERrR1JtMkRuc285eWY5YVJjZEU4bDZrZStCdkRZZURwN0FKbldQQ1dzVndzRGZWSzU3MjloV1FmRlBQSkpOTTM4V1ZpN1gzM05UZW84N2s2Z3gzbnlhWTRVQWloaUhDSU9OcWdZYUpuakoyMkpGV0lSdFhJek0yZmJMWkVxVk5pYmNVR1plNEkrMUU3QXFMajc2YVd1M0E3VUZJMTNoVklrUFhtVFNTRUxDSldETVJldzBudFZWakdWZW95eVhOOFg2Vjk3djJxVDRmS3o5VFphb0pKYVJyMjVIcE5Nb2gvNHBoUnR5Mk5TeDkvVnhUNWZpTi9jZEJ4YWpCd3Npa0Z0WlcxL2NYTlVibFVraFZOeVA3dklxMHpGRzg5eXRnNUxiODJGNnIzdytqREdXN0VxYmNjMUJZNG1Uei9tRUVqb2JFNnJuYjRvbS9pQTdBOXp0ZTRwUlJXd3hheElSUVFQbWlLdENzVEVGRzVaZ2Y2RDRwUXRrT1ZBV3V0ajJCSCtkREpsS1pqaUZ1VEc2NmJBYmZlaktic1VCUGNnODFLeUxEeHRuRU1ZM0Vub04rUlFON09rOUtUTGk4Q2NITVRJcVhpZFR5Nm11WjUxa2MzU1BWV0t3U1hpalA4YkNTTU5pcDMwL05kSTZTd1RZVE8yd2tqMi9NcXlDUWJsV0c0TnYzb2VNdlMvbjlONVptY1JMNWhoWGJkZThZOTZhbnlQU0Q4TU9yWlplbnNmbEN4SkdZWkJPVkd4R3JZL3RYWFBDOENiTXNSaWl0aEFMRHZldlBuaG01eEp4MktCOWNrU2hXWHNBZURYZWZDQVBMbEdadGNndk9RcTl5QlVNMVRGajJkSHk3Rm1ZemszVVh1cE5URW5VZ2hDU1J5S3A4dWtKd29JK3JVUWZtcHlML0ZScmpVUWIxQ3lka3VTWFNuYzNQYnZUbUhtR2hBV2NibmExUW5Qb0NkeHpUc2JsTk8vN1UwUW1lZWRZSVlnZklvbm52cUY3MytLaXV4WlJ5RnZ2VHJFNkYyNG9BRHlrTUxyZjJzYWR3ckpKaklGbUN2QklURktyY0ZHR2szSGNiMUVCMU45SnZmbWpraTJ1dTdBblM0cDhleEdmUGZIZEp2a1hpdmpzaTlSWEE1ak1MNmJYUkNUZjdXdFhXK21WYlRyTEFDUXNVTGMycDN4cnlRWVR4OXpISEVCVGpjcWpuWmdMV2MrZ2tmeXFUazhQNWVDSlAwRkI5WTRxUFZNNjN3ZU43dHlMNkYzaWFNaDd1NmdYUEFGUEs2dVNMRXFmMWtiVkh3M3BMaFU5UnRhL0ZTVmlFWllCUU5SdVJ6dldTejBLSFE3aHhIZSt0UUFEdGZlOVIxalVOcTNZZzdqdmFsa3JyWFV2cXRmVUJ1S1hINjVXMW4xaE8vZW1Fb2h0Q3N6YUdCSTlJRkluQmJlMjl1QlRyaFhSaVJaMU5nQnZla3lXTm5IcDdFZTlMWVBrcU1kR0RBeXFDQnl5Z1ZrOHlRbVJ3aitvcHNPNHJZNDRNc1paVTFFZzMwTnVLd2VkSzFrYzNENnJGcjcydnRWekJ6WmdhN2hXUFlkMkN4cTFpeEhwM3FWSEtVaDBLV0NFMjB0NzFVWVdYelVPb3NkSXVEd1Fhc1laWGtCQnNGQUIzNU5XR2pLaGt0RXIwZ09ic2RPMjNlbytLSWJEQnI5K1NPS1B6QVkwWXNIamJiMDdGVDgwY2lLRUtsU3l0NmJnM3VhYWlTZnVYQkd3V0thQ2VQMDdkKzk2M21SWXdTTWdVbmMyNTJybmFQNWNoSUpBVGl0WjAvalJKSUNaVlZWN0tLVE5HMFQ2SEx0ZEhSOE5LWFFHNVk4YlV3TGxuaFAwbzNwdU52ZW04cmt1dWxaQVZJdVBlbjhZNWlkR0o5RERZSHZWRDRPcnRNcE0waGRkVGFsYTRzZCsxWXJGWWI4dk15MmNCVzFxRHVQMnJvbU93dm1JcmdEU2VWRll6T01Qb2xGd1FReEZUd2xYQm1hekRhdG5UL3dwK0lTOUZlTE9EeTdGdUJsL1VzZjVLUXNiS2t5M2VJL3p1UDVWN3p1dzh4U2RJQnZ1YmZ2L0FKMThwV2t4MGJ4NG5MNVArWWdsV1dKaHN5c3B1Q1A1VjZaOFh2eFhqUHZDcko4bTZja2VIcUxPc1A1ZWF5aTZ2ZzFVRHpBRGI2bnNSdDJOZEpwOVJzeDAyZWErUzBFc3VvVzFjTUg0Z1BIU0hybk1KK2xzaXhURElzTE5iRlltSnZUaTVCekhmKzZwSDJOY3BRdVZpa1ZWRzF0UVBBOWhXSXkrV0xEd1J4eHRwc0xXOXZlL3Z2VjlIS1pjTXVpUzRUWnJiYjFpNm5KTEpLMmR4NC9CajAyTlFpalMrYUZBSzduNFBhcEhucWlnSStoanVON21xQVRMR0xrMkp0WUU3Vk1XY21LK29YWFlLYXoyMmJzSGZSYStaWkdBV3kzdnZSbHkxbExYWmQvMnFIaDhZcFlBU0Jyclk2aHdhY09MRE9BMXlVRzV0YTRwTEpicGtrTnVHN2MyTkxrbVdRL1FWMWNiYkdvcllpT1ZiMk94L3BTSnBneWp5OVRFYmdlMUlPc2R4REs1SElJMk5JUjl4djhBVUxibllVMHJhZ0hhVGNYOUI1dDcxSFpVakFDa216M3RmbTlBbGs3V2lSbHBDRHZwQkZJTW12eXdOMTAyQ2ltSWtTN0k0SUQrb2I3QzFSMVp3NEJJMGs2Vk42QUpDNHAvU1hHa1h0WjlxUk5pbTlXd0VnTmczTjZia2xWcFUxSys1MDJ2ZTFKWUc0ZEdES0c5S2ptZ0xDVjdMcVpnU0ZON2IzbzBhSmtGN2hMWFM0M3B1UmtEdXdVQTk3VW1PUlN1cTEyWGkzdFFKWSt4WllneTZRYjdhalJ6c0JHU0ZGOXJsS1owaFpiRmc3SG43MHFSeXFPUUdKN3FCUUpZNi9yYTRrdW9IYWdrdWgwQ0xxMjlWNkFZRlVVRDJ1MytsQUFCOWRyQVhGdTlBNGJZRXlycE5odnR4YWxMWlkxY2srclkwbFhEU3N4SjAzdnBZYlU3aUdIbGczQlcxd3E5cUJVUnNVNVZRR094RmdDT1JUQ2xRQ3ZwdGIycVRpNXZOS0M2K245UUhHMVEwQ2lkUzUrcFNkdUxVRFpCU0JwUVRvc0I3YmJVNWhFYWNpek1WQTJCQjNxT1FnWDZTYjJzYjlxZlF0SGNLUXlyNmtiMnBHTVhKS2xBS09wSjByd09mNVZtc2Jodk94RHFvMEJ6cXVwL25ldFNKQ28xYUJZaTVQWWoyRlVXS1ZZMFo0VVpRSDFYUEE5eFVrSk5PeUROSGNxTWZuZVRocG0wQzkrTnU5Wlk0SFJNd2NhU1Q2bDR0OFYxR2FNRTMwYWdOd0ZIYXM5bVdRbkVZcHBOUzZIMzNHOWFHUE43a21jdnJORW1tNG51VDhENy93RDdObVJSa1dFZU14cTI5djR4cnFQaWgweW5XSGh6MVBrYnNVVEhaZk5GZGViNkw3ZnVLNVIrQnNrZmg1eStNN2VWbVdOWC91L2ltdStxUmV4QVpUNlNEeGJ2L1N1c3h1NEhtT1ZiY3JSOFJVRHhvSTJ1V1FGRzFjaGdiZjZWQ20yVDMzdWZpdDU0ejlPUzlJZUx2V21TeWdMSmhzem1ZS290NkdiV3BBOXJHc0ZpQll2dmIvV3FFdXlTeUpNZFlKdUxqZ1VsRy9qS2ZpMTZjbENzdkJVZDZZdi9BQkltQys5NmFGazF4ZUZ0VzkxcU5EaXBNT1Y5V3BSK2cxSStxSWp2YmcxQUNqdUQ4ZkZOWTlNdFZlUEVHeVhSZ3U2MnA1SDhobE45TitMR3EvRDIyTzVQOWFlU1FBZ2xmMnBDV09UYWF2S0lKc1Roa2xkU2tVaE41V0cyM085VmZVT2R2bWpSWWFKeXVYd0gwUmNEVjNZL2VpeFhVV014R1dyZ28yOHZDS1BVby9WVldRV0pzQmNBYlV5TWJMR1hOeHRnTnZHb09vamRodlFpTHFwMG13dndEU21HdzJPbmkvelRVYkVBZ2RqM3Flek8rS0svVlptWHQ3VU5mdHRTcktXTmdmYWtBOWp2ZnZVWTgxUGg3SitYNnJ5K1JlRmMra2NuWTFIV1F5ZFVZYlFoVXJqMTIvVi8xTnFWME0xdW9jRDJJYzJQN1UyZ2RlcU1KNWdJRFk1RGZ1VHJwejZFWDVNM09iS3h4SUE5Q2htQXNlZCs5TWxHL3NuRmFEWURlNXAvTTN0ajVWdWJobXRTOEpIcXkrVkpBdDlCOVB1YWlSSUt3aDh5RkZDM1UyTy8ycHFPMzVmMDJleE9xL3RSNEZDK0VnSllmU0NUVFdKTEZKR0RuVVdHa0RoYUJHaU1kUTFFR3dJK29iN1ZKNmMxSE44R1ZCWXZJQUcrRFRMUEhITFpQK2xmMVg3MUs2ZWJUbjJDY0cxNVUyL2VrZlFpT2tadmhSbDgrQnpDSzhUWWVaUTI1dVJmbXRaMXZsOG1MNllnbkMraHRTc0ZPd3VOajlxbDUva1VlYVpKaUkxMGlSb1N3TnR5UnZhbU9sNTM2bjhNNWNETVdSNGJXSExGZ2Zlb0NTdURrbmh0aGY3TzZqNmh5d3VGVm9CaUlSN2k0MkZkODhLcFVpdzJnQWd1V2MzSTNyaENzTW84UXNKaUpGMHh5cTBjaEg2QVJZQS8wcnJIaHRqa2h4ZUZSU1VGM1hReDMyUEgzcFovWkduUjBYS3NTNlk3RTRYWm1qa0p0MjM3MWFTVGl6TUc3aXNobGVNYUxxUE1JbE9vRUtFSk85cXZoTGFBcjVaS3RzVGVvbVM5b3VGeEllVGpjMkcxT3JJR2tzdmFxN0JTT3dqa0d3SXRmdWFsWWQySk56Y0huYWtEb21INkNHK2srMVNsQUVDaHZxcUNyZndtMnZUc2NqZVdvUEZBZGl5Z1UzdmE5UG1NaEN3NEZ2NTB3enF3RnpZamVuMGx1Q283N2o1cFUrUVNwbkFmeEp4eFAxdDAvQkhHcTRrNEhVN0FibFM1c0RXY3dnTEtvYm13USsyM2VyUHh0eGE1ajR1NGs2cmpDWVdMRHFCOVY3a2tmMXF2dzZGRld3QVZRUjZqY205Vk5SSTlCOE5qMlkxSXM0TlVka0pENzIyUGFuOVdpVGNrajlOTjRhN1JFYVFQU0JlbElvajRON0hlOVo1MmE2SE5KWXNTQUdOdHhRZEVMV1JpR0h2M3BDbG1ZcWJyYmdlOUxEZnc3SjZtdmExTUZHa2YrSVZiMERtOUpiVk1vRGZ3eWI3RGVqTEhTNWRkU2syMCsxQjN2Y0lvVkRiY2RqVGdJT01Rckc0MTJZcVFBS3dXZXdxNXZydklqQWJWdnNVbDlsVzVIWW5rMWpzMnd0NVpnYkwzKzVxMWdhc3dkZkZ5andaN0N2SnJOM0NnN1hhcHNlSWFNSnBjbHI3dTIxL2lvY0VmbUhRekhWK2swN0hHMEpNYzVCNzZlYXZNNXFEbEIweTB1K3BtYU5XRjk3SDNwelVJV1N5eUJXTnJMeisxUVlwU0lnU0JwdmNYMnFkSktDcFpTVzFkZ2FpYUw4SGE1STd3cktRVVlyZm0vd0IrOVRjamtFVXJNYkJWTnVQcXFMSXg4Z0RkV3ZjQWpjMG1LTkV4Q2tnb3pXSkY2YytZaVJxTTAwZFF5aWFLYlVsenFBQkI0L2E5WE9JWHo0VWpWaDVpNzZYL0FORFdOeWJITnBVUGRTVGIwam10bEF3ZUhYSkhwTnJYOS90V2JKVXpzY0V0MFV5T2xqRzZxV2tZRGRUK21zNW5lRk1zWmJZQlRlNUhOYVdOU21KTVlKUVdxRm1tQUpna1FuekE0MkJwRjJQengzSm81ek96WVp3MGJhR0lzQ0tLVEh5VGhHY3JxK25qbjVxZGpzTkpESU5hb3QyTnJIWVZVeXhSb2hOanFVN0FjZmVyeWxhT1l5NDlqNUxBeWZ3aGNCU043cjNxWERKb0xOZDBjampWNlNLb1ljYXNaQWZVNmpsVDNxU01WWkVJczZNUXR1NDM3MGpWa2VQTFROWmdzUzVTT3dTWU1kMGtHNjI3MU5neEF4RTdvb05yOGdXdFdkd21JRWZBVTZkOWQ5L3RWeGhzVWp3YXRlbTU5NzFCT1BKdDRjaWE1WlpMTHFPNmxRVHdEVW9OZFFSSVFSeHEzRlFvOFZIR3hack0xeGNjRzFTUFBSZ2RMQUFtKys5UWRGMU5OOEQ1MWVWSGNXdWRpcDJOSFp5ZFFJVjdXTzlOcTNsaTVmeklqdUF2YWpLSzZYVWVrbnYycENRVWdrYld3VU5wSHFLbmltSk5Ja1puSnVBRHBYZWxyZTVSTGpVZDdVb2x2TUJPa054ZWdhRHpZeHFUMUVGZ3h2eVAvU20ySlhTOGxtQWs5STAyK3hwNE9yTTRsRnpzQXkrOVI4VklMSFdidmV4REd3QW9IRExvUUxodEpCdVFhSVNDK3Era3FPM2VuSjQxWUtvSlN3MnVhYlpTZ0pVaVFnV3RRTnNRSFVrc0R6Mjl6UzRidXpXQkFBMlBhbVVBWDZya0UzMnA1SXlrWUNTaFcxRWhUM0ZBeEJGZ0dES1BUcDBuNHBUU0ZGM2NnMjJJOXZta1NyWmdCY0VpMUxpVWEzREQwbGQwSTJGQS93Q1J4VHFEWFliRUVFY1VzQ1JyQlZHelhKSnBMTmNrR0lockQ3Y2JVY21xSUlnTnl3MUEvUHRRT0FKRlczTFdOOTZVektXdG9CTGZQRk5yS0VXeFkyc1JlM2VsdUxFdUJ0WUJqUUF4aWpHSkpDV0txQ1FkTlFOTHlTcXFqMGNCdmlwc2twVWxicDZqYXpEbjVxTEsrb1hWTkFVM3RRUnNTckVGWTVDcWdYQXY3MHROQ0ZkVDJJUHFBNHBEeUFBc21sMkIzUSs5SmlPdldiWEFVRVg5NkJwY1lZSTBVWVlYQXVRQWRsKzlWYlJhWkhqc3JJTnlleEpxMXdqUXVrZDF1TFdZL05WaklzbVlnQWtSSFVDQjNOT1FzL2doUnh5UXFZWGRXbFMrNEhJTkU4S1hWR1VGaCtydFQwK0gwWXRHVjlCSXNXTkhKRXNrOXRGdHJFamk5U3c3UlV5UVZQOEFvOVovZ21ZRHdTYUZTVDVHYTRwZU5qZHI3VjNtMWpZZTFjUS9CckMwZmdWZzNhUFI1dVk0czMvdldrSS8wcnQ3YkVYdDdHOWR2aC82MGVKNnZqVVNQQ1gvQU1SN3cyZ3dHYTlMOWU0WERwR01kcnl2TUdqU3pQSUJyamR6OGk2L3RYaVdjV0pERXN3RnIyMnI2eC9qQjZQWHJYOE9uVjJIdEkySXkrSk16ZzhvYWlaSWpzUDVNZjVWOG04U3l5bU4xWWxXVUhiaTN2VmJNdVJtUG1QSXdBekFCaURmYW96RFF3M3ZidlVvR3dCSUdxM0FxTktDRVBmNHF1K3hTWXBEYVNEWUFWQmZUcllkcjNHMVRvai9BQWdRT0FQM3FMS2w1blB4ZTFPRnNjalppQUxpL043VS9FTE1DZDdkcVlTNHVSemJjVStuMWkzcDJzVFNDaWtCQnR5RFNyc3FuM3BLTWIyMDhpaVVIYSs5d1J0UUpZRzdXdXpEbGUxTWdzdDdPVjN2YmFuK1ZZS1JwTy9GUm0wNmpjYzAwUWhGcjhiVVFiUUNDTGlqMDdVb24wN2MwZzh2T2tDUm5XRkMzVmc5d1J5TnFVSEQ5VTRaaXR6K2JYVnJOaDlkTmRKa0hOc0xkaW8xZldPYjBUT0U2Z2lhOXorYkRFMnVCNnFjeHE3Tm5qc1RmSHprMk5pMndQTldHV0VBcW1sbUxxTEw4MVE0bkVKK2NaeUwzWTcvQUwrMVhlV3V5NGhVWUVoeURiVjJ0VUE4VmdkRVdGRVJqc1ZkZ2JHNDVwaVVQRkhJcTJCR3pYTzlPeEl5WXpFUjJLQXVKQXQrQlFkdk5uQUF2NmkzdnRiYTlLaENGSWgxZ051VitLZHdEdERpRktBQ1dDU09RRmQ3RFYzK0tqNGcrWDZyN05zZDZleVlSK2RpaGZad29KWTJ0WTdVb0hxekJxbUt3aXlsUmVNQjNWZUNwQXZXVjhObi9zN3FicVRJSFZvMFlOTkVEdllOeGF0SjB0TVpNdnc2T2ZNUjRsYldUWUc0NEZaZnFTK1I5ZjVObU9ISlI1SlB5czZzMzFBOFZXK1NWOUhPT3Y4QUsvSnhpSUZNYk1HSnNkOWFtd3ZXZzhNTTlYSFNZT1N4Vml6SklOdFN1TnJuNzA1NHVZRXdaaU5LYUlqSnJFaDVXNHJJZUg4d3d1THh5eCtZR0xpYm4xZTFTTldpS2pzZUN4d2g2bG1hOXk1dGM5eU8xYkNNdnN0eUNOejdiOXE1bkJtQUdjNGQ5QklMQUZrK210NURpaGZrZ05zS2hhb21Ub3ZzSk1SRDVZMktzUnRVeUJXQ3QyN2JWVVlLVW5FTUUvVUxpNTN2Vndrb1JJN2k3TWJHOU5GYnNtWWMvd0FLM0pwMjUwRWtXdFRPR1c2djZyV05yVXRuR2l6YkUwMWdoUysxcjMzcVRnUUpjWEVMMlZXR3I3ZDZZSU1VVjdYTnFZbnhneTdMc2RqM0dwY0xBOHhVR3hJQ21sUTZLdVNQTW1kNHRNNDY2Nmp4YlMrYXN1TmtFYlhOcktiRCtncTBnUU9MRWF4cHZwNEFyTDlPSTB1Qi9NYVNUaUhhZjFuNmJrbmY1clZ4TTVFYkYxVU1OMkkyL2FxT2ZzOVI4ZkhiaWlpWkJ2R1NxblNvM1cxT29OOVJIMm9JQkV1eXVVSXZ6UnBFeVJLK3E5MjVKdUIvNjFVWjBDRkt6SkpvY2pVUmRsQS8xcElVTElwTjl6ZEFLSmJ1N0ZpVHZ1ZU5YLzJwVXJzczRHclpSWmFZS0lXNWJTNUZyN09lOUp0YU5pZlV4RzRIM3BSbVZZV0lHK3E1MjRwb3ZwWVdKSkE0QTVGT0VJK0lRdElDRGI0dFdhem1ONFdMcWdkR09teDVGYWZFS2ZLSllsYkhVRzkvaXM3bXQ4UkdrcW16aC8wN2kvZTlUWXV6UDFVZmFaSEdCWTVsM1pRVzBranRSK1g1YTZibDE1RGs4MUl6V0pYY3N1bjFHNVVpbytLVFRBaDhzalR0ZFR0V2xIbzVDU3FiQkc3QmhFNEFGN2F2YXJIMEdOdHRSV3hLZzdEOTZxcmxsUnJrV1AxVlk0YVJtamNQRjVjUjltdWFTUTdGSVJwSDVlUmxKSTdkeUtlaWRaSTFKYTRJL2NWR0lqQy93VzFEZ3FkdTlDS0U2dlVCY0cxbFA2YVNyUXU3M0dweWgxaGFKdE4xUERBN210emxjelNxQ3hab1NQcE51YTVua3pCNVRFTGhnZGFBbmExYmpKWDBrSlppNVc0QVBwK2FvNVZSMCtpeVhGSXY4Y1RHZ2tpVW1WWDNCN2lsU0F2R0pCR2JFN25rcisxR2dHTGdjb1NISnVpL3BGdWFaeTl2TUxCM0s2VzdIaW9FNk5xN1JrYyt3WkV4WkdFaWNsRHRZL2VzdlBGSkhLMnRCWWk0QU5kRHpiRGlKR09rTWtqYm5UOUlySDQzQ2hBMmc2aW8wbTQzNXZVMEpjbUxxc1RmS00xaVpHVmxMTXFEamppbXZQOEFKYTZzUWgzc3ZKTlQ4ZEV4amZZRzUrZ2pjVlZZaU1LQ0ZiZXh1VDJxL0hsSE01cmd5Mmp4QlBCS0VnQXFEelYxZ2NTeFRRSldpMDJHa0FHc1RoTVY1WG1YY2tHM3BOWGVCeGNpUUVnckxkN2I3TUtUSmpMT256cTFadTRKM1ZRN1BHemZUclliL3dBcW40ZVJTdW9hRzFjZ2Ntc3RsK05EcXdjRW0rcTE3MWNZU1dKOFNrdnJVVzlCSTROVVpST2x3NVUwaTJqMmlYeTFKWFYrNEZPTXNpR1R5MnNuWlc3KzlSRm1YUWhpbkdwaWRaSXFTQVNxYVdOaHlWLzJxRXVqaHNFMW94Rnh2YWtHUkZabGNFb1JzZm1nSlZRMlN6RW5lNi81VVRxV2U2aThaRnJOU0NqMENlVDVoMTN0Ylk5L3RRTGh3TG9EYzNDbm1tb2pyc3hZYWdiSC93QktmZUwxSzZ5YW1ZYjM5cUFJNGVKd1JJakI3Y2ppbUdWV1RVVTlTN1dKdGNWTXVFall1d0FjYkgycUZQRXJSQlFTejN2ckRjMEFOUEtPeWVVaTdiQzl6UzQzVnBTdTZtKzR0elNDak9yRU5xWTdBRTdDaEFHaUFRdDY3M2FnaS9jT1NrbVVOcVB0L3dCdjNwS3lNalBmMUZoY2ozb3A1dkxYU3dBUmo2aWU0b21ZUElRQ05RWGozb0hFaEdDenF4VFNHVUM1TjZka1loaEdRWFJEejNOL2FvU3N4ZXkzS2prMUkwb3pwSVdKdHNWQnQrOUFCaFJFem81TmxZYmtjaW5KaXBQb0pDOEdta1JoTUZMRXB2WmliNzA5WnBEc1UxS0xYWVd1YUNSRVBFcUhjSklMcXcwalR5YVlpaDh3UEVEY0wreHFUSklUWXVvV3dJTGZOTllhZTgxcEN2cTJGdVRRTWRmSTFpRVFZa2toYkFXQTl6VWU1WmRLaTErVnFWam8yYVZpYm9vQXQ4VkVqUlZmWHVUYTRCK28wRWZGOEZyZ1VBZ1ZRZEFEYmhxajRoR2x4Nk1sbzlMMktyOGQ5NlZnR0RSc2RXcmNFbTFQdU5lWUlSZmJZbnNkcUIwbGFJK1k0V1NlRXNpbnpCYzJJNTNwS1RMaWNJcnJIY24wc2VQVU9hdGNRcnFBRlVyZmRkTlZFZWpEcmk4TTIxeVpFWTkvZXBJOW9qemZpbi9aN0QvQ0Z2OEFoNzZmWWczZkZZMTdmL3Z6WFlpZDk2NVIrRlZBdmdEMHlxeFBCdk8rbVJkTndaU2JqM0ZkWHNCeFhkWXYrdUo0WHFuZWFUL2tyT3A4QWMyNmF6akFoZFRZbkJUd3BmalUwYkFmNTE4U1B5ellKR3c4MjBzUmFKN2U2bXhyN214RUNWQ2JXdmZmM3I0dGVKK1NqcDN4SjZzeXRaZGNlSHpURUlqZTQxWC9BTmFpekVXTXgxeUxrRWtuM28yNGtaZ0xIdFMzSjFIOVIrS1RvR29hZ2JrR3FoTU93RUNJRTdBYjJwckVSbnpqdnN3NXB6Q2xYSVE4azZUVFdLVFU2bFNQTEJLajcwckFHSE5qYTJwZ2JqVlQvbWJzeEl1ZHlMY0dvcUM2bTl0dHFrS2pLdHh4NzNwQm83RzE3a0FEVnhmdFJJZEkrTitLS01sZ1FDVDJzVFJ0ZjQrM3RRSUZxSVpkNzBoMHU3RTl6U3IydVQ2VDduZzBYbS85cCthQUsyL3Evd0FxTUxadHVhUzI0MjNJcVZrMFA1M05zRkRhL21US0dIYTF4Y2Z5cGc4cytrMlZjMHc1WnJXMWNqdmFtWlRwejJPeE52ekNhVCs5U3NxY0RxYkVGQUVVWWlWUUIyVzV0YW9reGIrM293eFhWK1pUanR2dFQyTk5QZG56RmwwM3VUdjM1cTBTUVBtUTdEVDlWckhpcVZsVTQ1cEdCWUJ6WVg3MWNMaHBVZFdUY2s3RFQyKzlSTWNUcGxmOHpITURlOXVlOU40cGlIYVJTb0l1Q3FqazFJV095SXhPdzNDamV4cHFlTlU4eHBtSXZ6NlNMZklwQUlHTVVOQkdpV0hkZ2VMK3dwL3BpS1NiTUlTRlZtYTZoTFh1Zm1vc29MQ3pzaUN4c1IyMjJyVjVCazh1R3lmcG5Id0JQelVzdnBWanAxdDkva1g1b0VPeWRFWWtZYkFZZkJ6TnFraFE2Z1JzUFlDb1hYT0RmTmNJNjRZbFo0MjgyQTk5WTNzVFZkRE9jQmpaVWtqYUxXdW9oallnOXhmdjk2ZHgyT2xNa1hxMDZCdXQ3MUIrNGxYUkE2em5QVXZTbUF4RHFZTVF5K1c2MzlJY2MvMUZjd3lqTkZ3MmV4UzNhUFhlSTZqWVh2WFZzMFFTWk5DVVZkWmtMNlgyRjcxeHZxWENIRFkzRmhVS0IyOHdXSDBON0NucFdJZFd3UUQ0ekQyYlRvZmY1M3JvZVZZdGNhUlpoWlNmVjgrMWNoeVBNM3pYSU1IalcwaWVTT3pCTzdxYkg3Y0N1bTlEZXZJNUpDcExPNTlONzZiRG1tTlVCc28zVU5FOWdXQkl2eGFybEgxS2hJN2Jtc3REaVZiQ3FIQnUyNDJyU1lLUS9sMEkzdllXUE5xaVk0c2tjYUNRZlIycGF0dVA2Vkdoc0VzVnRZZCtLZEliVUI3YzBnNUQ4aDFxUVR2V0w4V2MyYkl2Qy9xREVxd0R5UkxBb1BOM1lEL1d0bXhGaUI5VnE1WCtJYkdSeGRIWmJnUE5Ddmpzd1RWcUhLSVFUUy9CUHA0cWVhTVRsbUFqWEI0V0JBQ0RZS3k5aldpdzZnektBVUlDN0tSeFZMcUVjdWtOckxicW9IYXJpS05YakpLRlNMV0NuZS92V1prUFZkSkhha2l5U1ZRV0xYRnpZS1JlaURXQkJGOTduL3RwSnVxQmJmcC9lOU9xUVl2TEtqVXcyTlZmazF3bUI4cDI4d01MMjNITkVRSmJMcUZ4dXZhakNrT1I1Z2ZUYXdRY2ZlbTVMc3hJWVBjMkE0M3BRRURUNmwxV2Y5UjdIN1VRRHhseVpQVHhZSHRTaXBDSFZmekYrcTUyb0tnZTIrcXc1RkFyR3BnRzFDK3RsRnhWTmpvVHBHbEZqSnV4QkZyVmNiK29oZ0RiWWU5VldaUjZYR3BTNFlXdWRyZmFwSUZYTitKa3N6amRqSHd0aVRxSnZlb1NrdEVGZTVOK2ZlcmJOTU1Ga1pkemMyVlR3S3JKTmNMeUlRQnAyVjdiR3RLUFJ4K29qN3lFZHlXazVVOER0VmhocERMRUZzU1dQQysxUTVENWM1MUlMc1FicWU5cUdGeFNvNGp1U1NBU0J4VGlxcGJYUk54TEtHdUcrTkZxYlUrWGNOY1hGNldmTWxkVUEyMVdXL05OczVrMXF3Q3N2b0NlNXBxVmo3c21ZR1ZJTVhHeFlnRWUrOWJES0oySkIxc0ZJdGYvQUhybjhiaU5pV2ErbllwYTVIMnJVWk5pNDhPdXNMSkMzQjMxZnRhbzhzTE5YUjVOc3FPbDRHZThZMHNwdU5SQ245cVlKOG1VM1N5bGh2MnFKbFVva1NPYmVOU0FDZFFJMWUxV0VpQXlhMjFsdmJ0V2ExeWRoamRvUFNVTjJ0NVJOck1OaldaekxCYUdiVnNkN2c5Z2VLMGFzY1ZCcGsyVmRnUnpmM3FIbU9HSmpJY2x0UkZtSE8zRjZJdWlMSkRlakVacGxraW80UmttSVc2K3ZrV3JKNHVCbzFrSnVXMEQwZ1gvQUsxMHlYQ3dTcElXWXFPRkRDNXJPWnBsSDhJclpVWlg5RGpZSDcxZXhaSzRPYzFta2N1VVlDUjNqa1dNYWc5N2w3YysxU2pqR1NOWkxBYmVyL2VtODh3Y3VDeEUycTU4b2FqYjM3MVZlZTRVWEYwTys5YU5ia2NwTnZGS21iSExNMWRVVmZNU1JBMTlhaXgrMWFmSjg0VklwSTNkd0ZhMSthNUdzNzNBR2tnRzRVRzFYR1U1MHlUWG1VK3pCVHhWZWVDMGFHbDhpb3lTa2RraXhDVFJvaU1wTjdqVWx0NmxDMGd2aUZDdGU0YU50NnlXU1oyWDBCSEJzTmpJT0JXbnd6cE5CWXNHQTROaUJmdldmS0cxMGRwaHpMSWswUzA5YVA1akVsUnRZYkFVUUFzTkFPaHhZazlqU1VhVGNBQVJrV3N2QnBNaGxNY1NxZkxhKzY4MytLaExmWS9FcDhvU3lXQkJPd0Z0cWVpaFZSZFpMZzc2anlLam96RlRmWmYxcWR4VG9sUXJzcTJBdmNEZWtBREw1WVlvRktuczNlbTUxMHdqVWdhMzZrMi9hbjVKRFp0bXNWMjJvbWpUeTdNb1lFWEZxQUt4dzJod2lwcDVJVStvVTBXc2lzcnF6Vzl1QjdWS21kZTZoZTFodFRhUngrb1cwQWJVQTBBeUlxdVZQcnZZYXR4VFRCU0ZLSDFFN2UzelRoaXRHZEpRSCs4TzRxTDlPdlNCdHdUL0FLVUVjK2liRk9JdGNiQW50Y2R6VHVuV2dPblM0SDA5clZFd3l2NWFzTGdsckFNZWFsSnBVRVdJVUwyTnlUUUZqc01ZYzIxV0VodHB0ZmlqbmlLU0M1c1NOajJxTkRQcm1BMHlFOTdNTmhSc25sM0FMN2JnbmVna1R0RWZFbEdVRVhrWWJXUEFxUEc1amszUU14NFBiNzAvaTNOcm9mTlk3N2kxcWh5U015QjI5SkJzd29JbVB6TThyczNxSkl1U1RUVEJwRmpTK2tEZTdVR3hJZENIUnRON0FpbTQ1b25SMVM5aU9YLzBwNzZJcE9wRmhnaDVaOWIrV2I2U0I3Q3BiVy9NZ0svbUp0WWphcXlHUzQxcnFaa0krcmkzelZoR3lMSkV5SHpFQTFBK3g3aW1rMTNSTjFTT0dzVnNPQWU5VTJmU05oc0srSUtra1J1aEk3WFUxY0pJTVE3c1ZES3BHM0c5VS9WMG9YSThVM3BMc3Y4QTArNU5UWWxja2lEVlMyNHBQK0QzbjRMWU1aZjRROUd3YWkxc3RpTmp6dmMxdExXMjdEYXNsMGJJbVY5TGRONE9kbGlPR3l5RmlTM3VOcTFjWkR4cXdzUWR3UlhkWS93UjRUbmU3Skpqa2JCWlVKNEJyNUhmaXU2WG42VC9BQkI5YlllZkQvbDRzVmpmeitIdHg1VWdCQi9wWDF2QXVkdi9BRSt4cndwLzhURHBoSXNmMEgxSkRhUEV6SmlNdGtVMk9wVUFrQlB6NnJmdFVlZFhFYmo3WjRkWnZWcUIyRzIyMUphd2tTeFB6ZWxTbGRtNEh4M3BwbExBRWI3MVFKUnpDWFNZcVFBQyt4OXFUaTF1NjNJRm1QRkhBdHNRUURja1hwek1BUEtzb2F5bitkQXBHWmh1UGtVNm9MUC9BSVFmcDk2WnRhd0l0VHhZb29CM1VpOXh5S0FIbFlPV1lqNG8xT2xRT0ZPMTZTQ3lnRzI5OS9hakpERmVkOXJVQ0FZVzlGcjNwS1BDQll4Rmo3MnBUQUJnZHliV0ZOaDJYYTlxV2tCVzltc2U5WEhTR0hNbWN3eWtlaUlnMytiMnFuWDEzNzM5NjBmUzBUUlJSNGhWZGZObTBoMlBwRmhVWThpNVQ2czZudDN4RW43QzUzb3BDZjhBaUdCbUlKRTZMZGUrK3hweklrRFo0Vk96dGlYSDMzcHVZQVo0RXZ2K1pDaitlMUxMb0RUSW9iRytxeDBra2dDeE85YUdDTVE2QzV1aEhwSjdrMW1yYThTNnNiTXB0V25XTlpJMUdsaUFGSzMrMVJnUzRrZUtXTnRpdGlMZHIxSHhLc1ZrWWtFVyttcGF3dS8xU2FGWnRxcmN3bHRFd0ZtamE0UHdCU0lhVXVNdVlHYXloN01BU2UzZXVvOU9ZcUFaWGxlQ3hhNjRqQUg4c2I2RzdFSHRYSzV2VEcyNDFFWEY5OTY2TDB6aVZrbFJGOVRmbGxJZTMwbWxZaHFtZzFUYVZ4RFRCVFlMS053UGFqeGNraUxkWWdHSitvR3dGTnBpV09MTWV1OGhVV2JUdzFTc1ltcElSSzFqNW1wdllnRC9BRHFGa3FIc1dETmxNWUZpTmxEZjcvdlhOT3BjTCtibFpFOUFjN29EdUdIYzEwcWZGYThzeEIwRll6c3Ayc0xkZ2ZldWQ1K21sWTVTTHVaQXhQQkE3Q2xpREdQRDNHM3d1T3dHa2lTTmhPaFhzQ0xNRDlyVjJqbzEwZzZQbm5SaXAxc0NuWWZJKzljQ3lTUnNyNjJ3YjdCTVNXamROVzI0TnE3ajA1S0QwUG1DdURyUnpjSnMzSXRZVVNCRjkweGlreHVTa2tNcks1Qjh3OXExbVZUcytFQVAxcnRjYjdkcTVwME5qcjRWMExLeFovVXJINmE2SGxKMHltSURTV1hWenR0VU1pU0tMeGJsRlBZbTlPb3pTTzE5cmlvMExyTEV3dVJwTzI5S2lsQ0R1R3BqQ2lYcDFxZ0JPa25mZmV1TC9pQXhINXJxbnBUQlBJcVJ4WWVURVNKZTVOellXSDdWMlBXRm1BRFd1Q0s0RjRxWStQTlBGbkZ4aDFaTUZobzRDd0gzTnY2ME4walQ4ZGkzNTRzcVlERDVna1hVSEZ3dnVSVnZCSjZtOHYxcXZxRnY5YXE4T0YxbExYUU56N1ZjNFNYMU1Hc2hQSUh0V1pOOG5xT25pU1NXUlZjOG5scWNpa0tTRW9wbDByd2Zla3hvRmp1b0lqdmNFbTk2RWJwcVlxRDZ0aUIvblVMTkVLRFdnWmo2UzE3aGUxSkx4aFVkb2lHOXlkeFRzY2NZMWV2YzhiM3BrTkxKdWdEc0RhNTRwQnRDWHNIWWhSWTM1Ym1pVndJemVRbzVQcDIySTdpaEpLcFVBRGZnaWtIYU53VjFLb0ZoM3BvNEJWR1loQ045aGMxV1lzSnVDVHAvVDMzcXhrc3BDQmJOYXdaZUxmYjNxTGlRYkVNQ21rbHVONmxqd1FUNVRNNW1FY3JRQWxRMXpiVUtyWlZJampEM0NqWUFqNnF0c1F0djRaT3dJWU14c2VLcjJleWhDck1MRWpVZHF1UWx3Y3puZ3JJR0lnWmtJUkZsWDlJUE52YW9NWUNrUlg4dGwzSUE0K0tzOTdsVHV0OWxCLzFxRElxUnloUWw3azZqZmdWWmk3TW5MSG14MkFSeU93OHdvTnp2elNtdzVqbFhRUXh2WUE5Nzk2anhOWnd5dUVVdmEzUHhVaEluVXVYa0VqTXhLNkR1S0dDVjhFWEV4UEhpSk5sOU50UlgzcTN3VXBMSjVoSUMyczF2ODZnWWdUU3BNcldUU0F6RURlMUp5L0VuRFRxb2ZqWXEyOU9rcmlTWVo3TWlzNlJsR045VndReThXRysvdmF0UGhnMklBVVhaQXU0UE5ZUElNYm9kU1ZBYSt4R3dJK2EydVhZcVR6REloRDZoc283Vmx6Vk03VFM1TjhCeUVlUksrR2tZcitwTEc0KzFJeElDaG9tQllteHVPMUx4aUJaZk9CQW1qM0trN01LTnhyaXV2NmdHSWJlMVZ6UlpYU3h4RmZMdDZRTndWNzFWWWpEcVM2T0MxeHBGaC9JMWN0cWtMV1UzN0U3Z1V3OFViS1hkeXJyMnRzYWNuUld5eFVseVliUHNxV1VhVmdZNmdJeU9RNStheHVhWlIvWnM1V1Z0VmlMa2l3NDQvYXV2ejRZU2F4cnNXRndHRnJHcUhPY2c4Mks3SXNnYzJMWHZXamoxSHdjMXJQSHh5SzRuSm5nOHVTNUFJUWJzcDUzMnBoWFpHTmpkL3FEai9XdFJtbVF5UWVaSkhHVG9PNFlkdmlzeGk0L0pMSFMxbTN0d1FLdnhtcDlIRzVzVXNFdVRRNU5uSmh4a1o4NytGK3RXK0s2Tmx1Y1E0eGcwUklaZVNENlNQdFhFb3BpU3Rqc0dGbWJiYnZXdHlQT0RIT1Y5Q3JjWGEvMUQ0RlY4MkcrVFo4ZHIzQjdKSFlNUGlWMWpVemVyZENOZ2FjdTY3dGJmWWZGVXVXWnRCaUliQjVGL1NGSUJ2VnhEUEU4YXFwOVY5KzlqV1MwMCtUdXNlUlNWb2s0VndXTGthVHYzcDlYVTJMTU4vUlkxRVJOTGZ4UDRnUDZsMnA0VGlPSzFpZXhOdUI3VTBtajlqaFF0RUdETXhBc0ZKOUpGS0RwcTh0bHNUdmJ0eHlLYVJ6b0tFdUkrOUphVWlSUURaZ3ArYmoyb0hVaEdKMVJCaTZYMCt3NHB0ZElLU0xiV1RlM1pxZW5sa2Nzd1lFMjlLK3c3ZzFIa2JUNmtBQUF1YmIwRFJtWnRMSFd1bHdkVzRzQ0RUTHNycVdLZ3FOOXQ2a3ozbmhWVkFEcnZwSnZxL25VSldXRmlqRm83Zy9Ud05xQ05reUhVeGpqYVJ0Vit5N0QybzVwZ29pWFNES1NMTU9LalErWWtjUUJkYjNhN2NqMnFZMHJBQ1ZsRmhzcDA3bWdjdWhFZXNTTTdsZFhzcmYxcVFpdEkyclJkcldPLzlhaUZRenFkcm5jTVIvU25RVnZzRGUxbU45aFFKQWRsMFdaU1FGdGNzS3J5WXlkN0tMZTE2a1M3K2hpRUJHMStEVUZyc1hSUnFzTGxRTzN2U2lTRVNNR1lOckVxVzNXMWdEeFVkWkJETTFtREJqc281MjdWUFRDR1NRS0FqeGFibGpjRmFpVHdSUnlxUUxoZGlMNzNxVzFSWGtoenpDdDFKSXViSGZ0VStNTXNZV3daRk93WGsxWElxdFlhdExuMUR2YXArQUtyR3NaY25hKzVKTi9nMHdmRXRHdEdWQ3VHSkc2TDJxbDZtVm55eWU2V0J0ZFc1SXZ2YXJlTlBNWFJxQ09OOVE1L25WVG5yckpoMkR2cUlrUkxkOTJGVFl2elJEclgvd0RIay80UGV1UUpoc3p3bVdxaVd3Y1dHaFJOWDFXMEM5LzN2V3pSUXFnQVdBRmhic0t5dlRHSFhEWVBDcDJFS2Z0NlJXclE2bEJCdUs3bkgrQ1BETWo5N0FlSzh4Ly9BQkRzaWp6UHdCanpQOHFac1JsbWFRUythb3Y1S01TcmsvQjJyMDRlSzV2K0pMcHFYckh3QjY4eWlGMWprbXl0MlYzK2thQ0pEZjhBWlNQM29ueXFHUjdQajNNcERMY0N6SGI0cHRnQVRadGdiRy92Unh2NWtNTW5lUlFUYzM3VWx2VHJ0eU5nS3pGU1paQzFDT1VXY2pidFVyRTZYaFlIYzIrbys5UXlTRnZiVUJiNzFPa0NtSWdua1hwR09LOGsyRi9XUjcwK21uVDZiQWQ3VTFxL2hBMjlKMnZUa0dsYjJ1U1JlM2FnQjFYWmxDaytpOS8ycHowNlNMV3QrcW00N2hHMzJiK2xMSlcvRnpiZTFBd010YTF4ZTV1UGlrWHViNlNhTTc3NnQ3WEF0U2J0dU5PcTNjRTBBVmJOb1FsdGhhdGhsK0gvQUMrSHdNUlZ0VWFhbUJPMXlmYjdWbGNIQTJMeHNFR25VWGtBSVB0V3ZNby9QQWFqcy9QOGhUQ1Npa3llYnlzODFrWEt6dHg3WG9UeUI4NkVpcnBCeFF0ZmtIVlRlU2tqT3JDNVBuT2R6L2lwekYyZnFJbFJkQmlGSkh6ZW5NWXV6UXdsMnhjbDdhdFIySStxdFJsejZvMVVBaU51VzV0dFdad29KbmNnWGRMMnY5NjBtQ2tMUVIyQy93QU03S0R6NzFHeHhZdElxSXFPVHJVK2sydmY1cW96S010TTBhalVxN04yQlB2VmhKaVNrYnlXQUtxZlUzSDdWVE5JekpMTEtESXpDNmtIYmZ0VEJHVTJZNHRvc1BLUUJmYXhJNzNIL3BYUU1obmFLY0xjZjlKYms3V0ZxNW5uMktXR0U4QWhsVmI4RTZoZitsZFR3MGF4NHFRNlZhRjR4ZS9iWUVVdENJMEdIZC9PZHhZUnFMbVg1OTZzOGRLWm80UmZYeWRLOG0vZXFYQllsQWhhK3NFQTJIMGtIYitsV25sTkhpMEJZQXJHYkZUZmMrOVJTVjlEMFNNVEFmeWNlSFVYMDJPb2ZUYjdWaStvMWFXU1dFV2Z5M3Z0MkZiUEh6TGc4QThzaElSZlNXSHZXTjBIRjQrYVRTU3o3aFNlUlRrS1kzTXl3d1VjNmdSeXdPSEZ2Y043MTJMcGJIL21NbXg3cmRWeFlXVFZmaTYvN2l1VDR4UDQwcWdYVnlRVDlxMGZoaG1KYkE0L0xXMUg4c1FWdi9kSXBXckJHNDZNa2pnYkZ0TXR5SEZ5RFlOdi9uWFRNQk9UUEhNcW5RYnJwdnNLNVowdmlCSGpjVHRxTEtMZ2p1SzZOZzUvTXdTRmdWWUM0SU50L3RVRXV4Nk5YRnVwUGJ1VDNwUmtNVWdKSUlQSDNxRmhzUTA4ZkkyRmlMVStYQkVSUTNOOTZZT1Jad0tUaVlFSXVXWU5zT04rOWVacy93QVN1YWRkOVN6cXl0cnhyQzQ5aHNMVjZXZ2tmQ0hHWW82UjVFRHpjN0hTcE5xOHBkUHpOaXNJK0tZYXhOSTB0aWZwSk4rYWl5ZEhRZUhqZVZzdk1NeUtaR1JRUnNDQ2ZtcjdDQXN6TVFHQ2l4S2lxYkx4NmtWbFJ0WkpMZTQrYXVjTWRFYnJwSVMvS2ptc3lYWjZKcHVpYmh3UnNiRmwzdDhVY3FsVGRyQ1IvcEsweUxxck9VY3IydFN5d2xkaUNWc0w2YlUxOUY5Q3l4MHV1alN5a0FrY1VpOXBKQXA5UUFJWmVLREt3SlUvVHF2c2Q3VWFiRDAvVGV3dHRlbUNrWmxDU3NvdFlpK3I1b096SWlrQUVDakNBc1ZjQmlCZFdKM3Q4MGtmVUZiYS9ZVUF4bGtFbS9tcXVzWFVtb2VKMDNETXVwdUNTYmttcGMwV2pWNmZRT05yMk5Rc1ZDY01pM3ZxYjlSSGZ0VWlLa2x3VnVZQ0pTYjZMZ2NNT1NhcnRENjlEZ2hTT09iYlZaNHNOWmdXUXN5MlBlMVZoQWhjb3hJYTJ4OXhWeUhDTVhNbFpDbUpVYldVRTdFVkNtYlhNeXV0MksrcGhWcGlDSXNRdm1XU1BTTERrVld0SGVVRmdRQ2VRYjNGV0l0VVkyVk82RU9FVnc4WUNyYTVKOSsxSGc3eXprRFRic2I4bnZTeXl1V0FXKzFqYnRURUlEWXBXWVdBc0xrYkErMU9JdUZLdzV3Qk5JMnJUZjBnbmU5TlJzUkxaaDVhcVMzbzN2ZXBPTFdPVEVPVVJsakFJSlViRSs5Ulk4T1k1Q2lGZERqMk8vNzFKMnFHU2IzR2d5V1ptSkxQcFMyb2E5allWdU1veGpPeFpZMWpHdzh4VGNIN1Z6akxaakRLMmhTRVZiWDV1VHlLMldTWW1UeXcyblNCYlNsdTNlOVVNc0s1T2swR2F1RFpSbnpZNWxMcXhaYkFFYmsvZWl3OHlqRExmMDdrRUhzUjJwakNmVHFOK0wzSEswY2lqRHlHeEpVNzJZOC9OVUsranA3c0VzUk5pcmFUWW15MUdNaW1IUnViSHYzcWJpQS9tQndnOHNXM0hGUTNVVFdGOUlVOER2UU5hc2FVQjdyZlNiVzlacHVUQUpNRlVzRklCR3J0ZW4wRWNpdHFBWWcySDNwVFFBSVZWcldOeURUbHdSdUtmQm5zWmx4bGpjdWlQL2UzdHRYUCtvZW1taFdSbERzQTExSjRBcnJzbUZqREZUR0hGdGllUDNxdnpMTGZPV1hTZzBNcElYdFZuRm1jWmNtTnF2SHd6eGZCNSt4c1RSVHNyQ3pnY2pnajRGSGhNZXRrdnBBQnNBZWQrNXJjOVlkS0dLMklpaVkzT3JVQ0xDdWY0bUJvWExGVnVlR1UvVlcxQ1N5THM4OTFHR1dreWNuUk9sYytodytJampsWUcvb1ZsRnhXK3d1T1dSTEJBRUxYMURtdURZSEh0aEdWaTJ3L1NLNlIwMzFCSGk0WTRST2NPNEl2dGNIOTZvNThQMGRKNHpYdDFDUjBTTEhSUnhFTkliRDlOcWFoelpDK2hkS1NEZHQ3Zy9hczVuT0l4RFJ4aUtMUUJZbGlmcUZaZk1zVzBXSWR6TVZWVGJZMk56VlJZdHpvNkROclhpZFVkV2p4cllnQXF3Q24xRU50cEZPUXY1YUV5MlUzSVZyZlY3VnpiSjg5VDh3Rk04akt2cDllNGI5NjFXQnp4Y1MyalhyYTFpTC9BT1ZObmkyOUUrRFZ4eS9KZUNZeVJnQUJYSjNZZTFOWWh2SmpBVS93M05pZTVOTk5pb0pvUTZlbGh6OGZla2ZtV2tKSUJTMXJIc0tnb3Z5YWE0SFhWMmwwK2xiZ0FGdU5xcjNhUlpBL2xGeGNyY2NWS0U1SnNXVjlYNnFqNGlRc3dleFJSZmExZ1RSUkZMb1hMTW5vWUNSaU9RVDNxVnJRYVZ2WWM2VzdIdlVmemZPVlNXQ2ZBNzArVkM2YjZRcEZ6dnpTRDRVUEtTa0VoMCtralkrKy9haXQ1aU5Hb3NDQnp0VFNRYXlKQkVEcEJGdFZyQ2t6T3dzWDRZV0Ivd0R0UVNOSkR1SUNnaFdXNEE1dGVvMDFoZVFBdHVOZ0xXcDBNWFJWK25hMngycEVqc3d2ZlQyKzlCRStoRFlnc3hzTkdybjJOUlRJVWxLTkdEZmRXTzIxUE5pQVZpWTJRcnN4WGVvOHNia2F4ZlkzQk8rMU9SRElXWXpCRnBLQzUyRDNwVU1ra2JNV1FOWUFBWHR2UWFXT1lGdGQxSjFGUU9LYUFBOHkrb0VFZWs5d2Y5cVVhaThpeGdFWVpHQ3U0K2kzSHhReXpMM3p6clBwM0swRGs0bk1vbzJWQmR0SWRTZHZnVkJ3azlrWmJsQ1RlMXEyWGdIQ2MxOGN1blE2bC95dm40cGR0N3FPU2YzcTNwWWJzc1VaM2xNdnA2V2RmUjdRbnkvTThybVl4eHJpOE9oc3NpaXovWTFhNVZuTWVQUXhPclFZaERZeHYzKzFQWUNYellTR1ltekVnL2ZlbkpjREJNMnRvd0gvQUx5N0d1MlNwSGl6ZTdrZkk3YkFrY0dxdnFySlQxRDB0bk9WQ1FSSEc0S2ZEZVlkOU91TXJmOEFyVmtFQTBra213dGVuRTBsd1NMb2RxT0dDN1BobE5oSHl4cDhFYk8ySGxmRGx2ZlF4Vy85S2J2cENoZGlPYjhWdVBHL0tvc2o4Wk91TXZ3eWVURGg4NG5XTlNPRkxYLzFyRVNyWU90cmU1ckphcDBYQkFHcDJKc1BZbnZVaUgxUTJPNVArZFJnU1RZaTQ3VS9oUm9EQW5VU2RxQnJJc2R1R1hoaUxVcEhNTEZTQnBPLzdVVXphY1JPQUxlcTIvelJIZjA4a0MyMU5vY09ySW11MTl2YnRUdm5STW12VW9QQkJOUWdiSFNSdHhTMXdpdGVUeXo4SHNLY01KMGZvUzZTS3lIc1R2U1BVUDhBcFNLaTgydjNxRThJdTM5NGRqUVdLNDNJRkFFM3BxUHpzYkpOc3dnUWtFOXlhdW1EREZST05sREFGYmJYcUYwMUQrWHdjMHRoZVdRcUxmM1J5YW1NK3VhT3hPelgzNzB3bHNxTWtVZjJ1Q0FkUm5ZZ2ZjMFdKSWJxQWdjTk9vMis5SnlwN1pvcWtGajV4TndkdWIwdkVobXprcW8wcWNRRFlkdCs5UEkxMmFQRFhYRU94STFkcisxNjBXRjFmbHc2QlFBYkFnYi9BRFZEaGhlMXlvSVlnM3E3aGxmeTEwTXdVZWtxR0hOUk1leVRpUWZ5Y2FnRU56Wmp4VmJtQ3FZMEtzQ0xCamJiVFUrWFdVUkZVYVFibTU5UjI3MVY1ek1zUVFoanFMQkNPUURUVUlZM3FhWFZpWW9nVktrRmlWUEI3VjBUb2ZxRCsxOHRqRWttcVdPSUk4WXRxdUI4Kzljc3pYRUhFWStkbUFVQjlJRnJjR3RCNGV3akY5VjVKQkl2bVJTNWdvWkFiYWhwT3hwMUNJN0ZnWFJoaDlUS2tZOUJCMkFIc2ZtdERoN3RKSVkzQVUyUUh1YXlFR1ZZWk15U0lHVUs1WTZUTDZGYSsyMVh2VGtBdytiNFdBcXhWcGdYREhWcXR5YjlxaWZBcGM5UVliemN0VERsdFF2cWNIa21zcGlZMFZrTWJhQ252ejlxNkwxWGw0dEg2aUhiNlF1eFVkcjF6clBjTStDeE9nblE3R3kzM3Q4MGlkZ1pYTm1jVEYwR2txZFZ2ZW5PaHAxZzZzbWlENlJqOE0zcFBkMTMvd0FxWGp0VStoV0kxS0NyTnhxRlVHVlppMlZaeGdKeXlvTVBPVVpwQWJoVzlKL29hbFhRcVoySHA5MWZGTVdaanB1VFlkeDdWdTh1eElrZ1dPUWtTY3JYT3NvSncrSnhjYXNZM0pMRFYvZFBCSDNyWFpUTXdpUnlBV0EwcVFkL21vR2g2WnVNanhGb3BvZk1YekFkemJpclREbFZrWGZWdGUzeldaeVNYVmpKRmNrM1VFRWJWb29aRi9ORmJuU29zYi82VkUreVJkRUxyN05Ua1BoOW4rUHVWSXcvbEEreGMycnp2a2VIWEI0U05kSkJSUUFHNHVLN1g0K1k1c1A0ZlE0WkNralk3R3h4U0JoekdBVC9BSmdWeUhCU0hTZ2RFYUZsdUxjajRxSEowZFI0aUczbGxoZzdKSHVkTGR5ZTRxOWhkVmhoRVpCTnYzRlUyQUFkR09vcUxIbXJXQWxZSTJkRk5odVFkNnpaZG5kNmQwdVNXRnVRUVdGeHZxOTZjRS9LRWhUeHgycU9YWUlvSkIvVmNuajRwMWlDR1lDeHBqTDhSU2Fpd1VDNU45L2VoTERLN2FpUFNxNlF2SDdVdGxKSVpXS0FnRzlONnJhaTFuVzk3OTZZS1JrWFN4SlVxMytNVW1RNkZZc3BVMzJJOXFlbGVWeW85YkFDNHViMnBGOVJLWHYvQUlUUUpZd1pHVkc5Vm1PMmozRlFwbTlXaDl3ZldOUjNCcWE2TW91ejJXOWhVQ2JVVGRoOUIwbjJOU3hLMlFnNG5Uc1RZcFk2MXZ1YXF5UmlFVkdWMUF1dXNqaGFzOGVOSXNBb0RiaGxGLzJxdDg1L0xWV1VnanNUVnRkR0xtL0lTeFJ6enNScDNIdHRVQ1JUR1ZFWlZtRGZ6cWZKRUVWZFdvUXlHNm1NL3dDZFFzU21wVUxCQ0R1U0J1YWtqMFVNa2JSR2tBWkpHS3NqSCs2T042WXV5WWdPV0VoY2piM3FaaEhhVENNZlNXTGFiQnJFVkdtRFJ6QlNySXlIVVdPKzFUSi9CU2FEbmlZWWk2ZlhZa0FIYTFSeElya0ZSOUpzeFBZL2FwY3M3U0lWWFRISTNESHZUVFJBQnRpR3NRUWZjZDZjaU9hWFFuQTZzUGlFWUVLdTViNHJUNVpqV0VkeHIxY3Mvd0NuVDdWbGNLd2pGbEdvSGRnM2VyYkRNSEtrUFk2Z0FPOXFpeXEwVzlMTlErVHBXVDRzNmdBYnF3c1dxeXhUdmlZVExvVmhHUFNmY2UxWlBLc1VjT3NLNmlnMWNuZTFhNkNaV3cyaHdSR045allHL2VzMXFqdE1FOThVd1JUSzhBQVlCQ04xTlJCR2p3c3BJVmRleE94SDNwekM2WXBKWUdRT2JlZy81VW5FcURxWnhvM3N3Rys5Uk10a1RVbm1BZ2hYdVFDT0NmZW5DVWNxZ2NlWitzMDFLaVJnTTBwWTMyQTJ0U29wRTVkVHVOdmMwRVRSTWhzWXRPb0JWMjh6a1hwTG9DcXFDR3ViRTIycHBYQytpUDBJMzZHTjZrN0FYWGFSUmJiaTFLSFJVNWxsMGVLaUNNRjJlOWdOcTVaMWwwWitURWtzYWdRZzZqdHNMOFdyc2swbDJ0cElCSEozSDJxSGk4SEJQR0k4UXF5aGhmY2JDck9MTThja1pHdTBNTlREcms4ellpQTRLWmpwR2pnM080UHZWdmtlTzhpYUtReW5TaERhZXpmRmFIcjNvNDVSTTdwNjRKR1lheDI5dHF3MEN0Qk1VWS9jbnQ5cTJveWpsVm84N3lSbm84OVBnOUU5UFI0YlA4a3d6TzRoUmxMTkVtNXZmbXN0MWRrYzhPcDR3ajZPQXc1QTVwUGhkMUNyWU9URHVGWVJraTUyTmliMTBMTTh0Z3pEQ2l5YnlyOVZ1R0hmN1ZrdVR4WmY0Tzh4d2hxOU51K1RpTU9hbkNGZlY2UWYwQUZhMEdSNTBCSU5RU1RVM3BMK2sxUjlTNWRKZ2NYTDVjV2dLVGRRTEQ3aXFpUEVMRGlkYTJCSkYyTytrOTZ2cUttamw0NW5wc20wNjdoY1FycVpZVUtxNXNRTjZtck14MU1XRDNOdmEzN1ZoTXZ6MXNNNmtTanlndGc5dS8yclFZVE5IeDd4cWlpVHpCckRBMjJyTm5pMm5VNmJWeHlSN0w1bWpkQVFoVWpsaWJDbUE4ckVnRmczYjJJb2xZcENHZU1DUzlpcFBha1RUUksyMnRWWWpVb05RbDl6dEVtT1UrWXFTSjZnZDlIZjk2bWl5dWJRMkFQTEhZVlZseHJCQ2h0WENLMVQ0NGtaOUd2U1c3RTkvYW0wUHh0a3BKQkpIcXZkcjhEdlREbU9NeUcvT3c5Z2FlZ2pNYU1xZzZpZHpiaW91S2hNZW9YVjdiM1A2dm1rTFV1aGNjbDFPb2ttMXJXdGFoT3Y4TlNOMXZhNXFLcFkzZjBNcTJiZXJSWXhpTU9HZlFxRlNWK0NLVnA5a05vcmJzNE1SSzZkUkFZYlUwenNzVEVrNmxIRkhpVWpkaUVhN2JYdnR1S1pZU3lNMTNCdndCeUtkZkF5WTlDM2tuK0dGMHNvdUFLSmtFd0ZtMlcrOUhHV2NpT05tTWRnQVRVblFpd0tRVkpCM29RMUxqa1RGZGtMcnZyWFFMODExRDhKbVhIRytLV2M0NEZ5bVhaZjVha25hOHJiZjVWeW1WbmlMRlFpc2gyYjNGZDkvQnhsZW5wenFuT1hTN1l6SHh3UlNXczJtTlRmL3dET05hMmhoZVZNNVR6Mlp3MCszN1BUdURrT2tHOXJiRmZZMWJLMm9BMVNZU1FOcHRzZjFBODFkUm02MnJxa2VXcmpnVjNwR0hqOHVaVkxsbEp1cTk3ZDZYUmJobElzR0J1RzdpaGNEMzNaOGZmeEY0NWMwOGVPdnNTcEFVNXRMR0xqbXh0WE5Xc3hKM1Z1MSszM3IwcitQcm9tSHBMeDVseG1HalNQRFo5Z284ZnBXUFFvbHVWWURzVzlONy9OZWJKRjFhYmtFSHY4Vm1aSXRTTFM1Nkk0SlUzdVRiWTdVL0FRQzdiclk4RWMwMHgzSHR1QnZ4VHNMYW5Za2drZ1dGTkVZTVdENTZ1U0xOMlAycUtGQUZ0SkJIY1ZMeEJEcEdDUnFCTzF1S2k2Z1FTb0d4c2JpZ1d3ZlhidnR1YW5YREVHMTF0YmYzcUd5bEwydHAwOEE3bXJDSFpVT2szQ2pacUJveWNQclFzQWJqYTU5dmNVeitYdHp6VTg2bUNzQ0Z0MkFwUDhNZlV0ejNvQW00S0lRNEhEbzRLdUZGd2RoZnZVbXhteE5oY2xUYmNXMnBOZ3lsV3VPNFQzdlQydVNYRXJxREVHMm8rNHFOSWVaeksyQ1kvVHEwRHptMlBiZm1sNG0zOXZBV052ektsbXZzMjlONUtiWTl5NEQza2JTRHhZbWprakg5c1JvU1NCaUZBOXh2M3A0aVJyWVZHdDVHUXJlOWpmY2IxWnhPQklBeWdheUxPby93QmFyMWV3SzIxQWtnanVRS2xIR0pobGU1WVFnS0FxaTRVSGttb2hTZGl2VGpQTFlFTWhBTEx6ZXM5MUhqUE1lZGd5cEJnbDF1QUw2bk95aS84QXBWam5tWS9rcFB6YUZGRWxpclg1YTIyMVl6cUhFeUdPREJzR2pYZWVVRVdabVBCYi9hbFFGUFpwUFUyeEc1K1RXbzhPNXZ5M1ZQVHN2MFh6QUFTZGhzZjk2eTRGOUpCMlB0VjVsQk9HWElaeU5hLzJnUFQ5aUtkVmdkN3lYTFRqZXJVd1VnVWtxd3NtNHY3bXI1TW9reTdGWWllT01UeVlkeEdkQnN1NHZ0NzFuOGp4bjVMcktQRm5pT1VxVlhhd1BJK2E2RkRLdVp2aVpZNFBUSSt6SjlQRnFyekFLWEY0YlBFVFFqUjRxTmIrWEpzRC93RGF1WGRRK2ZKbUVzakZtbDMySHhYVTF5OVJtUG1hL01TSlR2emMreHJudlcrRkNUeVRveDE2N01PQUI4VXlJdEdNbVllV1N3TEt2ZnZXYnhjT25HVHhzUXpQRnJETWJnWDdWZTIvaXFvdVMzWW5nZmFxdkgvL0FJY3R5QU5KUVdHemIxWkJuUU9rY3hHUHl2TFoydjhBOU14U2xoOUxMdGI5eFcxd1lZUXNGc1RiVUFwdHRYTC9BQTdkWFRNOEpLMm1SQXMwYWs4ZzdNQlcrdytPUmNEaFVCWFZDMmtrYkhSMkJOUlNCY00ybVc0MHhUWVVvZjRiR3pBMXNzdVBta3RlNXRjZzFnTUhJckxIcDAzSHFLc052NTF0TXVsREFsRHBKVFNDRFVEUktuWnozOFFlTS81cnB2S3VGVFhpeVJ2c1JZVnpyQlJtR1J0WmJTVkFGN2JWcGZHYkh0alBFWDh2RHZGaGNHc0xGdHdTZHlLenVCSVZSSVlnckczZS9PMVFaT0VkaDQxTlVhUExwVjB4b3g5VEMycml3cXl3MWxlWlZBMk43cnZlcTVHYU9GUXJLRlVnTWJjMWJKS05ZU3lBdDlJWHZXVyt6dWNTcElEcW9KVmtBQkZ4WWJVNEFRcWtIMHFEKzlFeC9qT0M5Z0Z0WWp2U21QcVZkdHhzRi96cHJaY0NWQ0hZNnJwYTlpZTlLQ2tLZ0JBY25lKzlHZ1VTYnVUM0t0Mm9nd0pJVDZDM0ZOQWpNbW1hYXk4Q3pMYzdtaytXSTR0SnNHU3phUWZlaWtjbzRMa296SG1qYUR5cnRmY2JhanZxb0dkRE03TEtGSlU2aDlQc2FpenhFcUFiTzF6NlNhbHlNd3NDUXBVZWxlYjBpUTZmTTFMcVpocXRhcEU2SVo4bE5pR0VlRzNVaFMrd1VWVkpHV2VSZFJ1cDFDNDNxOGtuaTB0Rk5GY01wVmJtMWo3MVVPcXc0aVNIZldSMk5XbzlHUG5YdUk4MDdrNkNwMXEzQzdDMUlabDF0cDFSRlJheDN2VDhvR2thaVViM1BQM3FMWWgvVEpySUI5UjJOVFI2S01uOEVaNDFsa0pXTkZEL0FLZ0xFSDdVMWlMQ2NCaWZNVURTd1hiOXhVdVVPSFJoZVM2aTk3RDk2YnhaSk9ncHB2dzN2VGwyVkpLa01USHpYR2twTXR4cTA3Yi9BQlVhV0tJeUlHa2R0TEVLMStMMHRpd2E0OUdrOWhSR01OYVJtMllrc1VOd0tsS2pHbjFSU3JxTnlwdWJjbXBxcU1WRHBCMGpjZ25nL3dEclVLeERxVFo3M3VSdWFsUlNlbDdqU3ArbmJnMHJTYTVIWTNUNEw3TEp4aHpocmt5WFAwcWUvd0ExdXNyeExQRDVMRldYZ3YySHhZMXpYQ1NvdWlObTB1UFVwSFAyTmJQSk1VM21RdHJVZ2dxUTM2UGtqNXJQeXhvNmpRNXI5ck5Dd0NyQzlpdzNYVXA3OXFjYU84UjFGbE43SC9lOUxqZFo4TzZ4cVhpQklJWGswMWhvbktXTmlxblQ1Ykcxcjk2cU0zN0dESEtMZXBiQTN1d3ZjZkZNTE96T3lzeDBXTmc0L3dBcVhpWFF4NkNyRnl4VUJlMVJ5VEhERmNXWUhUNnVhUWprMnVTVkVZekhHRklhdyt1M0o5cWRFakFBR3kzRnZtb0ViZVgvQUE0OVRzTnlvcDhTS1VOOVEzdmR1ZnRSUTNjUHU4anNraXVpRFRhNEd3b25McWdQb0IydTEvcXBnVDdtN2VWRjNBRzlOdDVidVNtOS9wMWJDbG9PeXI2cHlvWnBoWnRmcld4M1U3QTlxNFhuV0JiRDR4bXQ2QVNMRGEzdmV2UU9MSWtqMHRaRUovVHhmM3JsM1gyVmxzVExPc1paWkY5VEp3TGU5YWVsbnQ0WnlYbTlNcFI5U0tLRG9yT3Y3TnpTSm5WR2pMV0RIajk2OUJaUkxIamNPcnE3RXRjbGYwNmUrOWVYOEppR3crTExxd0JQcDBnZW0xZHQ4UE03OHpLNUlTMmxZUUZleHZjSDJwMnFoKzVGVHdlcXArbElzZXNNa2lueTU1MmpaWEVkbDc2bDl4WEhNWmhXd2s4a2VtNldCc1I2cmZldlJEczhtRkNhVWxVbTFuSDBMN1dybGZYUFRxUXpOaUJhQWdFTTl0ajdDbTZYTHhUTDNsdEZ1ajZrREU0WEV0aFhDckpwdU5UYjNCK0swbVY1d0pHaFIxOHB1QXltMWhXVFgwZWxsOVJOd0QycWJnSnhIcWZuZXhXVC9Tcjg0cHF6bU1HYVdLWFowdkM0eEptMG1SZzF3TG5lcDc0aG8zVm0wczN0YmNWaWNEbWNiNFlNeUVNVytscmdFVmV4WTlaMlZyS1BUYTJyZXMxNDZ0bldZTldwcEl2TU1ZOVVheW9BR08zWWlwK0cxbVJkMWFUVWJGaFlsZmFxWTRwMnNGT3F3RFdhMVhHRHhMTktUTE9HTEo5VERiN1ZWa2ErT2FaUFJRTkIwV1JiM0ljbTN4VFU0M3N6SnE3V3VSVHNURUtMSGJzd0hIM0ZOeWdxdnFBZlY2ZFJHMzNCcVBvdTNjU254Y0N4Z2xicktkenBOeFllOUp5L0ZNQUk1RlkzQnUycStuNXA3SDRaWkVKVUNWVVh0c2IxRXdjQjg1WlNoVUJkMS92VkoyalBsSnFSY2VZdG5EUkw1MjFudlRjcGQ0V0VoOU45dE5OU0dPUzdLbkpGaWFLUGUrbGdISjFLcDI0cHBPK2VSS2xrTVoxa2d0YzZMYi90VXFPU1FSU1I2MExIMUhiZ2RxYmhrUlhVdG9WZ05SWURqNG9TSVgwank5UDZqSUQ5UXBWMkNhWERJMll5QVF6U1NBa0lMZ050ZXdyMXorR3pBUzlQZUNmVFNZMk1ERFkvek1kRkxIdnA4eGlRRy9wWGo3T1ZKeXpFU1hHcnl5QnJOaFh2THc3VVpMMEowMWx5eHI1TWVXd0w1SkhwUHB1Ujk2MzlCSGxzOC84QTFMazRpa2EvQ3FIQzZIREVIZmU5WEdISnVSZmNiV05aekRZZFp3MG1YdVk1RWJmQ3liRWZBcTJ3T08vTnpMRktqWWVkUllvdzUrYTZDTDRPQ2ZaYmtXb3JXTjZiUnl3MzJON1dweHZTYlVySFdjQS9HZDRGVCtNbmhnY2RsS3ZKMVAwNEh4ZUJoRGJZaU0yODZLM3VWQkkrUmJ2WHkyMGg0dzR1QTNBSXNiOTdqNzNyN2tBMk8vcVh1RHh6L3JYeUcvRXQwQ25odDQ1ZFc1TmhZekhnL3dBeitjd2lCYklJNWZWWmZnRWtWVnpSK1N4Qm5MQ2dVS3dIQnNUUVd6RzdGZFB5T2FYSXBKSUhwVnZWWW4rbEJvajZRd0JIUDJxbU9ZeSs1Zlhja0RiVDdVa2hVOVNDMXhhd3FRNmxpU0RZZTlNeUQwN0x5TDNvRUVFRFZkUVNmbXBzVU1oaVJ0T29nMnNEelVGMUJBdVNOdDcxT2hFZ1NJZ2xTQ0xFOFVBU1J5eEpHc05hdzdVMFZ1eE91MXplMUtaVHJrQlVLTlpPcjNOSTFiOFgrYlVBV1ROcUdvTjZpT1BZMDlESWZOV3cwUGV4MWIyMnFQTXEyZFE3QWEvNS9OTEx1anhuU05KTjlVWnZUQjVRNVNQTXh3Q2I2Wld1ZUI5VlB6S0Z6dERxTFd4VVk4d2NHNXBuTEdhUEdxKzV0SSt3cDJ3T2N3Z216SEVSK284V3ZUZ05nOFRHVjBSMUJMRzIzMDA1RmkxaWdiV1ZVc3VrNmg2UUIzTkIxVlhaMVpXQllnM05tRlYrT1BtNFdaUkl5cXgzTnRsSGMxR0JDelhOa1REd1krT0VTNGFGaW1IRW8vNnNuOTYzc0t5V0t4RTJLbmtteEVyeVloOTNaamZVZmY3Vkp6TEhObUdKVnlTSTR4b2lUc0Y5N2ZOUkFENWVtMzdrVXRBQldDQUM2clk4RTJOWDhZYUxKK255eEdoc1pydUR2OVE0cWdJRjExV1lEdlY3bUpNV1FaSVYyS25WZTE3ZW9HbklEdFdKSlRNWkdNakZoSnFJQjlUYmk0SDh4WGI4cndDWWZKY041SVZpRXN6THhxdjNyaHVIbVdiTThKaUVRTkcwc1pFaW42U2ZmM3J0dVhGb2Nzd2NhblF1aitlOVZaaW9UaU1BY0xJelJrSTF2V0I5TEgzckJkYjRCc3h5cVlyRXZub05XcFJZa2UxcTZOalNqeDZ5U0ZidjJyRTVyUE5Da21zV2packZqdGNWSEY4amppYjR3UUIzMUF2WWl3NUZRMXRORnFZV2sxM0gyOTZ2ZXRNbWZBc2NiQXl5NFpoL0dWUmJUZXFlRlluVkVYVHBZWEJ2ZTN4VnU3UVZZN2xXYURJT29zRGlaTFNKTEo1REJSY01qYkFuN1YwbHBmTG5HRzhzeWlad3BWZHJMM3JrdWVEVGx1SW5RanpZV0JFYWppM0J2WFNjRm15NGpEWlZtYWdsY1ZCSEloSFlrQVBmN0VmMXByK3hyVkc3aVY0dDJERERsQWlzUHB0Mi9ldGQwM2lGa3dHR1lGNUNqMk51U0wxanNSUEpnc3R5N0RDUW5FU3VXOHJuUXZ1ZnZXazZZeEw0U2JFR1FFS3NidFlEWTJVbTlRTWx4OTBjYTZ5eGFabDExbnVMWlhLdmlTcWxUWUFMdHhUbUViNlMxOUpZV1pmbmJlcVBLSnZ6VWtzMHNqRlpwWkpEcUZ6dXg3MWZaSktBNmg3SFUxZ0c0TlZNM1IzV2hqVzAwc1NLaFpRdHdvc0wyS2tqMnFaR3F6dWttNlNyeXRyV3FEaFlMdWY0WU9rMktCdGp2VmdFT3NrM1VIamIvV3N0OW5Zd0hpNGVZUHFCSTJLa2Mwa0loTGV1MTlnRjVQeFRWeEhJYktTUllrM3Zlbmdtbld5bTVINlQ3MHhsb2RCOHNLeXNsMkpHb3FMajRvaXBMa01ENW52Y0FHazZyK2xyQmdSYXcyRzFKOHJnOHNUeWV3K0tRQnAwdWJOWW5jMlBhMU5FNlZkemV4N250VGtpMnVnSVdSaHp6M3BpWjIwYVBxSTJJN1VveVEydXBtQzdudmZ2VWVadFJZbHlsemEzelVxVlZWNzdvV0hwdnZVYWRXQVVIdDJiZmZtOVBJR20rU0RpQWxpclhJRmlHdGV4cXN4QVdiRXRJdG1hMXJIMjk2dXNUcFZ5Q1dzNjNFakxaUWZ0Vk5jT0dWd3YrRWUveVBpck1Id1ptVmNqRjVFbFFCckUzRnlMN2U5TXlFU0xhMXdOaWVTZm1wSXcvd0RFQWtJMGtYTnVSVUR5L01rWkdGdFI5SUpzVFU2Nk0yWERISlFvZzFLL21McDAzSXNSOTZpdkU5azNKSkZnTDdIL0FHcVI1bWxuUm1WZmRMVWxvbWNFaERxQTJKUGFsc2huVFhCRmtaZzF6dHFzdWttM3hha1R3YVF5cnBJN2hhZjFsenBmU0NMV3Y4VkduRm1aZ3JTeUtRRU1mSDJOVGZCVWtpTVBMQ2tySXl5WDA3WENyVW1LSmhNWXRRMW5leGJadnRUT3ZYSFl4NzJOMTRzYjBNTVJFOW5XeVcyREc1Sis5UGZSRkhpVms2SUdKdG90WkM2dFlQcVg3Ky83Vm9PbjhVcXFpc3JxbTViVUxzL3Rhc3hHNDh4QWxta2o5UUEzMWZGV3VUVE9qTHJ1VHVRMnJqZmdWWHlSdEdqcDhqamxUWFIwUExzVEtzWklMSVZPb0JmMVZQblp2elVidHBUekUzSjk2enVUNDBRMlpVTXJjZnhEL2xXaFZsbWlaMlE2RVhhL04vZXN5WGRIWjQycHF4bkVBaVlYS3F4TnRxalRhZ1NTUTZJZHdUYjk2ZGE4b1FyWWo5UnY5Sjk2aG1VU09Wa0JzRzlTcU8xTkNYMEZ2NXBWQ1dra1BwSTdmZW5WZFVmUXhFakRZMi96cHBXWnRKVkdIOU5xVUNvWlNJN252YmtDbmRES0hZeUl3NnVReDl4eUtiSkFHOWpwM0F2VFlCVDFxQ1hMZnZhamYrS3pzRVZXSXRiM0I3MEJaSHhTcklyZWhncFhWdWRoV1Y2bXd2NStCUkhaYmdxUVRZR3dyVkVCRkFrYnpBUFNZN2NqM0JxbXpOSWhoNUZrUnBGWStoYldDbjcxWXd5MnlzenRYQlRnMGNTekNDVlpTUVFpRTc2UmJldGw0ZjU4MkN4OGFIVG8wMkduY0UvNHFxK3FjRXVHeEJSUnBMRytsZVZGdTRxbnlxZDhKaVY4c2xTcDFEZllmZjNyWWFVNG5uK09UMHVvdEhwdkQyeDBLYUhMTVUxUHZ1eDloYXFicUhMSXMxeTJRUEMxbjJzVDlKRlJlak03T1lZR0hWcFo5TnhPbTFqN1dyUjZQTVdNYXdvUHZ1Q0t3N2VPWEI2VGoyNThKNSs2Z3dMNEhHc2pyNVJYWUUvcTk2ckVtOHNsbUk5Z09iVjBqcnJJdGF2Sm9rbEt5SFUrbmMzNzF6aWFCVWV3WFRack5jM0pOYmVLYXlSUFBOZGdsZ3lNc29aWk5RdE0xeVJZSzNhdEZoTXdlS2NSbUJKQllGU1RleDczckhST3lzM3FGcjNQdUtuWWJHTkd3a1U2WkFRTlJPd0ZMT0thSWNHYVVUY3RpVEF3T2kweElJVU5zQldoeXJIMm5WZ2pOZjZycmNmdFdEd0dMamxDV2laWC9XMTczK1JXbnlmSGFQeThieUZTUFZjOTZ6Y2thUjFHanp1Vkd2V1IzdUdrdC9odGEvd2FibGprSVlxeldRLzlNOGZ0UXc4Z21BWVhlL3RzS2NsUmpjNnRNZ1BwQTNCSHpWSm5VUjVnUkdiV2JGd3I5Z3k3Q28wbktzZEs2am9KSEkrUUtrWW1UV1dRc0dMYkxZVXcybU9aQ0lXS2xkeVQ5UkhhbnJvclRTc2NPdEVLYWhZYldQTk5hMmpJVU5wZGR5V3NkcVViaTVWRDZtM3VkenQyUGFtZ1IvRDNWYmcza0pGeFJWZzJPSnBNWUZ3VGV4djNQdlNydEVTaGV3UGZlMzdWSGoxdk1OQzNVYmNXdjgwN0loWFZzU3luWlNiZzBxNEdYOGtUT0ZMcERISk9vaW5rVU1ISXNCcUc5KzIxZTZ1bmVvTUJtR1U0THlKVmtpTU1hbzZHNHNGQXVQNVY0czZTeTA1cDRpZEg1ZkxGSE5CaU13anVqMjNISkJIdFhzbnFid2dsZ2xtelBvVEdKbDBpczViS01XQ2NOSzkvcFZ1VXVld3JvOUNxaTJlYS9xR2U3S29tcWdsRFRLMnE5aHM2bm45NnRSaW44dEpacmtEdU9SKzljaXdmaVBpY3RoeEVHZjVUTmttYjRQZWJBWWc3T252RTJ3Zjl0NjJXTTZ4bndtU1FabEJrbUtueTRoYllwWkZLMkl1U3k4cUJXdW5SeUROaEJtc0JZbjgxSGNjQXRhLzg2RWZXbVRZcVdiRHg1bmhteHVIUVNTNGJXUE1SVHdTdk50anZYSXM5NjB3R1o1SFBqRWVITXdqZ2pCNWRBeGFaZTZodmY1SHRXVjZ0Njc2SzZKaHdYVXVhOUo1bGdNWmcwYU5NWXVHWnZPZ3RjaDJIQUIyOVZLNXBkajByUFFtTzZxVmN0bW53VWFUWWdML0NFNzZJWkc3Qm01QTM1QU5lQVA4QTRnSVRHZUlQU3VaNGdSNFBQc1ZsVHg1aGdZM0R4d2hXOURLL0xCcm14SUhIRmQ2NkYvRXpIMVBpcDh6Nmt5dkM5TjlLd3dLOEdIbHhDdThjS25WNXprOGxoWWFmdGF2RC9qUjFUaWV2dkVQUGVyamlHeCtVNC9GT01JN0cvd0NXZ0JQbFFzQjlObHRVR1RJbWlhS2FaZ3JuWlZHdFFMamJqNXB2eTFMTWRUQzIrNXBkeGNXVWJDeDM3VW5VR0JJVWhUNzduK1ZWQ1JpWDB5cWR5dGozNzB3NjJJRjdIMkpxVVNWdmNENmRpS1pLZzZicllFY0hsdnQ3VUNFYVFDNUJOL1R4VmhGTmVHTWxHSVN4STl4VUp4NnJiS2JXK0tsd1JxK0g5WjBFN2F1M3hRQStMTVdMY0VrNlY3YjBFakp2WTJGOWhSTGFKNUZJRmcxZ2JVblVWSkY5KzlBRCtheTZNSk14Q3FYR2dBTWY2R3FDR2FXQzNseWFGR3d0eGVwRWVjU3RGS3VKQzRxSmg5RnRKdjhBRko4dkJ6T3VpUnNMcUYyMWk0Rk1Iam1XdVRpMDB0ZG1iNmhleHZ6VDZuVG5zWUxYUVlsUWZ0ZW8rWEFxNFcrNm02c2RnZnRVZ0ZaODdnQURJcjRpTVhBK1JlbldCdVpWV1RFTTJtNFkyQ25tMVVQVldaSkRrYVllUFdrODhoVzIxdEFxN3h3R0hpZVNSMGpoRG4xR1FYSTRyQlo5ajF4ZVpzMGJzNlJqUWh0Y0g1L2VtVUJBUWFVQUl0M0ZLUHBLZ0FnSGVrdVFkTmpjQVdPMXFHMjN2MnBRRXQvMG5OOUlzYkVDKzlYK2ZBbkljb1MyMm5lNTlQYXFKaVFDYjlqdFYxbllaY2x5OFhDeHNnZTUzM3RSZEFkaHlmVkRuK1g0VFVHMWVRNk1CY2ZTTGovMXJ1MkZJR0ZoWXE3aGJMZjk2NFZsTS84QStzZVRFK2tOSENYTVl0ZGRHOWR0eS9IL0FQMDdDRXNoUmg2ZEo5SkYvd0RPcXVSQW1XRVpFdDQyM055UGdWaGVzOEhxa0U2Z1dVRXNPTnZjVnRaVjBNeEFWZmcxbU9zeW93MGpHeEMyMUVEZlNmYW9sMlBPUzU1aVBNeXlhRi80b2wrc2cySSt3ckpaZUd3a29qWUFtd1pMSGNiN2Z5cldkUVFSd3lJRURBNkxDLzhBU3NubVFURE9zc1kwelIzQk43QXJidWZlcmlFdWhlZXV2a2VRcTNNMnBtOXlSNzFmK0hlT2x4WFRod1RNdm1ZRjJ2WmVJeXdOaDhWbGM0a01peFRoU1ZiVXBKN1g5cVYwM21qZE9xK2E2R2FHREVKSE1oNE1jZ08vN1d2VG11Qkc3TzE0UE1IbHpLS1lvR2pnWDFDK3dCTnJWcHM2eEl5YnBQT2N3aWNoMXc1VlFwdllIYi9Xc1BCcC9KVHZocGtPR3hrSWRKUi9kMzNQelZ6MTFpeGhQQ1pZQTVrYkd5eElzaS9USmE1UCtWVldXY0hNa2M3eU1CTXZPaGRLYUNvQitkNnZzaElHaFhRK1pHYnJwM3Y4R3Mva3hNT0RWUTJwQytyVU9RUFkxb01wVU1HbDFzRlkvVUJWTEs3Ty93QkdrcU5EaDVHUjdBcXArbzNHdzM0cXhVZ29kS1JtNHNGTjczOTZxc01GQWRWRE5HQUJ4YTVxeHd1MG1rc1FMYkFyL1M5WnpSMWVOcGgrcG1RWDFCallzb3RhbkZFaWxnbzFNZHRROXFJa2xTeWp5N20xZ2VLQ2hveW1ncyt2YXlteC9mM0ZSc3NVUG94RE1ZMEJVall5RHZUUVlzVkpESFN0aHBPdythTVA2QUJJZEttekJSc0tBdTdoYmVrRzRBN3JUclFnMDdPOFJkUXNhamYxYzB6SktoUjNRMllDM3E0UHpVaDVQT1ZvdzJyYlFBZjg2aVNOcFVoMVZtT3hRTGNBRGo3VVVEUXpPSGVJS3pNV3VONHh1ZnRUY3BKMUFONlcyUHVEODA5Tkt6UWtYTm01SFlmQXFNN0JFVU9wUXNiZWtYQis5T1NLMCtCbDVHUURSdW8ySVkvenF0bWlqRW9CakpUa2FiQWcxWlkwSFNxQkVYY1gxQ3h0OFZBblRRVXNGVmdDdHJYUHhVOFROemNFU1ZMcUpMTmRkbU4vMDFHeE9sM0FMRU1Cc1F0OUsvNzFPWStpSUVvUUNBeWdrWHBsblpabjBhYms5dC84Nm52aWloSldRNUl3QVRxUyt4WFZzU2ZrVTBaNUVrOHdnbU94MTZCOU51OWpUOHkrY2hkZ1hhOWpwNUh6VVhYS2plcGhNRTdhZVI4bWxSVWtuWUhWVEd6MkxGd0dWbDNPL0gycElVbVJaZEtvM2UreEZ2bW5kWVlzYmhYdUNGWGhoN1VsNHlJZkxBQVJXTHJwK25lcEV5RnhzaHd4dElaSXQ3S1BUTHNCVFNwY3NHWmxFVzk5amVsQ05ZcmoxV3Z2bzR2NzBseUkyRHBwYlVRckE5aFVyNkswaDJKR2M2ck42aHEwbTFpQjgxSndyQXV6U0pvQjJZQS95cXZaakRPUEtjaGI2U3JkdnRUK0h1N25TNElKM3VlVFRHclFRblRScmNCS0pHUmcybSs1N2ovMHJZWUNkeEFqbHpLUCttd0IySSthNTloNVo0eHE4dEprMWNLYmFmbXRMa09NRDZGVmdzaHZxRnVUN1ZuWlk4MmRobzgxcEkwdUp3NnJJQVVESzM2UWQ3Vlg0dThFMGlsVEVyV0ZsTjlxczBJRDJHbFN5MkFidFZYaW9HUm1LeHMwYWdFdGZZR3E2TmFTVldpTzhxTWJxeklDTnJpbEpKR3BPN094SE5NTkxJcFFzTFNFZXBqUkhGS1ZiZXhHMWdPRFR1eXNwZlpLalFScXhTUzNjM085S2NZaU9ZU0lxdkd5OEg2Z0tpUk1ObWFSVVlDOXl1NXFja3J5SUc4eXpNTGszNDlxQnlwaVgwTWhpa1M4REMvbUJiT0c5dnRWZGpJbUNPeFJESWkzWGVyMk56SmgxakFPbFcxTjZoc2FpeVlkWExDNVF0MzA4aWxUb1NVTnlvNUgxaGd5RVpualJabWtCWWdrM0Z0clZpQ0hobjFLUWRyNmx2YXV0OWNaU2l3TzhZYjBHN0JoeFhMTVFkTHlMR1BTTnREVnRZSmJvbm5IazhUeFpqYmRIWjJjSGlsUkp6RzhqYkIrRFhYTUhPaytERENJR1Fla2tIK3RlZU10eEFpYU11Z1BZZkZkWjZHejVKVWtpYkVBekFXQkk5Skh0VlhVWStiUnZlSDFpcjA1R3N4V0ViSFgxTkdyb2hGamYrdGNkNnJ5STVmaW5CUXh5U2t1R0J1dHE3YllDSUVDOGgyYTNBcko5VzlPcm1HR1dXTmdabFloMVAwbjdWQmd5N0piVFg4bnBZNThXNWRuRkRyaVlDNEJKM1BjMDdETVROenVLbFp0Z0pNSmlYVW9Zd0Q2ZmFxNk1FU2trZXIrOVcwcWF0SG5jazRTY1pmQmNZSTJrdWhQcnZzR3NhMFdVNHRrWUt1b0liYWdkMkZ1NHJIUXpCbnNXYlVBQ0FSM3F5dytLWlpQT1lzU05ycWJiMURPRzR1NmZVUEcwenNPWHpIRVlVR3lrbjFlbHR4OXhVcU9iU1FGWStrNm1zT2F3K1FaeVlzUHJWeDV0d29aMzN0N1dyVVlmR3dZcU5DVzFPb053RjVQdFdQbGc0czd2VGFoVGdyWkpuYlhLYnNTckgwOGJWRmQ5TGFSZHJINmdlS2w0V2FKR1JsMHJLU2JheHRWZmlZUHlqeUZnRUJPN0x4ZW0vQk5OMXlTaWdNVEtGT2h0eDdnMnF2bGxYY21MVllXM0pBTlRJM2FDTjlFdDlRMlB6VUhFRWVyVUJ1RDZXYWxpUXlmdHNrai93REJ4ZEdSN2hRMTlqU1VVNmtJSkVTM3Y3M3BwUVd3b0tOZDdBZ00xMUJwY0tsQUZKSWJ1ekxkYWVseVI3blJaOUNaN2hzazhTdW44MnhjMkd3V0Z3TE5NODJKdVlrMjJKN2cxM1hCL2lzNlJYeEF5ZkJ4ZUlHV3ZrV2JOTEZqWW80SEl3ZUl1TkRpUWpaR3V3cnlmMUVUak1zejRTU0Mwa0xLRzdDMzk0ZHE0VkFRc0tlaTIxbXZ3YTM5Tk54alNQT1BNUjM1clo5R3V2dnhpZUVTWmxpc3RlZk04MnhlSGN4eVl4TUo1bUhad2VWdWZWdDNGcXBjVCtPZncwdytDVXBsUFVXY1RRTUZpd1N4cGg0WkJibjQreHZYZ2VHUW1WQUdzdCtLbEEzWnIzT28xZGVSblBiSW5zbk4vd0Q0aStMd2VMRGROZUhtWDRiQmhTbHMyeERNeC9hTWdmMHJqUGpYK0tIckR4MGl3V0Z6YUxCWk5sT0UxTXVDeXJ6RldVdFlmeEdZa3NCN1Z4NWpxQVpUeWZwSXB4cGRGZ1daUmUvcEhGTWMyK3hWRlI2SlMrVk5Hd25aMllnY25aZ0xXVzM3VktoNml4bUJXWk1HUmgwbWlhR1c2Z2wwWVdLbjQ5cXJudTFoY04zT3JZVTNyM3VEZHVCZnRVZElrZlFsQVYwOEVJdkI1SDcwbldkYXNkVnp0U3lTRDZUWmp6ODBuVUZ1UVA4QXltbEdCN3hoZ3hKM3NlQnRUUkNxdklMRTdFZHFXLzhBRVgyWThsdURUYm5UdWJEY2VsZTlBQ1dJM1VXT245UkZTWUYxd2kreDczNE5ScmFSWmZTcFBxVTFKaGo4eENBZEF0YTVvSFVTSlRvbGtCTEtWSUpzTDNvdExOdUk5Vis1a3RRWUdPNk0yb2JYSzBGaVcyeStZUDd4b0dsQisrL2VrTXhLNlJZZmZlbExmdDZpUllFZS92UUhwRjJHdzdpbUR5WGw2bnpWMUFCT2JOeGY3VWVOTExOSXFzVnNkajhuZWtZTWhaWXkzQmFqeFlVNGlXelhYVWJNQnRRQkVZbGwzSllnN2dFa1hveHN1L05FTEhiU1J2YTQ0Tkt2WUFFYmU5QUFzU0wzMG51S0Y3YzBEc1J2dFJOZXh0dlFBVWdGallBa0FuNzFlWjRQL28yV3ZkbnZHU0FOZ290dnZWR05UYVNBTFdPOSthdHMyTFAwNWxyYTlpR1d3UEZBSFhzaGNuRjVMSXNtcGhoazBzR3Q2ZElCRmRoeTZlTVlmQnFRV2phTXFvWWJnMXhMS3NWcmt5MlhRU3lZYUliQzRBQzJMYlYyVExJMmd5Zkw5S0dUV3Q3Y0c5enZWZkl1QktOTGhYVU9vbEFjQWNIZXEzcUdHUEVDZEJHSFZrc050alR1QnhLVHlQWWs2VzlRdHZ4VGVZRHpvN0loUWRneHNiVkRYSkwwamgyYnE2eUZYSjFKK2s5Nnp1YlJob3lxdHNSY1g1SjdpdHIxYmxyUVlpVHk0MlZHVHpBdXJVYkgzckU0NlF1cE8ycFFRQmZ0VnVQUXhsWmk4UXo0VERSN3NzWjlmelQyQ0JtNmI2blJZbGNSeFJPMnI5Rm1zQ1AyTlI3RER3aFdZZXRTdzczUGFySHBlRnNUbFBWQVkzUDVmdnVUc1RzUGE0cVcrQkMyOE1PcDRQeWt1UVlxVUxNd0w1ZTc3STVQTVYreHZ4V3c2NnhVZzZINlZ3THlEOHdjUkxMSXkvcHRjV3Q4VndETVN6UjRWcjZHSTNLbTFqMlB4WFE4QjFOaU9yY2l5UVRmdzVjQ2o0WjVDTm4zdUdIemFxK1NOSXU2U083SVgyQ2EySFJZMFdObkJ1QUxhNnVzdEpiRENYU3lsTEtxbjNxa2hFaGdWWWp1bzBscTBHVmFaSUl6ZHdUdXlrLzFyTHlIZWFSY2x6ZzVId3poQ1M2QWdtTHRVOWRVamtyNkdYZnkreE5WcVJzc2lNakZoTDlSUDZiZDZ0SXZTWGU5eVFic2UvelZHUjB1TGdkWUNTWVhsVUczcVMyMTZhVlZFcXFaU1ZIMHNQMG1sUlJvcTdqV0I2aUIzK0wwMjJsZk1zU1FlUDhBYW9tVzdKYndlU2gxRU9zbzFEVHlTRGJlaWYwdWhWUVd0WUt4MkZIQXFwSkd4R2w3N2s4WHRUYnNFTW1wZlR5V1Q5WHhRT2ZBY0tCb2hkYkVnM0Z0cWl5NjhQTHNTZHQ3anRVd09yUktDQ1RlKzlNWW1Oa0txTlJBRnlBYmkzdGVnV1hWa1NVckxwRE5aenVGdjJxSFA1a3lvQnFHOXJBMUlZTTdlV3AwZ0d3SGVtNUdhTXlLd05odHVkNzFJbVVaY2taeVI2WFhVeWJGR0d4KzlRSEFrbTFlVWdVM0Y5WGY0K0tubG1XTjkyc0JjSDVxRGlTWlhKYUVSQmh0WTN2Ym43R3JFVnhaUnl1eGdrcUN3UUVBYVgzL0FLMHpNcW9nUUxjcU50K2FmM0dJVXFCdXVyVDdqdFRKVm1sTExxVmlkdjdvKzlTTGtveUJJRVpIa1dUZXdzRk5yVkdsdzhpeU9QcTJ1VGFwVEpxYlFDbGlUNWlEbW1XU1JFUmtTUzQvVnl0dlkxSWhrbzJpSmgzY1N2SDVTeUszMFhOckgzTlBTUkFyYVVGZFBOaGNVM0VOZUthNTFLUmNnRFlWSlZsSzZTeklHSXNiWHNLZHdWMUg1SytVS1VJQVZBM3FETnRxK0tpdVBPamE0VU10aVNOdDZuWWpUSFlSS1puQnYvRVU3ZzgwMHFKRTdLNERCK0ZQSXFTeXRPTnV5dkR0SUZFcXFySDZlNEorOVBJanFvWFNXWFVMN2JXOXFiUWVWcWo1Q242Vy9VUGNVbkNZaFlKM0VldVIyL3VnM3NmZW5OY0ZXMVpjWmNRNUVaYlNWYmZVMXlmYTFYZUV4TnBGTmlzZ2F6bFQrbXM5aGpHMFgwdEUxN2drQzl1OVdjY3FhZ1VrSllEY0VnQVZWbkEydFBrMm8zK0F4Q09WQVlhUDBsK1A1VTlqOU16dlpqSkhJUHJHMmtpczlsdWFPV3c4a3FCMlgwRUgwaTN2V2xXU09hSlZSZ0VKdUwrLzNyUGtxWjArTElzaUtISFFNakt5RldCNXVkOXU5UmxrSG1Xall0R3czSjk2dkpjTUYxbys0OXp6Vkc4Qnd6bFpMQWNxQ042UlA0R1RpMXlHanZHQ0ZmWHZzRzcvQUJWbGhwakkvbWFRRlpmVnZmU1JWT1FZMkdxRVNJRGU0dmVsUnpDTjJaZlRiZlRmdDhpcE5wRkNhVE5CcElRTWRKRGNzdkFwVTBxb2xtaVZqZlpWTzUrYWk0U1Z5UHEwbzR1VXRjSDdWTVZWSzNqaVpnUnR2K3FrYW92UWFraUZtR0VHT2htODZJS29BOUkyTjdiRzNldUc5VzVSTmxtUGN6TXpoaHFCMTNiN2ZGZWdTaE1oV1hVcE94OWdQdldQNjU2T09iWVpuZ1UrYXJYMjVJKzlXdE5rMnVtYy93Q1gwajFFTjBGeWNUdzg3b3RpMXZnMWY5T1pwL1oyTFQxZnd5MS82VlRZM0JTWURGdkU5dGFmWGMzRjZhaXhJamtGeVVCTy90OXExNlVrZWY0NXkwK1MyZWgrbnVvVnh1RzF0WTZqL2V1ZnY5cXM1NEE2aUZ4b2hadFNPQnllKzFjVzZWNm9iQTRrSk82NlNkSUpVZ29QY2U5ZGx5dk1zTm11RERlYXJLbzBYSUlhL3VCV0hueE9FclBTdERyWWF2RW92czUzMXprS3JPeHc2RWpzcmJBSDNyblUrR01Pb0xjcGZjSHRYZjhBTzh1aXpQRE1xSkc4K2l4WmpZZ0RnL05jZHp6SzVJSno1c1Bsc0xoYkg2ajgxZDAyUzFUT2E4eG8vVGx2ajBaMURyYXpYRmp5ZTlPcTUwSnFVQmI3RU52VEVpbEpKTlNsbHYyYTI5TERpNmFsMURjYkhnMW90VWMwblJlWURHSERGNWw5SlVCV3N3M0YrOWE3TE05dytMUmg2b1ZYY0hrazF6dkN1RmIwT1dZdDYxUEFxM3k2WkZuam1BL2l4Z2hneld1UGlxMlNDa2EybTFVb2NNNmpEbWNjc2tRV01vbW13Wmw1YW5NWTBiQ1FnK2dEZlY3MWo4cXphWFVMT0ZkbURJakc5L2dWYkhIeXozOHorR2hhekJkN0dzK1VPVHFjV3FVNGNrK0ZRWTJBSXVvMkYrYVNJenBMZVdoSkdrS3h1YjFFZHBURjVxTUNsd05mQkg3VSt4ZU1xNVZUcTNXNXRUZHRFaW1wSU5Tc1VMSTBlaDEwalNlYWxIRU5Ha21sbVZ3dW9INXBpUEVhSXQ0eUw3V0p2djdrMHhtRGtaWmlYY0ZaQXZwMHQyb1M1UW1TV3lOb3ptWTJmcHpPcEh0cmFGcjJQSjk2NGxIL0FOTWR0ZTl1d3J0OGNZLzRjekVTaGdUaFpENnVPSzRmRGJ5MEZyV1d4R2s3VnNhZDhIQmVWWHZpeVRCWlpBeEFVSGkzK2RQMkpDaSsxOXZtb2l1QXlXc1d2Ymp0VW9yb0RCZHllUGlyck9la3FZNHhETUFQUzN0Mm9hOWMzZTF1RDJwRCtsQWJIU05oYmswNHJoaU83ZjR1TFVpNUdqaW13TFhJS2UvZWt0ZDJBVURTUnVCUnhqVUwzMWFqWUEwbTlnNVlHTlYyL2VoOENnWUd3QkEyMnBKSkJzb3V4NUZ1QlNqc2xoOUZpV0ovcGFpakZ3RGF4QXR2UUlGS0ZzQjlTOWlSdmVrYWozc2ZudlN1QnkxZ2Q3MG5VRkJJRE5xK20vdlFPb0lBalZjTnF0OU42ZHc2ZWFwSmJmZ2c5aFRWeUdCSnVRTnpUMkNaZERNRytyMGdudlNwV0ZraG8vTENKcUpKWFZ0eGFqVTJIMC8xb2pwTVlZTUdWcmo3YjhVbEpkckFOWWJiQ2tDaWlpT3IxY0R1S05qY0VIdlFvVXdVZXdKQWxCdWZUWWlsNGovcXpGZlFDM2FoUW9BaHE0SXRZMzl5YU9VMlVINW9VS0FGL292UlgwNlRhOXpRb1VBSUlCSXNMRUdwOCtLODNJc09DTG1LUjQ5L1lpaFFvQTZobGNoaXl2SnBodzBDclllNFd1MWRQRHo4bHl0MlpnSllybTNOOTZGQ29NblFEK1ZTaVROQzhaWWFpVjBzZHRxdDhZUTAxeUx0d0w4Q2hRcUVsZlJ5anIwZmw4ek01SkphRlUwcnNDM3Vhd0dOalV2cUtMYTVKdDlxRkNyY2VpTmxFUnFmRFFqNlZWd1NmNlZvK2dFdmdPb3BmMEhETWhYNUNuZWhRb2wwSWN6eHhGb0ZGOTcxdXVqSTBqeVBDRjc2WExEU3ZBTys5Q2hVYytqVDBIL1lhekNFejRaMFlLeGhZRFVmMWZldERscE1zVUVnc2lTUHEwS09QaWhRck15SGI2VHN0Y003ZWUyczJkU1FDdFdTZ2pEcklUdVBqbWhRcWhJNlRFT3hCWjFLM0trSVh1UGlrcGFWOUhBSUJvVUtpWmFKTE5lVWZJdFNQTkpsV01nYVR0dFFvVUQzME4zVURWdmM3TlRNc2lNanhzcHVvSjI3Mzk2RkNnV1hSQUVPcGdtc3JxR3hBM0ZONGxoQkhkMURXRmlWNUo5NkZDbnJzb3NZeEFJalZqWmd3dlkwMHlsbWFMekdIRGJXN2loUXEwdWlqa0lLa1M0alNWc1FkbUJzYlVKR0U4elIySWxrT2tQZmloUXFSZEZPUWdoa3RJb1VsaVVKWVVEYUpWQytoait0ZXhvVUtWalYwUjFqODZjN0JkN0ZiYk44bWp4REdOakM0VmxBdmNiVUtGSVJSNklXTFlyaFZrVWxWdmZZNzFDZ3hubUF1eTZ3RFlCdWFGQ3A0bExMd3h2RXlSdkt3Q2xCeUFPMU5ZUmc4MGh0c1JZZTRvVUttWlZmYUxPTEVGY1VxV0J0NmFrc2drVXh5b3NoRzRiZzBLRlF2czBJZEZ4bHVOTGtKdVVDMnMxYWpLOFlIVkl6R0NpK2tYNW9VS3pwZG5SNlBvc3BScWlETHNWR25lb1dJd3Y1aFdFbGlVVzRQZWhRcUw1TktSUllxRWx3Mm9pNXRha0VHSUJpeHN3MDJGQ2hVcUtEUzNNazRQRU9zaWdrK2pZRUdyNkpXakVqNnRUQ3gzb1VLYXkxajZIQ1ZKY2k5bU80SnBiS0drWkR0NlBwSEZDaFViZFM0SjRLMXlZSHIzcEdERnZMaW9SSEV4VFV3SzhtdVBFRERsdFkxbFdJMDN1S0ZDdHZUdDdEemZ5TUlyUHdnOEZJMW10LzB6K2o1N205Ym5wanFlYkF5czhVc3VtRUtTR3R1UGFoUXFUTWs0bGZSU2xESlVXZGFnbE9Jd1VicW8xSDFHVnZxc2UxWW5xL0lvbGtaeTUwa2oxY3N0L2FoUXJKMC81bmFhdEtXbXQvUnpYTWNPTUppVmlhenFVTnR1TjZpRk5ZS0MxcjNzUnRRb1Z2UTZQT0o4VFljUVZKZEZ0Z0xrajNxVEhMWnJLVHFqYXdZamdHaFFwU1NKb01wYnpaaVR1UUFTZmI1SHpWMWg4V2pOaDI5WUxzVWI1dDNvVUt6NXJrNlhSOHBGemg4VDUwTWl4cUVFSURNVHkxNmFPSlo1UVBteHZRb1ZBK2pXa3E2Rnh5dHFrWWhXVzQyYmVvV2VTTkxDOFYrd1lDMndGK0tGQ2tqMlE1L3dEckNJYVRKTWZFYlhsd2pyOEN3cnovQUJ1MmdHK3dCdjcwS0ZhbURvNDd5bmNQNi84QTBjZ0t5T3BVSG45UnFWcXNHSXZjRzlDaFZ0bk9TN0hCSUFIQjNXL0ZFcWZ3aFk4RTg4MEtGQzdHanNRREFrQzJsUWFUTk11c0x1VlBZMEtGSyt3RXZJcTJWbE9vY1dPMU9GbGJVYmRxRkNrQVRxdTFyZmFtcGZTVDhibWhRb0hoRS9XVkhwSEFOTzRmWk5aSHBPd0hzZmVoUXAwUmhKYVB5RkNvZGpjbS93QjZOU1V1QVNOKzFDaFRTVDRQLzlrPVwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n')}]);