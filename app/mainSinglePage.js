!function(I){var n={};function g(e){if(n[e])return n[e].exports;var l=n[e]={i:e,l:!1,exports:{}};return I[e].call(l.exports,l,l.exports,g),l.l=!0,l.exports}g.m=I,g.c=n,g.d=function(I,n,e){g.o(I,n)||Object.defineProperty(I,n,{enumerable:!0,get:e})},g.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},g.t=function(I,n){if(1&n&&(I=g(I)),8&n)return I;if(4&n&&"object"==typeof I&&I&&I.__esModule)return I;var e=Object.create(null);if(g.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:I}),2&n&&"string"!=typeof I)for(var l in I)g.d(e,l,function(n){return I[n]}.bind(null,l));return e},g.n=function(I){var n=I&&I.__esModule?function(){return I.default}:function(){return I};return g.d(n,"a",n),n},g.o=function(I,n){return Object.prototype.hasOwnProperty.call(I,n)},g.p="",g(g.s=62)}([function(module,exports){eval('module.exports = "data:image/jpeg;base64,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"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9pbWFnZS90aW1nLXB4ejAyLmpwZWc/YTA1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQ0FBa0MiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LC85ai80QUFRU2taSlJnQUJBUUFBQVFBQkFBRC8yd0JEQUFNQ0FnTUNBZ01EQXdNRUF3TUVCUWdGQlFRRUJRb0hCd1lJREFvTURBc0tDd3NORGhJUURRNFJEZ3NMRUJZUUVSTVVGUlVWREE4WEdCWVVHQklVRlJULzJ3QkRBUU1FQkFVRUJRa0ZCUWtVRFFzTkZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlFVRkJRVUZCUVVGQlQvd0FBUkNBTW1BcndEQVNJQUFoRUJBeEVCLzhRQUhRQUFBQWNCQVFFQUFBQUFBQUFBQUFBQUFBRUNBd1FGQmdjSUNmL0VBRTRRQUFJQkFnVUNCUUlFQXdZRUJBUUFEd0VDQXdBUkJBVVNJVEVHUVFjVElsRmhNbkVJRkVLQkk1R2hGVkppc2NIUkZpUXpja09DNGZBSkZ5WHhORk56b2hnbUtJT1NOVVJWWTdKay84UUFHd0VBQVFVQkFRQUFBQUFBQUFBQUFBQUFBQUVDQXdRRkJnZi94QUF3RVFBQ0FnRUVBUVFCQkFJQ0FnTUJBQUFBQVFJUkF3UVNJVEVGRXlKQlVUSUdRbUZ4RkNNVk14WkRKRkxCMGYvYUFBd0RBUUFDRVFNUkFEOEErYm9hL29HeXR0cE5BN0FXNzBCZHJtdzlPOUVMbjduaTFBQjhIMnBhc0FMM3VLYkhCdVNUM0ZLWDBxU0JjSHRRQTRXR2pTYkFjMkh2VGtjbWxFakFBQ3Rjazg4VkhWTEN4UE5MREFLVnRZZTlBRDhrUmxRMkZ3Q1JSNGw3dkJwc0xSQUdocjlDYUJwdDZWLzNwVXlxeVBwSUZodjl2YitkQUVlVUFsZlR2ZmswMDVhTnpzQzEvd0NWUHZHUnRwQjJGeURleDk2VE1DNXZmVVVIUHZRQTBHdHh4Nys5RGczdGI0b3IzT3c0My9lZ3B1VHR1YUFCeGMvVjkrMUhZUDN0U1ZaYjczdlNqZjhBU0xqNW9BSkRwRzM5S05UNnZUdFNMaFVzQlJua1gyc0wwQUxISm9NREliODI3Q2tBNnJmTkRlOXpzZTFxQUZhdGdMaTN0UnNwQjJ1UjhHaUkvdTdmTkV0eGU3RCtWQUN5eEJGcnFmbWkzYjZtTjZMdnRSOTlodDgwQUhwK0xmZWt0dFJINnJDbFB1NXRRQVFRTWI4L0ZHVHAyMkZ1d29BMjJ0M3BKQURFSGREdnQ3MEFLRGRnTEZkNzBBVGMrbzBRYlQyMC9QTkViMEFIOVl2Uld2dFJLUWQrTFV2M0pGaDJJTkFCaSt5KzFLMGtVaTk3TnVQbWpRYTcySUkrOUFDajlObDRPOUpiMUN3TmpSb3dHMUUyeCthQUhZbUR3bGJBRWZxSXBxUjdxQ3R5UGtXb0kvbHlCUWR1VFM1OXBMMnVHM0ZBRFlOeFFGOVhBSW9FRlZ1TjZKdElGemE1b0FVdHp0dGUvYWxEaGh2U0xrdUFQVHRSL1NiZTlBQjZEOVFZVW9GbStrZ3Qzb0pzcCs5QWdIbnYrMUFDbDJISHE5dmFrcUNMa214TkRiUmUxbCsrOUJpTkkzb0FEY2JHOUM0c3VrNmQrYU54cHNEdGZpa2xUNy9OQUJoclh1TEc5Nys5RmUyeTk5Nk1sbUpOK2FLeHNCZmVnQTduekJmZmFpVk5LaGVMYjBaQUFGd1FhSVhQelFBWmF5YWxGZ1RRYmdiL0FGZHFKZ2JpM0ZFUUwzSW9BVmE5aHNMVWRyWEZnUlRadGMyVS93QTZVQmYwbTJudXB2ZTlBQmo1T21ocEJKS2tlcmZVZWFTUzF5UUFMVUZidXluZWdBTHF0YmtMN0NncHNmN3Z1RFFVV1MxcmZ2U1JiVDZ0NkFGTjZqZlVWSHhRSnRmbTN4M29CZHY5S0JOdHh6Mm9BSXFiZW0rNG9HK2s2UnY3bnRRSnVxN1hmdnZ4Uk1OVEFzd1lqYmJhZ0JRT3d1MTE5L21oZmJkdC9la2FmVmUxaDdVWVVNVGZqMm9BQVlKdnlhYzlSM080cHRWOU42Y1U3V1BibjRvQVVEYzI0WDJvTXhBc3ZGRmMydUJZbWc0QlZiVUFPYWYrUWtBVzEzWC9BRHFNUmNOZnNOTjZmT2xjSzV1VC9FRnJmYW1IUHBiMnZ0UUFaVUpiMVVuVUc3VUd0Zllrcjdpakc5N2Iyb0FXT1IzcERHeEkxa0Qyb3dDZlZZMkhZYkdsdXVzTFpWQXYzNW9BUXpncllGdGp3TzFBdHRxYlRmM1BOTEVaMGJiTGY5NkhsZ2IzRng3MEFJYTlnMisrMURteDlOeHR4dlQwYXFsd05nd3VTYUs1QUFXMTdkNkFFQ01zUVJmZjNvdkxhN3Fkd2V4NHB3RzFySFJTN0ZuOVhKcC93QTlCamNaZ3NNOEVXS2VMRHlFQjRsYjB2MjRxT0l2VzRYZnNiYkNpTE16RWN0YitWRTFrNUozOSsxTllBc29ZM3NEL0FJZUtNWEpHcnR2UXNHRnROajgwV29vZldGSTRwQUIydndXOTZBVUUyMG0vM293Mmx5TnQrUGFpdU5QcDNVOG52VHdEMDZTMWpiZmtVazY5VFdZRVg3MHF6VzBjclJDdy92aW1BTW5VaTNGclVDQ29GcldwVVpHblNmYmlrbTYzQXNlKzlBQldDL0pOQWdFV0Z3ZmVnbG51VzUvcFJBNlFlZHU5QUJnaGR0OXVLREM0NHZRTzltSjJOQXRRQXNNRjA3WHRTNDVCSDlYZlltMTZhQ2FybSs0NHBZY3BIOU9wanpRQkk4dXgxRGNXN0RtbTVMcklkUzZGUGMwaFppZ0pKdmZzVGExUHNubmtEYTUrbHIzQzBBTVR4aFdSbDlTc043N2IwM2NrbHVXcVpqREdaVVJDV1ZWdHFJdGR1OVFtdXQxSjUzdlFBQllIMDdOM3BKSnZmVWIwdXc3ZlZ6UmFqN1VBRUhMV05yQzFCcldEQzlqNzBkcmdIZ1d0UXRjRWRoeFFBQmQ3MzRIdFNyZzNQNlRTYjZSdC9XZ0ZzUWRXci9DS0FEQjlKRkFqWVVrRUVudFN5d0l0ejgwQUpBTjZNRzNOQUQwL0YrYUJYYm1nQkxmVUNPYVVDRzNBdTN2U1RjTUNLV3lpNUY5UDJvQUZ5ZVRjMG0rNS9sU2dOcUFhemNBN1d0UUFnY1hQSEZPRWdyWUg0cElBUTJPNE85cUZ6ZjBtZ0FEYjZWdVBZMENRRGRiNmp5RFFWaU9iazBZMVhPNEJvQUlFYmtjZHdhUHNTQnBJb0tkVzVYUWY4NkJCSDJOQUFXMngvclJ1TlJzVGJ1S093QTM5N2lncmdsanliVUFKQkZyV0dxbkh2SkYzMUx2dWI3VWo5S2tqK1ZMaWUwaWdiWDdlOUFEWktxYkRqdFI3cTRQSlBhaEl2bHMwWjNOOXJlMUVCdDJ2Mm9BSStwdHR6UjgvTkdHOVJGcUNEbWdCWWExRFVBUmNEYjNGRUwySXYrMUJnQ3d0dlFBQ2JiODBRSzM0TkhRc0Nkai9BRW9BQjN1VGNuZ1g3VUJ4YSsvdlJrYmR4OXFKcmFlUnphOUFDZ3R2dlNUZTR0UWJkaUFhSlRiYWdCVHFHMnViMGtBTHNML2FsRWl3TjZTR0FhNTIrOUFCaHdMM052dlJPUVNMSGlpSDZ5UUxYNW8zWDFiWE5BQkc1SnNMS1J6ODBTaTl5RFlqbS9lZ3BaWDIydnplbkNnM05pQjgwQUlKMVdBMzdrME43N2k0K2FORUtnOGMrOUxaME93YWdCQzhjVy9laVVYTzFIc1RzTC85MUJaVkNrQUFYN2lsb0FLbGd6QTkrOUtJdU9ONlFaTGIzSDJOQldhNUl1MS9haWdBZlR1TzI5R0dVZ2tnZTlGSEhLVkxhV1lIaW5QeXNsbUxhVXRiWW5maWlnRUVnQzl0cUxVQ05xZUdCSkNobk5qdlMveXRnTi9Vd3Y4QWFrQWpoVFkrNTJ2UzdnbmIvd0EzelJrQUJyTUxyelNCemNHOUFDaFlYdGZmZzBhQTZyait0QWpiNXBPdlNMZHpRQTR5aHNHUndUTGMvd0FxanFOUi92Ylh0VWh0OEtvSU5qSnVQMnBrTG9ZTHdiV3Z4UUFZR3F5cVN0bDNzTFhvMFBtRWNYdmE0b2xCSzJOOVZ1YUNiTmJqVHhidlFBdGszUDZ4ODBCYjZTTk5DNUFQejcwWStrcmJVZjYwNUFFemFyYlgzdmFqWVhsREJRQ3cvYWlOd09SY1VxNWRnUHFITktBU2VuM3VCYTFHUmUxeVR0NzBmbUFxYmtGenR0N1VUUmxWSE5xYUFWeVdBTmg5NlZmMWIwbXhVV3ZiZm0xQWtIVjZ4eHpSUUFzUGNodmNVTGx2ZDc4NnFYR0FUdWJnRFkrOUtMM1lhVUpGdDZLQVlCWWIySTdFR2xCUXpFVzROeGVsN200NHYyb2FmVllzRFJRQ2IzMUFqVGYyN1VRQkNiTDZlTDBFQ2tYMVhiZ21rZ0Zia2ZUeWQ2UUE3Z2JibHZjVUxmTFVHdVR5ZHhmaWlDZy8vZWdCcXd2WU0xNy9BRlVhc0Flelc3bmswbGpZWElMWFBOSGJjWEdtL3dBVUFFOWx1RDM0RkVUcFhZTmJ2YjNwVE1yS2ZiL0Z6U0dVMkl1UmZjZk5BQU85ckRVdnQzcFcra1dBVWUzTko0SHY5dTFHVFlEbWdBd2ViQzFFV3ZZSFkrOUFIWTBRTy9IODZBSFkwMU5ZQUgzdlR5T0dKRGVsTGNMM3FQR3hRaXg1b0lkVGc3NnJjZHFBSk9oWFVpTnIyRnhjMUhZWElERDR0N21sUmdvNnFEenlMMDVQRm9KWlNWRnUyOTZBSTRGckQ2V05FQUZ2NlFhTUVXRndHSTRORWk2bXNlYUFDVTJzRHdlMUtBTmp0U0xxYlhCMjlxWHFEQTJKL2VnQk5yamZiNzBlclRhd3RidUtMNjdxZDdkNk1mUWFBQ0NtM0czdDcwbzdLVGJpZ0NMNy93QTZMVmV4NEI5NkFEQkl0WVVhalVMc2RKL3pvbXVUdFJhbVhrWG9BVXdzUUwzK2FCVUU3NzBRWW45SXRSdHQyb0FJMnNRQnhTUmNIZllmRkxVQU9DZUxVVzUzN1VBR1RhUUhTdHJjMFpVMjFIY2V5MFFGbFBmNG9LYlhBM3RRQUZMVzNHbWlZWFVnMjV2WWQ2TlNEWVhJQm9kcjZxQUFWRzJwdjloUldBTjlybmlqSTNYYmFnVkozSUcxQUJra2dDOUY2VHRiZWlPNTJvd2YyTkFCa0FING9hZEpCRnYycFZ3QnhlaFkzMy9sUUFxVWhrVnJIVURZL05NbHVMY1ZJdzdEV1ZZWEJHMU1rV2RrUDFDZ0JQTzlxVXBQSjJvRUFDaUJBUGNmTkFDbElWaWIzb2xKWnlCNlI3VVdrM1kzMkpwWkZ6ZmlnQWliVVpGMTVzTzN4UitsYmF1NG90U2NiN1VBRUdKSHo3bnZSRTJGMXNSZmdkalJzdzBuVHY4QWZ0UXZyVWdoUnRmMDgzbzdBVnVXM0ZFWXlMNnRnS1JxMUJBRzlRNWE5QXBJeDRaMnZ4YWxvQlNvQ1BxQW85S0xmVjZ2aW5JOHZ4RWhCOG0xK3hOU0V5ckZLd2U4Y1JRZzNPOXFWQVJRTmR0S2FrSGVrTkk0WWVnQS9maXJ6RVFZekY0bVRFelluVk5NQnJieTFVTUJ0d0xXL1lVeXVUd3h5TVNoRDhobk42U2dLanpHTEVmcW9ocmMzOVczeHRWOG1CZ2pZRXFGQjJMRDNwUlJGTGhUdHo5NktZRkhGZzVaTndsejd0dFRneTZVc1NTcWdmRldjanFGM0lCSHhTWCtrRU1VRjkrOUZEYklZeXNsN05Lb0JGL3BwUzVmR29BT3AxWGs4VktNNjZSYTZrbm0vYW1qS0FXS2tzdDk2Y09DWERSS0xoUUI3SHZTdlNGT2xiZkZKMWl4YmNqMnBKUGZmY1hvR0N0SkowRTZnZUNOclVtd1c0RnBGUExDaXVBUW8xQWplNTlxT1VScEsva3lOTkcxdDVWc2I5K05xRUFQU0ZBSTJ2WVVaWnRZSklOOXZhbTBJRndWTEc5N2s3Q2pZalZ2Nmh6OXFHS2lJK2xUSlpyQW4wbjMrS0FiMUMreG9ONVlFV214a045UzlodlJiRTkvdlRCd3B3U3kyc2JVQ3JDKzM3Q2kyWGU1NXR0U2pzZlRmMk42QUZPdi9LUjhqVTVKK0thQzZiRTdmSXA2VC84QUJvTDdFM1B4U0ZKRjdXVVcrbzhYb0FTcExtNTNiMkZCckMzdlJYdUNkUlB1d0ZLdGNYNEZBQ2pzZ3NkalJXT2k1M1BkaDNvaWdBM0dvKzNjVW9teTJHL3VLQURzcW5ZQzlKc0Q3amUxSzlCUkRiMWQ2RzdBZW5hL3ZTb0FuY3FCdUZQMjNvTnFJdnF2OXFLNitrMjlJdUNXOTZVTHI2YjJOcmZCcHdDU0RZWEpJK2FVbGhZQlFibjk2U0hJYXg1RkdvYTVKMnR3YVg0R3RDeEhlMXpzZXc3VXNLQVFvYlVCeWZla3JHd2JZTTN5RHRUZ2lKVUZiS2U0dnpTQ0JBQUsxdGg3VWhpTGR4OFUrdUVkamNLVDdxT1JTbHdNakVLVnM3SFlFMzI5NldoMWtIbFdPN2QrYlVSdnVCc0Rhck9ES3BjVEk2UTRkNTJVbGJScVd1ZjJxMHdmaDluK1lZY3pRNVZpQkRlek00Q0FIOTdVeW1LWmdJUUNiV3R0cW8vTGIrOERXeFh3OHhVRHNNWm1XVFlKTGpWNStQWFVvLzdWdWFRT20rbkF6ZzliWmFDR3RaY0ZpR0EvZlR2UlRBeFN1U0FPUmUrMUZxNXRxWS9ORDZUWUN3OTZNQ3pIZTN5ZTlJQVdrRDFBYWovUzlBZW9XTndCMzlxVUdBMUFpM2Zha2xXTVpPeFUwQUJyODhmNjBSNEh2M3B3V0s2Yi9iNHBEcGEzYi9XZ0FSZ2ZWd2ZtZ1NDMi9CNW9tWHZmOXFGOXQ2QURKdHQvS2pIMUUvMG9tQUlBTzQ1dFFEWGF4UGFnQnhTQ0NTTGZIYXBLUzZSWmg2YldBRlF4Y0FoRGNmTlNNTVJwVWdqZHJzcE5BRE1zSlVFcVNSZmcrOUZJbzROdU43YzFMYU5XMUVYMDM1djNwbG9pd1ppTGJVQU15V1o5UFllMUpKMWppdytLV3R5dXJhNUY2SVdBc3dJTitQZWdCQ0N3WUh2d0tVUGJ0Ukc0SjNvbXRZaWdBYjdxZDZXUnZia2RoUVUyQUh2dlJqNzBBQVhHNW9oYzhiVUN6Y2MwU2szSTJIeFFBWjJVM054M283YjJHL3RRRjNVMHExOTZBRWdFWHZ0N0dnQTF6NnRod2FEYzJKb0w2VHZ4UUFWaVJ6dlJxTlJBTzN1YUFOMlBZVWt0ZHZ0UUFaSjNGclVBRGExS3Q2UWJHLzJwTi91RDJvQVUwWkMyTjZTQVJ0ejk2TUZyZXJjMFJmVCttOUFCZ1hIMjdVZHdEY2szUGFnamhoL3BTU1dKdDJvQWR0YjcwVXJXWWYxTkVoQXRiZXd2YWhxMk53RDhVQUtENlpMSzFpTndlMU9ZcExoSkJhN2l4SVBlbVdVTXR1M3hUc2FlY2p4MjN0ZFFPYUFJOXlyV081b0hleDdVdmUvRmdOdDZKUVdKdFk3OEdnQWpmZTI0bzFpWjJzRnZUOEtCU1ZheHFaRjZCOUkyNys5TFZnUUJnNW40akMyOW01cDZQTFhKdVpCYzlxc0lTbHQ5ckQrdEtFdWxWTjdYL1ZTMEpaREdWcnBER1J5T09LZWl5MkJDNnN1cHUxNmVhYlN4RFgwbllVbVdjYUFTZFI0Sjcwb1dPcGhvWTFEYUVUZXdOcjA4V1VIZTRCMjI3L05Rak42QXR6cDRBTkUwakVlOXRpZmFnUms0T3FycE5nQVBxcEJ4SHBCYlpxZ3M0Wk5LMysxRnJPb1hOeGJtZ1FtU1RQSUQ2cnRibWlHSTBxQTJwd1J1UlVRTnAzSGZuNG9nV3Z6WVd0WWJVQVNqT0xnQTNGOXpUYlRzV0cxNzhnMHpxQ0JRQnlibWkxTVhPOWp6YWlnRnEyNUIwcmVrTTNyc0dwS3VXQU43OXQrMUJQNGdLa1d0elFBZW9GZFFGeUtQVWRBT3NCRHZhbTlZWUxxSU8vYWpLWDFiZ0grbHFCYURMbXgzQXQ3MG01WkNQZmU1N1VRdnlRRGJqVndhQWJia1hKNDl2dFNCUUN5aXlpOXp3YjBrQmhwTEN4dnhSMzlSSnNiMENia2dEWSs1cFFvV2Q5dUhhOUhFdC8xMllDMjNlbW45WlcxNzN0elRtb09iQUFLRGF3NXBCYVpIbHhCWlVqMG9nak5ycU4yUHpTQnFGeWVPOUx4QVh6RDZEYmd2Zi9NVWxoWWJtNmpZRVUwVUlxdXgzcFMra0MzTjk2QkJTNFVDdytvMEJiU05PeWptOUFDcEFTa0FPeHNTTGZlaUF0ZnZ2d2FmQ2Vjc0NxZHJGU085elMyd0xTQjBJS3VtMXRQZWxxd0loYTV0cWEvOUtMWW0xL3VLa0dFNkZNaktMbXdJUGZ2Ung0Y3luU0JOSXBGN1JSRmlEODJGTHRZbGtZU0JoYTFoN25takdvalVOL2hlYlZlWUhvblBNd1JKY05sT01taExGUklJVFkrKzVxMFR3M3pXSUxOakpjdnl2RHVEL0Z4bU9qQUc5dDFVay8wb3BoWmtWaklKSU5sYjNveEV4RmlOU2poaGV4K3g3MXJoMDEwM2dKU3VZZGFZSmdCNlRsZUVreFZ2dWRxZXhCOFBNQzBTUVAxSG5Wb3J2T3ZrNFNOM1BJVldCWUFHaEw3Rk1jY094UERNM2F3OUlIejdVUWl1QWhkU2U5aUwxcm8rc3NpdytYcEhoK2g4QTJLQjJ4bU54YzBySDdyY0xmM3BPTjhTODdkZytEdytVNUVRUVZPVjRCSVNTT0RlNUpwelFuSlI0WEljZGpvbC9MNEhFNHBEOUpqaFlodjN0VnhoL0R6UEpZeEwvWjVTRWpjNGlhT08zODJ2VUhNZXNlb000ZnpjZG51Tm1rTzl4TVYvb3RxcEo0WXBaV2FRTkxJUmNsenF2OTcwME9UWkhvckI0SCtKaitxTWl3OElXK21LVjhSS3A5dEFVYi92UnhMMFpsOHdYRVp2bSthS3grcks4R21ISVB0ZVFuYXNhdnBKQ29xZ0hheHRZZTFMUXF1a0tCdHpjRGMvdFJZaHFwT3F1bk1QT3l3ZE1TNHdJM29mSDQ5Z3hIWXNxYlhwS2VJbVB3bUlMNEhKOGx3TGFmUXlZVFc2RDJCWW5lc3Ewald1MWlTM1BGR0xlYU5sQjdHL05MWXRGL2lmRUhxVEdEUWM1bmpBYlVCRWlSRy8zVUNxWEVZdkY0K1YzeG1OeEdJWTN1cnlzYi9ONzFIRHBmMXZaeWJFVVBNQkMySkFHMjFGaFFVY2NjZW9JZ04rVzVOL3ZTbWtWanVMSDRXOU5GMVVla2VoTmhmbWovTXlyc0ZVaWl4S0l4SVk5N2UxR0RjS3A0Qm94L1E4VVNqZjdVd2NIc1FRS1RaZ3g5ajI3Q2pVRTZyQzFFRHFBdHVDTjZBQWdBdmE3RWNnVTRmWHZheCthYlJRQVR3YUFGdHhlOUFBTjBiMURlaWEvY0Rlbm1PdFFEelRMTGZrMjloUUFGSGJtakEzdVJScWQ3Z1dvaWR5UlFBQllIa2dVcFNBQ29YNXVSUlVRWXNMWEkydFFCSVZrVWM3SGExdTlPcnJrWjFMQWhkZ29xSlludmY3MCtoOHVKblczbUUwQUpUREFSekZtQ2lOUnQzWW4ycG0ydmJiWVhCUGVwbXRRR0RnNmlMS3k3Z2ZlanpQQ3d3ejJnMUZkQzduMzcwb0VBaHVhWDhrOStLTXJwTi84NmJKdGU5OXpTQUdTQzF4ZWpPOXFCTjBGaHYzb0hraXgyNzBBRzNBTnVLQXNDUTJ6ZkhGSlk3Ym1nQnRjNy9lZ0JRWFRmMUFnKzFBUHVBYmJpOXFBUVd2YTl0ejlxZDgyMEtJQ3JSQUU3THVDYUFHMkl2ZTFoOG1rRitkZ1FQYmVwS3ppSmtlSERxbm8wbmErcjVJcGdSYVFHQkZoejk2QUN2ZllVRk54dDIrS2Q4a0sxd1RSaFFTQUFBZTRvQVozdGJVMjNHOUswczVJSE5PUmdNMi9wQUhlakIwZzJvQVlFUkl2dmI1cFN4Rm0wZ1U3ZTRKSnQ4VWFTQVdOQUNSQ0xHM0lwWmhCOTdVYkEyUDM3ZTFLMUEzSTdVQU5UUXJvMWJBSnNiKzlJdnNlTmhlbnpwZERxM0hiNXBqeXg2cituMitSUUFTVzdtMS9lbFJ0cGU0dnQ3VUJZOEtEYjM3MFlZK29Xc1BhZ0E1MThweGNFQmwxQys5NmJ0b0lKVWdtbjB0TEFWRjd4K28vSTlxajNablVJcGt2dUZITkFEaWdLM3ZVcUk2amNtd1h0VVRWZTlodUtrcHNRQ1RadmJlbFRvYXg5V0dxOXlwQjU5NlMxdzExUHh2MnBzRzF0UnZhbEFzNEk5NmRkaUN4TXZ1VDIzb3kxaHVOL2lpRzBZYTJydHRSRDFEWTdkejNGQUN2U0Vibm5hL2FraHRZSXZiL1doeVFMMkEzQlBla3ZJRlc0dGNmMW9BVmMzSUp1UU5pS1NwTGl5N1c1SGFqWWduc3Z1QlJFcnZ2cFB0UlFCa1h1TmhmZWdScWJZR2tzeHNCcHVQZWlzYityMUQ0UEZBdEI2ZEpOemNlNG9NUVNPemRqU2JuYmZVdCtlOUM0WUMzYy95b3NLRk9RQ0NCY25ZKzlKMTZUc0JZN0RibWtxVHBOdlV3TnRRcGVndXhLa1hQOUtRUUlOZGlHRnpiaWhjaU5qYmdnaWpFVERuWnIySlBGTmtySDlicXU5dC9hbG9kWWJBQVhBS3NlZCthSjJiUi9ldmJhcCtEeUhOTTBWVGc4cngrT0I0YkRZWjVBZjNBdFd6eW53QThSYzFURFNwMGhqOE5oY1RzbUp4MmpEUlc5eXprVUtMQ3pub0FJT25uc0R6UUdwZ05nRjczcnJVZjRjTXd5M0dtRHFiclBwSHBrUnJyQm56UloyUHhwanZ2VUZ1aHZEYkxNSTV6UHhObXgySVJ2NGNPUzVSSTZ2L0FPZHlCVHRvV2MxMEZyWHVwSTIydlJ4RlVhN01xN2R5Q2E2TzJjK0ZPVTRjRERkUGRTWjFpMVA4U2ZIWmdtRmpZZjhBYWdZL3RUVXZpN2t1QXhxUGt2aDMwOWdVUVhSY1lYeFp2N25VYkUvRnFLb1c3T2R5SkVubTNVdUNOU3VDUXQva1dwbTl3UzJ3TmlBUGV0WDFQNGpaMTFaaE1SaE1WaHNzZ3drbnJJd1dYUlFFV053THFBYXlyQXNVSk54YitWTVlBYTloMnNMbTNlajA2aUxpd0crMUVSdllHL3ZRT3pHMWhjQWIwMEMweTFjdDhxWnN3eG1LZ2xpQ3ZCQmg0ZzRsOVZtMUcvcHNLdG42aXlGY0k0Z3lqSHZpVy84QUdteGdFWjMzdkdGdi9XczFKWlgwdHBJdUNBZCsxR1pIZU55cE5yQ3dXbkowRko5bW93L1hqNFVZbE1GMDFrMkc4NExZeXdtVXhxTzRMTWR6M3FUaXZGenF6RVl5ZkZSNXBIbDdUS3FzbURoU0piS0xBQUFWalNwUWhyaXhGaVAvQUVvaVF4M1lLU2ZhOUx1Q2t1aWRpczd6TEdTU3lZak04WTdTRXMxNVdBSjk3WHFDK0hoSkVoUU94NVpyVWt5Z2hpV1pyRzFoUUVvSklLQUMrMTZOd2xEZ1ZSZEFxK283WDUvblNuYlM0WTNQWWdEdlRCYzN0cEdrZDZCZHdpa3NiRzlyVWxnaDhzZU55TGNYc0tiWXFicmU1dDM3VXcxckRVMWdlM3ZSMnN3WWtCTGVtaXhSMHlJWENsamIyRkF5QlNEYS93QWQ2YkIwajZndllINW9pQUNwNzhHM2VtZ09OSnlkSUMvMXBPczdXSS9sYWdaQTBndDlQK1ZKSUJleGNuNHRRQW8zdjYyMm9oWmpjalNsN0MvYWlJQ01EZTQ5alJoZ29JdFlrMytLQUNKQ3Z0WWtkL2VpMDJYM0h0M3BKYzdtMS9udFN1eDVCb0FON0JIQld4UHZRRHNSc0tTV0pZWDN1TjcwZS9ZMm9BYXV4WWtjSGExRVdaVkxMdUQvQUVwZHUxKzlFZ3NTdDdpZ0FqeXdHNTVveDZtdU5nQllDaXZzMStSMytLQUdsYmpjMEFDOXFQaTlGYmY1OXFXYkFiZ1VBSUpJc2FjTm5VTmIxMFIrKzFKc0d1TDhDOXhRQVNpOTc4aWpQMURlOUxZaHZVb3NOcmltMkZuSTcwQUQ1b3IyOTdVQ0FEdTM3VXBycW9BTzVvQUxXdHlkN2RxSU5wc1NOKzRvQUYwWXJ3UGlsK1kxaW85UUpGd1ZvQWZqblNHRStpOHJiZ3NmcC9hbjhPVjBGcFBNYVFzQ3F0d3d2dlVPTnZLSVlLQ1IzSXFabCtNVENtV1NTSmNSUEltaU4zSkFqUEpZRDNwYkVHTWNvU1EyWUVFbTQ5aDdWSEF1dS8wL05TSjRnMnFWZHl4M0h6NzB5Yk1Od2RxR0tJMGM5cjB0U1V1QWIzOTZERTdkdmExQWVvK3IrbElBbGwxR2p1Q0xVWkF2dHNLVUFiN2hSUUFBRzArdzdXNzBZTjJKOStSUkc5ckE4MFFIdDJvQVVXc3gyUEZyZzJvMFkydFlXNHBCTjkrZTFxQWE5LzhBVG1nQnc3bS9lazZqdVNMSDNvS2RXdzUrYUNzUVR0Y1hvQVUxQWtXNG9qY2szc1B0UkJ4YmUxL2FnQlFIcHVCZjRvMXVWSnVGK0xVV3JpMUVkNkFGcTE5eHRlakpZZXhKcHUrMWorOXFOckVublZRQUxGQU5QYjNvbkFKQlAxY1dGSzFlbmY3VWZsRFR6YzNzTitEUUExY01kdTIxR2RqYjNGSktGQllNTnFVZDdYNUhGcVdoTEZSeStWSXBQMGtXYWxPajRYRU1xa0FqZFhIc2FiWkFkaU9lOVBONjRGYzI5R3h2M0ZJREFGSUpCc0cvMHB4U1YzQnNmaWhob2RVc29CODFpTGkzWVVSUnhJQVF3SDJwYUdocmIwKzNjVWZtV3VCc2V3K0tSSHF1ZU5KSHRTL0pCQmE2a1c3R25KQUFnNnJYMkZFemcyUFllMUFOR3JhWFlhdmhxc01yeUROYytuYUhLY296SE01Yi93RFR3V0VlVWtlNHNLV2hMSUNreU5xSXNmWVVKRzFBMkF2eHR6WFNzai9EaDRuNTVBMG1HNkp6UEN4cDZuYk1rR0ZDajMvaUVWTmkvRDdqNHN1bHh1YmRaZEU1RVlyaVREWWpPNHBaeC81SXlhVlJGT1R5cXhGMk43KzFISkc1YXhOcjhXRnpYVTVlaGZESEtFdzArUDhBRk1adHJQOEFGd3VSNVhJN3IvNW5zS2ZPZGVCK1VZdERCay9WUFZPSEY5UnhVNllQZjJGcjBtMWZJSEplRlcrNC9xYUtOZk5jcXQ1R093Q2JuK25OZFdIalQwVmxXSWtqeVB3bXlqeW1VaVArMXNYTGlKVitUWWk5TkwrSnJyYkNaWTJYNVJCa2VSNE85MVhBNVRFSkVIc0hZRTA3YkVMWmxNbDhOT3JlbzVZbzhzNld6ckd6U215ZVhnWk5MZjhBbTAycmM0RDhLdmlSaUpoRmpzb3dmVFROdUh6L0FER0xCZ2ovQU0xWkRxRHhsOFJPcW9JOFBtM1dXYzRuRFJDOGNTNG55bFg5a3RXT3gwczJZU05KanA1OGJJeTJFbUtsYVJ2NWswMjB1QjNKMXovNUZaTGxuNWxPcGZGbm8vSjhUaDJLbkM1Zk0yUGR2Y0RSWVhxTytVK0RXV1lHTjM2bzZvNml4WVlhc05oTXNYQ1JzUDhBOG83bTM4cTVRc1NnaEN0Z3Y5emFuQVJyc2RadDNKcGQ0VWRVbDY4OExjbnhzTStUZUdtS3pFSVBVblVHZEdSV1AyUmJVckNmaUp4T1RZcVorbnVpZWtja2pjVzhvWll1S1lmK2FUZXVVbzhhTGZ5aGMvMHBTbGhjallIdFNibUZHL3huNGhQRWpHNE9YQ3AxUGpjdXdrakVuRDRCRndzWUI3S0Z0YXNqbWZWR2Y1MnVqTWM5ekxNSTR6NlV4ZUxra0Erd0pxckxQdGV4TitEUWNtN2FqYTU3VWJtTFNDL0xvVkpaZ3VyL0FBNzBrZVhwc3BObDJ0d1A1VWFvQW9ERW0zRkhmWXJaYmZOSmFFQUNpL1N0aXUyMUVKU3ZDM3VMQUdpTjlWN1dOSmNGNHp2dmZ2U2NJS0ZUU01VYlZiWHBwR2tvVkI1c0tiWUt3OVN0Y2JFMDR3dllnM0Z1YVJ1eFFFa1Bmc2FJblZZMnZ2eFNqd04rQjJwSVQxZnQzb0Fka2N4ek1qTUxpeDQ0cHE3QzVERnJjVWM1QnhENnVUWVhIMnBBWnRKRjdleG9vQVhJTngzNUxjMFlMSDdENG9DeEYxRy9zYUxWcFczNis0N1VnQnNMWEkrcTFFVHR2dVRRUmoySVB2ZWlKQkJ0Mm9BTm5JQzI5K0tCR2tiRzI5QUVrZ2dDd3BMRlRmdWFBRjIzQnRSRUt6S0IrbmVpQnNRTnlPYjBSM0JQQkk0K2FBRkZneEpBQlB0UVYvNG5GL2MrMUlKQmNFblRmYmlsQWxIWURiOTZBRExFTmZ2L0FJZjlhQzdtOXJta3B1T1Azb3dwNU8xQUJwY3VRU0xkNkpDU1NTTDJPd283RGtiM05xUXcwbmNYTkFCaGlReXJzVHhmdlFBN2xUdDgwb0VDOWgrOUVGWW9TRGZmZTVvQVRjRzVJSUFHd28xdVJzRGI3VUN4SXRmYWkxRHVXL1pxQUdpU2U1bzBzcUNpTHJ2WUdqSjlRb0FVZnAzNCtLSnRQQTk2TTIzdDdVblpsQjVBNG9BTnpaZjlhU2RnQWR4NzBiVzIzdXZjMEZBTngvS2dCVm1KSVVkK2FCSUZ5V3Z2N1VaSUYvZTl3YUkrc2JpOXlhQUZOY0pjRzkvOTZEZ09TNjdEOVJOSTRIc1BhbEliS2JjZDFQZWdCSUIrcmZlaGNFN2MwcDFMS0dBRmgyQjRwT2tLZEpZWEZBQUFGK2JFY2lsQXFmZjlqUmFSN2lpdmFnQllKMWJHL3dCNlNiQWI4VVY2V1NOSjFMYjVvQWZ3azE5WCtJV0FGSXhLR0pnZHJjMm9Ra0JOWU55TnRoMnA2d25pRHNDM2I3VUFSTGJrNzc4Z1VTaFNPRGFuSlZNYmFPeDRQdlJBOXZhZ0FLVlUvd0M5RmYxRS9GNk5odGYybzFYV0ZGOVJKNEZMUUJFdHRjY2Q2QTJOZ2R2ZWoydC9wUkRrMGdBMDJQeFNnb1VYb2tPcTQ3RG1oY2s3OFVBSHozQitLQ2tpaTAzZm5ZM3BLbXdKYjNwYUFWYm50N24yb0QxSWR0Ujl6UmdHNXRRMDNCdHpSUWxpZGQ3YVJjaWxnM056Ukl0d1NPUnpSMnNOUnZwOTZLRkRCREhiYjNvQzRBSXNhUzBpc1JkZ3Q5Z0w4MUx3bVU0ekhnakNZSEU0b0xzVEZDekMvd0RLbG9DTTErNmdmdlRsMUNpNkM0M0J1YlZxY0Q0UzlZWTlVYUhJcDBqTFc4eVlpSlI5N25hbi93RDVaNHFBRVpqMURrV1czQUxpWEdlWVIvNVZHL0ZDaXhMUmk4VWdTV3h0Yzc3VW52Yml0TjFKa09TNWZnbm53dlZPR3pYSElVVllNUGhYVlNMN25VUjJyTkRZYnNDdlkwclhBaUJ2cE4rZmIzcFM4c3RyS2VUZWs5L2VscUxpMTdIbW1wME9OaDBMMGJKMU5LMDBlTXdXQ2pWZExZakhZcElVUVgrYmsvdFdyazZCNkh3T1krVm0vaVZsTUNLcFpqbHNFdUtKYjJCQ2dXK2E1RzBLVHN1b2owamE0MnBTUVJKc0FmdGV3cCs0YlIxUUw0TTVkSE9KczA2dHoyUmYrbTJDd3NXR2lrSDNZM0Fwbi81aCtHbUJ3UWh5L3dBTTVzYmkxTnhpTTN6V1FnajVXTWdWeklORkc5d21vcnZTdnpITExHRk5HNEtPcFRmaUh4a0tRSmtQUS9TWFQ4MFZpazhHV2lhVTI3bHBkVlJjMi9FZjRwNXppQk0vVmVKeTloNlJIbGtVZUVYK1NLSzVzTVM3ZTJuNTJvdk52Y2FnRDdVbTRUYVdtY2RSWjcxSGlaSjgxejdNY2Zpbit1VEVZdVJpZnZ2YXFsY3Znak9xd0xYdUdBSCtkRVhSZUdMSHZ2UjZ5UnNMVWJoeVZDM2dqakdxeFBibWhjSWd2SGV4MjJwR3NtMnd0UlBNektkOWhTV0tQNmlTT0ZGcjM5cUR6RmhiVUxBYldxT0dMS0w3QzFGWUJyTGEvd0FjMHU0U2lSNW5wTjJQMzcwMkpRUjNQM3BGeVdQdjM5NlNWdnVHNDk2WjJLTDh3RTIwYjN2ZWpMWGIrdE5Bay9WU3FBSEMzcE85RXBMS2IwaTlPSllvMU9zQnlKVnNEZTNhbE94TGUrOUlqWDA2UWJBYjNwU0htL2J2U2lXRVFXVGp2Uk5ZQWVrRzN6UzVEZFRaaHR2VGJxR0JGeGRmYW0wSWdPZlNBUHZZMDBSY2U5TGE3ZWs4RHZSSDFnRzlqU0Roc01ibmM4VTVxdllFMytLWllGVHp2VDRzUU5ya1VBQU50b0EyNzB0VnU0UWpla2dhV0ZqWS93Q1ZBRXRJZ3VlUVRTb0JFejNsYTIrOU43azdBRTBKVy9peW51R3NhQWJTcEswTUFiajFmVWY1VUNMZ2tjKzFHRG9iZjFVV3F4K0RTQUhZRUM5QTJQQnRRQ2dkNzBPRFFBbFV0dVRlKzlIOU85cjBDQ2YxYXJldzRwUUE1RnJVQUkxTWRnZElvMVlOenVhWHB2YzdDMUpZaXdGcldvQURLQ1FHM0h0UmFSZmtiOXFVZU5oYzBsVFlteStvOXpRQUN4QkJBNDJJRkdYOVJGRFZxY0FDeW5tZ1JlZ0JJMkZIY0htMUFqNzBWeWlIMVgzb0FBNXNOeFFJRzRDMi9lajcwUWNLU08vZWdBZ3RoeGMwWVlqc0tCVzR2ZjhBclJDTy92OEF6b0FiQjBqVFEvbFNyRW5jcUR6dFIyMWpjMEFKdGM4ZzBDZS90UUMzdjJ0N2MwWkFBRnIyK2FBQ094dnhRNTRvY21qSUFPMUFBczIvZWdnT3Jld3BMRWx0cU8zcEh2ZmVnQldtNU50L21pMDdFY2ozRkFLRHliRDNwUU50UXZRQWxQUnR1NDl2YWxOR2hGK1IyRkpVMnZlampPZ2x1Yjl2aWdCSUcxckEwcTFod0ExQ1JMQWxTQ0QvQURGRXZGMjNQdlFBQnNOTGMwTld4RFd2N2U5RFlpaldPd3VXQStEUUFrYk5aVHBIZTlTQStsTFhOandLYWpJMW52N2c5cTEvUlBRdUE2c2p4c21ONnB5enBxTERFV09ZdXhaN20zcFZkeisxS2xZR1lkeEpFRWF5eURhemJtMU13NGRua3NCZSt5Zzl6VzA2a3lUcC9wMXNiZzhzNm93L1VVWVJXanhHRncwaUpJM2RmVUxpMVpKV01EaGdvTEJsWWpjZzJwWEVGeU5QSGYwNmdyZzdqMm9tUTRkdGhwYjZxbnk0bFZ6QnB6aGxLc1QvQUFoc3UvdFRFTWF6QlZadktWVk5nMjVvdWhXcUkrblk3Zzk5cURBNnRqdHpZVktDNFpTQjV4OWlBT1JSbVhDS2JyRTdqY0FsaFRSdGtVTDZReElzZjUwWVc0YTNGU3htY1VLZ1JZT1AwOTNKUDlLRFo5aVMxMVdDRzR0WklyVS9hS0lod1UwNEdpRjN2dDZWcVRGa0dNbFJ2NE9oTDN2S1F0Ukd6YkZ5a256NUZYdGJhb3pQSkk5M2tNZ3ZiMUc5L3dDdExZbGx4L1lnUUJwOGZobzk3YU5kelFPRHlqRGthODBERGkwTUpPLzNOVTNsaVN4QUE3VUkxMC9hNSsxTnNLTkMwblM4T0h3N3hybVdKeEIxK2ZFeFZFdmYwNlRiaTE2TCszOG9oWW5EZE9SdFkzSDVyRUdTNTlyQURhcUZiSFNBTmp6U2p0dGJUYnZTN2hLTkNPdjh6dzBTL2tNRmxtV01qNmxPSHdnTFgrN0UwbWZ4SDZ0eFVRamJxREh3eGczQ1FTK1NML1pMVlFLOWdSYmIzcFBiWmlMVWxpMEx4YzAyWXllWmpjUkppNVR6SlBJWGIrcHBDWWRFQnNRQU9MYlViV1lYSFB1YUlNTEFiazBibUZJVkdrVWNpa3JjOGk5SlJUZGhwMjdVcG1Pd3NDT0NhSXViMkg2YVN4UStmaWtsYjBvMjJ0N1VRNHBBRnhSaVpYakJBWURVbzkvZW1oS1dHd3Y4VTRqR01xd3Q2VC9PaWxqRWN6VzRPOUFEVE8xOU42VUpHQnVHM0ZJVlIzM1B4U2xOMTJvQUloWE55TGs5NldGMGplM3hTYjJOd0I5alIzdjJ2OFVBR0FWM0FBcFRFRmJEbWtqWWI3ajVvY0dnQUQ1cFhhaTVCb2w3MEFHUnVON1VrTnVUZWpKNG9FYnQ5dHpRQVMyWjc5NldiZHhjKzlKSTJVRWJFYm52U2dMZ0dnQkpHeHNOdmYycEtpeDVwZDdubmFrY0Eyb0FVU1NPRFMwK24wN1VXeEd4SW9LYmRybWdCNEc5d09hQWpKNTNGQ1BjRW5acVc5N2JrV3AxakJzYmVrRzI5Qy9KWTNCTkVmZ2JVQnNONlVWQWJkU0NMMzRwdVVuUXFFQ25lQ0xnbmZ0U0hqM09ubTU1cHREaG9xQWVRYlU4SDNGUndEcXNSVWdwdUJ4dFNBQmpjY2cwTEh6Qnp1UUxmdlJCZFZrM0JJNTlxY2kyblE3bXhHL3VhQUdKbDA0bVFjRFVSUmNOdng4VWtzMGtrakhna3RTd1FWRmhRQURleE5oU0k5aWIrbjdVclNOTnh0UldERG5mMm9BY3VDTCs5SlBHM1B2Ukc0dHRZMEJ1Yjk2QUIyL3hkN1VvN250ZWlmbTNlaTROL3dES2dBRW50UjN1S0hZRWl6ZXdvbUZoY1VBRU45dUw5Nk1OY2IwWXRwQnQ5NlF4c3hLN205clVBS0o5UTNzZXhGSitxKzNIYWh1Q2JjRGFndnAxQzNxN1VBSGZVcDk2SU5jK3g5NkNnaENUdWZlZ0w2V3N0L3VhQUF0MjIveW9pZlVTYVVRcXhxd3V6ZHh4UU5sQTJvQUwrSG9CdFkzNW8vU2R3Ui9LZ3hHNEErYUxZL0ZBRGVtMnczc0xINXBRN0FjKzFEMkhGdHZ2UkU3Z2plNTdVQUdCYTUvblJNMTF2Ukwrb2svTnFPNGNiRGYyb0FJQzlBRzI1RnhTbFFqdFEwTUFkcUFDWis0V3dORnBKTjcwNmtRWWJuK1ZKWkVVWDFpM2ZlZ0JKRnlRZGdONkFIZW5DcUZmVURmL0FFb0tWR3dGaFFBMXVUYnQ3MGV3TysvdFNtTnp0U0QzTkFDMVlMdGJudlJrQzlsUHE5KzFOTFp4dnVLV3JBSGZpZ0JRQVlmNjFNdytCWEVLUDQ4YWY5eHFGcGJTUW83VWxRUDhQN2lnQjV3a0dJa2pZaDJCMlplQ0t1TWh4MlVZYURNRXpES0pNd2VWQU1MSWszbGVTM2NuM3FpTms5SU8zYzJwNUZMNlZVRWh2YmVsWFlHbHpwb3NyeEU4ZUJpd3NzTHhMZG81TlZpUmUzM0ZabDUzYllrRDVGVDh6aHhtV1lzUlkzQ1BoWlZRQVJ6UUdKckhnMlBQM3FzMWZWY1dCTjdqaWxiZnlIOUNnek5iMXRmbmVpMW5UWXI2dmVrNnhzQWIvTkFHN0crdzdVMFZ1eFZnVGExN2Q2QUdrRWUzYWtlb01RS1VTYk5mdlFOb01zU3B0Y2JjVVRYSVdqWGlnVFlYL2Fsc1VNODBRMkp0dGY4QXBSKy94UlhIdlNDVUdEZTVzRys5SkRhdHJXdlFXNVBGaFJvQnY3ZzBDaEc2a1dZN1Vhc2R5Ym1od3BvQmhibWdBeWFIYWdEdUR6dlJFWHR2M3ZRQWZhM2VnT1I3MFFzV1p1M0ZHQnZjOGlnQUVXSHpRVUgzQW9NQ1RlOUFHNUk5eFFBYXQ2N1h1UGVsMkhxK09LYkNrTjhVOXFzbnZRQWxWR25lMjlHeStiRHFIcTh2K29vTHNQZjRwY0dsVzlRdUR5UGlnQ0lCWTdjVUY3MjRwMWtDRXJmYW11TmhRQW9YVWJibWpVa0FCcjNIZWtoYkhZOFVzRy9QTkFBTGJiR2dDUHVhTlFMVUZVWG9BSHRjV29ncHNkdWFYYTUrMUdwSUlCb0FiSXNPS0JCMjNzQi9XbHVodis5RXhBc0R6UUFRQk8zYWdSdllIZW5GdHZTQUNTUUNCODBBSkFJQW95dExJdnRSQlJRQVNxTFVPeFBZVWRpRithVHZ3T0R6UUJJUWpRRHo4MFk5WEZNNnRLV0ZPQnlWRmhhZ1NneXVuY2tmYWd3dUQ3VWlRN0M5QU1Uc0RlbHNLRFlsU0xEMGpla01TM3E0dnZRbGNLVnYzb1BZMjA3aWl4UnZWZC9hbmdScDFBN25hbVMxbkczMnA1Z3d0YlluY21rQVZkUWJjRWMwVUp0Sjl6c1BuM29NdXdZQzU3MHVCZGVKQ0Myd0p2OEF0UUJER3pQN1gvblMxR29DM3ZlbW94Y0g3MDRwSUZoelFBbTR2ZjhBcFN3QlpSYnZRRnJYSXR2UkZnZURmN1VBS1lDNTV2U1BTZmU5QlNRYlh2YmU1bzlRR3gySjlxQUNZNldKcFFKWTk2UVhISkk1dFFCM0ZqenhRQXB0dmcwUnZjRGUzdlNsVm1XOXZpNW9pdGpRQVFCS20rMUpzUi92UnVEdUI3WG8xanVBYjBBR3BBTnI3MER6Uk1nUGUzelJxTkpBSjNCM29BUXgxY2JXb3lDNDIycFlBc2FMZXc3V29BSUtkTnJiMFdpOTcwNXVGc2RqemYyb3RqOU8xeGNpZ0FnQVcvYWtrV05LN2hUc2I4MDRnMURZWC9hZ0JreHhncUwzYTkvaWdRb3ZkVHR4WTBRQVh0c1AxVVNBNkJmY2k1TkFBODVRTmxGLzUwb1NqVGNiR2tFZHdCZWdDUnp2UUFvc3pEWWpudlExV0J1U0RTR055TGJBVWJBTUx0UUFaSUs4bWl1WEJ1QWI4YlVSRkJUWVVBS1k3anZRSzcwUnN3Mm96UUFPQlF0L0tpNEpvenBId1R3UGVnQW1HbytuaWlJc0tVUllYSDlhSmZWdWVhQUZySXJLZFY3VzdVVXFGQW9WUTRPOXgyb2xzaFlkdUtYR3hRc2grazBBSkFEQTNxeHliSFNZQ1NHZUNOWko0NWxZSTR1RFlnZ1ZYc2dqTzRKRnI3VWNjdmxNR3NyWDVRMHZRZkI2UC9GSDRnNXgxbG1lQ2ZOOEZrK0pYRllYQ3puRTVUSUpCQm9qSytXVzdIZmNlOWViR0F1UURxQTJCdHRVcVhIMnY1TVFndUxNRkpzZnZUR3hIRnZnY1VyZDlpSlVOMm8ySDAwWkEyOTZGcm05OS9hbWlnOSs0b2ZhakJCQjdVUTV2UUFvY1Vra1hzMjVHNG85VkRhOTZBRFc1L1RZbmswa2l6MFkvd0M0RDR2UTArcTlBQ2tJSW9sSDFmTkRWZm4rbEFHdzMyb0FLOWhZamFqMlViQVhvZ3BZYzJvYmsyb0FPMTZKdjYvRktLWG85QW9BSU5lUGFnckFrMjlxRmxDQlNPS0s5Z043L3RRQW9uYWpVWCs5R0JmYnNhSVdRa0NnQVgzdFJwY1hwTnQ3MHRXdnRRQVpJSjJGcU1MWmdUYWdGSm9NbzdqK3RBQ25RTkdyV0hxR2xxaWtXTnFsUTIwbUlnK29YQithamxBU2JiTXBzYUFFa2I2UnphbHJ4U09iTjdtMUtXK3ExQURpclliMExEMnZSMjkrS0drRGk1b0FGLzhBN1VGRnpjN1VPQ0w4MGJFbXpkeFFBR0pheEhBcEY5UU5MTzVERFkrMUlQUEEzb0FVQ0Z0UmJEam1pY2JINHRRdHYvclFBcGZVZDZNSFQ4MGhqN2RxSzRvQVVXb3IyN2JVQ2I4VVdyYWdBMDlSTjlnS01NT3gyRkREMmtkcmNEa1U4RTA5aGFnQnNray9TU0tUNWJqaFFnK0tjTEhZRTdld3BJYTViNDJvQVJOcWpDYTJzTDBiUmxWQlluZmlsTnA4c0E3c0JiZWlCc0FHRjl1U2FBRU1nQlhhOS9lcEI1VUVXTnFqUDZyMk80N0NwbW5aUjNJdUtkUWdnTVZPMjIzTktnc0pRRkhwVU13KzlxU3lFbTQ3Ym1uSVFOY3BPMm1KaVA1VWpCRmRHQVFBRGMwYUZsYTk2TUFJQ3crcXc0cGFDN0QzcEJRZ0dMRVcydmVqOGowa2xqcXYzcFMzUDcwWWIzRi85cUFFTEJkRHVOWDJvRkYyMjNBdFN6dGNqbnRSZkZpU2FBQzhoQnVSYzBMQmRTOXJiVXJTU2R6c1RTU21scjJ2U29Sc0FWclg0VTdXb1dPcFIyQXBUYkMvOUtJRGRmZWtGQVdQK3RKYTlyamcwcGhabTJ2Mm93dkErS0FHeGNoYjdpOXlQZWpQcmZibTlyMHNpeEF0UmFlZTN0UUFuY25pNW9FMm9hRDdhcUpnZlkyRkFDZ2JuZWlLQ01YRzlBSmNYQnZRdU5OZ1FTYUFEQzZpRkhKdTFGTC9BQW10cXQzb2xVYlgzTmpTeEdoQXVsejc3MDZnSTV2dWV4N1VZSDk0Zy9hZ2ZUOVd3OXFBT29nMkErMU5BQjRvanlLRE5ZZ1cvZWdEYzBBSHNUUk9Sc1NiMER0UUJKNzBBQTc3R2lZZSs5SzBnRy92UkhpZ0FXT215a0Q3MGR5UnYyOXFHd0I5SVA3MFZnTzRIeFFBTk55U0Qyb0EyTnRqUjMyUGVpQUJCYmdpZ0F5TG0xNkNnTDNvaDJKMnZRdUNkaGVnQTAzc2Zhakp1YjBiTnBHNHRTVDZlYUFGd3ZyVVJ2c280TklNWmpOaUx0Zm4zRkVUY1h2VHNicVFZMy84cG9BYllYMkE0Nys5SHVSWUcxQnhheXY5UW85Qk5BdDJKdFkvSW9qN2syTkxKQjJ0ZTFKTmlMZjUwQ0EyTzROQ2dMRGIyb0hibWdBZjUwTzFBRGU5Nk5oYmZtZ0ExSC91MUFHNVBhakJ0UUhxNG9BSUc0UGFoOUkzNysxR0J6OTZGOTZBQnAzNUh4UzdDM0ZGd094K2FTQ2FBRkUyb2kyd1BGQW00b051UU8xcUFEb2lQVC9wUUIyb01kMDMrOUFBVTczdFJsaGM4NzBROVhGRnlkcUFGQTNGNkJYWUVVQUtVZDl0dHFBQkczcXNhV2ZVYkNtYjJOeFR5allFYzBBRDZXMURjamkxSnhTV1lPdkVvQi9mdlRpaXlFZnFCM28vTDg3RHNuZERxWDVxU2tKOGtUNlFQaWdENnIrOUVTZmFqMUVtMWhhbU1jT294SEZCaXBGN01EVGVzRFljMFlPNDlYN1grS1FRV0xsZ1NhTW4rbE1wSllJYmR0emFqOWJmcElQdFFBdlhZbWlacmtVUEptUDZLQ3d2dzloY1VBSldTNW95cE8rOXFjL0xnRUM0SkZMMDcyMVdJN0NnQ0xyOVJVYjBOUjlxZk1RVWNiM3ZlajBBbmptZ0JoV052VHVlS01JNTVVMUpDS1hOeFlXb2d3WmJpZ0JrUnRHTlJOZ1BhbDZyZDl2ZWxNb0M3bTlOTjZWRjZBRmxyajRwSmJ1ZUtJRWtmRkxqaGVja0ltdXcxRVh0dFFBbjJ2dWFEZlFmZWlObE5oeWQvd0JxQU8xcVZBRXpla2V4NXRVNlAxQ01BV0FYbW9MMkM3OFZPUUJRaDNJSzA0UmhGTGJiaS9KcGFvQ2s1NUpoWVhveGErM0ZKYTRpeEZoWWxDQWFWS3dSWHFOSy9mdFRnVzQxRGI0cEc1QkIyQTcwdU5iN0R0VEdLR2x3RnVMR2xLdk9tbElMWHNlZTlMUmJIYmYzcEJHTkJMYm42Ylh2Ukw5SVk3WDdlMU9tTTIwalphTlkyV05TVkxHOUtoTEdpZ0o1M285SnZ4c1A2MCtFQWE3QUFuZmVrR1ZCYTdBQUhlNXBRRzJVN1czdlFDN2dVcldwQVdQVktiaTJrYm1uNDhQaVdWR2p3Y3NoYmRXMDJ2OEFGQVdSd3Y4QUdVQmhiZTlGR0NCWWczOXFzVnlUTURPeXRCSEF3RnlKWkZCL3pwd1pRc1prRTJhNGJEMk8xZ1h2KzRGRkJaVytXekZiYmZCb21TMTlSRzNhckZzRGdGSkxZM0VUdGJZUlIyWCtaTkJUbGNkeCtUbm5JNGVTWUFBL2ExRkMyVnFLQUdiVU5QdU42U3JSeUVhWGFSdllEYXJsc3dnUW9FeTNCeFBiL3FhU3grOUYvYm1OSytXalJ3b1R0NWNZSDliVVVKWlh4NEtXY3NzR0Zua3VlZEZTSU9uc2ZMSGI4c2tXK3hsY0xSeTQvRjRtUXZKTklYQjNzeHFPL3dERXNIdTdBMzNOei9XZ0xKYTVLMFNnelpoaElOaUNvdTdFK3dzS1VtQ3dlbjFaakpmL0FBeGJWRlZqR3JCV0lIc0tlV1BXb043VW9XVVk5Vm1POUpCSTdlbWpHeC93MFlBWm10d0tZT0U5N2RxV0ZGcjNvZ0JhL3dBVVduZzlxQUFSYy9GRVJhbEUycE43MEFHcHZSODdVa214MjcwWk5sdU9RYlVBQWdNVHRRS3FPUWYybzdFc2ZhZ3B1U2UvdFFBU0d4KzN2Um5iVi9TZ0FlVHpRUHFJOXhRQU9lYU85dUtMNzBXNE8vRkFCOGplZ2ZuZWl2WTc3Q2dPUUNiWG9BTmJXRzNlakFzOXJDNDcwQllMZSs5SzR0WStydWFBRFErYmRYOVJCOUwwYkt5bXpiSC9BRHBBVUJiY0M5NmRETElBcmJNQnNmZWdCc3FMMGhsMnRhNHB3cVF4RExZKzFKSUo0M0h2UUFoU1c3V3BSVzV0UjIwajNvRW05NkFBRkFvd2JHL2VpSEc5SFFBS0x0dHRSRW05R0R2YnZhOUFBVWcrKzlBN1VZMm9IZzNvQU1DNHBPNE5xTlR4U2pRQVFHMUhiaWs4MGRpUUFEWTBBRTNwSU5EamUxNk14c2UvODZCVWlnQXp6dHRTZjJ0UUlMYlVGVGFnQWFqY1d0Uk5zeExXcGZsZ2p2UUtBRVg0b0FiRjc5clUvaDNMWEZxU1ZBUHBGcU1IVHVOcUFINDIxTW90enpScXhoZFd0ZTNiNHBjYXJwc09EM29qdVFiZW9VNU1Sa2JGd2lIRU9xa3NyQU92d0RUTmhwSjRxd3hhaHNFcEE5VUozUHVEVUVvQUxrN2Y1MGpCRGtNU3N0eUFmdlQvQUpVYTNzb05NeHNGUTlqN0duU0xHNTMrMUtnWXBRcEduU0xVZm1EY2tiMGdXWGNHZ0ZOeFNpV0hjMytLREM0RnVmbWtuYWdyWGF4RkFXR3lnRURrOXpTV1hTZU9hVVQ2clcvZWdPVGJjVzJwckN3bEhCNXNiYjBUYkVzUDJvd1R1UGZtaVlXUzVCc2U5SU9BWHRmK1ZDd0FzdXdwWkFVSFVPZUxVZ2drZTFPb0J0Mk5yRWkxSnRmdHFGS25BU0puc2ZTTDdWMDNDZUFtS2VFeVkvcTdwbkt6NWFTaUtmR2d1d1pRdzJIZTNJOTZYYUpaekFBVy93QktEQmdMaTQ3YkcxYUhNK21zdXlyTXNEaDE2bHdlWTRlZHJUVDRTTmlzQXZiZS9OVnVMd3VXUmovbHNkTGlHdVFUNWRoYTVzUjczcEtDeXVVRlZ0YlY4ZzhVZHJBSDNxVEhoVllXRWN6MzNBVkQvbFV5TEpNWXlhbzh1a0lBdU5aQTJwRUtWTEx2Y25mMjk2c0laa01TZ01MV3FlTWt4WWlqU1FZYUpBeElCY0UvdlMvN0RqV1QrTG1VUVFEL0FNTk5yMDRTeXRFeTJBQ3RjK3cycFQ2aWpEWlJhM3FOcXNUbEdCc3BiRnpTcU9iTGFwZURneXZCK2F4eThZdG5UU3Y1cHlOSCtJVUJabUVqamlKRWtxbTNLb0xtbklsQlkrVkJQSWZZUm4vT3RDTTZPRVF4d1lMQ1FpMnpHSUZoKzlSMnpySHpxb001VlYzQ0tBQVB0UUpaWHJnY1l4c3VDa1VFNlF6N0NuWk1ueDBZdElzTUk5bWtCL3lOQ1NlYVUyYVY1TitDZHFJeHNUWUh0MzNwQUZES2dxM3hHT2lRZTBZSk5JYkM0QUZkZUpubTk5SXNCUm1OdHRQMWZhZ0lOUjNGajcwb2dzZmtGVWFNRjVvQjVrZWovUEJEb1RDWWRiL1Q2YjJwc3dxb0JBTjZCaUtxeEIrMTZBRnJtR01zQ2tnakNuWUtBdEZKaThWTlpac1JKSVNMYnNiQ2o4a0ZVQkd5Ny92UUNDOWo3M29Bak5lUjduMUQvSHZRTVJZYWR4WTMyMnFSNVFZL2J0U2dob0FqK1NTK2dYb3pHRGRRdHlLZUlKZjRQSm8xVWR0aWU1b0dzamhXQTlRTmgydnVhSVJrVzVWVHdwNXFjSTlRSUk5UTcwU3hnbmNpL3dBbWdjUlRBZXh0NzI3MFNRYWdOWEJOaFV5SlBNTmdoZjhBN1FhV3VEbWxTNGhZZ050Mi93QTZBSWdoSXMzY0d4cFlpWTNQdlVsb0JESGFhV09NTjd1TDNwdEpzSUxxY2JFQ3B0M29Bek52VFFHeHY3MGFiZ1g0bzI5SjR1S1lQQ0F2ZjJGQXNWVTJvaVNOZ0xVYkFGTFhGNkFDSUxjVUNMRDVveHRlMUM5OStmdlFBQUJwdFNSdHQyTktmWUNrbHJPTzlBQ2pzQ2FNRHYzTkozUEk0TnhSZ25VZDZBRExFVVJPL0c1bzltSkhjYjBWd0JjbSs5QUFvSGVoZlV4dFFJc2FBQWVON05RdmRnVHVLRkdTTk51QmU5QUJrYlVRdmZtOUJUdWFNOFVBR2JVV3IwOXFBKzFEVHEyb0FmOEErdUNoYlM2aTRZOXg3VXdTUXdCR2tua1VKQVNBcmU5NmtCUmpMZ25UaUZGeDdOUUJIc2IydnRRL2NVSDc2YjdHMi9Jb0ViVUFBZk5IU1JmOXFWUUFUQUFYc2FBVTZnM2FqdlIzc0xjMEFGYWpJdjNvNkJGQUFLRFRRdFI4MExjVUFKMGlsRDI0b3pZQUMyOUVCdmJtZ0FpYmJHNU5LSnVMMnRSZ2pTTzdVVEUyQU8xQUNiMk5MdGFram1sQTN2UUFUWDdVQ0MxdllVUk85TEFCUW52UUFTblVDS0xqYnZTb3dBRHR2UjI5Vk9RRHVFT282VHRUNVVhalVNRWdnallqY21wc1pFMWlOcjhHbEVZdUFoSkxPZlFRVk42cXBFOG91aHZyVTIrOVdaVXJjRmRWTTQyQ1I1T0FBQUFHSnNLS3NFUmtRQk45Nzk2V2I2TERuNXBTd2tLQmRUWTcyTlBMR0NTcWhuUGZTdDdVdENNWmpqTE1Uc2JDOXFDM3RmayszRnFzTUxsYzh6TUZ3OGx5cDBpMm00KzlQdGsyS2lpQi9MeFFxVjJFa29KRkZDRlJwSkY2TUo3S1Q5cXRteTZBT3F5NHFGR3R1STk2VWNweTdRSEdaeVRtMXpGSEhaaC92U0FVNnF4dU9EN0dpSTB0WXVvYmtiMWJDUEswOVM0ZkVUV0Z2NGhJcFl4ZUNSdjRXWFJxdkExTVRZMDRkWlNoMEJzR0xkanBCUDhBcFVtUExzVEtCNWVFeERCdUx4bXhxei90ckVLZlNFaDNzQXFDa3RuT05rNXhjbDdiV050NmFOdGpNZlRtYVNhUE13b3c0T3dNemdVNjNUazZraVhHWVNCUjMxWHZVYno1WkwrWkk4aHZjbG1KcEdnRyt3Sk85elFMWkxqeWZCd29mT3pMVi84QWswcHYrejhxMWF5czA1QnZxT3hJcGxHc0RxL2xSa2FnQjNXaXhxN0phSmwwZi9Ud0sydmM2MjNQM3BhNDhSdGVQRHdSa2JEU2d1S2lvTzQ1TzFPckdMWHR1YUJ4SU9hWXdsVzgwZzIwZ0RiYW83WWlWMElNcjZXMlk2dHlLSndBNUdydllmRkVMM0lQMnY3MEFKc3hhNU5MSkI0SGIyb2lEODM1Mm9kN2k1K0tWQ01YRzVNakRlK201djdVL2ZTbzNKdnp2VEE5VFdISEZ4VHlnSUNEdmFuRFJtWGRwTzRIRjZhVUZISGUzTlNOS3Y4QVVkajJGRkVnSk9uYzN1YjBCWXdJU0xFSFk3ajVweVBjOFdJRlNZTUhMS05TeE80NHVGTkwvSmxDd2NyR1QrcG1Bb0N5SUUydU9UUjZDVnQzcDkveXFJUytOdzZsZVYxYm43VkhiTTh0alUyeER5bjJSTDAxamtFWXliRWpaVFFLSFNpMzUzcERaN2cwM1dDV1gvdU5xWWZxUGdSWU9NV04vV2IwZ0V0MStrWHNSeU9hV3VGa2xJMHhPeEhIb05WMy9FbVBGMmo4dUs1NFdPNHFOTm5PT21ZaHNVNnNkenBOcUFOQXVXVEdNdjVaVVgwM1kyM3B0NDRvYitaaUlJOVBJTGdtczFKcm4zTHl5SC91TkFZTmk0SGxqWVhzdzNvQXZYeGVYS1NXeGdKUDZWVzVwczV4Z0l4cENZaVFqNENqK2RWNlpkUFlIU0U3N25tbExsYmEvVVY0NUZBcExsejJOaXZsNFhTYldKYVhuK2xScE02eEVrdG80b283ZHlMMGNXVngyMUYyUC9hZWFjYkF3aXpHOStTTDhDZ2NSam0yTVAwNG9xM3ZHTFV4SlBQUDlVOGtseU9YTlQydzhhbjByWURrbWpTTUxHU2dVS3g5cUFLd1lkbnMzbDNiY2I4MHRjTk5iYU8xV0J1ck52WWRxVVZiYTF1S05xK3hMS1k2VXQyTnVPYUljSFkwTEwzcFI0cGdvaFR0WTBDTndiWE5HZzNOeFkwb2JMUUFHRzIxSksyUHNQaWpLOTcwUk56elFBVmd4c2RxT3gwYjBEOVZxRndOanhRQVo0RkZhZ0NTTithV0FPUlFBM1liMEFEYmdXdjNwYmNpa2o2Vis5QUF0WkxnV042VTNJb0FXM28vcU5BQ1Q5TkZHdTl6d2FWcDNvNzJvQVQrbzJwWEZKSXNmdlJuNlJ0ZWdBN2Q2QU5qUkM5dHY1VW9nV0h2UUFUQTZ4dGVqREZXQnZvMDhFZGpSS1NCUmczYzBBUHlBWXhTeWVtYnY3TUtqclp0L3dDbEtpYlExeGNFYmdqaTlPeUl1SS9qZ2FYNU51Q2FBR1RmdXUzYTFDMjE3YisxSzQ3MEZGMkY2QUVoZlRleHBTcUZvMjJiYmdVWUd4dlFBbTFHMXJiQ2pqWFdEUzlMVytEL0FKMEFJc0F2elNSelRoQVVXWTNvV0F0YmlnQk5yMFJXd050cWNJN2hXdDdnVXJ5MjBFYWJBNzNKcFVBMXBzYi9BR29qNnU5U0VnWUlBU2kyK2JtZ0lrL1ZLZHZZVTRhaGpRUmVqS25ZRGdiazA4VmlKQnV6VVROR0h1RU52WW1rWXJHOUlCdjc5NlhvMjA2anY3Q2xlWUFRRlVBaWdaWkN4TngrMUloQVI0WThOcXQ5clU3SGhTeCtuK1pBcGxKWHNRekc1OTZBQko5Vk9BZkVDcmV4UUE4OTZlWHluajBMT1ExcnJwVHZVSUVqZzJwM0RzVk5yM0kzb0VKT0hpVTRVbkVlWTAyOWdwc0NLY1A1Y0pwWENxWFVqNjJOSlNNTEdHYTZMZlpSdVNPOUJ5ZElJUUFXNEhlZ1ViYkYrV1FWaGpRZzdXV2xObkdJdFpKZE4rNmdDZzBra2Fzd2NyNmQxOXFNVFNTdUpGalY1ZGxLaGJodmdEM29FR3hpNUhaUTh6c0RjRzU0cHBvaUdJYmNwc056dU8xWFdXNUhqczhtRU9HeWZGTkxJMmdIQ3BjMzlpRHhSNDdwbkg1WmlVd3VaWU9YQjRweGVPR2RTcnNudjhpa3NDdjF5UnhMRTdJNEl1Rkp1MzdHancrR1hFT3J4eStXVkJzU1BwUCt0UFlqSk1UaE1VSWNRcGlrSkpXSXJadE51Ujc3VW1DSDh4SkRFSVhjNmdzYU9OTEc1NXBSeTZEZUtHYUx6RVl5ekw2WlVYMGo3aW95SlpkSkZ5TmdSdU4rS3VNUmxjU3RKR1EyRHhFYy9sc3ptOGNpbmtEMk5ET01xZkpjeS9zOTR3enRHc2hqSEZtRjEzKzFxU3gxSXBkSkxFM3UvdlNpaERLdHR3TG1wMCtGdzhFTWMySEpsalBwdVJ5dzVDL0ZNTGhwSFk2SXBKQ3h0ZTNGS01JNHNSZTNGRDNOcmc3MU4vc3ZGUWFSSkg1V3Jqekd0VGJ3UjRZQXk0bUJSdnhKZmVuQ0VaVnZheS9lbk5BdWFVK0x3S0hmR2VjQ1AvQ1RhL3RSRE44dVVGakZpSlhQWU1GSDhxYUFZVXFQaTlLamxVcUJlNTlxakhQNGxKTWVYSTEvL3dBWTVOQTUvaTJVK1ZEQkVQOEFzdmFnVWx0Q3ozdEd6RS8zUVRUMzVLVXFwOHR3VytrTllDcW1UUE15WVdHTGFNTWR3bGdLaVNTWW5FdDY1WnBMY0hVYUFxalROZ1dSUTd2RkYyTjVBYVlNK0JYZDhXZ0YvVnBCTzN4V2ZUTDVablgrRTVQdVJUc2VUenRwSWpBdGZjbTFBZGxzYzJ5dU5qYVNhUmI4S2xqVGI5UTRSUVREZ3BIVUgveFhzVC9LbUV5S1VuMXVpK20vTjZmR1FLRkd1Y25iOUlvRGhkakk2am1RM2l3c0NFWEkxRFVMY1dwciszOHdDMlRFTEViMjlDQ3BveWpDZHk3V0hjMnA1TURoVlQ2TGtjRnFBdUw2S1NUSDR5WUVQaXAyK3hzUDZVMGNOTktBU2trbTNjazFwVThxTUxhTlFCc3k2ZWFkODYvdGZzQlFMWm1seXFXVUFtQXI3WDJwNU1peEpRZWxVUGNFOXF2WnB3UU5ybnRSR2U5d1RjM3RRSTIvZ3EweUp3UFZJaS9hbkZ5V0pnTHpOZnZiaXJCcEFRRjJzT0NLSjJBR2xkdTlBejNXUTJ5akRKY1d1TzEyNXBTNFNDTXNWaFhZV3A4dHhwRjJwRHpXTjlJRkE5Z2tSWTdXVWVyWVdIQnBqRWM2VGZWYXhOUGViZmUrNTRQdFNKck5leDdXSjk2QkJ4Vkp3MGJFQ3d1TjZJcnBISVB4U01OZDhPNFlraFRRa0JoSTFiaHUxQWpFa0RiVHNOeURSMkFVRS9VUnVlMUtzU0NRdWxRUllIdlJHTWpWNmRTbmVnVWFLbnZ1VDJwT2tHMnJiMkZQSkM2OGcyOWpRMEUzSkFKR3dvRkdiRTdBQWozcFFRTUFVRmw5alR3Q0VXSnNmaWpBaUcxelFJWjBSaGpxWGdmVkczNmFSWStvZzN2NzhpaUF1ekR2cXNHNHZUckh6TFJ5MjFIWVNEbW1EeG9BMnYzcFM3S2I4MFFqRWR4ZTRGQnRxQUJHTDNvTXFudHZSY2kvYWhhOUFBREVIc1BpbEJoWW4zb3dBUUJ5ZmVrbGJrYjdVQUVXN1VvQUtMVUNMRGFpTy8zb0FPa3YycFF2WVhGcUE0Sm9BSS9UU2w0TkpDajl1YU94TGtXMk5BQ3JEM296M3BJOUhPOUtQQm9BVHpRTjlPM042TmVCUmsyNDVvQVJhNU5odFIyTnRqU3RKMDN0WTBkZ0J5UG1nQXJpd0E1dmVpRmwxWEd4Tjcwb2ZhbDZSSWRoWlR3RDcwNUFOTDZqYTRBOWpUa1lJWWxkKzFoUkVLb3M1Q3R0dDMvYXVyK0R2NGErdHZHak5vTVBsT1V6WUhLMnMwbWI0MklwQ2krNHZiWCsxSjhnY3JDR3pmNGU1NEg3MWI1RjBibjNWTXNNZVM1TGpzemFkeEdyWWVCbVF0N1g0cjZGZEVmL0FBNHVndW5zd3cyTHozT3MxNms4clN6WVNVckhoeTQzSnNvdVYrRFhxVEpNZ3k3cDNCUTRES2N0dzJXWVNCYlJ3NGFKVlZSNzJBNXFlT09Ram5YQjh3Y3MvQVg0eFpqZ0ljVWNud09IMXJyRU9KeFNySUw5aU94cmtuV2ZoaDFUNGQ0N0ZZVHFUSmNabGttR2NJOHJRa3dtL0ZwQnRZMTlxSExCckc0YjJ2VUhQc2h5enFuS2NWbFdjWUdETWN1eFNhSnNQaUVCREE4ODkvYjJxVlk0eTRHN3o0ZStVdGp1YlVSVlFMYWRaUEF2MnIwRCtJajhJM1UzZ3htMk14MlZZS2ZPZWk1R01tSHg4QTF5UUxmWkpWRzR0ZmtDMXE0QXRtVzZOZmM3L3dDWXFzNGlpVnNMRFNGdjc4MHNPdzNCMFc3QWMwa2dnN2c3VVJGaUJ1U2Q2UnBBTGRuYmx5UG1rbTZqZHRSUDZqUzFVYVFXMkpveXFnZXE1VTAxQ0NBZ0JGcUxUNnhUaGpQSGMvNVVwRjJJQUZ4M3B3RFlXOTdiMFJXeHYzcDVMS0wyL2NVcFVVM05yVUFSN1hvd3UyOVBlWGMra2Z5cFNZZHoray92U29Ca3B0UmhRUlVnUWtFSXhDbnZ1TFVoWW93VHJsaVgzM3BXQXlxcnBzZHpUMFNLc1JrYXppOWxYKzhmL1NrK2ZoVlFCc1FDZmRVSk5MT0x3cUNHM25TRFNiYUJhKzlORkhVWHpJcEcxRXlFMnVCdFQrRFZESUVZZ013MEtUdDZqeC9Xb1A4QWE4VVl1bUNCUFl5T1NLZlRPSjFqL2hZZUNDQWJzK2pVU2ZlOUxhUzVEYmJIaGdaRm5FUmlWNTlXZ3hFM0pidi9BTC90V2d3TVV1RGpoanc3Qm1nYldIV095Ni83d1BZOXFIUm1TWXJQYzh3dUh4SllpZlZmeVI2dEFHKy9hdGZOa2Nja3VPNmRPTGh3T0pnSHB4WlEzU1FpNGpjZDFJdDZod2FpYzEwaWJhVnVHNjQ2a3loWlk4Tml4bGdsWFZMSWtZMW41K0NmaXJoUEd6UDF3ZUZnelk0YlBHd29DUVM0M0NySktxLzl4M0JyRVQ0YVhMOGNNZ2x3N0xtWmN2Tk83Rm5Sd0xLZ1BCQUcvd0M5WE9kWk9meUtUeHhJd2lSVGlIVTJjM0czOVFhWTFZOWNJMk9PNno2VTY1eTJmRDVybE1pWWpXb0dKRFhlRmR1TnJnZmFzWDFIMHhGMDdpOE9KTTJua3ltZUoyd1dNakJjV0g2TDhnL0Jxb3k5NVpzVmg4UkFqaHdydklRaDBuVDIrYTAvVHVMZ3phZDhEbWtUbnAxditaeE1hSGVOaHVDdnNHT3h0VFVwSjJncE1vTUhsVWNNZUZobmVCbzJJbGo4eHl1dERzeE4rTzI5S3czbXlDZVRFTGhaSkp6NUNvSkJxWkExanBZKzQycVBtU3c1cG51SUpoYUhDeGx2S2p2L0FOSlQ5S240cDNDZmtzeHpUOGhoc0lKUVl2S254TXdza0tubGw5dms4MHY5anRwV1oxTm0ySHhOc1lmeWl4QUtzRU1Jc2tmNlNDUDJ1YW9zZkxqbE1zV0t4RTdGZ0dVbHZTNC92TFdzbnhFbUZ4Y21Fd2tubXh4blN6eURhM1pSZnRTMXpKcHNPMkdTSkdoMG5WaFdGNDBQdWg3ZnpxWk1ydnN3YTRLV2NhZjRrbTIyb2swN0JrczlyaUVLdjk0bmV0UzBma05xOVJISTdXSHRTQWdaQ0FDM2ZZMUpFYlpTSjAvTm9KWmxVSHZmZW5Sa05rVFZMZmFyZEVMTGU0STlxVWdWajlPdzV2VGtrTTNGZEZrT0dWZFR5U05mMjJwMWNtd1lGekV6VzkycWVBVHVPQlNtQUhxRnd2Rk9xaG00aHJsK0hpMldHTWR4Y1hvTWJNQXFMdC9ocVcxMTQ3KzlNRmJlb0tEOFUxZ2hsZFdsZlY2Ym0xdHFYLzRZNzM1b0xjRTZ1T3dIYWkwcmMzWTNPMWhUUndueXcxcmdHKzE3MG1hUUlwQU5yZHFCdVNBcW0xTllrT29OZ0NDTzlKMkJITXVnM0l2ZWtpYzJZbGUvdlRtaTZXdnZTWklpVUl2WTBnQU03SmI0MnBJeERBN2ZTMjFHVkNxYUlSZ0xZN0FVQUtNeHNGQjBkcmY2MEdkaEtMZW8rOUkwazMrTjZTeERFZ3RhNHZ0NzBDb1VraEozRi9jM28xbEdrN1dJUDlLUmNNQzNBRkdvYVVhQWhQeUJSUW9zU0JPK3hwTHpnL05PSmdNVklmVEd4dDcwK01sblhRemdDNTdHbnBBUVBOWWovQ0JlbENUMGh1eDdWYVE1RXpTS1pKZlNiK2xSVDhlUXhhYjJaaWZjMHUwTG9yY0ZQRkMwZ1lGbFliZ2MwbHAxTE1WUjlaUExlMVhzR1Z3eGFid3FXdGZmbW4wd2tjbHdzYWdrODI0bzJqTnhtcEN6M0FqWURuaW5JSWNTeEJDRUtkL1YzclJMaERFZlZ0N3FmZWxuQ2w5SWUvbG9keU52Mm8yaHVNNm1YWXF4RWt0cVZIazhodmVXd3RxTnVhdWpoOVJhd0o5V3hQYjcwdFlRVzFFZXExcjlqKzFHMURuTGdvVGxhS0NTeGVuRXdNT2tjMWN0QXcyS2duNDlxanBoV0svU0I4RTA3YU1VakFjbGZrVVNyMjFXcFNrSDl1S0ZpR0pxc1RpaDZSWW5VS1NRcEpJTzE2SkNibWdGdjhVQUdwdUxVZW1pc2ZuOTZQUWFBQ1llMUs3Q3dvdEpBTktYWVVBSUkzdmZhbEVYdVFOL3ZhakNrRUU4ZTFFVjNKSW9BSnIyRithTWJMYTlCUmJnZnpvYVRZVUFKNFczZTlIWmdiM3BXbmlsYlVBQlRwVVgzcE5neDJwUUJQOEFLOUdBU0wzVWZhZ0FySGNiL3dBNkNpNTAyTEg0cFpSbUd4SFBlcm5wYnBMT090TTJqeXZwL0xNVG0rT2RnUEt3c1pjcUQzWWpZQ2xTc0NrN0FXSkI0cFpqR2czQUFISlk4VjdEOE9mL0FJY1hWZWZZZURHZFhaOWh1bVluRnpnOEhGNStJQTlpU1FCdDdWM3pvcjhBWGhqMGppMXhXT2h4blVzd0FzdVl5a3hBanVGSFA3KzlQVUdKYVBuQjBqMEYxSDExaVZnNmR5UEc1eklTQmVDSWxCOTI0RmVsT2dmL0FJYzNYR2ZtQ2JxYk5jSDA1ZzJBWm9ZaDUwMzJJNEcxZlEvSk9uTXA2WHdTNFhKOHN3ZVY0WWJDUENRckd2OEFJQ3JGdGwzTjZrVUd2eUVzNFA0YS9ndThML0RmeXB6bEgvRU9hUm00eHVhL3hkeHhaRHNLN25oSUlzSEFtR3c4U1llQlJaWTRVQ0tCN1dGUk1UbThXR2ZlMjI5cXpPYzlaTkNIYUp3cHZzcE5OZVNHUGtsamluazRSc01UaUlzQkMwa3pBS043MWk4KzhWY3J5ZlZxeE1VZHRqZGhldVQ5YitQVDRDR1hDcEtrc3JNVklYZXdyaE9aNXZCbitiaWJHU3NWSnZjdVFvcWhsMXJmNG0zcC9HcEs4cDZKemY4QUVLc09Pd2MyQmlueG1COHpSaUpFVDBSanNkVmRuNlk2bnduVldYeDRuQ3lCZ1J2WThIMlB6WGhiRzlheGhwTXB3c2hreStYREdQRVFSbmJYZTZzTGR4Vjk0RytOMkk2WHp5TEpKWmcyTGtrRWFDVmpvbUI5dlpoVU9EVlRoa3VZL1U2TEU4ZnNYSjdobGlqeEViUnlva3NialM4YnFDcmoySU5lYVBIRDhDM1IzaUxIaU0wNlZDZEg5UWtGdjRDM3dzNTltajRXNTdqM3ZYb2ZDWjlCaXNBTVIvMDdyY29Ud2FtWURGTGk4SWt5bjB0Y2l0NVRobDZPYWNaUVBqZDRwZUVIVlhnNW5mOEFaM1ZPV3lZSFVTSWNhbnF3K0lIWW93L3lOWTh4RngydjJiL1N2dFQxWjBwa1hYbVhTNUwxSGxPR3pqTHBFT3FMRVJodE4rU3A3SDVGZlBqOFZ2NEtNUjRSNU5qT3NPa2NYTm1YU2NjaE9LeStVM213QzMyWldIMW9PUGlvSlE0c2Rmd2VYV2pDRDFFRDdubWhyalFnTklsaVBmaXE4eEZpMWd6THRiZTlHbUUxL3BKYjVxSVFtUGljTUR2TVNlMWx2ZWt2amNPb0drTzM3V3BrWUNTNjIwZ1c5NmRYTHBDQmQxSGVtb0JQOXBoYjZNTUIvd0J4cEl4OGpFbFVXUDdpOU9wZzBQMU14cHhNTEhwdUxrWDcwNENNY2RpaWYrcW9IK0ZiVTAwMHNsOVVzaHF5U0dOVzJVVXRFQ1hPa0cvdFNwQVZJZ2E3QzdPVFk4VTRtQWR3YnhEOTZ0Vk9uYzJCTisxTGpBWnRyay9ORlVCVkxsenFMa2dmdlQwV1h0c3BiVXczRnZZMWFSUUNaZElKODc5QnQ2ZjNvbnc4c01sdElWaHluNmhRT1JHdzJYUnFDTlFaUWJrbmNXcXl3V0p5N0RvZFVBdEo2UWIyL2NDbExsYytJZ2hodzZ5TkxLUVc4cEMrbTUyRzNKcmM1WmxPRzZja0J6bkI0bHNaQ1BURE5FSTBRY2k1UDZ2dFVNcEtpYUNObDRPSmtYUytiNXpta2tzb3hrV1dNdUVURko2VE8zMGl4OWlBYWxZSHc5eFdjNGFQTXM3OHJCWXhHT0tqekhEdi93QTNpNWYxYWw0Szg3ZXdGVGVoWUIxRG5NM1VIOWtSellORkFqL05rc3J5RVdMQTI5UkZhWHFsTXl5dkU0RTRISHdaak1xN1lZeGVpTmU2bGh3ZjlLcWJxWlpVTnk0T1ZkWFpmZ3Mzem5CWWhjWi9aV2R5TUIrYk1kb3BKUDB2ZnNwNE5WdU42cE9VdGk1cHNKQkJpMWs4ckVZSzRkVWJoOUI3cmZjSDVxeDZ2eCtJem96enl3eHlReEtFdXFnUmdYM0E5Z0RXUHd1VC9udnkrSXgwZ01NU0ZnMmtxekFFMklKMklxd3BxaUo0bVRUMWJpY0w1Wnk5b2o1a25tbFJHQ0ZZN0VmeUZRTVptdUpHTmZGdWlvR0pFaVJpd0krMWEvSDlQNERKczJURHhSRHlwTUJGTEZpUU54SzNjajU0MnJUOUdkSVpmbkdQbGp4Y1l3NGxoMHhGeHMwb0grWnFPV1FkREUybWNwejBmbW9reDZtTmRhUmlYUitrMlBJcXZYR2Ztb1ljRGs4TXp5ek1VZDFGMm1sUEgyVlJYYWVyL0NhVHA3TmN4aXd6UnpZV0hCK2E4YnI2aHJIQkE1c2I3MXpUSFN5OVBZekR0Z0lWd2ZsUXNzajRaYnR1TEUzUHZUNHlVaUp4a2lYa3ZST0R3MlhTNHJQMmttZ1JnTUxoOEsxOFZqbjRLci9kaUJ2ZGozRzFGbldYcEZwbFRNY215elFnRWVYd3NYZFJmZ3RiYys5VW1YNXgrYmowTmlwNDIraFNyN2xiM3Rma0Q0RldPSDhNUHorRm14c0NTeExjaHBRUzR1TndvSE56U1hzRlViNktTVEJTTktRVzFxQjVqK1diNmxQY2ZQeFRDUkdQY0M2NzI5UFAzcTd4dVJZekltRE5NTUZIcFZ3WFhXLy9BTnFnc1h4VG1ReitxMnBrVTd0ZmE5djYxWmpPK2lPV09pQXNaQkFLZ0UrdzRwd0xvRGJkNmtDQ0tMREI1SGxsa2syajJzRnQzTklLa3hOY2o2aFU4U3FOb0NFc0xIZTloUTJJSitrZTFPT0FYdXZIYWtpTTc3YjM0cEJBTXVzMk95Mk5RNUZzbzNJOWhVMXlvQWJjRUc5aDNxTkt3dXd0WU51S1Jpb2pvTGpiZWpBQkpCQis5SHVqMlhZbmcwVnJzTG50ZW1qZ2d3c2JDMXVLY1N4WWoyRzk2UXBBUHJQTzRGU1BLQ25Xd0oxYmJVSkF1Q0hKZ2ZNYzZHdGM3ZzAyY3ZuVnVkVnQvdUt0UWhMN2phOVNNTEZlVXN4MUtCcUE5L2luSkE1TkdmVEFTU0VBcnBIYXBFV1N5T3ZxY0x2eDcxb3hoYjhnQmIzMDAvSEVBdnFWZFBPNDRORzBiNmhuQmthazNKSWJzQnhVaUxJSUJjRUZpdTk2dWpBVlFPU3BMYmdld29tUW93c21oQTNQWS9hbktJYjdJQ1paQ21qVEdyVzdlOVNrd1VVVUpVSW11KzVwK0tCaXEyL3ZFcjlxbHJDQVBwRE00R20vNlRUbEVOeEZYRDZWc1ZCYzgyMjJxSk5DUkxxWGNqYTN4VndZOVc5OXh0Y0M5cWI4bFhheGE3SG13bzZHN2l0RUlMV0NIWVh0UkxGclVBSFRwcXphSXhJVllDelczVG0xSUVKRHNHVUVjcmJ0UU1mSkhURDZFSkoySXNLTllWWUMyMWp0ODArcDBGUlkrclptOWpUdmxGVGR5TnVDS0JDQzhSa1kyYjZUK29jMHI4c3lwWXRkV2JZK3g5NmtJakVhV1crbTU5UGNtbEtoOUlJdGZnL3BvSFJJeTRmVXJMdnBPNE51YWpKaEZWMjFFaGZnVlpoTlRFUDZTUjlWOXFKNGx1MmtrcHdCYm41cEFzaENCaEdmMU1Cc2ZpbWpoa1d3YStxMiszZXJSWVFWUUVIV0J2NnFKbzlCc0YxZTVJcFJiT09nNnhlMmxxRkpZMzNiWWU5THNDQnRzUnRWUXRDZE5ybTk2U3FXT3FuRld3TnFPNHQ3bWdCSkZ3TFVyYmE5QUFuY2NVSEZyWG9BQnNEYTVOL2lpZGVPMXFWWWtiZzBaWFlBMEFFU0YyNU5Fd08vWUdqRzF5UnY3MGFrVzV2UzBBbTMvd0I2TUtUUmwxdmJ0UmVZcWIyTnp4U0FBaXhzYVBRRDNvYWpiZFJSQ1VuWUlLQUZvdDF0WVdJdFMxUkxjQWJYSVAzM3BwVlppQTMxSGhmZi9hdlFQNFF2dzR6ZU92VzBlT3phQ1Jlak1xY05qSmVCaVpCdXNJUGZ0ZTNhbFM1U0Rya2MvRHArRDNxZnh6aml6ZkhTUDA5MGlya2ZuWllpSmNXTzRpWDIyK3F2b3Y0VytGblMvZzNra2VVZExaV21EVUFDWEZQNnBwaVAxTTUzL2F0cmc4RGhzdHdFR0F3VUNZWENZZEZpZ2dpWFNrYUFXQUFGSzhrTHdMbXJIb3U3UTMxVStHZ1BKNlFkN0RlOVZoemtCdEpKRmpiYXJKbEtpL0tFV3JKNW5BK0h4TEZCZEczMzdVekpOeDZIUmhab3BNMWlXRUhrKzk2cWNkbmp3RzRJSTlxejhtWmVRN0JpTERnRTFndXZQRWlMSmNISzBoRndObzR6dlZYSnFIWEphdzRISjFScE9xT3Q4TmxzVTBrc29VS0xsZ2VEN1Y1dDhUUEdpYkdueThOSklMWC9BSWNlelA4QWYycXB6anEzTXVvV2VlZHpDcEpLUjN2cUgycWp3UFJlTXpuRWlSSUhNMGw5VHVMYVFhb1BJNXMyNHdqZ2lyN09lNXhuMmFUTzJKbGR2Tmt1Ui9oSHRWSEhMajhhVjNuOHNrM1lHd1AycjBGaGZCdkVFQXk0VTRoMVc5LzBpb3orRmVQd3NpRnNPTkkzQUM5KzFIRWZnYTk4bitSeExEeFlqSzBrbmxsZEVSVGR3OWlCMm9aWjFUbCtWWnBnTXl4Y2srQmx3azZUd3l5ci9EbTMzSXJmOVUrSCtJeGVjNWJsaGdieW51OHprVytuZXgrSzRsMTluSzU5MVpqaEd1ckw4SXh3dUdqSDBoUnNTQjhrVkpqaDZwRmx5U3djdDJmVUhKTVpKbW1Ydy94N1FZaUx6ZGNlMTFJMkkrOWRCNkJFaTlQcWpGaUZKMEZ1ZE42K2IvaFQrS25QK21PajhKMFRpTUtjZmlXbmh3dVg1a1d0NU1URUFySVAxV3ZzUlgwdDZYd2pZREljSkU1SmNSS1dZL3FPMjlXOEVHc3FUS09vbkNlSzRva0lEL2FlL3dDbENkcTVOK0x6T2NWbGY0ZXV1bzhGZzVNZlBpc3VmQ0dLRVhLUnliTTVIc28zL2F1czRkaExqWjM0MDJIODZvK3JNVGhzSmxQVXVLeGl4dGdzTGxVNG5Fb3VtalFiaHF2U2xVR1o2U3V6NHhSeFdoajlRS2hRQmJ1TGMwZjBYUEZEQnFId2taalhRaDFGUVRjMjFHdy9sYW5BdTV2MnFBWUpWYnR4OXFkZEJkZHZWd0tRbnh2dlRscm1nQmtHNGIwZ05ScnR0N2RoUmtCWElIZjNvRVhOdjZqdlFBQnVRQUxENXBZVWFTQzRIeFJLcEc3YjdIYWxyWnpmVGE0b0VZcU9KREd5aEM1RGJPcmJpbkZ3N2lUMUovUzlJUmRNaE5yRGczRk9RczhZWUxJVUJPNnJ2ZWdFTC9JcTBiTkpQb1QrNzNxNHkwZm10RUMrVkxFN0QxNGtHeVdQT29iMVc1Y3Bmeko1QmFHSUZ0eGU1OXJWYzVCZ0pjM3hoRWtoZ2hqVHpKbmpBOUtYc0VVZjNqZW81dWtUd1gyZEZ5RE5jVGhNTk5pc3F4c0dHaVJyS1lZZ05MRFkyUEpxNWh5akI0L01vOFJtTXh4czBsM1lUc1dhVSs1ck13WXJENER5b1k0Tk1hbmFCVDZZMCtUM1AzcVZsL1VLU1ozSk04akxOaVA0ZHhZYUZQQ2o3MVNsZmFMcWltZDU2RmJCcE5oSVprL01KQ0xuQ292b2dIc29IdnR6VTNPTXNqeDJMeDJaNHFIOGpoZzMvd0NDUnJwZGdQMGo1TlMvRHFmRFpaMDFQaTJnOGpGWXBUSERDNHN6RGd0V2I2aG16RHJETklNcnd1SGs4dVJydE5ydEhDaWNsdmNrMVhhK1d5ZUtwMGM3elRvekFkVlo3T0pKeGg4bFJSaVpjRGw0SktBY1JQSjdrMnZhbWNSMDRHaWwvT1piSFBGQXdKdzl5SWxGdGtVamZZVzUvd0JhNi9sbmhwRm5reGgxdmhNa2hsVjVjU0NWa3hUajlLZ2NMOTZ0dXErbE1IK1RUQllERFBoc0tFSlkzMU03TnRlNStLVDFKTG9sOU9LK1RoMlZkTjR6cUhHNEpuZ3RDbUR2b0o5TVpCSVg5dUt2WU1wYkE1UnA4clhLa2dMWEJCamt2dDk2N0wwOTA1RmtuU3VCeTh3eG5GQldVempkdElPb1hxb3puS256bklNd2dsVkZrVllkVGl3MGszTzF2L2U5RGRvWXUzRkdZNnh6bkxwY1hCZ2NaaVlkZWJvTVBLTGJxTk94dU54dU9LNVZuSFJPS3hHSW5od21HYVFUeENJczUzdUZKQSs1QXRYUTM2WFRGWnhmRm9WbmdLc1NvdVFFK2tpdEJsUncrTnpuTTVwWWI0ZkVERCtYcU5pamk0dVBrMlBOT2pLbndHeTFUUElPYzVUTmwrSVdkNGxoaFlBTkdEWnRRTnRxNlY0T2RUUjRYcUFaUFBLdUt3ZU5ZRHlocytHbE95eUQzWHNSVzc2cThMSXprK2RRSUJpRGdzUzhwWmx1UWplb2FUN2IxeHVIcDJlT1RMYzJ5VFN1S2hJbVFFK3JXcmY2OEdySHFMSXFhSy9wdkhMZzZ2MXIwRGo4NnpuK3ljWGhoZ21uQi9JWXlYWUZ3ZlVIOWxQYnZYSnMzNktnNll6bkVZYk5ubldhRUZuand6QVdCMkFZbjVyMVQxamljQjRrZUYyRnpyQ3pma1p4Q3Mwa3N2OEEvVHZ3eWtld2F2UGZpRzAyY0RENWxpbzBrRW1GRVdKUGFabE5pNjI3WDdVdU9XM29pYXZsblBKNUlKQ0ZoRGFWWXFReHY5ckh2UlBHeStXcFVLRUIxL0xFN1gvYW5EZ1lZRlJJWTNNVTVZUk0xL1N3NXVPMXZtcFF5NlJiUW5FUmx3UVN6N2FqL0tyK0tia2lsa2pSQk1ZMFhIQm94RVFMV3RwMnFVeWFUcGFQMUtMTUYra1V0SXl0aHpZV3Y3MUtWU3ZLRG0yM2E5UjVZL0tiY1g3Q3Jnd0lkSWZjK3dwaWFJYUNsaHFCdFEwS2lvOGpjMjVYdDcwZ3hXWVdGd2VMVk9PR05tMGkxOXIzcEp3cHNMZW5TT2U5SWh3MHFCa0E3MUpCQkFEQzU3ZkZHa1Z3cE85OXIwL0JDcnZwVW40SkZLQW1GYlBkZ1RiYy93QXFrWWFNREVmVDZnTmhmbWxwRWRtSTlYSHdSVXZDd3Ewd0lVYWdiWHRlbkpDTVRJaEVtcTFnQnVLWENOSUxHektmcFU4MU54RVNvQnlMcndlOU13b0hLa3JabHZhblVROWhLQXlXSk9uNUd3b09Uci9TRjcwK0lBck1EZlNmVUI3bWdjRVoxRFJxVGZ0eFNDb2pDTURTQ0xLVHp4YjdWTVREbGwxRmJzZGdWTlJpK0hoQ3JOaUZCMVcyTjdWYXdSUnpKZUJ4S25HcFR4U3BMNUFpQ014M0F1dzkxN0dsZmxoR21vdDZ6dHZWZ01OZDdvcEowMlpSMithS2FOaWlsZ0NCc0xkN1VWOURTdGt3dW1mU0QrbjZqN1UyOGNna0FVajFDNVE4RDRxMWJDK3RnUVF5aTVGUnpFb0lOamNHaW1PVWwwUVpNTzEyUlVDOEV1T1A1VXFXSlVMSnV6Q3g0cWM2RHpEcEZ4YjM1cE0wR21Zb0RwVzMxRGVpbUk1RUx5VEltcGhvQlBibW16SHVxa2JBSGFwb1QwdUQ5T3gzRzk2REtxMnNDNVlYSnR1RDJwQkxJU3c2bzAxdC9ESEswMndMNlNBUXQ5aW8vcFZpc0tzVXNWVWFia25pNHBob3l0anFzb1lrZ0Q2cWR0UXRNanBleDAyWmovbFRtaEJlN0lEODB0VkdxNE9wRkdrV0cyOU9YVk5pRkg3VTBLWnc2NEJGdC9nOFVGc1ZKdmMzdnZTRlJpd0oyTitEUm1FbmhlZTlWQytHSlYzQVAzRkR6VkJBQU85QklTekFHMWhSbUVpeDJ2ZWdBZ3pBYkRhaVozVzN6UmlGYlhKM3Z4U2xqVmp4djk2QUNNamFkM1AydFNkMzRjMDlZQWJnY1g1cE9rQ3hBQXNLVmNNQkl1QVJzQU81b0JDRnVSYSs0cDIxeW9JQnYyRkdWc1NML2I0b2JBYkNrY20zeFNsajFOY25pbGpjMk5HTERZbTFBQ0FvTDZiazBzS28rb0RuVHZTMWpDQUV0dWZZWE5kSjhEL0FyUHZIZnE1TWx5Wkh3MkZqczJQekZsL2g0YVA3OTJQWVVkT2dxK1EvQWJ3Q3pyeDg2dlRKOHJRNFhLb0dENWptWnY1Y0Vmc0QzYzhBVjlaK2hPaGNvOE4razh0NmJ5SERMaGN0d1VRUlZBM2tOdDNiM0pPOTZoZUZuaGprUGhCMGZoT25Pbk1JdUd3TU5qSktSL0V4RWx2Vkk1dHVUV3NZNkJWNkdQOEFkSWhuSzFTQUNMR2tQd1JjN2pta3lTYVVKN1hxaHovcU5jdWdlRytuRU1wOHNqZmZ0VWVYUEdQQTZHTnRxaUJtR2JuSk1WSmg4UmlWT3YxUlhhMS9pc3RtL2lEaG5ZeGlaRmtHd2pKOVJybTNWdmgxblBYMDdEUE9vY1JnRkVnZUlZVzQvcmVzdjFCNElZM0RxWlllb01iallDbWdLWlA0aUR2V0ZQSk50bTlDT05kdmt0L0VieGVneWRYUVkyRVRFRmZMajliMyt3NHJrV0JHZTlZNHhKemg1WmxjblFIUGIzSXEzdy9oSGdzcW1SNW5kSjdhalBLNEdwUnZ2ZXVvZEdabjB6a3VHQ1lYRTRXZVIyQTgwTUQyNDVxdTFLYjVMcXl4eHJoRWZwVHdaOGlQRHk1aGFTUW5VVkc0WDRycUdBNkx3c0NqU2lEUXR0dTlPWmZtZUh4TUlhSjFLbmdYcWJIbWtjUUFaZ04rS3RZb3hnK1RNeVpwNUpWUTloOGx3eUpabEs2dHJBYlZEekhKb2I2WTR4ZXBpWjZzcW5jV0I3VkZ4T2FwS0N3UEYrZGlmdFZwN0dKRnpSelByN0laNU1WRW1HaVdQRllqK0dKZFBBdGE5ZVh2R1g4SythOU9adjhBbitrSTF6SEtaMUR2Z21jaVdHWGh6YzdXUFBQZXZjRVpqeFdPRTdBS1VUOWZZR29icGh0Y2hhRU1HMzl4ZXEwZDJOKzBzNWR1VkpTUEFYZ1A0S1ozNG5lSzJWWkRpTUppc3R3bURmOEFPNWhQSU5JampRM0FWdmNrV0ZmVnZBeng0VEwwamVRL3dWQ2gzTmlRQllYL0FHcm0zU1dEd1hUV1d6NWxHcVljWWczMUlMRmlLekhVM1hHZGRXWi9CMHhsbUVNTU02YXNSaUpXc1kwN3RVeXpPS2NuMlFMU2I3UzZSMnJJOFNyWVBHNHNzQ2hrWWh5ZGlCWEkvd0FTUFVVZVNmaGk4UnMxeEROR2N3d1UyRGhiM01wMEwvblYxbS9XZUE2ZXd1VjlJWlhxekhNWjlPSEN4RzVCL1V6ZXdGYy8vR3BrK1paLzRNSjBka1F3MDJNYWVLV1RDelNCSG5qaDlaV0srelB0ZlQzcXhESXBxbXlya3dTeHVrdXo1dFFJWU1ORkhhMmhWQkYrOXFNYkM1RjlYYjJvU0tBWFVxUXlIUzZOc3lzRHVDS0RIaGg5SkcxU0ZKcW55RUJZaFIvT2xsQUNMR2k5amV4cFlGd0NCOTZCQnFRK285eDdIaWxBQ3g3anY4VVRvRllsbXQ5cVV3M3RZQlQ3YjBBRUFkWTN1RFRoV3gyb3JEMDI3VW9ibmZZMENNSmZUeUwwOUdoa1pWUVdjblRZZjUzcEkxQzZnZ0NwT0hWSW9uWmd3eERFSWdINlZIMUdsUUlmYU5QNFdGVm1lTFl5Tkg5VEFjMXJza2FTREt2ems4aUN6RllsanRaRkhCUHUxWTVjU2tLRklqcW1aYms5d3A3QTlxMFNTTW1Id2VYWVdFNHlSVkRwQkVMcnFKM0x0d0xkNnI1T1VXb0lmekhPVXdtQVdFQ3p6UHJMY2xqN0Q1cm9QaEYwUC9hR0poekRPRUJ3NlJtYUdKdXpYNWYydDJGWlhvL3BvdGpobURDTEZUUjIxVFRtOE1MWC9RdmNqM3JxbUR6NFNnWWFERHBGaDllcGxRM1p3TzkvY250VlBMTGJHalF4d2JhT2pRNGlLV2RNVGlIQjBrTGhZSWpjV0hOLzNycDJUZFB3WURLZnptS2g4dWJFT0FrYWk3U0E4WEZZdnd2NlRNd2p6Yk1JN0tEYkRZVWpkdCthN2prMlR5WXpNSHhXTVlhdE5sVUMraGY3bythcTh5TFdSUml6TXJsVXI0NkhDQ3lYak1wVWNJb3BqT3NMRERnWXhHTGhkK09mYTFYbVQrWmpwczh6Rm93anlTbkRwL2dqWHRUZVBqamNoWkY5RU1JZXc0djJxUlJJbStUTVlYQm1iRktaVzB4bFFwSkhmdldMNmpadW1zUG5LalhpeE5LTGhSK245Qkg3MTB6RzRONGhoNzdzNDFXQTJGNjU1NDM1WWM0ZkM1ZGxwMTR3UVJ4NGhZellvSGtYUTF2Zm1ocXFDRXVTRm12VE9OZkduTW5qMDYxVDZlOWxHMVJZTW1paXhwZ3hYOE5NWkFGU1dQOEE4R1pIOUpQeHZYYVpNbEVtVFFLQmNCQW01dnVvRmM0emJwTU04c1U4c3E2cG1PcFYra0ViZjFxdGNzYzdaT3F5RW5ESkdSaVhNSDVyRXlMK1Z4TVpVQzZqdmI3ZDY4NFlyb3dkRzllWWZLWXNSSEpsMDhvWFcxN3dCMk9rc09iQTgvZXZRbUJueE9UNHlXSEVNU3lvdjhmZ3VCeCs5Wmp4SzZTSFU0dzJhNWRoUHpPWllkdEpodnA4K0poc1FlUlpySDRJcTBudTVSV1MyeTVKc2ZSdUF5M0M1bmtTU3RMbFdZNGN0T08wVXBObUs5OVBCcmovQUZmNGNabGtrK1hSNERFTEpHSVpZbzRaaUJlNDVQSUhGOTY2bjRiWitPc3N2d2VJbXhQbFkzQ3dQaDhYcmE1SlZpQTEvZTl0Nm5kWmRLeTU5Z2Y3UXdka2x3N2xKSVcyU2NnV2NOOTFKcFZjVmJHT202UFBlYTVWbVA4QVlPWTRiTnNtaU1KaldZVEs0V1NOdU5RWWMzNTRyQXZnSlk4SEdadGJzZ0Fjc0xoaCtseDc3YzEwUEhabmljZ3pHYUhVeUpoU3lyaDV6NWtieDNzRUk3cmJiYXNWaU0xd3VZemVaaEQvQUdkSkkraDh0a040Q2hKdVkyN2I5alZyQms1S21mSDdTdWFIUXZOdFE0N0NnSWlsMUpPOWhhMVRER2prSUdBQTQzdnZTemh5dnFZN0d0VmNtUkxqc3J6RnBYbm5zbzJGcVRMQjZCSW9ESWR3U0xFbjJxemhaRVZsajIveEViMUhtZ09JakRGdjRnTzE2V3ZzYXBGUVVLa2diRzEvL1NpWk5HbGplN2NBRG1wOGlEemJhZEtEZ251YVNJR1VrQjlnYmt0d2FLUSt5TWtKYlNBQ1FEZTYvd0N0U284TWJMZTExWWsyTlB4UjJVazdBbmZUM0pwNkdQV3BDQVhCdFlpa2FYd0c0WWloS0tPU3gzdHp0VStIQ3Mwa2FKeVNEcUd4b01DaU9QTGFhVTJqamppSHFkeVFGVlI3azE2ZTZPL0JEbXVZWkhEbUhXdlVEWktQTDh4OHB5eFFaRUFGeXJTay9WN2dDbnJvRW5NODR5UnhZcGx3c0htWXZGZlNzR0hpYVNRa2kvQ2cyL2V0TDA1NEtlSWZWa3pwazNSR2FHRVdCbXg0WENvUGthemNqN1Y5RGZEcm96cGpvenB6Q1FkTTVUaGN2d3hRZXFLTWVZeHRiVXpjbHZtdFhyZGdOYkZyY1gzdFNxTzVKaVNnbzluZ3JBZmdvOFRjYXNieVlucHJMUnFETVpNVks3SU80TmtzVCs5ZFQ2Ti9BbmtXRkl4SFYyZVluUEpMay9sTUgvQWd2ejIzTmVvcm05ei9BT3RFVGZtMS9mdWZ2VXNjYVhZN3JwR1U2ZThLT2pPbGNGK1V5M3B2TDRJU1F4QmhWaVc5eVR2V042Ly9BQXMrSDNpQmlUamNSbGpaVm1Pa3IrYnk5L0tzVCtvcU5qYjVGZGRvRWZzYWthUzRTR3ZnK2QzaXo0TTU3NE9aakZGbkRmbk1pbGswNFBQNEZQbDc4SlB0NlcrZURXS09FTWpnS3hJc1F2OEFkTjYrbjJZNWZoTTN3RStBeCtHaXh1QW5YUkxocDFEUnV2c1FhOHErTFA0Uk1WbGNlSnpUdzhDNHpCZ0Y1dW5aM0NtMy93RHp1ZVArMC96cGppeUtVYjZQTXo0SjMyTFhZSGdiZnpwcVRDV2Q3clpXNFlIWTFjTEIvRm13N1JTWWJGUkhSTGhzU2hqbGliKzZ5bi9PaCtSU081VWFZMVhVTlc0djdVeG9oNVRwbEJGQ3JteXFkdU5Rb3BvR1Y3NmUyK210QWNOcHMxOXJhU29YYS92VU9mQ0ZyZXRRTndRT2FTbUYyVkpqTXJLRkc1R20xQkFxK1d5a282c0xmTldjY0FNVGtqeTBMYzIzTnRxWUVFYml5OTJ0dU4vdlNVTHVJTFJYQkpVc2dCRnJDbVpzTW9IcFVvZjAvd0IwRDVxMFREQjRHWUtOVnRKdnNwSXBpT0JaSWR3R0xIU2JIWVc3MCtoMjlsY3NFWVg2OTIzSVViVTcrV05nYkRmNHZUcktzQkRvTk4vU0N3Mm9CRkk5T3BoN2lvOW8vY2NBQUlHMzlhVUcwaXgzUHhSTVNSWUFmem9iQWJIZXFCb2crM05HRkxEVUR4UTA3WG9qdnZ4OENnQW1KTEEyMjdVc3J3M1B4UTAzS24zNUh0UTM3VUFDdzJPdzJ0YnZSWDlJdU5LKzVvMXR5ZWFWcTBXdlFBQXBWTGdiWHVEU2xGZ2FJdmFNam05S3RadWJmNjBBR045cVVGVXRZZy9la3FDU2RPNTlxM1hnL3dDRVhVSGpkMW5EMDkwOUQ2VklmRzQ5eC9Dd2tSNWRqNzgySEpvQkV6d1I4RHVvUEhickdQSk1ramFIQ1EyZkg1cXcvaFlhTy84QVZqMkZmVmp3azhKY2c4R3VrTVAwL3dCUFFHT0dQMVM0aDk1TVJKM2R6M1ArVk5lRDNoSGtmZ3AwVGd1bk1qaFhURU5XSXhaUzBtSmxQTHVmOGgycmNqK1ZXOFVMNVpITjA2UUY5QUEzc0I3MGx0NzByNzAyN0VmN1ZhbnhFaXRXUnNjNVNJaGRpYXowdVdDV1Y1SmxNaC9UdGVyNmV4dVR6ODFSNTdtMEdVWUtTV1NkVVVMdHFOdDZ3OG5MTDJOL1JsK3BaMHlxTmdkSkduWXViV3J5dDQxZmltdzNROHJaWDA0STh6enRnVmtMRzY0ZmJsaVA4cWlmaWY4QXhIU1pZczJTWkhqa2x6UEVLVmQxMy9Mb2YxTjgrd3J4d3ptVjVKSkhhV1YyTHZJKzVZbnVUVElZM0o3bVN5a2x3elI5VGVJZlUzV21LV2JOODJuZDczVVF1VlVEdngycWl3Mk14V0RlR1RDNHZFd01oOUx4eWtjZDZhMUJic0FCdGEzeFNVQkkrRC9TcmUyUFZGZmMwenEzUnY0anVzdWszZ1dXZVBNNEV2Nlo3Nnp0L2V2WFFzTCtOTEhGVCtZeWdxU3U1QnZZMTVuWnJEMmIzb3d3TDNEalQrOU1lT0xIck5KZEhwMXZ4bHEwUG93azZURzRzRU5oVk5qL0FNWCtleTR5RjhGaHhIR3BET3NxWC9ZYjdWNStSMlBEYWg3ZHFjUEhxSVVlM042VDBrUC9BTW1aNnN5YjhiMkd3K0ZqanpMSmNUK2EzRTBzZHlEN0FWZjVkK05IbzVwVVRGNGJNWVFlYlFGdEgzdFhqUkdKazlSLzlSVGk3U0VnbFI3VWl4UmJvZC9rU1NzK2dmVFg0aDhwNmx3VWVCNlRmKzM4M3hNaitUQVFZL3lxMkhxY0hnYzcxWlpuTWVtb1RnVGlwTTA2d3padkxDUVRXY2xoWWNiaFZQZXZBZlNlZVp6MDFtejQvSThaSmwyTmFCb0huanNEb1BJdlhvZjhHMmVQa1hqeXVJNnF4VHpZN05jcmtHQ3hlT2ZWWmx1eFVFOFhXLzhBS3Fzc2FUcG0zcDlUdWgrSjYxOFBPaHNENEdkT1lqT2M5eFJ6UHFGb3RlS3h6aTRnSEpWVDJBdnpYbkx4ZDhhSXZFRHF1REZSTXh5TEJhbzRjV3QvWEkrNVlmQXNONjNQNGkvR2FQcmlLZm9UcFRNbGtYRUwvd0RWOHdnSUtRUS8vaXczZG45dTFxNG5nSk1ISkZKa004Y2NYNVdQeWtVbXdrUUQwL3Z0VmJLMUZiWXMyZkhhZVVtOHVWZDlHWDY5OFA4QURkVVh6SExDa1dibmR5dnBpeFp0dHE5bXQzcmpja2NtSGtrZ25oZUNhRmlza2Jpeklma2Uzelhkc3V4ajViamprMk1KU0UzT0htNXQ4R3Ficm5veGVwb1dtaFJJYzhqWFVyRTdZaEIray9QejhWTGd6dGUyZlJYOG40eUdTTHk0Vnlqa0lzVHlkK0tVUVFOUEdxZzBja00wa00wYlF6Um5TOFRpektmYW5GR3RsQkdtMis5YXE1Vm80ZVNjVzAreHFVV1pRQUcyc2JVclFBeEkyOXg3MGNpNlNnQTA2dHIvQU9sS3NBeEEyN0FlMUEzb0lFYXJqZjRIYWxDMm82djVVYlIrb0VBZ2diL05HRkdzWEExZDc4VUEyS2dnODFpTGVrRzdmYXBVUmxsdzBpTEdubHJiYlFUSUw4YVIzK2FRbUphSkN5cUZJQUF0VHNPWjR3TXpqRUdOckZDeUFBMlBJQnBzblJKQ1B5VE1CbExMR01SaUZYQjRabXNITzhzd0hJUmVRUGsxYnc0eVBMb1pJc05FNGhZM0VkNzJIdVQzTloySEdhQ1MydHh5Ym01WS9ldE4wNWtlSjYwRWNXQlJteGNNb0xZZUpocWFJL1V3OTdjL3RWZWI0dGxxQ3QwalZkRDVEaXVzcDVNUkpJTXR5WENnR2VhK2tiZnBYM0o5aFhlK2craGtseEFkc0t5ZWNWYUZHM1pZeDlLa2RpZWIxUzlBZE9ET2poMVZWajZjd0xCTVBGRXUrTG5ISitRRDNOZWsraCttbHcycVY0d2NZNTlZL3VYN2ZGWnM5MlNYQnNXb1JzdGVsK25CZzRvM2xRbVQ3YklQYXRUTVk4bHlqRzR4eUFJWVhsUDdEYXBNRUFpaFdNYnRmZjRxajhUc1hIaGVsVGxwYi9tTTJrWEJ4eGo2bkxjMitBQmNtcjNwYlltZHZsa3lVVlBRVVVuL0FBSmc1cG85VXVOUjhaSnFQZGp4VUdOWHhpdkl4S3hlZGEzYTNaVC9BRnJZNGpMRXkvTDhMZ1lUdEZBc1BwNVZSM0ErNC9yV2FzUDdHMGhnSFJ6TktDUjJPNFAvQUwycGlpMHVTUnUyNkc4N2pENTJJTU05MVhEQWhqdHBjOGZzUGVzYjBKMHRMMWwxM2ljL0t5eDVKbFUvOENaMXMrWTRwUVZMbS84QTRTYmhmZTlXL2g1bkQrSkhVZVl5UklIeXJDZ1JTWWkrejI0UlBjWDcxMVBEd0pnY000Z1FLSTBLckhHTEt0dUxVK09QZHlSeXl1SERJR1VaVG93REsxbVlTT2RoM05aanFISldFMGtxTGNtK29YMkZiL0xob2cyQUFZbGdCODFHelRMbHhSWmRPekEzK2FkbHczRGNrUTRzelU2Wng5OHFpeG1WU2lWZGNpaHJsZnFCN1dybHVYOVlUNWNXMVA1ZU53TXpKNnQ5Wkcray9CSGF1MEpoWk1xeCtJdzhucGlZSDEyNDloWG1IeFBaOGh6elBwWTFRUUxpRW1rWlNmVUdXMzg3MWxRYmpLallTVTFiS2RNd3cvVEhWV1B6dkpvRFBsdUlXWDgzbDBUbitESTFqcVgzVDI1cnZuVHVaSm1PUjRYR2VZSjhMakZFY3VrN0FFZWwxOWlEc2E4aTRqcUhGYWt4MkFtWVlqRC9BUFZqSEZqM3QzQnJ0Zmd0MS9nYzJ5UEVaUmlUNU1oUXNrUjRSdVRiOTZ1VjdlU2srT2hQaWYwaVlUQkpobFJKb0djbEpBTmdOOWo4KzFlVnMyTDRITWxTZFd2NTVsRHVoQUlKdlkvSXIydDFuSmg4NzZZbWdrTjVWaVpVWS9VVGJZVjQvd0NwSHhFN1FRRzA1aExJenkyVW4zSDdVL0R3K1NETmRGbGdXZ2xSWm93Q0pCZTRIYXBZMHVxeTIxTmJoaGExVm5SOGY1ZkwzallGNW9GdU4vU0FTZjUxb0hoT2xaQ3BaMkZ3QnhXNUZYRkdKbDdJYndXS3F0bUE0MjNBK2FZblM0SkRDM3VCVnVJWElKQzMzQXVPMUUyRUxvTGdlWGJqZ1hwV3JLOW9vbnd6QkM0czZEZyszeFRUWVVBM05uSE5qMnEwbHdqS1dWVktLTjJIMm92eXZwWXF1dldMbTN0VGFaSW53UVVoZCtkbFU4V3RmN1ZZUXd0b0xJdTRHNXR2UzRjTUpiRUxjQUN3YnRWaERBeXVWVWFQVHNRYmsvZWhSZllrbnhRN2tMTmxIVWVTWTlJMWNZZkh3emVZM0I5VnIyK0wxOUxjK3hrbVA2TXg4eVBlU1RDdDZoeVRibTlmTlBIWVZtd0R4Z05ZRlZqWmZlNE5mUi9wTEZSWXZvVEsvTS9pTExBa1pBNVBwRjZpbkxiSngrMFg4SE1GTDZIK2hGTDlPWVNVZ3FKRkRpdENEc1QySGVtVVdETDhHcUlnaWdqVFlkZ29yaVBqRjQvNHZLK2w4d0hST0NHYVptcTZFbmtiVENqRTJ2YzgycVZUamh4cE44a2l4eXpTdjRPbVo5NGxaQjAzbWNlWDQvSHd3NHAxMUZIa1ZTZytibmFveDhYT2xRQ1RtMkdVRDNtWC9ldm1Cam9PcTh3ekhNOHk2b2p4bU96SEZTYXNSakpneEJiKzZDTmdCMnB4Y3hFS1JKNU1NelJlcitJU052WTFuVDFlUlBnMUlhWEJLbTJmVURLdkZUcHpQTVltRndHUFhGVE1iV1RoZnVhMXFzanFyS2RTbml4cjU4ZEVlTTNUMEdDamd3ODR5WEg2UUdFcUZVWnZkV3J0L1FIalBsK0YwakdkVVllWWdBbGRkN2Z0VHNXdW1wZTlCcVBHd2EzWW1lbUxiWC9wUUd3TnRyODFudW11dHNCMUpoVW13OGdaRHNINHY4MnJRQTNBTjcvSXJYeDVGbDVUTUxKaW5qZFNPWmVNWGdEa1BpL0VtS2tac282Z2czZ3pYQ3FBMy9iSU9IVThXUEhhdkl2WG5oNzFQNFlaaStINm55NFF3WWdsWU0xd2lsOEZJQnhxSXY1WitHL25YMEgwaHJFaTlNWTdBWVhNOEhOZ3NkaDRzWmc1bEtTd1RyclJ3ZVFRZWFrb2dhVDRQbkMySFpsUXFHWVcxM1EzVzN4Ym1reTVUaThRaXZoOExLU1RjZ1Jra0QzNHRYZlBHYjhJdWNDR2JNUEN2TzJ5Wm5KYVRJcExlU3c1UGx1YmxUOGNWeEIvd2llTDJPU0Y4KzZxd1dBMWk0anhlYitTVlh2WUxhLzJxS1UydmdqV0Q1SzFjb21SWWhLMFVMRzloTk9rWkgzdVJWYmo4ZGt1WFNPTWQxQmxlRm1BOVNMT0pHdC81YjFlNHo4SDNUT1hNSmVvL0dmSUVjbXp4Uk9jUTYrNCtvNzAybmcvK0hUcHhZbnhmaUptT2N5eGtsbzhCZzlJYjRCTnFadlpMNlNSanBQRURwQ0NjdExtVStLQ3I5T0R3cjJiMkFKNE5ZZk12RjNQSlo1RGc4UGhjRmdRU1k4S3FYY2ovSGZjbTFkd254ZjRiY2tFY3VFNlk2anpsaWRRT0l4SmpqQithYy8rZnZoWGxFeGx5YndXeW1LZU5qb3hHUG04eSsyMjFOdGhHQ1h3YzJ4M1UyYVFkTVpMbk1IVHVIelRBWm9IU1BFeE96QlprK3VObzEzVTl4N2lvQzU3MTlpMUV1RDZQbkdIYjZkR1VZaGgvT3U1ZUMvaXJqODF5WHh2Nmc2ZnkzSjhqeG1YNERDNXZsK0FFQ3Zob0pReFNWbFZ0aHFYbjVyRVMvams4UkxSazlSNGFBbEFmTHcyRFVJUDVDbzl6RjJIbDFSWVd0YzBwcks3SGNmRkpzZjA3R2hjNjlSM0ZxcWx3TStrRUVnbm45cUliZ0hqZWdDU1RmOEFwUUd3b0FNTVM1M28xTzFKWThlL2VpdVJ4UUE2VlZmaWh1YkhZajVGRVJxQWFsRTNJSW9BQjQ1SDdVcFZCQjV2MnNMazBYbGNFQzVQYi9ldEgwTjBObmZpTjFWbC9UM1R1RGt4V1o0eHJJQUNWalh1N25zbzV2U3RVckhKV1dIaGI0Vlovd0NNUFdjSFRuVDJGTDR1UWZ4NTJCOHZDeGZxa2NqanZZZDYrcm5nZjRKNUI0RjlGNGZJY2ppV1NVcnF4bVBaUUpNVklkeXpIbTNzTzFxclB3OCtBdVVlQS9Sa1dWNExUaWMweFFXWE1jd2I2c1JKYmUzK0VYTmhYV05JQnVCVTJLRGs3WkZrbFhDQ0NoYU9nZDZIZXRGSkxoRmE3N0JXQjY3OFpPbnZEL3FES2NrekdTV1hNY3lZTEhIQ3R3Z0pzTlJ2dGM5cTNqTnBOWVBNK2crbWgxREpuK0l3YVlyTTlXdEhtT3JRYld1QlZIVTVIRlZFdTRJUWI5NW9NMHg2NGVNSDlSQS9hNHZYakw4Vy93Q0lTTHBoUCtIOHIvalozTUczTEFyQ0Irc2ovSVYxN3g1OFo4SDRkZEs0N0h5VHArWVZTWXhmZG1iNlFCM3ZYekx6M1BNYjFWbkdQem5NcEdueDJOY3lNemJhUVRzdjdWbVJUbnlXSmJZOUVPZVdmR1R5WWpFU1BpTVRJMTVaNURjeU4zTkl1YkJlTGJYdlNRcDFNYjhXNzBiQzRBSGVyU2ZCV3QvSWV4M1BhaHJZY0NqS01RTHJjanZRMDJVYi93QTZVYStReXB1RGZjKzFHRnZwSXVBT2FRdHp3YkVjVXNBNlNOWEhOS0lHcTN1ZmJoYjgwcEZBSkE5Vi9mdFJMZlpUL09saEwyM0k3QWQ2QmFBdHhja2JBMkJ2elUvS01xeEdjVCtUaHdTb09sNWp1QWZiNzFaOUc5RjQzclRNR2ppQWh3VUgvWHhUZlN2K0ZmYzEyUEtlbU1CbE1VV0R3a0t3d3hHd1p1Zis0MVV5Nm1NT0YyZEQ0L3hNOVUxT2ZDTWhrUFNXSHdlQmVMR09UaUYwZ1JLTjNCNE5kQXpubzNBNTdCZ0k1R2x3VDRCZE1jOEJzNEJIQUkzSEpxc21TSEZkZlpOR25wZUtPWHpUMmRMWEJQNzFyM21zU3EyMWczUCtLc2pKbGsyZDNvOUZoU2VPdUNCa3VWNVprbUQvQUxQd1VYbFFhYnZwUHFsZis4NTVKKzlWM1VPVXRLaVQ0ZlNrNm5VWFh2Ymk5V2l2S2txZ2xWTFg5Ulh2VDd4ZzRVYWh2dmYzTlZ0MTltdzhVWERaRmRHWGdtaDZsaGp3K0xieU1kRC9BTk9jYjNQYS93QVZJZ1dhVkJoY1QvRHhVQk9sdVE0N0VmRlFNOXlobzhTbUl3ekZHUjc2UWJYSHpWaGx1WlJaamhrZ3hGek5HMWxaVDZsUCtvcXhkcFVaY0l1TW1wR2Y2bDZid25WWUM0aGZ5MmFwNmZ6SzczdHhxOXhYTHN4eXZGWlRtSndXTVFwT3B1cEEyY2U0K0s3dm1lQWFRZ3VMVEx0ZGZTSlY5NnorYzVMaDg4d1l3MktPb2plQ2RUNmtQOTAxYjArb2NlSkhPZVQ4VXNpZVhHdVRrdUoxUlQ0T05sdTBxR1VFYld0c2Y4cWFBQWR0dHh1My9wVS9xRExjVGxlSkdGeGNlbWFFNlZOcjZrUHNmYW9JMUNZV2E0R3dyWVh1Vm80S1VaUWJqTHNOVXV2UFBZMDRndnFCMGkzdUtTRll2ZSsxTDBxTnpxQTdtMjFPUXhoaUl5UzZSdXU1L1ljMGxXVjlSQTB4S0Myb25iYjNxZGx1Rmx4RXZsb2xueElPaG40VlJ1VGFxdkV5L3dETE1OZnBkdElIWTI3MUZKRmlQNGptSUxUNGlPRkFWakNDUjJ2WWtuZ0N1cmVDdVc0bUdWczB3eWxNWEtURENWRzZ4amRqKzU5UDcxeW5CNFY4d3pMQ1J4YlNUa1F4MzQyNzE2eDhNZWc1WFhENGZERXdSaE5JdU4yVUN3L3JjL3RWUE5LbFJmMDhlYmZSMDNvZk9zczZjYTJaSkRGaUhPc1JZVWd4d3Q3YWV4KzFkQ2w4V3VuTXQvakhNNHNEaVFWS0tSdE1CeXArVHhlc1prWDRmY0wrWFo1OHhrL05NQ2ZNN2dtb09ZL2hweE9LbE1rV2JxU0ZJU1BUeWZrMVNqdlQ0TkdheHo3WjFtTHg0eVhFNEZKTUZnOFhpc1hJcFpFQXNtcnRkdmFwZlRHRXpEUHMyVFA4MmFPYkc2YlllRlQvQUFjT24rRDNQdWZrMTV5eXp3eDY4OE5jVGlJcEViTWN0bU9yVEdTM2xIL0Q3VnZNZzZwelBCSXlQaGNSR3FpNVEzdlU3eVMzTGNRckRHS2V4OG5vbk1NSWtrRFR5VExoblZUL0FCNzcyOXE4bCtKL1gwdlYyYTRIb1BvckdUWWJBeFR0aDh6elpiM2xZL1hHcmQvay9OZFhrejdGWjVrc3JZTEJ6eVlsMTBRL21YMHhxNTRZL0FyTytHbmhlK1Q0N05NeXhBaWVWTlVTeHI5T28vVkl2dVR2VW1TZStsRVpqeDdQYyt6U1pmMDlqUENYTDhEbk9TNGFURlpURGgxaHhXV1ljRml5TCtvTC9mM3Y4MTBYcGJybnB6cXpwMXMyeTdOc1BOaHhHWG1TV1ZWbGhiY2xaRllpekR1S2c1VGpzVThVZUdpVmxhTDZtUERDbU0yOE9lak16bk9OeGZUbVh5WXdBdTh2bGFXZGp5VGJuanZWakc5aFV5MUo4bWw2V3pmRGRROVBZUE1jS3BHSGxCMEVpMXhlMTZzZE41U093WGlvMkd4VU1PQ3cwVWJ4eFJvZ1ZVWFlLQU5nS2tZZVdQRU5LMGNpc0I2VHVEVjVUVTFWbWU0eWpLMGpJOVY1U2hMekFEV0d2YjNGcThoZU5XWFM0YnEvTVluMUhCNXJsWmtqdVBTSkkyOVNqNXRZMTdselBCcmlvR1VqNVVrYmsxNW8vRUYwVGpjdzZhbG53RWZuWXZMTVFjU2NPQjZwWVNwRXFMOGtiL3RXUG14N1pXYStteXByazhMOVBaM05Gb2lhUncwYk5jamU2SGtIL09yN0s4N2ZKOGRGaVljUTZHT1VMSk9oMzBIdiszSnJKem91RHpWcDhQNnNNMGphQ3A1SGJiN1ZQa3hBRGtycFVhZE4vdnNhbHE0a0RselIyUERkYll6TXNQbU9YNG5HUi9uTk40WjBZL3hMRzRKKzRybHZXa01XYTRUKzBvWTJHS1VtUEVvVHNDZjFENzcwMWwrTWtHQ3c4aXFCSmhQU3hHNWNjNzFJbXhReFdZWXVWQ0pNTmlJbVJVR3dKWUMzOHFJeDJ1eHM1dVNvc09qbzBUS0VaVjFDU05SemM3YzMvZXRDa1JEbFRJUFFCY0FYTzlZN3B6cVhLOGdoand1TmFVTEdxMzhxUFUzZTlXOGZpZmtDU0lJTXB6VEZ0YzNNZ1dQVUsyTWM0N1RHeVFrMnpSTGhoSEtiTnFjblZvNCsxT1I0VjVWU1AveENUWkR2dldKSGl6bnVGeklQUDA5aGpsV0trOG5Dd1NzRmtqYy9UZHh1VDhHcldYTmZFUHFHSEc1VmdlbFZnbHhDR0R6c0pncFpKQUR5VllpMTZrM3BGZjBaTjhseGpNdWtpZFd1R3NTcEtIVVAySTVvUVpKaThSdERoSm5DbmhVSTIvZWw5SCtDdmk1bVhUMlJ3OUc1ZG1VY1RSU3JqNG5nMHRocDFsS0ZXTEM0dUFEKzlhUC9BUFE3OFljeXV1ZlovQms4VWkzL0FQcVdiTEdEKzF4VWJtbjBTckNVc1hUbU1oa2tMTEhobFFBczBrcW9CL09qWjhpeXdLY1QxQmxNQnVXWlB6S3lOZjI5Ti81VlpuOEdXUjVOYi9panhkNll3RUlIOFhUaWhLUjMvdldwY1hnaDRLNUVrc21KNjJ4L1Zxb3BaWWNod2Fvc2hIQUVtNEgzb2xsVVk4c254NldXUjFGV1Erbk0rNmE2dDZveXpJc3N6dUxIWS9FVGdlWEJBd1ZRQVR2OFY3TjhIcDhiaitrTUppR1pvNHNCTkpGNVoyTDcydlhsUG83cjNJK2laTUJsR1RkSllESitsOFJpeEZQbXVMSG01aUZhOWkwdmIxV0ZodHZYb0xCK09IVC9BSVlkSTRYS3N5OHlYSFNUUDVVTUtYQnVkdFRkdmVzckxxRktkbTlqME9UQkhaSmNzMzNpajRoUjVQbHNlWFJ5QmN3ekJ2eThLQTl6enQ5cXhuVzNoam1tWitHbUt3SFMySml5L05vb3hMRExORDVpU092cTBuYllIajk2d3ZWdlJ1ZWRiNXZsdldlVTRzWXZINVlDNXk1dUpRZHpvL3hXcm8vaFg0NjRITnNOTmdzWEJMaEpJWE1XSWdsVWg0bTdoaDdWQ3NqbE5iK2llV0Z3eDFCYy9KNVZ3WGh4K0pIcXZEdW45bDRqQ3dPUXBYRFJ4d0l3dnV3Si93QTZ3M2lCNEw5V2VIM1YyVTREck9mODNtZVlZWnNWRVlwdGVsQTJrNnJjRUd2WS93Q0xySnVwY1Q0VHAxSjBKbldZeFluQnlxOG1HeXVZajh4Q3hzd0FIY2Y2MXdqd0o2STZveCtaWW5IZGM0TEV5WW1mRHArU2JIU0dTVkl6Y3NHdngycTVtMjdlT3pPMDhaT2RNdzQ4SWNSbVVYbTRhV1JmVFlxQnQvS3FxZndyNmc2ZW5YSDRVZ1RSa2FHVmJnL2NWN0xnNlJnalFMSEZwc0xYQXRTSitsa1dNalNDcGJjRWNWbTgvSnIzRlBobkwvQzd4cm53dUp3K1c1eGh6bHVhUkFCa095U2orOFBuNHIxVDBuMXpoczN3Nmd5QXNSL2VCcnp6MVI0YVlITTRaWlBLSG5LUFJOK3Bma1ZXOUpkVzRqcERPRndHYVF5SXBiK0hpSXZwWk8xNmRpelBGSVhMaWhuai9KN0ppbFdaQXk4R2xDNDcxamVqK3JzdnpMQm9Zc2RISUc0Qk5iRFdIVUZUY0h1RFhTWXNpeUpVY3Rsd3l4U3BpdmZmbm41ckllSlBoVDB6NHM1UCtRNmp3SDVoRXVZY1RFNWpuZ2EzMUk0M0ZhK2hVN1JIWjg5dkdIOEMvV0hScXpaaDBSTXZWK1dLeGI4bk91akdSam5uY1A4QWV1STVWNE45WjV4RVpIbnl6TFhXUXE4Yzg5M2hZY3E2S0xxZmcxOWVBeFd4QnNSdVBpdU4rTVg0ZjhMMTFQaU0reUJvOHE2bktBVEVpMEdPQTRFZ0g2djhWVjNoUW05cm8rZlVmZ1Jtc2s2L25PcmNFbUh2ZVk0ZU5wSHQ4QTgxZFlUd055QVFQSGk4K3pqSEVHNFdGUkN2OGlUWFJzVkZQaGNmaWNCbUdWejVWbW1GSlhFNFBFQ3pSSHRhL0tuc3cyTk1uQ3hDVnA1aUlvb2sxdnZ5RjNKcDNwUksvcnl1aWw2THlmSWVpSSt0c295dURGTW1aWk5GZzhYSFBpQyt0bWwxQzV0WWVrY1ZVWmQwSjBsbFVEUXg5T3hUQXRxTFBKcU43RGE1KzFXM1MwalpubHVNemJFM1RFWnZQK2FlRXBwMFFDNndELzhBaHViMVlIQmtrNkVmVDIzcEl3dERaWkpJOGZYM0xEK2xFUmNld3BRdUJyMjMvU3RFTjl1TGU5WnBxQVUrZzZhQ3I3NzBRRnlTTnFXZUIvblFBa2JnMGRoMm9mVXVramJuYWpHMWd0ajk2QURHNFAycGFLUUJZYldvcjdiR3g5Nmw1YmwrSnpQRzRmQzRTQjhUamNRNGlndzhTNm1sY25ZQVVBUytudW5jdzZzei9CWkxrK0VreDJiWTZSWW9NTEdMbCtiMzlnT1NUN1Y5Uy93dy9od3kzd0o2VVZYVk1WMVJqMFJzd3gxZ2JIbnlrOWtGN2ZOWjc4Sm40WDhMNEo1S3VjNXNpNHZyWE1VSG56a1hHRWpPL2tvZXg1REh2WHBKRVZObHRiaW5ZNHZJd2xMWXFEUlZWYkFBRDJwVjcwS0Zhc1ZTcEZSdXdVbHRxVlRNOC9sSlRNazFBZEdGOGpPTnhYa1FzZFZqYXVZZGZkWFI1RGw4azByaFRwSjFFMkNqdVNmYXRCMUxuWXc4RWhMY0N3TnIzcndYK0xyeGxiTk1iTjBmbGVKTHM2aDh3bmlhd2pGOW9oOG0yOVllU2J5enBHaW9iRmJPUitPZml6aVBGZnF4NUZsZGNqd1RFWVZDTjVXdll5SDRKR3dyblk5S2duZS9Cb3RZMHFOdlNMRHR0UmtCeHVQM0JxZEpRVklnaytRZ0xjbm1qTzJ3QXRRMkJVYi9BTDBEYTUxY1U3c1lFeWxMRmJ0Zm1qQjR1Q2FXdHRQY0NnQ05KdHpTaUJGUmNXb3hINnh2UWNhZ0J4Zm1qRmx1MzkzY0U4QWY3VW92OEIyVldKYml0UjBOME5pdXNzUnIxTmg4cFJyVFlnN0Z2OEsvNzFMNkc4UDVPcHZMeHVaTStGeWpZcXErbVRFL0MreS9OZGt3c01PQXc4V0h3OFM0ZUNQNllVOUtpcUdmVXFFYWgyZFo0bnhFOVJKWk1xcEM4dXdXRndPV3g0RENSL2w4TkF0bGhHMy9BSmllNU5KTWlZZEZaOXdDZWYxZkZQUEdVWXNUY0MzQjRxcXpOM2YrR3RodmRML3BIdldIRzV5dG5vRlJ3WTlzVndpRDBlbjUvcXJOTVJLV21mRFJMR29ZMjA2amZtdG9pM1U2UlpoeDNGWXJ3M21YR3k1L2lMRjlXTFZGdDdhYlZzbFlSb1JjM0JQcHYycCtUaDBOMEx2RnUreUpJOTVOT25VRk4rKzFUblhYY203YXZmMitLcTNrOHQxSWJVTlZyQ3JtR1FqRGtFWFJkdzN2VVJlaExzcnN4d1lsZ0lWU1Y0SHZXS3gwY21BeFNQQ3NnSU55QnhmNXJvN1IrYXBYU0xnYWhZODFucyt5dHRHdU5aRTFia1g3KzFUUWUzc3A2ekU5dTVkamVYWjh1YVlaWTVYWmdEYXcySWIzRkl6ZkFtQmdXOWNiY3VwdUQ4bjVySUdSOHB4TXJJSDhzSFZwUHQzcmE1SG04T0t3SXNBWVdGemJmYW56alhLS1dMTDZrZGt1RE81NWxlSDZpd1p3MDQ4dWVQOEE2VTY5ajJCcm1lWlpYaWNueHI0VEZ4R09aZUxuWmg3ZzEydk5NaC9MQU5IZDFJMUx2ZXMxbk9VUjU5Z1JCS3lwaUkvL0FNSFlqMWZhOVg5UHFOdnRaem5sUEY3MDhrRlRPWlJBYWdiM0hhKzFPK1dRL3IyQTdYcDZmQ3k0VEVQaDVsTWMwWnN5bmcvYW1tR283MnY3MXJwcVN0SEJTaTRKeGwyT3BpMnd6bWRHY1RpTXJHTzI0dHQrMVVra2ZyU0ErbFNvTEE4Z2R6VmxtTGlLT0VSTGVUdXhGeXYvQUcxWFdBaWtaZlZyQUZ5Ym5uY1UxOEVrWDdVZEw4QWVpUjE3MTNpSlpWRW1DeWZER1hRcHNDNXVFL3JYdEhwYkoyeXQweGJqeVRKR0FFTyttMjI5Y2IvQlgwc0lPa01ibUpUVlBtV0wwNmlQMHhqaitkZWl2RWZJc1kvUkdOaXk0c21MZVA4QWh1RS9WV2JQbVRaclFkSkpFbi81Z1pIazh6dzR2TUlvbVFYa1ZuQUNlMm9tb0dCL0ZsNFdSNGw4SkwxQkJESWhzV0lKRzNlNEZxOHNkRC9oNTZpOFN1cEpJdXJzMlpzdlNaVFBBamtTU2krNmo0dDcwLzhBaVZ3MlFaSDF0aGVnY215bURwdm9uS280bnhrbUN3aXk0dVF5RDF6RzV1NVVEWVhBdWFteHh0WFpGbmJ4eXBJOTlaTm5PU2RZNUttT3lyRzRiTThITXQxbmhZTUI5N2NmdldZem5Jc0xoM3VzQ012WWdmMXJ4YjRTU3BMNGxybUhoQWN3eU9QRDVTMktseWpNeVRGajFoLzZoSXVRcGtHNCtUYXZhdlRlY1lmcTdwdkxzNGdSNHNQaklSSXNjZzNqUERLZnNSVGNrTGZRN0h1UzNCNWRnME1hSW9VS0R1RUZxdm9jQ2tFUldOU2dKTGIrOVFza2dDNHdxaHV2ejcxcVJndFVZTEcyMVB4d3RkRU9UTTRzekNZWkF6Nm5jVzMyTlpUcXJOY2RnNFhHRkxhcE5oZjRyZDQ1Vnc0WU52ZjJxbndtQkdZek5KTVFrTzRzYXJ6dm9saTFhYk9MZFRkWDlYUlJScGxxdG9BQm1abHZ0ZnRlbXNoOFZPcDhOalpJV3lpUjhJdGlzdWtoaWU5ZWdtd2VWWUtGWHhLUkxFZzNMa0xjZTlXdUVreW5FUW9ZSHdzcXY5T2xsYmFseFlwUDl4WWxueHhWT0p6UEsvRlRId3dSeVl2QnpJOTdYMDMvQUoxUHpITThIMUtqdEhhUEVPbTZrOHNPSzNtS3lQQTRseUh3NkZqL0FIUldPNnA2RHc4eEdKd3p2aHA0MjFLOFp0Zi9BSHFYSkdhWFBKVmhQRk9YQ28rZS9qdjRjbnBEcmpIZmtJLytUeG8vTlF4Z2Y5SXNmV24yQnJsc1VnMW4xV1JUWW94Ny9CcjJYK0luSlo0c1RsdVliTTBMWDFNdXozMklhdk1QVlBUY1NZcWZNY0FxbkNnSzAwS0QxUk94dHNQYmVtWTU4YldTWklmdVJRUVlqRVpaaGNGaTRVc2p5dDVyQmRtVS93QkxVdWVYVEl5MnNwY2lNallyWTgvMXE2empKc1ZrbVJZZDhKaTBPRmhDeUVBbG9wRlAxTHVPZmlzdTJKYkdZbVVhZ3BsYldBT0I4ZnlxVXJOVWRkNk14dmhmaHNpamc2azZaemZPT280MzFyaXNOaVJGRE9vTndscmp0eWEydi96ajhNc2ppV2ZwendreXFXYzIzemJGdmNIdnNHdHpYR2VsTW9HZTVqZ1luTTJJRHRhUVljMmRFSDFiKzl1SzZIMDMrSHpLZXI4d2VBWXpFNCtDVmpMQXdmeWxraUd4UnlQcGtIY2Z2M3E5aWsycVJSeUpLMnk1eC9qN2crcTh6eVRJOC95UHBicHpwdWZHcTh6NWRndk14ZUYwcVdqZFpEdVBVTno3Vm1jNy9HLzRqNDFUSkYxeEZsUUxNb2l5akw0MHNBZHZxQjVGYlNQd3E2UjZhekxINXhsMlJOQVE1d2VHZkZ5dktia2FUWlNiZGp2VWpKK244Z3laMGZMK25zcXcwaWJhbzhLck5mM3UzYzJxd295a1VwWm9STWIxbjRpZFhabCtHend1enFMTzgybnpmTXM5enM0M0VZT1psbXhDalFWMWhMYkM1cmowbVg5YzlYdi9BQjhvejNOa1QxSzJNa2xZSjlpeEFyMDVoT3BTc3MyQ1hFeHdZYkpZekpJMEtBQlo1M0paVlVEblNCeFViRlkvRjUxTnF4ZUp4TVdYVzFlUVhKWnZrLzdWV3o1WVlJM2ZKdGVQMEdmWFpLVWFqOW5FZWh2Q1NURUZjWjFKRzJsV0JYTFkyNzlpNUhJK0JYVnpoY0hnTU95c2l4eGxmUkZHQVAycC9NYzh3K1dZZG84RkFzSmF4Vmp2Y2ZQc2F6QlhFWnhOcVppV1pqdVQvbFhPWmM4c25aNnBwUEg0ZEZDb0syUU91blRPY25rd3lyNVVUcFlqZzN2ZlVMZDZwdWwvRXM5VjRURGRPZFNZank4VkJKb2p4VXRnWnJiTGM5bXJVNHpML3dBcEd3aytsUmF4M0pya2ZVK1E0WjgzbGk4cGlqalY2QnVENzFQaGFuR21ZZmxzYzhjMW1pZXN2Qy9QczQ4UDhmQmdNOHhzMGVWenk2TU5OSXQxVDRidis5ZGY4UStsQzJGWHEvSlpJWU16d3dWcFpWQTh2RlJIWWh4N2dYM3J3amxYam4xUmhlbTB5dk9VZ3p2Q1F4YUVubkZwVlh0Yzk3ZTlkTnlMcTd4ZDZiNktrd1gvQUE5aXM4eWZNTUlCRmlVa0VvOHByRUVXTzVxeDZVbXFveFhxY1NxWFRmWjZreXJ4QVROK241OEdxTGhXbDBoNGtQcFB1UjdmYXA2WVZCbkN4S3B1dUhVM1BjWHJ5MzBsNHV3Wkl1Q2h6M0xzd3ltVldCdGpJR2oxQWZQdlhkY0Y0cjlQNXBpc1BQRG1VTWdraXNoVnQ3ZXpVNUpwKzVGV1UwNWJvblRreW1WMURYOUIyS2lrejVNeGlLaEcwL05GbHZWY0dLZ1R5NVYwRmJnMzJJcXgvdHdOSHNWSTdIM3F4N1pGT1N5SjNSbWNWa2hDbEdVa0dzZDFsMGIrWXdqVHFnZDRsM1h1VjlxNnJpWlljU2JoaHhjMVRaZ2hpVG04TGMxV3pZazBPeFpaUm5aeG5wSFBzZGtlT1VZREVSSWpBQVlURUFXNTRCN0d2US9TbmlIRmpJQmg4Wmc1Y0pNTGJzYnIreDcxeERyYm9oY1FqNC9LaXNjMTd5Uk1iQ1Q3ZXhySDlQOEFpcml1bGNXdUd6YkQ0eU9HTTZkY3E2bEh6ZnZVT0hOTEE2TkxOamhxWTJ1ejJ0RE9zOFlkUHBQRk9MdlhFdWxQRzdMYzJsaVE1akVtSDA4dTF0L3RYVWVudXBjTDFKRTArRG0xNGRUcDFuOVI3MnJieGE2TTZUT2R6YVNlTnRsNGVhRi85cUlFTXBLN2p0UTVyU1h1NVJuVWNxL0VINFhKMXowckptdUFqQzlTWlVobXc3b0xOUEdQcmhiM0JGN2V4cnlObXNaekhwM0Z0Rkg1Wmx3amxRT1VHazNINzdnMTlFWVcwRld0Y0MyM3VLOFMrSS9TUjZCOFNzMTZlYTc0TEhNY3h5N1NwSmtoY25WR0I3cTJxOU5icnNpbGozTzBRZkU4WUIrcE9rc3h5MVZqd09kZEo0T2VORUZsMVFnSVFCd08vRlpaMWxacnFqMlBzYTZPL1J2VUhXZmhoNGJMZ01vancrWTlQSEc1ZkxEajVERkkrR0xmd210YnZ1YmRxck1mNFNlSU9IbjBMMDZIR2tFTkJqRktuN2JVMkdTRlZZeWVHZDJmUDlVQ2pZN1VkN2dqMnBRUG1EWWYwb0ViY0FEdldVYWdsZU54ZWdSYTY3N2RxVVBwSTV2dlE1QVB2dlFBbFZMS0xqVGJpbkFwNUEzbzFCWUhuYlkzN1VkZ29ZczFrQTNKTnJmTkFxNUJkRlVPYityWVdGOS90My85YStoLzRNUHdzcjBEZ2NOMXoxUmhCSjFOaW83NWZnNVJxL0lSRWZVZjhaQi9hc0YrQzM4TFNabWNINGhkWFlRTmhZenF5aktaMDJrYi93REh5QThqKzZQbTllOThNbWxGZHRtdFkvOEF2LzN4U0pidUJ6OXFzWEZFSWdPYmordFBxTENpRzIxS3JVd3dVWWxTVHNGQzlDa2tpeHFlK0NLN0NjMkJKNHFnem5NbGpVamJibTFXV094UGxSblR6ODF6THJYUDB3R0Vua2VRUnh4Z3lTdXhzQW81dWF4TlRrY25Sb1lZS3VUakg0bFBHV1B3L3dDbHBwb1pUK2VuL2hZQ0pUdThuOTc5Z2IxOCtKcFpjUlBMaWNWSTAySnhETkpOSXgzTEUzSk5iWHhrOFRjUjRzOWNUWnJJeC9JWVlIRDRDTWJLSWdmckkvdk5mK2dyQzdvekRnYmZOSmpnb3BNZk9kOEI3RWJDNDk2QnN0eU9iME5pTFhKTkJ6Nk5JTzRxVmxlZzdnaStvZy9lakRCdlNGM1A2dmFpSkdrQTgwTGxmU0R4elFJSGNqampndDNwUXN1NEFQelJNd3Q5UDcwa010N0VXSEphL0ZISHlLbGJvV1dzaGNrTDMxZTFibm9mb0k0OVlzMnpxSmhseWVxTERFV09KLzdoMlhpaTZFNkkvT2lQT2MwaFA1RkNQeStHZmJ6bS92RWYzUno4MTBzekdhY2FScUwyQUFHd0E3VzlxenRSbmE0aWRiNHJ4bStXL01pZkJNY1NFSlZRaUFCWWh3Z0hBSHdLbXJFSTVHVSt0SEJOdmFtOE12a0s1SUMyNVMxcjA2N1dPb2orRy9idmY0ckRidDJ6MFhCQ01JY0RUcUVaaU55VFlqNDk2cDhhZGJ6dVFDcUtTRzRxYmpaZ3pNRkpVMjAyWC9lcVROSkJnTXB4VXNucUdoZ3ZxM0czZXJPSmJwRkxWVHFEUS80VEF4ZEw0bDVFVlh4R0tMN2pld0E3MXNKSkNqTnMxaHRjRDNyTCtHVWFEb2JBRGNFdEl6MjMzTnEwWmQxaEtzemVXRHlPYVprNWt5eG8rTUVTRklJM2laU3Baa053cEZXMkRuS3hMWmQyMkl0Y1ZUNG1ZdnJjZ2duWWFkcXM4bWtLd2s3N3JzdHJpb1NlRXZkUkllTVhGN29RZHlPRFRFbUhKQjFLU0dOd3g3VktjZWFCZTRjYzBBakZSWWtvUGZtOU5zdE9PNWNtRjZqeTRrdk1GOHRnMWxZYjNIZXNYbDJaelpQaVdJVzFnTGIrbHQvYXV1WXpMNDJ3N1JsV2xEMzVOaVBpdWJkU1pRbURZbFFRU2RpYTBzRWxKVXprdkk0TW1PWHE0L2czL1RXZlE0cUVKTG9uMURkV0czL3NVZWVkTkVqODVnNVJORVJxSzhGZnRYSnNxeDJJeTU0dEVqSWJrWGpOais0TmRUNmE2dFRGeHFraDFNaTJ0YTEvdlRjdVBieWlYUzZ0YWlHeWI5eGplcGNvaXpXTXVnQzQ5RUpWbUc1ckxaRjBQMWQxVXN4eWpMSjh5amdiVE1jTEZjUkh0cVBiN211MVo3MHYvYWNQNXZMMDhxWURWNWQ5ais5Y214Mkx6REpzUmpqZ3NaaThyeGJqUk5GQklZeExialVBZDZ2NmJPcW81enpQajlpOVJJUjFMNE45WjlNNVJoOGRubUJPWFlYRVloVVI1WjQ3a2tjV0J2d09heHJRYUpzVkd3OVlaVVdOVDJKM1AycCtiSFpybUFaNTNueFVDK2tNekZsRGZZbWhrdUJseE9ZUllkYnJJYnlPV0dxd1hrMjVxOWsvRTVISEJwcEgwRi9DeDB4RmwzUU9VeHhnYVA4QXFiRzVMRWVwdnRYbzQ1Y2NUZ21oVFpXWFRxYm11TmZoNVNMRDlENU1CcWIvQUpkZHo3MTNuQ0FOQ3BBM0ZWOEdQMUc0bG5VVGNLbzUrL1MwR1RUc1h3cXRHVGNzRnMzM3JJK0ozZ04wSDR1VDRQSFpvMkx5ck44T25sZm5jdUlFakliYk9DTE54M3J1VFFwSnM2aHI4NnFaR1c0VFVTSVZ2OXF0eDBrb3Yya1ArVnUvSTVmNFErQnZTWGhVbU9teVNURzQvTU1iRjVVbVlaZ1E4aXg5a1FBQUtQdFd6eURwV0RwTHArVEw0cGZPZ016elJxUmJScU55UDUzclJyR2thNlZRS1BnVkd4SUR0WThXcWJKajJxbVJ4eXliNDZLaktjQm94QmEyeFBGYUJnQ28rS2J3K0hWRnVPYWM3VkxoeGJZTmtXV1crUlRZN0F0Tk0ra1hMZHE1MzRzZFQ1bjBYZ3NOZ3Ntd1VlUDZnekVsTUhoamNvQ09YZTNDaTlkY1Flc0dvMk95N0RZd2lTYkNKTktGMGhyYjIrOVZaYVp5NUxHTE9vdW1mUHY4VHZTT2RkTC9BUEMwUFZuVytOeFhVZlVBbG5ueEt1MGVCeXVGQ28wcEd0NzNMN24vQUExaCtuc1BoczA4VE9uOG82SzhSTTB3MkdLUTRhT2ZFU3lTeFM0OW1LMkNrQ3lGdDdIdFh1RHh4OENNbDhiTUZsME9ZWTdGNUhtZVdhL3ltT3dxQi9USUFIUjFQSzdEYXNiNFUvZzF5dnc1NnN3dWZZL3FNNThjdS9pWUhDeDRSTU9nbTdTTnpxdDJHMVFlbnNseVRPVGx6Wm1QRDc4VE9kZEc5Ulkvby94Q1ZjSDFObDh2NWZ5VlErWGpBYkFQRTNaamNIU2RyWHRYb3VMUG9jK3k1WklpQUhGMUE1RmN3OFhmQUxCK0srTkVtWTRObzUyY1NETWNJMXAwY2JMdWUxdWEyUGhUNFc0am9iSXhnc1pqcE1hWTFJUm1PMXI3YzFUbnVjdUVXdG1OUXY1TUYrSURwZWJOdWtwRWpJOHlNYXhiZy9ldkpQaVZnNDhuZks4eWpJakdZUUtqb3V3REtiRzlmUWpyL0tGeEdWYUN2MUlWSUF2ZXZCZmpSaGhMMHN1RmU2UzRiRXpScVF1OWp4L1cxTVN1ZEV1NVN4Y0dWekxMQ2NoMXh6bHNLVzB6eGhiTkN6YmduM0Izckg5QzVIL2F1YVl5dy9ONFRLNEpNWE1rajZKUEtCc1NvN2xlZFB4V282ZDZ5anhlVzRiR1F3UnlZckN4TERqOEhPTHh6SmExM1huVDdFY0d1bi9oMTZPNmF4WFU4MllTcW93V01hVk1XODhvOHZEUXN0bGpELzNtSk81N0NyZU9MYjJzejV1b3RsZGsvUitUOVA0dkIvbWMyWm81MWplVEY0WTZFZUpyZVZpNDI3Z1hLT3ZZamV2UVhUbVJZakkrcUlXT01qOUdHUXlSd1Jxa1dZSy8wVGtEaHd2b0pIT21zRDR1K0FqK0gzVGtuNURWaXVpUTBrcVRzZk5ueVNkdHhKRUVIcWhZZldtK3h2dFZQNERkYTR5RE1zcnlUcXdITDQraFljUytPekR6Zk9HUGpuOWVIaWpBdmNoV1d3M3NBYjFiVFdMaVJWVUpaK0lLMmVpT3BlZ1ArSU1tdzRMeWVYaFFzbmt4b0JyN0d3N2MxeVhxK1RMY2l4allmRHFqWXFJMkdIdzFpRkhGNUdHd1AycXg2OThjYzc2dmpmQzRLSTlNNUFMS0dRM3hlSVgyTEQ2Vi93QUlGY3l4bWNZVEFZWjhMQUJKK3VRajlYNzFUeitRcjI0anJmR2ZwdmRXWFU4ZndQTEJEbEVzbUowUmVZNythNkx5U1J5ZmVxVE1zNGFVUHBLK3MvU0R1S3FjeXpac2ZDV1VrQWpiVHlONlp3R0hhUm9neHZjV0pmZ0dzSEpLVTN1a2Q3aFVOUEgwOFVlQ1Zoc09jYk42aGFJN05jN1ZjdkQvQUdaQUZkdEROc3JMd0I5Nms0T0NURFFxdmwyWmpZZzJzUjcwbkhvMDZ1Q05UUm4wcUJ0VVZtZ29YR3pNNXZpbzBqS2xOYUhabXZ1My9zMWlNdnk3KzArdUJHak1xNFhEdlBpTHQ2U280RmJuTnNLNkZwajZTbzl0cXJPZzhzLytuWnptVXlobXhrdjVaSk81WHVCN1ZjeFRVSTJ6bjliaGVmS3NkOEdHeXZwSEY0WEFSWStkV255ekV0cURzdHpoemZoL2o1cnVmZ2ZuMmJlSDJNWHBuTjNNM1RPT2Z6Y0RqZFIxWU9VN2hOdjBNYmZZbW5NZ3l1TERMUGhGaWFYRE1MRkp2b1ljV0lwekJSSmtjYllDWXMyVVNQcHc4MGxtL0xIKzRmOEFEZmc5cWxockhHU1pSeitCeFpjVGkrR2Q0a004b2VMRkJaMkg2SmxEcjkvVldNNmo4SE9qK3BUSkxpc2ppd0dMSkovTjVXZklsMzdtMnhxZDRkZFRObU1UWkhtTFd6R0ZmK1hrZi94NGh4djNZVnNHd3AyMURnNzJycDRlbm5pcEk4dDFPSE5vY3p4U2ROSElvdkNET09sMFp1bGVzc1N3QXVNSG15NnYyVjF0YTlXR0U2dDhRZW5ZeEhtMlNqTU1NZzFERTRDVVA5N2puM3JvazhCVmRsQkpOUlpGZUpiaTVQdFRIcG90OEF0Zk5jUGt5V0QvQUJJNVgrWVRENHZENHZMcGI3Q1dGbC9yYXE3cUg4VldRNFZoRmg0cHNhMm9vd1NON2Z1UUszRHZKSkhwWkZiZStwMUJQOWFSRTBtR2F5d1FBdnlWaFc1cUo2SnZ0a2tmSVYrMDQzaS94RDVmK2FaSk1KajB3NUlJYnlISy93Q1ZieklPcE1qNjNnRTBXSmlsaksvOUZ2cit4SE5hdGhPUW9rR3BEeUNvdjhEMnRWQm1uUStXNDJkc2NJSThxemZUWk1maFFFWlQ4cndSNzNxdExRdEp0T3l4aThtdDFOVVBQNFQ5TjQyMCtJd0tTU1B4R0RwVzN1YTB2UnN1UDZGelZZakpLK1hBQUJYUHBSZllWbU9rdXFwc0ZtYlpCbjBrQ1kxZlZCaTQyOU9JUWZxWGZZOFhGZGVHUlFkUzVFR1J2VW9zQU8rMVpucE5TNTROUDF0Njd0SFFja3pxSE1JRWtqYThiQzYxYm5tOWNtOFBzUmlzcXg3NVppd1ZBK2tudFhWb21KVUE3L05iMmp5dCsxbU5ueHFEOW80UG1zdDE5MHl1ZTVYSGk0Y09zMmFaZGVYRE1WWFhZOHFwN1hyVTBMYmk0cS9raTV4b3F3ZE04K1M1L21zcXl0NWNPQXZaVjh4aksyb214QjdDcnFIRjR2Q3hpTlhsYTNKQnNDZmludkU3S1Qwcm5JelhFNWxoc0owN2pwRlo0c1NWUVllUlJja0VrRWh0dU85YzhmeC84TzFtbWlrNm5nRHhPVU9tSjJCdDNCQTNyQWNKd2s3TmE0N1VmTSsralhjazcvcE5xSXNMa1gzb0t2cFN3MUQyb2hleEJVaHZZZTFXQ21FZGh2ZTlLRzY2amRWOS9hZ054emF4dHZTeFp0dnFCMitLQUREYTdBRzdmM3E5Qy9oSS9EVS9qSjFKSG4yZllhU0xvekszdTN0anBoLzRTbis3dnVmaTFjODhEUEJuTXZHL3JuRDVEZ1E4T1hSbFpjeXgxdjhBb3czM0FQOEFlUEFyNndkRmRHWmIwWDAxbCtRNVJobHdXVllDTVJSUW9MQTl5eCtTU1NmM3BqZndTUlh5eTh5M0w0OExGREZDaVF3eG9FampSUUZSQnNGQTdBVllCZU5xQ0lFUUQ5cWNVV0ZYY09QN0s4NVh3QUxwRkhRRzFDcnlYd1YyQzl1YVl4RTNsb1RjVTZ4RlZXYVlreHEya2dINXFwcU1tMVVUNG9XeWx6N00vS2hhN0FCUWR1OWVMdnhtK0t6NVBrVVBTZVh6dkhtZWEveE1WcGF4VEQ3M0h3V05xOU1kZTlWNFRJTXB6RE1NZE1Fd1dEaU0wMG5IcEF1UVB2c0srWUhYUFZXWitKSFZ1YWRTNDVaV2ZHU2t4Uk1EL0RpNFJSLzVheVlKeWRzdXllMVVqTGxBRklXNnFCc0xjVVp2cUJ0dFV6K3g1cnFHQkY5anFOQVpNNXVBVlZlOTJxM1pYZkJEMkxEYjVwTi9XNUhCNy9GV2NlWHhHTXU4eXFSc0xua1VvWVhDSWQzQ0QyUEJIdFFodkpXRkE0NUcvRis5TE1VakFzVjlJN1d0VnA1bVhJYnQvRUM4TXBzZjJvaG11QVZrS1lZRUtTU0RjMy9lZ0Vpc0VUc0FMTTIrM2Ezeld2Nko2S2p6UjB6RE13VGdVM2lnTzM1bHZuL0RUM1NtWHk5UkZzVWNPWU11aGJkOUF2STM5d2ZIdWEzNnhvR1VSa0xGR1BRZ0ZsVURzS3BaOG0zaEhTZU0wUHFQZmtYQ0g1cDdrQXJzTEJVdnNndHdQZ1ZZNUpBQ1pKeXF1Q3VuZi9TcWN5dmlBRUpYVmNFKzlxMUdDalREK1hHdW9nQzVKSEI5eFdWTjhIZTRGYlNYUklFUVpFWVd1RGNkN2p1S2p6emxEcFJScFh2NzA4a3ZsQWxtMXRxSkRjQUgzcXV4czRsbUJKS0t3MlVjNnFySldhZVQyb2lTVGk5aUMyOWhWSDFvNVRJWkZVV0RIMWp2YjJxNm1jck1vYmNscjNISUZacnJ1VUxnZ3lHNFpyRmJtcldIaVJpYXFUV0ptdDhQeHA2T3djZXdrc1R0M3ZWOUlGalFHUU1TdmROeWZ1S28rakZVZEs1ZGJVYkliNnRxdDNEeHRkSHRjWDFYdWJmTlF6ZnVacTZUakRHeUJNbG9ISHFOeVd1ZVJWbmtEbElsWWdseURkU2VCZXF6SFNyb2VUY2czQjl4ODAvMDdKZFdZc1NCc1IzdDJwdTFWWXNYN3pRdXdZa0FncU5oYm1oSEZjM1plUjlWK0tDTHNXakkzNEJvRlFUWnlWdDdWRlJwUmZBaDFaVUlLNnczQkkzdldhejNLbGRtV1FnWDNMcXQ2MW9LTkdDcE5odGM5cWlZaUlUSVVDK24zTk9VM0hvcjVzU25CcG5DYzF3TDRYRnU2dUxrMkZ0cWN5ek01Y05pTlNUTkU0RmlPZFZhM3EvSVIvRWtpUUhhNTM1KzFjOGR5cldJQzJOcmQvNTF0WTJza2FaNTNxc2M5TGwzUk93ZE45VFN0R0l5ek82MllnblpoN1hxNDZ2Nkl3WFcyVmViRTY0Yk1rdXlTci9RTjdpdVE1Sm5Sd21JSlVuU280TGMxMGpwbnFiODJDVnVqSjlSSHRWTnhlR1c0NkhUNXNlc3hlbGw3T0w1cmxlWTlNWXFURFl5RTRlWFVmU2VHSHg4Vkl5ckhITHM0VEc0YmNTd0ZXMnVRRHphdlFIVlBTV1ZlSUdUbUxFbGt4R3hpeGFEMXhOL3Q4VndYcUxwakdaSm1FT1Q0M1JEaVBYNVdLYTZ3dXZZMzdEM0ZhV1BOSE1xT084aDQ2ZWp5N29yZytnLzRmTVVyZEtaWkdHRzBLRzVPeFB4WG9UQkQrQVBWdjNGZVJ2dzE5UWwrak9uWkgwZnhNS3BESnVQYXZWZVI0dnpvTDN1eDVOVGFSN1ptWnFzZHh0RnhRdmZhMUZlOUhiMzJyZTc1Umgxd0UxcmIxV21ZVDRyUXB1QWQ3Vkl6T1ZvOE1WUUVzL3BGcXJja2g4bkVzcEpkdVNmYXN6TkwzcUpkeFE5bTVsMnE2Zmlnd3ZTallBZHhUY2o2ZHIxZm02aVZFMjVCcUxHbGptbWxsQk9tKzlPMDNDOXlZNlNwamJRcElQV2dKSGVpR0ZpMjlJL2xUdENoNDR2dEROMGw4aUNnQnNCdDlxU1ZOci9BQnhUdEprT3hJOXFaS0VWSG9mRnVVdVNnNmxUek11ZXhOd3R4YzE4N2Z4RHpERGRVWmpoZGVpTmxaOUk0QkoycjZEOVM0MWNQbDBqczFnRVBOZk9iOFEySi9POVpaaUZBT3BGQ2c4NmlkcXdWLzJHM0ZTamlPUTVjOG1Ed3NtWjRkakRJcmxIOUYxZmZkQ1BrVjZxL0R4NGJ0bm5RMkl6akJUeTlOeVRZMmQxelZFRXVEY0lBSGd4TVRIU3lYT3g1RzlxODY5QmRKWm4xbkhQQkYvQndrZUlReVl0eC9Dc0J1Vi92TlhvekJTVDVmMGxoT21Jc3duaXlEQ0Y1RndxdDVhenV4dTd5VytxNXRTdlVMR3pVMG5pYzJ0WFZJc000Nnl6N041aGswaTRiQlpQaEU4dVVaZE8wbUd4dy92aFgzUWNqVHVLejZES3NreS95TU5oWW9JWWpxTVNDMjl6ejcwV016bU5DN2VZbGdvRElpYVJjZTN4V1l4MlpDWXlXdmJzUnpXWlBQa3lObmRhYngrbTBNRlM1Uk96ZnFNemFSRmRVdHF1RGV4KzFaNmJNSlpwSDlBSXRjdU8xUk1YbWdheUlScTAyc1JjMUp5ckFUWWtpWnBDc1lIZllOVWJXMVdUU3pQTktrT1pibHhrWkdaR1ozdVNiOXZlMWE3TDh2WHkwK2tCZUNWdUwvYWp5bkJ3UVFhVmFNbnZiNmovQU9sV0tueVc0QStRZGpVVXBGekRpcFd3cFZFZWtOZTdEY0dtNU1HVXQ2dldkZ0FlQjgwNEFvVWtPRHFQcUI1RkM3R05pTFg5L3dEU283THJkS2lqNmlQazVmTjVnQzZVSkI1c2JiVWpvckwxajZLeTJLVWx5MHBkMHR6YzgxVmRZWXkrVjR0eUN5SDA2ZFc0L3dCeFdoNkt4a1dLNlN3TWpGZGFycEFYdGFwWGV3ejQ3ZjhBSUx0SlROaUpCWWxQcFhTYkJQOEFlamxFVHJKSEpHSlluWFN5TUxxUndRYWJ3YW55Z3BEYXp1VFVwWWdrVHlTUDVLcnk1TmdCOTZpNlZHaTZJZUdqeFdHUmNOSGlwbFdGdzJFa2pQOEFGd3hIWU4zV3V0OUorSmVDem5DSmhNMm13K0Z6V0poSEk2eWdSNGhod1ZIWmozWDM0cmxlR3drbVlxSllXYkJZSTNWOFFSYVNZZXlEc1BtbDRYcG5JOERFZnltVlllT2FJaDFlUzhqNndiaHJudmZ2VjdTNnFXR1MramwvSytKeCtRajE3bDhuYXNabkVNWUpXRnRTbXhWdTFWT002azhwR1dQQ2F0SnVMKzlWbVE1OS9iRUVjT0ljREhnWExIaVQvd0JhbVRRS2wyVmR3YnNwSEI5cTYzSGxXVlhFOGExV2tucE1yeHpWTXBNejZ4ekFveGloaGpiVllYVzlWT0w2cXpseXFwaUZqYis4cTFkNHZBK2MxNDRYdWZaYXJwY2h4RXVsbHcwcDIySkZpYWw1S1RpVldJemJOTWFvamZHU0ZoOVdnNlNhaDRtUEV6c2pTeXpPOXJXTW13KzlhSEQ5S1p1N255c0V5NnQ5Y2hGUG5vRE1wZ05UeFJ0M1ppUWFUa0VsZkp6ekc1Y3N5TnJjSmlJN21LVXNieG5zd1AzN1YyUHdMOFJzWE5HTUJta2lHZFRvWWxyRnZtM3pXYUhoamlXQUUrWUl1L1pia0NvWFVIUVdKNmF3NHp6S2NaTGpjZGhCcWx3dW5TWjQrOWlOOVFIRlVOUmhiOXlOZlM1MG5zZlI2WHhVYXpZcVBFSmEzdUsyMlZ6Zm1NRXJYMkE1cmpIaGIxdEIxZmtjRThMRndWR2tIYzM0SVB6U1BGajhUL1NuZ2RoR3dNbXJxTHFpVmJSWkxnWEdwZm1Wdi9ESDlhcmFlVGhPMldzMGJYQjJ6TU0wd1dTNWROajh5eFVPQXdNSTFTWWlkd2lJUGttdktYak4rUExMOHJXZkt2RHJCeDUzaXovRGZQTVdOR0dpUC84QWpTMTVDTFh2eFhsZnhXOGJ1cy9HbkgvbnVvODNJeXhDRERrK0NZeDRPSlNPdzIxTVBkaFZmNGYrSG5VWGlubk1HVjlLNVgrYW1EV2VXeFhEUXFSdTBqVzJJN0FjMW95elc2aVU0eEU5VDliOVJkYzVyUG1IVkdmNG5PY1NTSHZOTWZManYvZGpIcEErYlZTdDFqaGNDeGlYSFFvdklGLy9BRXIzVDRXL2dONlo2Y1hDWTNyUEd0MVBtQ0MvNU5FOHZCUkh2WmIzZjkrTFYxL05QdzkrRzJielJ5NHJvckpaWGpqV0pUK1VVV1VjRGExTldPVStSVzFIcytOWlhTbTRKdnlCUkd6V3NOL2FsQWwxdTVETWR0dHFDa042UVBVTnFyMExZdUdGcFpCR2lFYWh6eldtNmQ2RnpicWJOTXV5dkxNRkppTWZtTWdpZ1VEVW5OaXpXNFVjazFLNkQ2WGs2aXhZd2VIdzV4VTh1MFFVNlRxOWdQbXZvQitGejhQMy93QXM4cU9iNXdJOFQxUGprRE5iNmNIRittSlJ3Rzl6VVU1YmVFU1JYUEp1L0FQd1h5N3dWNkh3bVJZTkVseHIvd0FiSDQzVFpzUk1lZjJIQUZkY2d3M2xydGFrWVhEcXNha0MxdTFTbDJOUzRZTjhzU2M2NFFvQzlMcElOcVBWOFZwUTQ0S29kSlpoeFNXY1grYVJNNFZmbW1UeUtLRmpGc2F4TTRpSHphc2xuMlBzcmI4OXF0OHp4VmczcXRZVnp2ckhQY1BsR1ZabG1PTWN4WUxCUVBpWnBQOEFBcWttMzhxeGNzM09SZnh4VVVlVmZ4dWVLSndlWDVmMGZncGYrWXhsc1hqVlUvVEV2MHFmdWQ2OGwvMm03dllTazdYMzRIeFdpOFd1ckp1dWV2Y2QxREloQ1krR09TTlR5cUFBRC83Vms1TU15ekJOUUxFWGUzdlZpS3FKSEoyeFl4N090eXp0L3dCeDcwMzU4aEc3WHR4OFVrc0Z1ZXczdFNvb1djdTRRa0EydDgwcEhRMDI3SDFmY0dqVStaR1FRYjlyMFppYVB0Nk85dDdHanZ1ZGo2ZWFWVzNTRlZLN0VORlpBYkUvSGFyN28vcENYcTNOSGdadnkrQXc2NjhWaWJmU1A3aS80amVxbkQ0V1hNWjRjTmhrYVRFenVFaWpINmlhN1JsbVZwMDFrMkZ5dUlycUE4ekVPdTVsa1B2OXVQMnF0bnlLUFJzK1AwYjFMM1M2UktieTRVZ2h3MGZrWVNOUkhIRXAzVzN2OCs5SDVnQ0J5QmUyNDdHbUoxTU1TTzI5ckVGZjAwOUZFemtxd0JqVkwyVVhKTisxWms1TnZrN2JISGExR0pPeTNBbEhXUTMxTUw2bDMwMW9WdUl3UXhsUUR1TE1mbW9lQ1F4K1dTRkNqWTJQSXFiSXBld0Z5QWJhVDJIM3FwTjI2TjNERFlySTJKbHNwc0I1WkZ5RFZYTE12bUtXT3ZhNjM0RlNjYmlGaVpyajByZlNPZC9tcTE1ZzFnUFdlYjMycFl4R1pNbndQUmFtOVFBSjVMZTFaVHIwM2lpVFdENWpYQnQvNzNyWFJ0NVdwU05WOXlPd05ZN3E0cFBtbURnRG5SclhVTnRtSnFmRitSazZ4MUJJNkRra1pHVVllSmdvYU9GUFVOZ1QzcVk2Yjc3S0ZzZm1rWVo3UXhvNDlMZTR0c0tlTjBZcVQ2U05qVmVWT1J1WVZXTkZkbVNzMkhWZG1CVzNwN0dsZE1PcTQyUk5mcVlBMzd0YnRTY3dBaWppTEFvQ2JnanZVSHA2VURHc1NReWxqYnNWM3A2WHRLKzdibFNON0dib0FiaTdiWDdVSERLVzI0L3JTWXlkR2tHNXZ1dnhUbWkybTEySjdIdFZjMW92Z1NUNml4UEd4dlNTbWt5RUd4dHdhY0toZlViTXJjaTk5NmJlQjJCREVuM0lwb3RsWG1XWHBpWVZqYlVnYTVKK3c0RmNuNnZ5VTRaamlJa01hRVdaU09EWGEvUk5aV0lOaFk3VmxPcU1uWEZxN0tyUlhIY2JNYXVZY214bUg1SFRMTkMwdVRpb3NqS3hpQTdibm10RGsyYURDT29YVUpBZlNSeDlqVlZtbUZPRW5hSnJPeW50ZW1JWElkRjFNdHQrYTJKYlp4T0VVcGFmSWRpNmI2a2xqY1BMSVNoNzhEN1dyVjV0bG1VOWNaSkpnTXhRTkU0SVJ2MVJPZUdYNXJpV1Y0NWxLcDU1TnYwc2VEZXR6a1hVcytFUlZkVmV4c1NwM3QvZUZaMG9iSGNUcmRQcW9hbkY2ZWJrNmw0TFJUZEk0VEtzZ214U1lqRVlGV2ppbEFzSkVKSkF0NzE2dDZielYxU011V0F0OXE4ZTVSbUNacEVrMFRDSEZ4Mjh1VFZ1ckQvZXZSUGhEMWxoT3JvZjdPa2w4bk84T3Q1Y0s0dDV3RzJ0RDMrUlQ4T1czeVlua2ZHeWd0K0xtSjNMQTQxWmtIZmFwZDlSQUEzcWt5MC9sb2dHRjJIUHhWaEJpaEt6RWl5ZzgxdjRzMWNObkRaY2JUWlJkY2RYWVRwT0hEejQyVllZYmtzemZIWWZOYzM2ZjhjZW44MzZwT0J5L0dUeDRxYTdpREdZWjRRd0g5MG5ZMTBqckRwcVBxU0FKTkRIaUlWRzZ1QWJmTllTYm9aWEN3SFRHRU4xazBEVWx1TEcxNnpjNm42bTVQZzFjSHBlbWsrem9hOVd3YUYxcjhIUUw3MUt5dk9ZczZsYnlpb0NiRlFRVC9JVnlmOEE0UXpmTkhreXpFNDBmbDMzZWJEM1dSaC9wVkVmdzQ1VGxXS2JGOVBETjhtekltLzVxUEh5SFUxKzRKSVA4cVgxc3NtaFBRdzlYVFBRazZsWm96dHUxajgvYXBBNHJPZEU1UG0yVjVZQm5XTFhGNHcyRjBGaFlkejgxbytLMmRQZTNkOW1SbmlvU2NVN29GQ2lKdHpTZFYyOXFudGZKV3B0OEM3MnFQT3l4SStvMnNMbWxUWWhZeGMzTnZhdWUrSXZpUGxYU0VLL25wbWJFdnZGaElUcWxrUDI3RDVOWitwektLcE0wTkxwc3VhZTJFU2o4V09vMXkzS3BsRGpWcHVFN3Q4VjVEYnc5VHFYUFpzNHovVTRNL214WUlOc1JiWXZYUytxZXJNYjFaakdteklpRERYUGw0Uk9JL2d0M05aUEg1d1lZNWJ5cHBDMjlPNUI3YjF6YnpOeTlwNmJvdkR4eDQ3emRreVl3WlVxeHhpSER3UnJlS0NGZEtrZTFxb013enZ5V2Rnc1liKzdlNUE5cW9jdzZnMWdBdDZySGRtdWF6V2RaK2NQaFdkcE5GN0VOYTdWSEdEbTdaclMxV1BUeDJ4NkxQTU9wV3VRcXhOWTNaaHNCOFhyT1lyTVo1NVRZR1M1M0lPd3FubHhNbVpUSVVrRDRiOVFmay9OdTlhWEljbllsUVdETVFXdmJ0MnNPMVQ3RmpUTWQ1NTZxVlJKR1NaUTJKZVdTYUxUQ0RZWDJzZnY4MXRjQmhIQVh6RVRTT1ZUWWdVMWc4QkVpYXRmbWtIMUlCWVZkQ0NOSmQyWUpiZHZiNHFyT1ZtOXBzSHB4Vml6SEVGVlZpVkFmbmUvelNvbDBFRWpTMzZmWTBrTXFNQ2lHUUQzcHpDT1RpTHNOUVlXMzRXb096UytCWVU3TmNnZzhnYzAzalp4RkJKd1Nvc0IydjhBTlNKQU5CRjczT3dKc1RWUm1yQllsQjNkbXN0dUJTVU5mSmdldThRSThuQ2dIV1c5UkE3KzFTdWk4ZWtPQ1RDT29pSlM2c0RheHFGMTZvUGtZY3lYdStweGUxN2UxVitEeGtVV0pXeVNGeXZwSHNhdnFLZU01dkpuMmFwdG5aY0RpWUpJekw1NlJ4cWdKWmo5TlNjSTBtYWhNUmlJclFMdGg4S0J2OHUzMzlxNWwwbDFDTWZqOE5sMHc4ekNvR2R0UERlM3E3MTFEQXlhbFoxZGl0dFJOLzJxbktOY00zTUdXT1dOeExCcFRLaFI3aFZGbEhHbW1ncTZsSlByVWFianVLS01tVlN4VmhjZWtIWW1scGRsSnNvYjZidHNMMGlYQmI2NkZ6V2tWV2pmeUprT3FObDVWaDNGZFA2QzZ5dy9VdURiQVl5Q09MT29GRFdBOU9KUzMxTDhqYTljbW1ZeHNOVzdJTnRKMnBtT2VlREVRWTdDenlZZkV4a3NycWUvdDlxdmFiVVBCTlgwYzU1anhXUFg0WlV2Y2p2cnVrVmlGRnIzdUJ0VVF6dEtSWkFOdHdhd1RlSStNeG1FaW1FS05NNHMxckJiam1xdVhyVE1KNUN2bWdBODZCY3JYYVk0cWNWS0o0YnFGTFRaWGltdVVkSU9KY3Rld0FVOEU4MUZ4T1BCa041RVZSdXdZOFZ6QnM3ekNlZDc0dVQxQ3cydGI3VXhKaWNZK0tVdEszbHNDcEpQZjVGUDJGWjVFem8rSXpORmtLZWVMS0NTUXc0cXNicVBESklzbjVpRklkVmpOTElFSEhGeWYyL2VzUW1EeHVMeGcwckpLR0JOdGdGSHlld3JMWnI0UU40N2RhZFA0TEM1cEVuVCtUc3d6bkhZZVFsVUJZSHlvencwaEZ4dGUzZW84cmpDQkpnalBKTXFmRkh4c2Z3bnpYT09udWhzenc4a21ZSUpac1hoWEVveTdYdThhV3VDNUpKSHNEYXZQWDlvUlF2Tmk1NTNNcnRya2xrWXMwcjMyYTUzdWFrK0pQUmMzaG4xL3dCUjlPenh2R2NGaVdXSXlHK3FFN280UGNGYkVuM3J0LzRVZkJQSytxYzFnNmg2Z2dHTmErdkE0Q1QvQUtRVUgvcXVPL3dLeUh0aWJ5VXBNdFB3OWZoSXp2eGZrdytkZFZ3elpIMHpJTmY1RUtVeEdMSHVSc1VTdm9SMGIwVGtuUU9TNGZLc2l5NkhMc0hBdWxVaVd4TzFyazhrL2VwZVNZV0hMOEVrVVc5bHN6ZS8vcFZoVjNCalRWc3I1WjgwZ2FpZWFGQ2hWeE91aXNuUjhLYnNiTVNDT1J0YWx4cHJRRXNxRGMzK0Izb3dwTFhVWFk3bTFkai9BQXplQWVMOGErcjBmRnhQRDBwbHNnYk1NU1JZek55SVFlNUp0ZjJGWkVuVWJMOFk3anVuNEkvQkxHelFmOGVadkQ1T0JjRmNxZ2NlcVhzMHJEMnZ4WHVES3NDRmpIWUgxY2NlOVYyUlpWRGwrRHcyRndzS1liQ3dRckRGQWkyVkVVV0FBN0MxYUxERFFnMnR0YW9JUjNTdGpwT3VCMExvUzFHdk5IeUtCSEZhMk9LaWt5bklGSk1sdGhTaWJVam1pYzZWZ2xhQWJMVUhGelhCcVJQSmJiWWJYdlZKanN3dmNEWUR1ZTlaV1hKWmJoRXI4MW0xaGhZN0MxNjhpL2pkOFJXd1hTTVhTR1h6Rk1WbWpYeEduYlRDdk4vdWY4cTlNOVNaeW1YNFdXV1VnS29MTXg0UUFYSk5mTnZ4RzY0LzQvNnd6bk9KWlhraGxsTVdHRjdnUnJzQ1B2eis5VjRlNTJXSnJhcUtyeEc2TXhYU25VVVdDeEFYRWxzQmhjUkgrV09vYUhqVWdBOXlMN2lzN21lU1RZV0hETkRFSk5jZWxtREM1SjdOOXEwYlp2ajhVRWxhVXNZb3RPcVQxYVVHd0FwL0NaZzBlRVVOSERMQ0RjNmtHN0g1NzFjYjRvckdOd0hUZUx4R1BndzdSV0pObUpQQTk2dTV1a3A0VWxpZUlTT1cwck9sOUp0ei9TdEhoc1drMnQ0NDdFQ3dJK28vQnF3ajg5c0tGWnZLWGNnTVBpa3NiL1p5L01jSDVFaXhhV0RoYjJDN1grL2Vvc2VXdVZDK3RwTDIwcU43bmdDdC9pOHNkWkVjM2tqSkhQYjlxc2N0d2ZrZ0ErUzByWGNlbXhBcGtzbXprdDZiQTlST2wwSDBSMGxEMHc3WTdGTzArWnVnRVlQRUFQUC9BSnF1Y1RoWkdCTVl1NjczSjVGTk5pbTh1MGFna0M3V0ZyZmFrbkZNVTB1VHAvdWp2V1ZOeW5LMmQ5Z2hERGlXT0tvY0ErcFdZbGl1b0E4R3JISjhOSXlSdVFyQlJ1Z081K0toWWRENXRtSWV4NEkrbHEwZUJ3ZmxOSGR3c3czMDl0KzRxR2JvdmFiSHZseVRNT2RLYVhRblZ1TGkxcVRqWjNTRXR3aEJQcDUvbFRra3hNVmdwWThFRTJ0ODFUWnBNZ2oxYTdPUDFLTjZyeFc1bXZrcUViYks3SFl1NVFyNlRZMy9BSG9ZRkZrbmRXSUFBc283Y1ZBWmhqWnhEYlJwOVJ2d3dxMnc4SWlJVU1RVDdjVlBKYlZ3WmNHOGs3SkpqUGtPd0Y3Ylh2V0t6Q0w4ejFaZ29Bb2pPb0FYL1VSM3JiU3FMblVndDJMYjIvYXNUbHhHSzY2UWdFQ05tWWtEa0R1S2x3cmxzcTYzM09NZjVPbXdGaWZXelRFM3NSelNpak1sd3UrL0pwTjNqbFVvUllpNmc4aWxvR2V5M3Z2ZXczcWcrN09oWEdORUhIdWZ5MGUrcEViNzcxVFpGUGJPY1N4WmRPb2dxZjZWZDQ0K1lXQzNVa2NXc0wxbU1xY1I5U3VoQWRuQTI5dDl6VnVDdUxNM05LczBXanFLSklycklyWGswaTYyMnQycVY2dFJaZ0Y3Zy90VWVCbjh0RGE2aGUzY1ZJaFFQcUJ2b1lXc2Y1M3FvemNpeGxWdUwzRi9ZOTZOOUN4Z2g5ejNGUEdOWkFsM0FQRnFLVUlWWmJXTnJYdHpTRDN3UmhaMXM2bjNES0xVaWZDbVdJdWJOSGJjSGUxT3kzc0FiRWJBMkZFZ0dxMWdvQTdjV29HcXVtY3o2eHlNU2Y4QU1LaWpSY2VrVy9uWE9aOE5KRnFPd04rM2F1LzV2Z1ZtaVpBbXRaQWRUVy85NzF5VFBzcC9LNHZFUWxDcWc2dHgydHpXcmd5ZTFKbkZlVjBXeWZxUlJSWVBGYVhVQStyYTVJM0ZhSERZZ01kVWVwRzdPT2IxbFRFOFVwMHVBUnViMWI0REZyTkdGS3NyZytuZTFXcHBQb3hNVTNGOG0wd1dmVFlhY1NwSjZ3TGFRTnI5cjEwTHA3cWRNVExoNUJpbndtT2hJTVdJak5tamIzQjlqL2xYSW9wTlVQclpSZGJhVjcxTHcyTG13engrVSs2V094M0ZVcDR1YmoyZEZnMWlTMjVPVXozTjRkZU1KemhJc296dWNRNTNwSWhtQTB4NG13OSt6ZjUxbCt0L3hNNC93MzZoT0N6VEljVmhzTklieFl1VVdpbEhjWHJ6NWtQVzhjOFM0ZkhNZEFOMVpUdWhIREErNHJ1L1RmaUprL1YyUnBrSFhzY09ZNEt3VEM1c1V1TG5oWkJ2WnVQVnhRcHk2YklNbmo4S3llcWxhWmNaWCtOWElNVEo1T0tnQ1NkdkxPb0VmZXRka0g0anVrTTh4YXc0eUxFWUFQeEs2S1kvNWczdCsxWkxNdkIxTXV3Yk4wMWsrVjVqaEdVU0NEeWwxa0QyYnZlcVBFNFBwb1lDYURQK2ozeXpFSUFETmgxMHNuN2ppcWp6NThjK1hhTmZINGp4dXB4M0R2OEF2azlGWVhxenBOWkkzaHpuQSthNEJIOFMxeC9LdEZoY2RoTWUvd0R5MklpbjcyUmdhOG1EcG53dHhXR0d2TU0yeTZaaDZaWG4xQmZtMXRxcmYrR3N0dzJNaFRwanhJeGNHTGJaQlBFNUh4eDJxOUh5VGkra1pPWDlNNFpwN1p0TmZhUFpvN2duK2RGckEydno4MTVRd09lL2lDeXpFSmhNSmxPSDZxd3FuYkVxd2p1djNKcnUzUStJNnZ4bUF3NDZteXhjQmpIRi9MaWNQcFB0Y1ZyNDllc25VYVJ4T3I4VzlNMnQ2a2JobTFHd0cvelVQRnV5SXpYS29vSlpqc0ZBNUpOWlRyYnhZNmY2RFE0Zkc0djg1bXAvNmVYWVQxeWsvUFpmM3J6cDRnK00yYjljZVpEanAzeXZLaGUyVzRaamQvOEE4b3crb2ZGTnpheUtYSFpaOGQ0Zk5xSktVMVVUb3ZYL0FJNnJEaUpzdTZaWDg3aVVHbDh4WWZ3WS9jS0wrbzNyaHVaNW1Zc1MrUHgwMHVKeGN2cWZFU0hWdjdBbmNmYXNqbjNpSmg4dmlNZUVBQVVhVlZCWWdld3JubVlkWTRqRVR0cHhERVA5T3EvcHJFbHZ6dTJkN2kveGZHeDJ4VnM2SG0zV3NJSVF5RTYxT3pMZTU5eFdIeC9WOHJFK2E4YUtMa0tvNTlyaXNyTmpjUktTV2M2aWJrcTFyZmIycUZQUHBsQlp0UjQrUlUyUER0NVpuYWp5Y3BmajBXdU02bmZYNWNZNEZ3eWprMVVxOCtQZC9NTHV3TmlDZTU5cVpRRjJBTE9RYjJBclpkTjlPeTRsVmwwMkVZRFhiWXNha20xalJtNC9WMWNxQzZkNmRMR0ptMStZcDdqWlIyQnJmWmRnUHl1ZzZpQ1Rjc1J2OXZ0U01CZ29ZVmo4eUowVlRmVjNKKzlYYUo1a0tRNmJzTjlYd2F6WjVOeDJPbDBxd3hRdFlDaW5VVjJZRWZOTExxVzBLV2FXL2NiV3BjYXEwaERjamhlNUZGSmRkbVkzTzRVRGRhZ2JOZEpCRWhPelc3MGNHcUZneXJyRGI4L1Q5NkVZTEd6RmxQYzJwVVBxY1h1QmZoUnMzd2FSRG53T01ubVNIWHNCdUNLcWM2WU1jUEFib3hmVWRSM0FxMWU3VFdWUVIzRnVLcThmRnF6U0dObU9oUnFKdjJweUdUNE1CMXlRK2RZZUJHQ0tXRnk0dXd1TzN2VlBqVU9EeGh1R2tWdTQ1cTE2bmxhTHFyRGtsbk1jZ1lNUnd0dWFQcUdCVGpqaW9qNThMMkxTM3RwUDJyUWkwcXM1RFVSYzV5YUlIVFVnaTZnT2duUXNtbEVPelhHOXZhdXo1VXpZaUJYOUlZaXpxZXhyZ2M4ODJCeFdEWURTU3dMK3h1ZUI4MTI3SThVSmNPSGprTHNWdVZ2WXIvdlVHb1R1MGFmaXNpNWd6UjRWNVdSbExnM0d4N0xhZ3M2cVNyL3hBVGJjYmZ0VGNUSUZGdVcrb21uMVRVcmZ4QVFEc3JiMVhPZ0krSXRHcFh5enBCc0Q3MUhtRFJLU043OEMrd3FiS0NxMlFDNU8vd0FWR0tNckYrdytvTFNYWUQvVHVOZ3cyTWl3K0xjSmc1VHBOaDlCUGU5Ykk5TTRhS1lMNVRGcmJFRG11ZHlpNitYNVRNSFBwdnhYYVBEdlBJK291blFjUUVPT3k5dnk4MXhjbGJlbHZ0elhUK0wxVDIrbEovMGVWZnF2eGUyUzFlTmQ5bWNYcHBGbVFKaG5YVU9EdWFrWWZwaWJFeTZZOE1Ba1g4UjNrSVZVVWN1ekhZS081cmFaaGljSmsyVVkzTk15eGtHVzVQZ285ZUt4dUlhMGFLTzN1U2VBbzN1YThUZU8zNG1NeDhTMHhQVCtRcFBsSFIrc2h3R0luekVkakw3THRjTC9BRHJabmxVT3p6M0hnZVJsbjQ2ZU9HWFpyMUhnK211bjhkTGllajhIaUVHZDR2QkxwT1BHc2VZc2JHeEtLdHdPTG12WDNRV002V3pubzNMOFIwR3NhZEp5bGt3ZWlJeE5zYkhXRGYxQTg3bXZtQ3hON0FLeS9TRlBBRmVnUHd0ZVBjL2h0Z3VvK25zZEZpc3d5MldCc2JnNDhNUVd3anFENWpMcVBGdHlQaXMzSmVSMmJHT3NSM2Y4UTJVZEM1M0hGaGVvOG93Mlo1L0RGcWJHRnlnd01BSDFTdUNMK3dYYzFnL3d6OWM1UGlzem0vc21ONE1CaHAveXNhVEgxaEJ1amZZaTljRThYUEZITCt2SGpoeUREWm5oY3Rra00rTWx6UEUrWk5qcHI3RTJGZ285cXJ2QjdxdzlMZGQ0WXVRdUR4dG9wTmJXVlh2NlcrL2FxdVNFdHBad3lUeWM5SDEzNmR6RmNUaDR6Zm1yc0c0dlhKUERIcWhNZGxtSFozOVpJQkI3ZkZkWmljU3hxUWUxNnVhU2U1VVFhbkh0ZG9YUW9VSzBqUFBpYjBEME5tZmlOMWhsM1RXVElXeCtPZlJxSTJqUWJ0SWZZQVhOZlUvd2w4TmNyOE0ra2N1NmZ5a0g4dmcxOVU1Mk9JbE50VWplNU8vOUs1RCtFendEUGhUMG8yYzV6aDFIVnViSXZtZ2dFNE9EdEdEN25rMTZYeXZEaEwyRnY5YTUrVTk3cEd0QmJVWEdEaFhaanNhbVcycG5EclpRYWZxOWhqeFpVeVNzVUtKejNvaWFUSXdBK0tzdklsR2lMYTJBdFkvRk5TU1d2YWt5U2FqOXFyOFZpUUwrdlJZVm5aTXBaaGlzTEg0c0twVzF6NzFuY2RpaWlzVVVLYkVsalUyYVlzTGsxbStwY3dYQjRWblppZHYrbU9YUHNLb3QyWDhjVXV6ejErS3JxekVaZjBrbVVSWTE0c1huRWhpQWlOdjRRdHJ1ZTJ4QXJ5VWN0d3VIREpHUXZra3JZN0tvSEIzcnJIakhtV0k4Ui9GTE9jTmxrMGMwMlRZWXhKaG1heHVOM3Q4M3RYTlh3eVFZS0pKdlRQdURFNHM5N2NFSG1wc2JVVlF6Tmp5UDNWd1Z4TWtjR01qV0lnQUtaSFZlVStQaTlKT0hNc2NaQktyRnNwSHRVN0NxcHc4NnNHY3lFYTJYYXdIYjdVdkRMcUxrZ0N3T2hXMkRWTS9zcVV4ZURqS0NaU3VsWlUxZ3FPRDcxYzRIR1BoZnk1eFNpVWtXMHJ5QjJQOEE2VlU0WUxoY2JFcnVFUXVBUmZjRDJxZG1zZUd5N01qQmg1UE1pSjFyYjlKN2cwamRMa21oaWMyb29sNG5HQ2ZHK2N5S2l4M0FJR3hQYWtZYkRCR21uVkMvbW13RitMKzNzS2p4YXRPbU5qWXRxSUl2ZW5wVzhwSEZuRDZ1T0xWUW5MY3pyOUxnaGdpdUIyVkk0Mk5wR0R0NmJOdVA1MHFPRm5DajFLQWVRdTFFK0pra3dpUXJFcWc3M3R2ZW44UEVXVUtXTmx0ZmVvMzBhUDVTSitDdytwd0N4T3IxZkIrOWFDS0ZZbGRXSlpEc0d2dUtyOHF3Z2pYWFptMVhBQjl2Y1ZKeGVLand5TzhqNll3cDFlMXY5cXB6VGxLamJ3MWhpNXNZem5PY05sQ0dUSDRsUWxqc2ZxQTdmZTlZV1BxMmJPUVhpVFJEYzZkV3h0NzFRNTNtYmRhOVJlZDVSTUVmOE5Jd2V3NEpOV09Bd2h4R01URHhxUjZyUG8zQis1cTlERkdFZVRuc3V1eWFqTHN4OUdpeWVBdEhxMUZYUDZpYjNxK2lVMlVzdXlja2JnVTNoOE91R1ZZNHdvVGdrVklqUlFWSUlOdlNSdnNhcDVKZkJ0WWNiaXJHY1ZLRmlrZERZcUFXTnF5blN5TGlPcXNkT1d1OGNZMEx4dGZjMW84NHhMNGJEWWpjcVN2MHJ2cSs5WjNvR000bk1Nd2wzMUVBYi8zYjhYcXhqVFVOeFV6KzdOR0owTkdSMHV3R25nZ0hlalY0d3hkRlkyTnZ0U0ZmVXFoWkFDUFVCYmY5NldWWTdsU0I5VjE0UDNxaWJzZVZURVl3R1JWdHFMOTc3Q3NUZzNXRHE1RnNRMnE5MTNERDJOYlRNRzh4R0tLUXBHNHYzckJQZkNkV1lmbUxVOXlmYjdWYXg5TXlkWTlzNFA4QWs3Smc1TlVLMmpMSjdjNmFrNm94cWQyS3J4ZXhzUDJxdnl1UU5oMUVaQjE3bSt4clM5TVp0SDA3MUZrdWVTd2lXUEI0bFpIREM2NmVHdUR6c1RVTVliNTBhOHN6aGgzeFYwVjZhWkkxYUpsbFZ2N3R0cUJRQTZoY3hrN043MTZwNjIvRDEwcjFjVG1PVXgvOFBaak5hVmNUaEZ2RTk5N3RId2VlYTRoMW40TzlXOUZSbDU4Q2MzeXlKZlZqc0NDeHQ3dEh5UHZWbkxvc3VQbjRNL1MrYTB1cGJqZFArVEFPcGZVRXNOVys5TkdJK2FxYkVoU0FDYW1Jc09JVXZES3NpQTZTQnNiKzN4VGM4TEFzeitrZ2NXQklxazByTm5mRm9odkQ1a1NvZlNxbmRRYjcrOVkvcXZKelBCTFBFQ3hUWWxoYTliVlZYU2JYdDcyc2FZeFdIU2E2aFFiZy9YMnA4WmJYWlgxR0paSTB6Z09aNFlyS3pEMVhOeU5OdDZpb3pSTVFEcElON2R4VzQ2bnlKc0ZqSk5TM2lrT3pqK3RaREU0RXhZb2kydTIrcXRlRWxKV2VlNnJCTERrWmFaZGlGbktLR3NRdTJvV3FmSWpDN2JYMnNBTjZ6ZURuYU1vZFpiMUJibjNyVllSNFpWS3N4TWlEc1BlbXlWY2syR2FrdG9tQ1JVWUs1UEhJRzRyUTVGbm1LeXNGNDM4MVJ0b2ZkU1BZMVJmbG1qRm11QnpjaXhOTGhrQ01GdUJkdUFmODZyeVZtbmlrOFRPL2VHZmpOamNuQ1lYQzRoWFJmcXdPSVkyRi93QzYzYXVwWWJ4UXhXY3VaWThIaFpKUnMyR2NYWS91ZWE4ZjY0Q3dNb01adllPaHRmOEFsVjNoT3BzM3dPSGpYQzVpVkNtMGJTYnNvdlVkU1hId1R6ampuekI3WC9CNjl5VHFMSU1jVC9hdlQ2d3ovVXl5UlhXLzhxMitBelBwbkN3K1poOEhnTUZDdDd5U3FrZHYzUEZlS0p2RTNONTEwNHA1TVd3QVVTQ1lyL2xVSEg5YjRqRktmK1ZWbTdtWnkxLzUwK01sSDlwQmswbVRLcWxtZGYyZTFjNThlT2plbXkyRnd1Ti90ZkdoUXd3bVhSbHd4OXRkdEkvZXVOZUlQNGg4OXp1T2VCTVREMHhsaEZtanc3RjhRNDlpL2I5aFhuM0ZkV1puSkVvVjQ0bytQU0xXRlVXT3gxM1pwSlBOTEVlbnNmbXBYbW5rNFhBM0JwTkxwWHZmdWwvSnVNWjE3ZzhLcC9KUU5KTXdMSEVUWExOOGttc0puWFUrS3g4anMweGpoNUtnOFZXejQ0cnFXTWFnZHRJT3dxQXNMeXVyQmxJVzVQeFVjTWFUdGttZld1YTJRVklMRllsNWwxRTZpcmM5clZIZUpZeUpISktzS2t5YU1OaDVOVjdNUllnWHYrMVFaNWZ6SUN4WE9uNmkyMXZ0VmlLTW1WTjIyTlN6cWJxb0JGckJlOTZhdytGTTczU011OTdHcCtCeWg4UUMyZzNaUUN3NUZiSElzaVQwT3FJeUViczIxdm1pZVJSSFlkTGsxSEJYZE05TW8wOXB0VjlPcjZlSzMyVzVla0VXbVAxbFNENmphbDREQlJ3UkNJSU5QSVlpekdySklGVkxxQXBJc2IxbHp5YjNSMk9sMFVkTkd2a1RDcEpiVlkyM01SNHA1R0JTMWhxTmhwNC9yUzdLYmc4a0FLUU9LTFNwQTBXTmpaZ2Y4NmdOTklmaFdOR05udUFkd2Q3ZnZTR2F4YjlTKzZIYzBBZ1FNdXNBRDJITktWeUFTcmFSWWR0cjAyeWRkRFNxU3JsUVZRamdibTlPaUZuQ3NScEkzdmYvQUVvN09zZG05VWx2c09hQ1I2WmV4SEk3VXFHU2RobGpkbVEzSEpKMkJxaWR6Sm1NcTZOeW9zYjdBR3JoVmFMV3dZRlFTeDFEZTNzQlZMR2pQbU1zcFd6YlhLOE1QYW5vamJiNE9lZFZZcS9WZVd5RlNWV1cyM2NqYitWYW5Oc0hQSUxoRnN4REJRbGorNTdDc3QxS294WFdXSFRRSXhjMlhWc2cvd0RXdHBrNi9tb1BVWFZZYkFLeHZxTjZ0NUhVVXpDdzQvVW5PTE9lWjhxcGlJbjFKNWFEU1NwMzIrSzZQMGRpVi9MUStZQXQxTnBPZFh0dldINnd5OUVrQ1J4M0pZbnkrTlB2YjNGYUh3K3h6UGwwa2RsWVJFYVVIcUNqMk5Ma1Y0N0lkS3ZSMUxpZEtnY1lpQ3pDek9iMnFaR2lYMHVibFJZV3FydzBoa1R6QXdqVUVXVUhlck9BYVpGWmo2ai9BSlZTK0VkUW5ZYzBiTkc5L1lDNDcwekhPWXkyazY5ckVFYlUrNUx1ektTR1BjY1dxS3pDeEdvS1NkeDcwZ28zS2drVmxVczR2MjdWWWREWnpQMHYxZGhNWkpISkpoU3JSNG1HSGM0aU94OVB0cXZheHFDOGpSYWdMV0szQ3B5YWp5cEpFWTVWazBvQnFiZjZUMnVLa3g1SGltcEpsTFY2YU9xd3l4eU9BK09malZuM2k5MUppUDdTVnN1eW5BU3REaE1sUmlFaEFZalZJUDFQN2svdFhOM0xhemYrZGRTL0VGMHV1QXozRGRRNE9MUmdzMFh5c1FGRmd1SVhrbi91RnY2MXl3QWpsZHVUOFYxT1BKNnF0bml1cDAwdExsbGphNllDd1BwS3J6ZXBPWDVwSmtPWlliTWNOWVQ0VnI2U0xySXY2a0k3Z2drSDcxSDAyT29pNTdDaWUxeUxjOTZWbFFtOVI1ZEJsMmE2Y0hJWk10eEVhNG5Dc0d2WkczSy9kVGRmMnF1a0Q2UmE2U0FoMXVkd1FiamVydks4TzJlWmZObGlrREdZUld4V0JEYkJoekpGZjUzWWZZMVJySXJBTVRxVG1oOHFoMW4wRC9EUjEzL3hCMDlnY1dKV2tPSWoxU0JyWFNRQ3ozL2V2VitSNHhaNEYzdVFBSytaSDRUK3IyeWJQTXh5ZDNVUmtqRzRkU2VEOUxxdjlEWDBXNkl6VmNYaFkzQjJJSCtWVk1Vbmp5VVhjcTlURlp1S0ZKamJXdDZWdFhRdzVWbU0wMFlYRFFBRzJrQTNOWCtCZ3NMbXFyQ1c4MDM1K0t2OEtoMEN1ZXh4TmJJeVZHQUUyb3liQzlHUHBGRXd1S3ZkTGdwOFh5TnM1dDdHbTJabXVEeFR1bWlLQWI5NmhsdUhYRWlTZzIyTlYySmlEbXozUGVybDBBSEZRWm9qcXZ3ZmlxRTA3TGVOcjRLVEVvem4wcVFCejJGWVR4R3pqQmRGOU01cjFIajVCSkhsMkdlY0xxQUNrRGExK1NUYXVrWXJMWGwyVnlGNUxuY0NzVjFmNFE5TjljWUtYQzlUNE44N3dZdTRpbGRrVmZrQlNML3Y3VTJMZnlpMVc1VkhzK2VQZ29ac1kvVmZWZUpER2JGekZWY2szVXV4WnJmMHJUNXJGZzg1aUNZdUZKNWx1RXhDaTBpKzV2VTdHWkRCME1NeDZiNmZSNXNJbU5sQ1RNTmltbzdFOTdEYTlNRERpRUF5SVE0RnJqajcxU3laSHZ1SjMrbDBjWmFhTU1zYk1uaitscDhFclRZT1l6NE1hZldUWnhibTQ3aW12eVN2bVU2UlJzUVNQTDIyTis0OTkvYXRMS1F1SWpoR3F3QkwyNGI3MXBNbzY4T1Q0REd4eFpMaE15emFPTC82WkxJUXFSUDhqdVIyRldzZW92aVJ6bXU4UktEM1llam1XWkpoY29oaldRbHMzTFhNTWcrbVBzVDgxbnBzU3M3dXhaaTlydHZ1V0o5NmhZek1zeHhHYTRsc3lhVnN5ZVF5NGdUSnBZSC9BRUZ2YWwyc3R5Q05ZMlB4VnRwTldqTHh4Y09LNUw3STVXYkRTU2tzQUNRb1p0d0JWa3g4K0lrYWl4TjlZTk00UENTWmRnazFRNklpQnBrSXZxQjVxWERER0ExZ1RIZTRJTlVadms2VEZHV3hDb1JaZlZzVTVCQnVhdGNIaFZta0FLaFNkOStQdFVhQ0VrbDNJa1RiU3l0dWZpcjNCdytUQktDYlBjTUZCNUZxaGs2UnA0Y1c1MjF3U29rZUdJeEQwTnlCMlA4QXRYTSt1K29IekhHZjJUQkl5UlJtODBrVGZWL2crMWFQcjNxMXNtd1M0ZkQyT0x4Q2FRQWVBZVRXTTZXNmVhYVlUU0V5RmJPeis1SEZTWW9iUGRJcWEzVXZKUDhBeDhSZlpSazBHRHdxMmd1N2dLV0MydFYvZ2N1Z3dxcVlvOUJia1crcjcwcGJ5SW9GemZjajVxVWloSDVPbzJKVW1vcDVOelpjd2FlTUVra1BSSUkyRmxDNmZjVW56UXJ1UFVYSnVvVzF2dWFjdjY5UnY1WkZqNzBVU01zcHUzQTJzT0JVQnA5Y0ZQMVBpV3crV3psVjlZRmxKUFk5NmcrSGNNWXk2YVFzMy9NU2tBL2FtK3NKbFhMNWhJM3ExZ0RidGJpclBvbUF4NURob3lXU1JnMGhYVHhjN0FIN1ZkVC9BTlJqeDkyc05QY05PZE1MR05SWmhld0pwd0h5NGhaYkJpYnI3Q21vVlhTRnViSG5WelQ3cytrc0FsbEd3VTFubTlCTWk0a0o1YjZWYzdYdWVLNTVtazBxOVVZYVMra0l3MG8rNUlybzJNWm9ZdEo0Yi9XdWFkVFdoenlPUWFqNmdQVDNzZUt1WU9VekY4ZzYyczdGbGs1YkNSbFVHdGdDZDkxKzlhS09NVHdHS1cxbUZpdmExWmpwdHI1WkVHanV4QUlKUHFJOWpXbndvT3NicUJheCsxUVA4dURheHBUeEpmYVBZL2hCMUczVlBoN2xHSmtQOGFOZnl6aTF5Q25wQi9jQ3BHSThTc2x5dnF6RWRQNWpQSmxlTmpWV2pseEEwd1NxdzIwdHh5Q0xHdVUvaGk2aEp4dWI1RXpXdytnWW1HNTNCNGFyUHgveUFObmVRNXZKRXI0V1pUZ01SRWR3UmZVaHQ4Ry84NjdYUjdkUmo1UEYvTVFsb3RRMGpUZGVlQW5UUFdja21OdzhJeUhOWmJOK2R3QzZRL3l5RDB0OTY0UDFuNE05VjlFdFBNMkRUTzhwVGNZdkFnNndQOFVkcmo5cTBYVE9kOVo5RFpIZzh5eWlQRll6cDJZdXlMSWh4VWFnTVFRZjFKeDJycEhTZjRpY2l6a3dybVAvQU5JbWJZNGhaUE13NGI1ZjlQMlBGUjUvRzQ4bks3TE9nL1V1YlR0UmxKdVAwLzhBK25sU1BUT1pHaWtSZEd6eHViTXYrdC9nMEJxOHRoWU5mdVJYc0hxL3dnNlE4U0lobUg1ZUtIR3lLZkx6YkxYQVlrKzl0bi9ldUdkWWVBSFUvUzBUVDRGRjZpd2NaSkQ0WlNKd1BsTy83Vnp1YlE1TVhLVm5vV2s4N2cxZEtUcG5FYyt5aHN4dzBrZWdFMjFLUWR4NzF6VEg1ZVlUSWo4OFc3bXUxdkdKNXdqczBXSlFrUERLdWlSUGdxZDZ4L1ZuVGY1bC9QZ1cwaW0rdzJOVnNjM0hob3RhM0JIUEhkak9UUENZaFlMWWZPMWpVckI0a3h1Q1hPNUc0TnRxczhiZ1FUZG1JYnN2ejdWVHo0Znl6YzZnNDQ5aFYvOEFKSEp1TXNUczJlRXhNZUt3NFZ5Ry91bm0xUjU4QVVXOGFhcm05d09SNzFSNVJqdEV5Nm5FVGFkeVQvU3RuQXdrd1paRGRXRnhZMzNxdFBobXZnbkhPdVNuS0svcVJqb0F1d1liZy9GSmtsS29wVzVzYnFhdWNSbDhnWU9DaGpGaUw4bmJpb3M4RWdDaDA1QlBOTEdYQkk0T0xwRUFZdGdyRFdWSk95MDUrWWxWZDJJdU81cGJxaGpRR0VsK3h2US9LdGlTRUN0ckEzMnNCU05qV3BrU1RHRlZzZ0xNT0E1OU5RUXN1SmM2bkpCL1Nwc0FQaXJXSExHWU5yWUFEdGJtaExBbUhmY2dPdkF0d0tWU29qZU9UNVpXL2x4R2JqVTN6ZXdGTXp6eHdJUnFLdktMYlU3ak1VcEJDN3Bmc0xWWHl3dkpFek1mU1RZS2Q3MUxGMlZKdFIvRWkveEozSVhiVWRpMjFXR0N5dHpNRG92cUkzWnRpZmFwR1c0RDh5NWtaQ3hBdGJ2V3J5dkpXWUtCSGRnTEJmOEFNMGtwN1NUVDZaNXBXeVBrbUFTTnZvS2tHMWozRmEvQ1FlVEJaVkRJTjNGdWFYZ2NDTU9zWkVTaEFMYmplcDhFZWpTZGxJdno3ZmFzMmM5eDErbHdMSEVSNVplTU1XdllXWXQvcFRpb3J4SHk0N3NEYmM5NlhHZ2VPOGlPRi92RWJVbzJOdEs3QTdudFVKZkVqekExckRRUU85dDZXb1owMVJoUUxFYmlqSytiQ1dMNjdONmRBc0tDQmZRZlVFSU8zdlNEckZwRVkxOVhxMkF1TzFOSWdFNEExRSt4NHRUZ1VCQ2RETVNiaFZQRkNTVUl4STFCK0N3SEZBMFFScUpidGUxaWVhV3FFU2k3QXJwNDV0UnJkV0lEQm1VQTdqdFNpQ3pzOGRyMjM3Q2dscFVHRVZnWTBiMVd1R08yL3RlczVobXRMaVhKSWU5dG03MWU0aGtFT3ZTTmdmU3ArT2FxTW5kbHVFMHlrbmRiYldOQkRKV2N5NnJkNHVySWlpNm5GaUJlN0UvN1Z1dW5wMkdHZWI2d3JlV3k5MU5jOTZ2SUhXV0dqc0JxSXRjMnNmOEEzdFcwNlp4SDVuQ1hZL3hHZDFJWGUzeis5WGMwYWdtWUdseUwvSm5CL1pWK0ljWWJCaVcyblMxbGE5ejl2dFVUdzh4bjVhZWVFUGJWdWJjL2FybnFlRnhnWmRvVks3Qm4zdDlxeXZSOHJKbXJhYnM2WFV1QlN4ZDRxSXN5OVBWcG83QmdKWXRGZzRkazVKRlcwRm1ZT3BaZ2ZUdjJyTzVaaTMwSWZMUUJtQUNqdjgxb1ltbVZtdlpGRzlVbWRSSHF5Y3hNU3NHSUFJQTJxUGlJMlpiS3VnS0xGenlhZGhsTFF1aHM4bzN1ZDF0Mi9laE5HN0lza3Jlb0QyNXBCeEFSeVlocjFhUVNkUUc5TnphRmlJVTNWN2M4L3ZVbkU2SGo4M1ZvSDBrRHZVZHovd0JOZ3F1ZXdKNHByRlNSVDlRWkJnZXMrbk14NmR4TWpsY1FtdUNTMy9TeEM3b3cvY0FINEpyeWU4TTJDeFUySHhTUEZpTU81aWxqYnN3TmlQdFhyM0dQb0tNQXF1RGM3MXhMOFFYU3d3bWJZTHFuREJSaDh5L2c0eFY0aW5BRmlmOEF1RmJHaHpkeFp3WDZpMEZwYWlCeTYra3RjYysxQU53RHlUM281ZjRaL3VtKzRHOUpzTlFJTnoyRjYyRHpwaTRaNXNOTEZMQTVTYUJ3Nk1mcERYMi8xSDcxUDZqd2NJeGNPWjROUkhsK1lndWlFM01Fby82a1o5dDl4OEVWWE1kWEZXbVN6dzRoTVJrMkxkWU1Mam5EUlN0eEJpUnNyay8zU0NRYUJvOTRmWndPbk90c2x4OGhLeHJPRWs5VmhwYjAxOU9mQ3JQR3hlV3dHNExXdHNkdml2bFJqTVBpY0hMaWNOUEcySHhzRWhTU054NmtjZjhBc2Z6cjZDZmhsNndnenpwUEs1RmF4a2dYVXdOeHJBc3dQOHFwNStHcEkwc0h2ZzRIcnpCdnFoQUp1M3hVaXFqSTV4SmgwSU45cXVBTGphdGZUeTNRb3ljc2ZjWXJMWmhMS0N2cVgzRmFqREhTZ3ZYSi9ESHF1UFBJTlJrQU94US9wWlNLNnJoWFZvdWQ2eWNFdHhvNW83WWtxZ09hYjFVdEd1UlYrRFRLTkN5TDBobHBkR0JjMWFVSTBSTVpaTGozcGhvQmY1cVl5MFdpL2E5UVQweWtyUStNNjVJaGlOVm5VQ0hENUxqcGtVYTBoWWo1Mk5YbWlxWHJBRmVuTXcwbjFHRndQZzZUYXFPVEM0UmJaZTAyVGRtaXY1UG42Q3NzODduVUhhZVJpdnpxTkx4T0VNc0RzcEZ3TDJhbXNFQ1lWbWZTSm5MM0xEWTdtblNaSklHYUtOU1R0Y04vT3ViZmJQYmNkTEhHL29pRExvaGpwMEtEWHBESzY3aTFRNWNsZ25MRXhHR1VmdURWaTVzMkYxS1l5NjdrOGFSeFRpM1l5RlVKdXd0OFUxTnJvVjRvVDdNWjFQaytIeFdFODNNWTVmT2hXeVk2SlFTQjdNTzlaRE5jSGdNdnd1RWxURVRTTEkzb2xTTWtHeEhwdGF1eERScWRCZGdSNmdUdFJTNFpRZ2lpMHFxYmhkSTBnL0ZXNDZocFV6SnplTWhrbHVpWUhGeXk0M0N3eXNqUnhyWUtyamUzMnBpR0ZzU1RIR0FXVzVERTdFWHJVWjloOVNFU1gxQmJYSTVxQmc4RkhEQUlnd1p4WXN3NUF2VHQ5cXlwTFR1TWxFazRhRFFJeUJHMEVZdHBzZWU5RE5zMWh5WExKSnBtVllWQjh0ZTVZL05URzhyRHhNR1l4cUJxT29XRnZtdVRkYWRTSHFUTkhXTnRPWHdlbFZBMllpa3hROVNWc05ibldreDdZOXNoeHk0anFyUFB6RXdLK2NkTWNZL1N0ZEx5cks0OHJ3VWNZUHFBdHE3WDl6VkowaGtpdzRLTEVNU3BjWFdNamdlNE5hZVZ6R1Fya0MvcHRhKzNhcGMrUk43RVZORHAzQit0azdZSTRqQ2JpdzBpKzlQdVhMZXZtMjFxYlFqY25jamE1RlBpNUtNVHVEeWFwdFViY0ZTQ2lhdzFQZmJiN1V5NUtCeWhGbU5tQjdpblFHYVYxUWoxRzUxRC9LbWNSSU4yYTRVY2VuK2xBcjZNaDE0NGNSQmJxUzF0UDJHeCs5YWZJQkl1R2hTeWhMQU1odnphc1oxVklKY1ZDaC82cGt1VlBDaXd0KzliL0tOSmlVWEhBQVYxdHZWbWY0bVJwL2RxV3l6aWpZcXJXRi9jVTZ5QjRCY0FrbmtuL1Ntd2g4d3VIRElGK2cwNWI2N2tBMjRBcW1kSkVaeEdvd20vcTBEam11WGRWeGFzd0tnRWtra2tIWmQrUlhVeE1GVS9wWnJndGJuNHJtZldUZjhBTk82UitYY24wci9rYXVhWXdQS2NKSFQraU1SNTJTeG56Qzczc1d0c0ZyWG9BSTBZRWx1NHJEK0hjbW5LRWRBRWpkUUFPUWZldDFocExpeml3N1hGalVFbDcyYkdrZDRZczFuaHJuc2ZUWFhlU1puTktZb1ZsRVUrajlTTnR2WHFQeFN5Q1hxUG9UTk1QRXBiRndxTVRCYnU2SFVLOGJTUm5FUXZFTElHNE5lei9EWHFkZXJlaDhxekpqcW1raUVjNi80MTJZZnlyb3ZGWktXMDgrL1ZPbTNWbFh5Wkh3R3ppTCt4OFhsc1RBSWpqRndnNytoN2FoYjczL25WcjFuNEtkTWRaeVBpbXd6WlBtcEJ0bUdXbnkzTi93Qyt1NnVQZ2lzUDA1aFkvRC94U09GRGxjT3M3d09wK2t3eTNhTWo0MUczN1YzVmh2dnYzcm9wTng5eStUejJDamtoVWxkSG1QTXZEanhJOEhNUi9hZlRPTE9aNEdQMVNyZ3hxU1ZQL3dETGgyUDFmS1crQld3NksvRS9sMlp6TGh1b3NISmxPSlgwUFBDQzhZUEc2L1VuNzNydHFHeDJOdS9OWkRyWHdxNmE2OUhtWmpsNGh4d0JDWTdDZndwMC9jY2o0TjZIT00xeUN4enhMZGpZblBPaHVqZkZqTGx4bUl3dUV6SFduOFBNY0craVpOOWlHWC9JMXhUcTM4TVdlNWM3UzlPWStIT2NKeitXeDVDVGo3TUJwTlRzZDRJOVplSEdQZk0rbE15T1lRQTZpc0RDSEZXK1VQb2Y3N0dyckkveEJaamxreTRQcVRMVEpPbzllaFB5K0lYN3h2czM3R3FlYlFZOGl0RzVwUE9hblM4U2ZCNUs4UWVpOFhrZVlPTTB5N0VaUmlSNmYrYWlLeHVmZ2pZL2NWejNGNFFwZExxUUNENmQ3L05mVUhDZFU5SitJT1huQ3lTNFhHd09QVmc4d2pHb2ZkWC9BTks1SDRqZmdyNlI2ci9NWXJwM0Y0bnBYTTVGMUxIRzNtNFV0ZjhBVkdlQmIrNmRxeVphR2NIVVRiLzVmRHFPWkttZUNzVkJaaXdKRGZJRlQ4anoxOEw5YTZvaWJFRThmYXVuOWZmaGE4VGVnM2JFU1pGRjFKZ1ZOaGlja2N5R3g0UGxzQWVQYTljZnhNWWh4cjRYRXErQXhpTVEyR3hLbU54dnhZLzZWQkxDNHIzRTJMVXBTdUhSMGZCWWlERXhyNWJIMWNIMk5TcGNOclFneXFmazJ2V0R5ek1wY3NtOHFRRmtPNnQzVTFxRXhKWlZlUDJ1emU5VUpRYVowdUxVeHlLMldKeTJWR0JHaGt0dGVvODJCZGJhcE5GaHZZYzB5YzFjQlFKTGhiSFVSdFVTYlAzRVVxa2dsaWVLYnRaWmM0b1ZpcnhKcEExRWIzMWJHcWJFTS9yMU1xTmJnbTlTWk0yUTJCVFZmNlJmdlZWaWNYSmlKU2l4Qm1hNDBCZDJwWXJrcVpNdHFva1dacnM0SkYvaXAyWDVaSmlzUWlxckpvR3JVRnZjKzFYR1FkRjRqR05HK0pRcnlCRTJ3UDNyYzVYa0VlQ0FqUUJTbXd2OCsxT2M2NkRUNlI1WGN6UDVSa1VxQXlTRmpHUnJKS2dGYkd3clRZWEJ4d042aHJZcllNTnJmdFZuRmdvNDdBK3B1SHVPYWQ4aFdQcFVBcWJodmlxVTU3am84R0JRVlJJU3hvQUZNYkJ1d0I1cFlZSVQ1U2t1dXhKRzFTV2lZZXF4SS93OTZFYUZZd0c3bTVBNXFJdUxnWUJzbDlKSTcwSTFFYktWYTBSSERVdlNXVmhxRmozUCtWRkloSXVUZU5leURlZ2VKRWFOSVBMY2hmYzdmMG9pck9xaFRwMEd4WS82VXVRTEtvbEFaTGkxcjcwWWZ6QWIvU3ZIdlFKYUd3Qlk3Tkx2dVR0ZWhJSTNHcnltV010OUswNDREa0V0cFh2U05Zc0UxNkRmdHhUQi93QURzcW94QVc0MjJIZjk2UnJraWE2MlFrYVRlZ3kyaEZuVnI3Qmh6UnFQUVExbUE1SjVvQkVYSHU4bUZsY3ZzaTIyTlYrV3VCRmY2VzcyNzFOek1EOG5MdjhBcDlQMzdWRXdNWi9KcEtkcEQ2VzM1cEc2UTF1blp5bnhOd0pqNmpoZDc2YmNqM3ErOE84d2JFWUxRcmFIamNodGh2N2IwUEZiTG5NT0R4YUlvampiUzR2dVFhenZoem1VZUd6RE1NSkl2bFFzNDB1ZDl6d0swZnl3MmNuSmVocnY3Tnpua092Q3RHNmxHYzZmTEJ2WWZlc0JsekhBWndia3hYSkRoZVI3VjBqTkJhQjIwTTdqMGcvNjF6clBuR0R6VkpDUUltQUROYmsvTlJZZVZSWThpcW5HWjAzcDJjNGlDUFV2a3NvdXJFL1ZXd3c3Z2hibmEzcURiM3JtdlMrUG1tS0xNQlpnTEt2MHFPMWREd0RLc1pWN3VwR3pXc2Fyemp0ZEc5cFpiNEpsaEMwYWp5MUFKUGNkcUZrUnlwa08vYzc3MG1NQlFBUmI3VWJKcVlsQ0dZQytwaHN0TUxhN0lrbXFNTUNCdWZXdy93QnFqdFlzM2xEU1NMYTI3MVpTeExKQVpBMTVPOWh1ZnRVTjQ0M1lpN0tPTGtVMWoyUm5tRGJGVTFBZlVhcTh5eVhCOVVaWGp1bjh3WHljUG1LYVZsWG1PVWY5Tng3V08zMk5XM2twR3hWZm9CM1B2VWZHWVFTMmNPb2FNN2hSWW4vMktmQ1RoTk5GWFU0WTVzVXNjdms4bVpybFdPeURNc1hsZVBUeXNiZzVHaGxYYXhzYlhIMzUvZW95SFMvSjM5NjdkNDM5RnJtZVNSZFc0S0JoTmhRSU16VURkb3o5TWdIdXRyVnhDWnVEcTI3YlYxT0xMNmtMUEZkWnBucGM4c2I2RmdldTNiKzkycE1pTExxU1E2bE5oY2R2YWlVNmwzK3J0ODBxTVdKL1Q4VklaM1Jwc3hsazYxeWg4MFl4L3dERU9XUXJIakkxV3pZN0Ryc3Mvd0QzcnczdUFENzEyNzhIWFZNZUd3bUt5bHkyckRZb3lnSGRTamdXSTl0NzE1enlyTmNUaytaNGJHNFY5T0x3NXVna0YxY1dzVllleEZ4WFkvQmxjSmszWFdEemJKcG1UcC9QSS9JZUpqNjhIaVVPb3hQOGM2VDNCRlJabzdvc3Q2YVd5YVI5S2VsY2Fza0VRQUFBSEZhd0FrYkVnVnkvb1hITEpoWXhyMzBqOTY2VEZJWGpVNnUxSnA4dTFEZFJqOXg4cVB3Ky9pTXhYaGpqSWNuenRueFBUN20wZUlGeStEKzN1bitWZSt1amZFcVBxSEJ4WW5BWTJMRjRXUUJsbmlmVXBGdHErU2lNTlRFZWhodUwrM3RWOTBuMTFuL1ErT1hFWkRtazJBY25VWU5SYUYvdXRSenhmdWlQeDVmYnRrZllyQ1o4WlYvaW4xRWNEajcxWllYTWxZRFZiNHJ3TDRUZmk4elhxR2JDNVhtV1h5dG1aRmtHSEJrRXR1ZElHOS9pdlEzU1hpL2djOFZaSXB3ZVZjTWJNckEyS2tkaURVQ25PSDVFbnB3bitKNkVpbVdVWHVLZEREc2E1emxuV2NNOGFrU0RjL3ByVDRMUG9YVlNyZ2cxbzR0VHh5Vko0SzVSb05WQW05UTRzZkZKYXpXTlNVa0Y3aGd3cTdITEZvcmVtMExBQjcxUWRjdUV5TEZpOWo1RWh2OEErUTFlazNJYnNkcXlmWGVLVTVkam8yMkM0YVVnai9zYXErcWtuQjBXTkpIL0FIUi9zOEVZQWY4QUpJemowSFViMzR1YWs0ZHRYbUw2aGRTZE43aW9HQUd2SzhLU2JQcDFMdnNmdlRrT0plTFZJUUhCVWc5ckd1UGwyejNHTDlrZjZKaGpMNGFFT2J4RmdEZlluYWtHTnNQSVJHNWlINll4d0JUa2JvVmdCVkF4TzFybnQ3MGNrWkJHdzR0Y2cweGxtUFJIdk1rZ1J4SDZkZ3lHeFAzcGFTbGJzeWk0MjlRMnBROVZtYjBDMjQ1cUpqcHdFSUl2WWFRTGMwaTdJNXVrVnVaWWd6eVNLN3JKYmIwOGZhaXcwYUpHUXhCWUN4STczNEZOWVdJU3UrNTh1TStzbnNmOWFwK3ZPcTR1bmN1YU9KQkxqOFNMUjJhd1gvRmFyU2k1dFIrREl6NTQ2ZUx5U0tIeEY2cVlyL1l1RGY4QWp0WVN2ZjZSN1ZWOUk5T2lXWmRXb1JyL0FOU1FuMDMvQU42b3NqeXlYTWNZdm1sbXhVeHV6SGY5NjZqbE9HandPQlNHL0c3RDNhcitTc01hUnpXbjNhek84bVRvc0lpQW8weGdJcTZiRFltbW1XeFVuVVQvQUlqdlMzdW91WEpVbjlKSE5HQjVyRXN4TDM0dHNCV2J5K1dkTlZwSWRpR3A3M0czWmpzYWRJaktGZ2RPOXJleG9vdEFWbFBKc1ZwUmRSclZSYy9OQk5WY0NFUW94SWJXUTNOTTQ2ZnpIWXZZbTF0STRxUkxwWkZ0NlQ3aXF6Tk1RMnpTTFlrQURUeGIzcDBWY3FJY3M5bU5zeDJQQ1l6UG8wdGRTUVFGOXdLNlBsY2JuQkxkYmFodC9sWE9jdjhBK2E2bVkyVlRHTEN3NzEwL0RSdEhHaVBwU1ZVdXdXNVg5cXNablNvenZHcThrcEQ4Y2FnRFVOV2hiR25HWlFDVVJ0d09UUWpDdEVxbEhVS2ZVZTVvcFVDbFpBTEFiV2JjMW5uUTlrZkUyV0lzUFV6RzFpZUQyM3JuZldHdU9kZ0xiblpqdnYzcm9XSTBDRUZWTWpNRHovcFdCNnVWWldsQWM2QUEybTNCcS9wakI4b3Y5WnJ2Qytjako0bDE2bExsVGNkNjZWaG5oZUhTNmFTT1IySnJqM2hoSXBWSWRJRFhOeXAvclhYWXdXaS9oK2tqYTdkNml5OFRzdjZDVjZlS1JJdzZ1ckJMRWhtc0R5QUs5Qy9ocXo5NThObkdUU0d5eE1tSWdCRnVSWnJmeXJ6bDVzbUhuOHl4TzJuYmcvdFhRL0NicU05T2RjNVRpcFgwd1NQK1htRjdYREN3L3Jhck9qeVBIa1JUODFnOWZUUy9vN1A0dzVNLzlvWmZtTVdrZWFod3NyRWNPUFZHVCsrMWJqbzdPdjhBaVRwZkxjd2ZVSm5pQ3pCdVZrWFo3L3VDZjNwdnIzSmY3YTZWeCtIalRYaUkxR0lpdnQ2ME9yL1QrdFpYd2R6cjh6SG1HQ0s2RUpYRnhyZS8xZldQMk5keS9mQk04UzV4NW5IN09rYjN0M29FaFZMRWdLT1NlQlJxTGFSNzdBL0ZaRjVKdXI4L3hHRkx2RmxXQyt0RUpIbXQ5NmhxaE5ScUk0S1NWdG1waXhFVWpYam1WdjhBdE42aFo3MDFsUFZHR0VHY1pkaDh4Z0c0R0lqREVmWThqOXFtUVlPRENBUnhSS2lLTmdvb3NUUCtXdzBrd1JuS2VyUXZKSHRSYlhSTkY3NCs5Y25KdXBmdytZU2RaRGtHWnZoQUJxVEE1Z1BPaXY3TEo5U2ZmZXNuTGl2RWp3dFFTU2ZtcGNDcHQ1Y3YvTzRYK1k5YS92eFhvZkRUREVZZU9RQXFzaTNzZVJTMWJVR0hiaGx0dFVucVh4SldRckNuekIwY1R5UDhUK0doakk2Z3lTVEFzZ3ZKaWN1Zjh4SDk5UDFEK1cxYURFWmw0VWVPMkVPSHpCTWs2Z2ZaQkZqVVZNUWdiZXdKczYvc2ExUFVYaHowejFVcmYybGsrSGFRZ2p6NFI1Y2d2M3VPOWNiNjMvQ0poODBVemRQNTFvbFgvcHc1dkY1dHJjQVNvVmFsY01VMTFROVR6WW4zWlhkVy9nRDZPekR6NWVuTTl6ZnBwbllzWVpOT013eUMxcktyV0kvL0FJalhLODcvQUFhK0szVDJEalRLY2JrWFVrS0VxZ2lac05MbzdYTGJYK0xtdFpGMEg0MStHRG8yVlpobTR3MFhyRU9HbFhNTUlQbnkyOVErMnFyZktQeEUrS2VUaFlNNnlQSnMxY042cFpvSjhESVI4RDZRYXB5MGNaRjdINVBKamRYUndyT3Z3NmVMT1J3eHZqT2k4UmlWZlkva01SSExiN2dHcURFZUZQWGNFMThUMFBuVVZ6ZlNZTGdmeU5lNHNoL0VRY2NpSEhkS1kzTGxQTW1IeGtlSlVudllMWS8xclJqeHI2Y2E1bWx4K0hzTC93QWJDT1A5NmdlZ2l1aTlIelVuMno1KzRMdzI2ak1nV2JwM004S2Ivcnd6V0FyVVpUMEZpOEVvSzVYam54RitaTUsxaDlxOXpMNHVkSkdJTzJjeFJyYTk1RWNIOTlxYlBqUDBURWJOMUJoZHQvcGIvYXE3OGMzelpwNGZPNDhWYm9wbmtHTHBqTWRlczVUbUd3c2RFRGJtcHpkTjVwRk1wWElzY1N5Z0JoaGpYcXVYeHY2RmdHdCtvc0tGNFBwYm4vOEFocVBKNC9kQXcvVjFIaHpmMlI5di93QTJvMzRxL2t2L0FQbEtYRVlxanpJblIrZnl5YmRONWl4OTF3NUFJcCtQdzg2cWxsL2c5TFpteFAwank3ZjYxNk1mOFJuUUtsYlo2Wk9iQmNQSTEvNlV3ZnhKOUZzZEtZbk1KYm5ZUjRHUS93QmFkL3c2K3hIK3EzOFJSd09Qd3U2MG5GeDB4akkvMCtwbEZQcDRSZGNCUFQwM2lMLzNqS24rOWQ3SGo5MHhwTGlQTTJRQzUwWUYvd0RlbjQvSERwMTRUSjVPYUl0dnFiQXZUdjhBaUkvWkEvMVhQOXFQUFE4SWV0U2Ivd0RDMklKSDZmTlMxL2ZtaUhoQjF5eWxoMDFOcU94QmxRRC9BRHIwU1BHM3B6VVJiTWRoYzN3amphbzh2ajcwckdOV3ZIaFNkSS81TjZkL3hNUHNUL3l2Si9CNS93RC9BSkxlSUV4RFI5TnRHZGdTMklqL0FONmRYd042OUNML0FQcThubUVFWE9ManIwTjBkNHpaQjF6MUxMa3VWUjVrMkxoaDg2U1NYQk1rS0xld3UvQUo5cTBQV0hWR0I2TDZmeFdiWmkybUNFV1ZiMmFSejlLRDcxRFB4MktFWEpsakIrb2RWcUplbmppbXp4cDFYMGZuZlErTHdlRnp6QnJnc1JpRU1rY2NjeXlYVUd4SnR4Vk1HOHdrdkFxZzdnRDJxMDZoenZIOVZaL2pjOHpOaTJQeFQzOHZWY1JwK21NRHRhcXBpUnBKR21UdVI3ZTFjemtVVkpxUFI2VHBuT1dGU3k5aUNRNjNDZ2FUc0xkNmMxZWdFclp1Q0RTV0I4MWJIUXJiM05LZU1YTDJibnMxUWxrck01S3JCNVpMYW5ZN2loREY1VUFqTEtEcEJOaHpUZWZTcTRqZGtlTThhV2ErMTZlSzZZd3pnTStnQUJPUHVhQUtUcXZESEY1UEtzcUJrTGZTVzRzTnE0OWxNLzhBWm5VaGpiMGx3cDVzaCs5ZHR4MFpudzV1RUFzV3VSZmZpdUpkWDRFWmZueDBYS2tpNUhCK0swY0R0YlRtZkx3MnlqbFIxdVZobUdDaWFCaEUxcjJMZXFzTjFOaEhCSmtCQXVDTlhKdFZ6a2VhcGpjdWdETW11UFlvMnhKcURuK0hZd201MXU0MnYrbmZnVTJLMjVLRzU1eHk0VklrOUs0MHlGZFV3TXh0ZS8wL0FBOTY2YmdKbUVLblh6c1ViWTF4Ykw1V2pWWkZEQU55UnNRZmV1cDlOWTZQR0pHR2xET2lpN0x1Q2ZrMUZuVk12K056Y2JXYkNCaEtnVmJFQWJMZm43MDRKSFZBaElLV3NiZC92VWFGeVkxYlJ6YzdiYWpUNVI1aXAwRFVmMGpnVlZONFZadkw4d0tDVHNDS1pudzE3MkpTMjRQelMwZXdkQ3VwbDVLQWdDblpQNGtOdFN0YnNlMUFGYkpFZGd5bG01NTVwYlFnRUZrSGxxdmJkaWZpcEdobklHb0xiZTQveXBKUzZrNzdMd0tBS2NGUStKdzJMWHo4RmlrTUVzVWhzSFJoWWcvYXZNSFd2UmszUVhVK0x5T2NuRUNLMDJHbVhpV0p0MVA3Y1Y2dHhzTFltT2ROSUd0TjlWYzk4WmVsSDZzNkxUTU1JcGJOTW1Ca09rZXFTRzNxVy94emF0SFI1OWt0ck9RL1VHZ1diSDYwTzBlZFViUzl1TGJVOHBCNTQvdlUxR1E2YTFCMGtYdVNDZjNvSXdERVcyOTYzVHkyVjJPeUl6cU5BQWEreEhJcTc2QTZxbTZTNm93bUlVTE5ocDVVZ3hXRmszUndUczl2N3luY0h0YXFOVlVOc0FlOWhUZUpnTFErWkh1NkhWZjJ0Mis5UnZsRDRTNVI5UnZERE1OT0Roc3hjNlFMbjJ0Y1YydkFZdStGUTNyeW4rSGJxYisyZWs4cXhDM1dPYkR4dGN0YzZyV04vd0I2OUs0SEdEOHNtN0Q3a1ZSaEt2YWFXb2pkU1BpbWR3ZVZIQkI1dFFCMUxjRStuK3RKQnVkL1RmZWd1eXNLdkdZdXpzSDRWQVAvQUo3ZEdCWDB5Zm53UU9RQmFoMTk0aDUzME40eGRYdmxHTTBZZisyOFg1bUZrRjQzSG1mMFB6Ui9oTVFOK0lIb3drM3RqQi8vQUttc3A0dmd0NG45WU9XL2lObkdLdjdmOVExTzFGNCtSc1pTak4wZWlmREw4VEdWNTQwT0d4ci9BTmxZODJYeU1RM29rTi8wdlhvWEordkkyUmY0bWdPQjlXNS8rMWZMdlp3RllYSVAwLzYzN1Z0K2ovRjdxZm9nSkZoOFkyWVlKVHZoTVd4Tmw5bGJjaXFNc1gwWEk1L3Mrb3VVOVpSelJnK2FwSTJOYVhCZFVSenI2V0YvaXZFL2h2OEFpU3lUcU5vc1BKaURsMk9Kc2NMaXlMRS80WDROZHp5bnFvWW1NRkpydDN1ZE5xalZ4N0prb3pWbmZGemxWak41TmdMaTlZM3FuTTF4R0V4eGYxQnNMTU5qL2dOWjJMcWZYR0k5ZG5BdnExWEZSTWJqamljSGkwRDZpMEVxODl5aHAwNTdvMExoZ281SS93Qm5rM0Fyb3ltRFRjai9BQmRxT09VSXgvaG14SDdWSHkvRUpQaE1OQzdhU0wyUFlXTk9LV2FjcXNvRndlUnRXREs3UFdWSkxIRkU3Qk1Yd2tNamFkQ3lrSFNkeDk2c0ZZT0FwSjE5N0hhMVVHRm0wUVNocGRQcUd5aW5ZTWQ1TGxXYnpWQitxLzAweG90UW1sSGxsdVl3SVcxZWx2YysxVStidVpZMVFHMGprRG5nWDVxWW1kNGVkUVg0SE8vYXNwMU4xL2srVG1TWkpQenM0VStWSEhiYjcwK09PVXVpdnFOVGl4eHViSlhWT2U0UG83TFhsa25WcG1GbzR3Ti8zcmliWWpFNTltY21OeE1tcHkxZ2piYVJmdFNNNXpiRjlUNW5Kak1ZNW5MRzRVN0JSN0FWZFpGa3ZueWVXUUczRHMxOXROYk1NWHBSNVBQdFZxc25rTXV5UDRvMDNTR1hHS0pzVSt6b05LRFR2V2drWUtpa0tDdkpYZzNxUGhsalRaUFNMV3ZxNEFwZm4rZFpWRE93WUM5dHFxVGJjclowT25nc1VWQkNsZDU0Z0NwQzN1UUQycTBHS2pObEFzdHVPOVJvb0dqZExrSUdOeUwvQU5LZUVZRWdEZ0Z5ZlN5OFZESnI0TkNGeFhJOEZLeCtsQVNlTE54UXNSWWZXYmIzTkUyNUFBdHE3bWowSWdQcTlmQkE3MUd5elhBclpXR3ZVd0c0WDNxaXpxVUxIcUNhZDlSREhnQ3J5V1VqQ2tGeXBCMjBnSCtkWmJxeWZ5WWRUS1BVdnBLTWR6ODFMaFh2S1dzZTNFUWVqSVB6T2F5WWhSWWVhQW9iNmJXdWIxMHlOZ3QySXVyamEzYXNQMEZoUW1YTE93SWVSbVlLZU9iQzFicUlHSWxTQVZKNTdpalBKN2hmR3dySFkvRURHR1VOcnR2ZWtNR1paQnFzTDNzZTlIRXc4a0lxMjh3L1VEUzVJeTBpblVvQUZnRFZRMjRrSEdNR2cwUjNWaTNJN1ZoZXNBMnB4Wml4V3hzTEFpdDNpR1lxQ0FvWWdnbnRXRzZyMG5XaFo3dUNHQjJIeGI5NnZhYnVqQThtdll4dncyeFlnek9YVVBRRjJCOTcxM0REekV3eHZJRHBZZW5WdmF2UDNSTTZ4WnEwWnNqTnBiVnZjQUh0WGZNTVJOREhJZC9NM0REajk2VE91Ui9oNWJzVzM2SE1SRTVrVWh3VnZldzJxWGwrSTFFdjZ2U3dZV085eHVMZnVLaDR0Ukhoei9FS3FQMG4zb3NKSzBiQjdEUVI2aURjZnRWZURxU1pzWm9iNE9MK1QzTDBWbjBmVkhTZVU1b25HSWdWbkI1MUQ2aC9POWNteUIyNk84VjVjQXllVmhoakpNT3JzZnFobDlhRS91U0tzL3cyNTYrUDZleCtWdWJqQ1RCNGdPZERDKzN4ZW1QR3pBUGdNK3kvTklsQ3RpSXg2eWVYaTlTMy9hdSswZVQxTVZIZy9sY0wwK29sL0RPem45Ulhad0RzZnRXWjZBZ0tZREhTdHRJK0tjbS9zTzFYZVQ0NWMyeWpBNDZNaDB4RUtTQmh6Y2plb2VYNFU1UG1XTGl1V3cySWJ6a1k4S3g1RlNWWEJrWk1kNW9aR1c1Mm9DeWdEWWU0OXhRTnZqOXQ2bzg2WTRuT2Nyd3l5c2d1MHNtZzc2UU5xYlZsck5tV0tLWmRoVkd5aXlEaTNhcVhMRWFicVhNcDliZVhIWkZYVnNUYmZhcmxtQWpMRHNDYXErbWsxWUo4UWZybmtaeWZqZ1U5S2l2a3Q1c2FpV3grT2IwMU5pSThPcStZMmk3V1UydmMwNFJjVVRJSkJabEIzdUw5alViN0w4bHdLdVF2dGJmWWIwakZZV0hHeGhNVkJIaVZQQ3pLR0g5YUxFT1k4UEs3azJWU2RxZ2RQdkxObDRubGxhVm1KMDM3TFNwTkt5Q1dTTy9ZMVpBekR3OTZjemRsL05aUmhYWmVHUlNoKzIxVmtuaEIwN3BaWVZ4ZUcxOW84UzFoK3hyYUVraTRBM3BFVE0wZXAxME44RzlQV1NTSFBGamIvRTUxbUhnZmwrTlYwWE84d3c2TnRaVlI3ZnpxbHhINGE4Sk1RdzZ1elJkUDkzRFEzdFhYMm5BWXhqMU1PYlV6aXN4aHdLQ1RFbnlrdmJVZTlIcVNSRkxEaFhhT05ZbjhMV0J4TU1NVDlaNTRJNDNMblRoNFFXMzROS3cvNFVjakFaWitwYzd4U0Z0V2x2TFc0OXRoWGJRUTRCQnVwM0ZSZnpYbnVVdzYrWnBOaWIySDJvOVdZNVljVCtEaytHL0MxMGxBQURqODRrQU43Zm10UCtWVDRmdzNkSHhOZlZtNXVOOVdQYXVpWXJOWTh2ZUpjV2pJWlhDSVZHb1grOVQ3N1U3MVovWWtjZUY5STVvbjRmT2tsQVVITlNPTjhjOVMwOER1bkVoYUpaODBWU0xEL25HUCtkZEF2UUJ2eHZlbStyUDdKUFF4UDRPZVMrQitSK1VGL3RETTRnQVF6L21iYmQ3MytLNHQxQmhNSGc4ZmljSmtFbUl6V0I1eGg4dWp4TzdTeW5ZMlBPblVMM05kbThUT3I0dnk4K1NRWWp5MUVaYkc0aGR0QzJ2bzFlNTcycGp3bTZGL0xNblV1WXhoSjVvd3VCd3hXeHcwUjNMNzhNM1B1QmFyVUp1TVh1S0dURkhKTFpCY0Y3NForSDhIaHgwdTBFMDBjK1pZbi9tY3h4ckRaM3R4OElvMkgydlhuYnhuOFNHOFJPbzJnd0wzNmZ3TEZNT2w3TFBKd1pqOWpjRDRycEg0alBFbzVmaGYrRTh0bUtZdkVxRGo1SW05VVVaLzhNSDNJL3BYbnFWMUEvaDJWRGF5S05oYmEzMnJrdkk2dmMzQkhyUDZjOFNzVUZxTWkvb1VDck94VUVNTGVzMDFJQTVOeTdTZzMxVzJ0UmVhN3lxeEpSUWZwQTJwU0FsYjJJM0pMWDdWemJaMzhYWWhMQmdyZnFHdzlxRGxYajhyMGdIZlZmdlFhOHNxc0JaUUxYR3hORkxyalZVc0NMajloOTZhU29vczNkTVRpMER1UnAyOVM4MU1EdUNFQTJGck1POVFNUzV4T2RHRjlPcGRsUGFyTnJYNDVPMXFBWGRrYkV3WWxta2tRV0FYMWFSZm5zQlhKK3VzSUk1SkVLRUVIVXFBZlQ3bTlkcHcrcUxjQUFIL0FCZHU5Yy82dHd3eFV1TFpJMjlSSlFrZlFLczRwVkpHUjVERThtTnRHSDZZeFN5SXNMV0trNnRZSHFGYURGdU1SR2dVa0N4Qjk2eUdUSWNITWlzMjZ0YmZaUld5eENERUlXdUl5UnZvK0t1NUVrN09mMDdieDdXVUdtWEN5c0ZLdUcwa0MvQUEzcldkSzVzSXY0QkJNSmNXVWZVTDk2ek9LaldSVlpGWUt1NEo1Tkx5ekVIQzRsWlRJek5xR2dmNzFISldpWEJrOUhJZDJ3R0lVcUFDMTFTeXF3MnQ3MUtEYWJIVUJ0dHZhOVpycGJOMHhVUVVTRDZkTmp2djN1YTB3d3IrWHVML0FOd2pnZnRXZTFUbzdISFBla3dhbE5pRUpQdUtKaVFyTUR5M3R1YWRUQVRCK0FWMjRhMUxWR2lRa2hQcTJITmhUQ2RxbU1TRm5VUDVmMGp0U1ZIbWhidjZqY2tXNEZQbFN6Z0lmVUJkbFBla1NScXBzbzUzMjdmRktLTmtpek1OdEl1R0kyUHhVUkhYTDU0V1dKV2prUDhBRkRHNEtubTQrMVM1bGVMYzZXdnNCN1V4TE1oajliQkYvVWJiMnB5bFV1Q3ZsVVp4Y1pkTThzK0ozUnc2SjZ5eG1EaGN5WlhpRCtZd1V0cmVodHl0L2NFa1ZsU05EQUhqM3JzZmozMUJsbVlaZGhjdFJHT1lZTEVpUkd2Y0pHdzNCL3pyanJCVHNMMkl1dGROZ2s1dzVQRnRmaFdIVVNoRHBBaWUzSklXMjJuZWx4bFl3QVd1U2JoTzVyUjlIZUhtYWRhSTJJdzVpd2VYS3dRNHJFQStvLzRGSDFWMFhCK0YyRjZmd3hhS0R6NWdwUXpZcjFEYmZWYnNhWlBVWThmQk5wZkZhalVlNUtrZEsvQ1QxR1orbVRsVFdTWExjUzhkdFhyQ1A2MXVQYXZabVdZc1Bnb2pjY1Y0VzhKVW02VThSOERJMHZrWWZQOEFDNkF2QWFTUDMvWTE3T3lMRU0rV3g2WDBnYkVIM3JPYzA1Ym9sck5nbGhleVh3ZklUYS83N1VDK205eGNVYVdIUEhBK2FSY0c0QVBONjFtYzh1enNuNFNXWWZpRDZMMGk0T01Cc0J6c2F5bmpTNFBpajFibzRHYjRvQmU0SG1IbXRSK0UyQXlmaUY2SFZXS0E0OGIvQVBsYXNsNHZ1a3ZpVjFhVjlRT2I0b2FqeWY0aHFmOEE5YUkxK2JNWUNQc3hwUUxYNS9sVFpVRWM3ZTFIdU9OaFVJOFU4WWtkZFEyRzRQY0d0LzBQNDFkUzlGdEhHdUliTmNDcHNjSmlHMy9adWE1L3FJMDJ1ZDk2VlpkVi9xQlBmM3BHa3g2bTQ5SHNqdzcvQUJFWkYxWElrUnhIOW40NGJIQjQxd0MzL2FlOWRieXJxV0hFNGlJR1VGSlVjQmwzQjJJdFh6eTZQdzhlSjZyeTlKSXZOQzZuNHVkZ1RXM3lEeGc2aThPODl4V0d1dVo1WERNUU1KTWZVcTN2Nlc1RlFTeGZLTGVMTmNsWjBFcEpoQmlvM1VlaWVST2R4WmphbW14OHNhSzJzcVFkdmMvRkhnODJ3M1VXWEhPc0dyUnBqNW1sRUVnM2kzdVFhYm5NZW94dWJFK29HL2VzcHFwVTBla1lzamxoak5qMzlvTStGWm1pZU11ZU9CdDdpbXA4WUl3cTNYY1dzTnRxYWl4OGp5dXE2WFFqZS9KRnJXcWl4Mk5od2tLcExONVlVSDBydWRYYWxVTCtDUExxdlRqYllNOXp1UEwwUlhjeVdVbFY0S2srOWN5elRHdmpNUS9yL2hnZnBBc1RlckxQOHlPSmsxNjcrclRyUE5Va2NTdEl2MWIzSUgrdGF1TEVrazZPSzFtcG5uZFh3VDhxaGZXcEs2UUI2aVBhdWlaSEhGaHN0MUloVjVOZzUvWFdWNll5L3dBMlJXS0IyVTZwRkozdDcyclpwaGRiZ2xpRnRmZmdmRnFoenp2Z3Y2REZLSzNEMGVHa3hFa2JYRU45ckE3bXJiRFJlUUQ2ajhYdFVORVZGMkZyRzFnUGVwY1VkdzEzUUtPQ1R2OEFZMVFseWRKajRkanJ0cTJaVHBJdnFBdlRxYUpHUzRLbTE3MzJCcHRKUzQxRFlBN2p0YWxrcnRvSllmYW9XWDAwK3h5U1JqNlFOMnNMMzVweWIxS0dqSlFBQUc5UjBkL09CQTlQSnVPS2NtdnVwSXNSdVIycHRFdS9nUk94V094SXMzb0pOWkRycGo1R0haYm1acnBwL3dCYTFja3FrS1ZOeUFkdXg5cXgyZnVjUmo4RERzUVpOWkEzcXhoNGtaZXRsY0ZFMTNTY0J3MkJSV2JVRlFCUWZjZTFhUUZ3ZFcyd3R2M0ZWK1V4T21GVHpMT1g5UWNENmF0RmlES3lNeEtzYmF1NHF2bGxjdURXMHNkdU5Da0NpTldBREMvQm9wRUtXZFFqamNXSnAxU0xrQmZUSHNMZDZiZVJWZC9NVmdDTnR0cWhML05FUm1JVGtOWnRsNHRXTTZzMUh6R2RGV3dJWFZ6V3dNUXVVYSsyL3dBR3NyMVByZkR1QWIySlVKYmYrZFc5UHd6RjhqN3NaajhteFA1VE5jTVYzVXlCU2JYdUs5RDVHUk5oQVl6ZE5JTjY4M2hqaDhWRTQxSXFTQTdtdlFQUjh2blpYaGlIc2dVRzY3Mys5V05SSGhNb2VEeVhLVVM4QjgrUFVUdHh4VmFwTUdJTWFsZ1J5M0l0OXF0VlpkV2txQ0xINHF0eHNaTHFWajBNTDZqZnRWQ1BaMWMxd2RkL0Q5MUIvWmZpRGc0R2UwT09qZkRTRzl2VUJkVC9BRDJydVhqSGxyWTdvbVhFSkdIa3djaXphZTVXOW50K3hyeVIwdm1VdUJ4dUh4bUhOcDhQTXN5dDdLcHVmNlhyMi9Jc0hVK1FGT2NObU9FRmlPZld0LzhBV3VzOFhsK0dlVS9xZlMxTGVsMll6d056YzQ3bzE4Q2JpVExjUzhGanlJajZvLzZFVjBGNHhLdWwvVXZ0WEUvQlhHbktlcWNibDB0MWVTSTRlVlc3elFNUVAzSVA5SzdacS9ldHJNcWtjVmhlNkN0QVZQTEcyOVFNUGxUSm1zdU9ra0JaazBJZ0gwaXJHaFVDZERwNDFPbS9najQ1V2JCWW9SN01ZemI5eFVYcDFnMlRZWFFicUJwUDNITldOdS9KOXFaVERmbDk0UUVWdVVIRi9lblhZeVdML2FzaUpGcUltMUlWbjFXSy92ZWxuWWk5TitTeXV1U0Juay9sNVZpYm14ZE5QM0pwM0xGOGpMNEVLNlc4c1hBNHFEbjFwbndNSEplWUVnZTFXNHZwQUE0MkZTeS9HalB4TDFOUTJKODlGWVJhZ0pEMnBSMjdjMGxsQUlQNnY3MXFXYkVDNDJIRk1YREw5Y05GTmtlT1ZueEdFbTlPTEVwWWx1U08xcXRNVGhvc1hDWXBWRG9keUdGd2ZZMVg1emthWmtSUEMva1l4TmtrWC9XcS9JdW9aMHg3WlJtYWxjVkdMSTkvcXBaTGRSa3gxRDA4MWl6THZwbWhtVXJocFJGY2tSblQ3amFzNzBMbThPSnkzOG03aE1iQzdGMFkyTGVya2U5YVk3RUhteHVEMnJNWi93QkhSNWhLY1hnbWJEWTVUcTlKc0dQK2xJTHJGbXd6V2JEeXZvMHMwYVRMNm8xMGhnd1U5ajcwcjlOaldiNld6N0VZbkZTNWJqb3ltTGhHeEkrcjN2V2tPeEFHOUJiMCtlR29qdmdnaWJDOWp4ZXMxMXYxUWVuc0Q1R0dLbk01Z1BMWC93REZyZmVRMWJaM25XSHlETHBNVGlDRzdSeGptUnV3RmN0eTNEWXZydlBYaG1rYU9aanF4czZqYUJPUXEvNHVCL1dwSVJWV3hjay8yeDdIZWlPa0IxTG1qWTZkWGt5N0N5Rm1hUVgvQURjMStiOXd0YW54VzhSWVBEcnBxVEZyNWI1cmlMeDRMREhscExmVWZoZVRXZ3pETU10Nk42Y214YzVHRXlyQXhYMHI3RGdENUovblhqN3JqcmJIK0lmVUUyYll0U2tCSlhDd3NiTERIZjBqNzI1ck0xMnJXT0xpanFmQWVJZW9udnlMaEZEaXNYaU1maXBzVmpKbW54czdGcHBpYmx5ZWQ2WWNpTkFvY2tkN252VGpUYVhLbFQ2UnVQbWtPVUpVc29La2Z1RFhIU2s1Y3Ruc2NJeGhGUWdxU0NVeUNKUllrZXhvRW1QbVhlM0o0KzFKam1BQnZxSjdHL0ZLMXJJRkRQZGgrbTF3YWhKYTRDZmFSbUJPc0RheHBMdXp4dTc5bHRxN1hwVWZscUdJQkxzZXdxTmltWllYdEdESVFkcjdBZTlBRkpsNVhHWnRJSEYzQkpOMS93RGRxc1poNUlVT3pFRmlQbW9YVDhpcytJYnpMeU51RDNOU2NXK255dzFodmRRUGVrWXNDVWRBd2V1ekFjcXAvd0F6V1Z6NW5XTzlpdnFzZDlpSzFFcmxzdWNLMnByaS93RGhxaHp3aWZBSUNOeVFCdHhUb09tUlprbkJwbk1NVGhVWE1aNDJOZ3pXMG5qOXF0WXNScFVCZ0NkSUd4NFBGcVJuUURTSklHR3B0eVFuNnFHVjRnWW1Kd3lyZmxOSXRjZzk2MUh6RTQ1TFpOb2o0Z0dNS3FuUXczR3JlMTZoZ0hDeU5wamRKTldyWDgrOXZhcmpGaFBOQ0JmVXYxMjN1UGlvbUxtRWI2Q3VrTHVtL0ErYUl2N0daSWZ1TlYwaG1tbUJRTFN4bHI2Z0xhVDN2WFZNcngzbUlpZVpyWFQ2VzdpdUQ1TGlId3VKTXNjamEyTmxWZnBCKzFkUHlYSHF5S0pHSzZTQXlEZTU1dlZMTXRzclIwbmo4M3F3Mm0zRXFrbU5pV0lON0tmNjBod3l5aTZXVTNJSTcxWHhZb3ZjM3RFVFlTQWJrZTFPWWpPRGhJYkFLWWkya1g1UDJxQ2pZM1YyU3lEdHFGaWVCNzBVa2JoN1g5WHNPOVpaZXZNSzJML0x5M2k4czJWbTRiOTZ0NHMxR0tJa2o0SDZxR3E3QlpJemZETEFtT05nZGl0aUdzZjYxeTd4UDY1d3VSNWZOaDhOTVpjZEl1blNDTG9wN2tkcTNmVUdkNGZwL3AzTWMyeElUeWNOQ1NQZDNJOUkvblhrVE5NMXhPYzVoTFBOcVR6bTFrYzgrOVh0TGc5UjdtY3Y1cnlQK1BEMG9kc2tZM0ZZakdaZmo4ZGlXTTJJbm5VTTNzQU5xZDZSNmVYcWpQbzhITXhYQklQT3hEZHlnL1NEMnZUV0oxUTVBdGxJVnBoZGozMjlxMkhnN2d3WnN4bEFHcTZSaTR1RHZjMXJ6ZnA0clJ3ZWt4UFU2eU1aYzMyZHh5M0J3NEhENE5JSVJCaDFRcEdpRFpGN0QvM3pVL05jSDVtRE1TS05FZ0pKdjhWSWpqbFdQQ2hvaWlXSkVZT3lVNnlGRWt2eFlGYmU5Y3pKdVV0elo3Rmp4eGhGUWlxUmplcW9ueXpMT2s4Y3NOMnlyTkVMV08raC9UWHEzS01iaDF5K0krdE5ZMWhUMnZYbXJxVEJTNXAwcGpNTkRFR2xKamxWQ2JicXdQTmVqK2tmTXh2VHVCbFVKdkV0dzRzUWRJdUt1WTVibFJ3UG1jTHg1Nyt6NVJwSVdEQWpZbTlBRXFMWElCNW9sR3I2ZUtCNDM0cmZPQlIxL3dEQ2UyajhRWFF3YTQvK29nQWYrVnF5Zmk2clIrSlBWNk1BSFROOFVEYi9BUEtHdForRkFELzlJTG9RWHVUbVNqZi9BTFRXWThZMUgvelI2dkIyUDlzWXNMZjJFaHZVei9CRWEvTm1IQnV0NzcrMUdEWW05QmJhUjhVQ2JBQzFRancxWUVqU0NEelJnV1cxanViaTFFcERiRTJ0UVZnQlk3bWdEUzlCRjF6L0FCRTBaS21IRG5lMjkyYTMrdEgxVmhGano2ZlR1SkFEenZjamMxTzZJd3h3Mld5ekgwSEZPUlluY29PUDYwdnExQXMrR24zMWlLMnEzTnFRZkZXelJlR0dLTXVSWXpDTXovOEFMekN5My9TZmI5NnRjMHhRdzgyN1dJOUlKOTZ3blJPWWZrOC9rQmJUSE5Ec0NkbUkzRmFETkFtSW5rYlZjeUFNMWp3ZnRWQ1dQMzJkaGgxVGxwMUZQb1BGNSswSWdLRW1VWGpZa1d1UGlzN21tS2tPS2t1QzRZaDdYM0ZMelRFckVDUFN6aGcyOVU4a3h4TCthejZtNDJOcldxZU9QNU1qVWFpVStMR3BnWGJVeDNITitCUzhIR29Za05kUU5pRFMyVFd4UEYrQjcxT3djWkJBc1RlMi9ZVlBkRkZSY21qVzlOTEhIRzNtaFNYVWFTdXhQNzFvaVZqaklVQUw3RTNOWnpMU2tiZVc1SlRZcjdpcjJOUWdZZ0VxTzdEZXMzSW01SFlhU1czR2tPaDBWTEdSdE94c09UVW1Ka21pT2tLUjgxV1M0eElCZHlJbTRYWHNMMUh4SFVlSENvWTNXUjdXS0lONzB4UWJMa3M4SWRzdkJpQkdRQUN4SXNBTzFLL3RHTkpBbW9DMjdEMnJONGJHWXJNSk84Q0cvcnZiOXFrdEVrQzdBbTQydWQ2YThZTFZidVM2R08xUnNVSnQ4L2VuSThacVJtREtwVWJBQzk2eitLeHd1RjFsaVJiWThVckQ0MHlPZ1dPemQ3SDJwTmdxMVNMakY0bEpVc2pYa3RmWWUzTjZ6R0hkYzB6MUhSWDBLTEU3QUUwN2lzWXNTekZtYUxVRHB2c1NhTHBLRTR0NTViV2R5RlZTQmJhcFl4MnhiS2tzM3I1SXdSMFhMVldPQ0RVV2lUUWRVYTc5K2FzQ2hXTXNwdVZPOU5ZY3hxc1NGejZVQUlIRlBBMlpqcVAxYkdzeVR0blk0b1ZGSU5IVjdnbTI5emFrdXR3ZGo2bHNOUjRwYXVpUFlNQXRybTYwbWVSWlltVUgxSGNON1V3bWZSQmRwR2lKWmd0d1FMMW1lcEZZWVc0dnF0ZlNCOVFyVE5JNWpCMmtLaTI0clBaMk5VRjk5WTJ0ZXJlSis0eGRkRzhiYU9jdEhkN2crZ25jRTcxMjN3MnhXckpZSXlBSXdDQUZQZXVMNWhHRW1CS2dBRzdOZXVvZUZHUEp3RHg2U2RJdXZ4VjNVY3dNUHhFdG1vYU9tZVo2d0FDVkk1dFVUTW9DK0hEVzFPYm5RZWR1YWxhWkVRRU5zUjZmYTlNNWdyR0VBRWxsVWx0N2I5Nnl1anVYVmNrYktzYWduS3NRQSt3UEg4LzUxN0Y4Qjg2Yk5QRG5BUU8ydWZBRTRkL2NiM1grbGVMY0RPc2VKSVpRcSt6amV4MnIwYitHVHFFUTV2ajhxZGkzNXlFVFIvOEFjbTMrUnJhME9UYmtPTTgvcHZXMDdsOUY1MVBoUjBmNHJUNDVRUkZpM1RNWTlIMUtTZE1wL21LN1NDR1ZIVTJSeHFGdlkxenJ4b3k5ZjdPd0diQld2aHBHd3NwWG55NWJEZjdFZjFyUytIK1ovd0JxZEk0Snp0TEFEaDN1T05QSDlMVjErWGxKbmtHQjdaT0xORlFvVUtyRnhnb1VLRkFnUUZyMEczbzZGQURFdUNpbW1qbVpieXhtNnRlbjcrbyszYWhRcDkzMk5qRlF0eCtSdG1rTHBvVWFMN2swY3NqTElpcXBZTWJFanRTaUxtNU42TWJMWUcxTkJSK1FyN0hhd094djNyTzRqQ2pNZXNjTk5ESFlZS0krWk1lR1k4TC9BSjFvU3VxOXpRUkZRQUJRTjcyQTVOT1Q0SU0rQlptbS9naVk3TlljQmo4SGhwdlFNVnFDdDJCSGI5Nm1rMzl4WWNuYTFKYUpXWlNZbGZTTERVTDBuOHNwdmRTUWYwNnRxQ1hiS21teWd3Y0F4M1dPSnpHS08wTUVYbGx6c0pXc0FUKzFxdjVwNHNMRTgrSWs4dUdKUzd1ZUZIdlNsakNLcVJvRlJlQU9BYTViNGlkWURNSmpnOE1TK1hZWmo1cGlQL1hsNENBZHhmOEFtYWxoSDFDcmp4clJ4YVhiSzdxSFBNZDFqbStFWEJ4ZWJKTEtVd1dGQjNVZi9qSDlnQnVUWFR1bCtub09sc3NYQ3h1R2thODJJeExjeVBiZHlldzJxcDZCNlBicC9ESEc0dFFjeXhLajB0LzRLa2ZRUHZ6WE8veEJlS0V1RWlrNlZ5aVVtV1ZiWS9FUnRZUm9mL0R2N24vS29OVHFJNFkyYTNqUEh6MWVaY0dIOGF2Rkp1dTh6T1haZXpESU1FNVVPTmhpcEJzWCtWSGF1Ymxpd01XclFEdWZiYWxXMEtxT0JwSTJ0VGI2MFRSZFN2YXVIelpubWx1WjdocE5KajBtSlk4WTBUNXJzaFpnZHVPTDBoSE9neHJhNGJjVzNKcGVKUll5VHFVOXJYdlNQUXBCVWtudlkydFZXeSt1RUowK1NXMTJzT2JkcVVIVldJQlZ0aFlpaWpBS3N4VytvOGFxVUlScTBSbFNvOXFhS0hjT09iRWNkdDZxODJkc05ncFdjQUZqNmJHNXZWaThpNmRKc3d2dFZSbjFsdzRWUHF2ZlVhQWY0aU1vaUJ3WUttMm9YWWtXL2xReEtxdzlBTEZmcEpQZW5jTGI4cEdIWTdKYXg3azB4S3B1QklReC9TVlBGSXg4ZUlralVIeXVaNDdBRDZqMzVxdHgxcG9XUVhEU2paanRhMVRvcEEyQ2wxa2xVVnZvTzE3N1hxcnhNbm1STnJiZGhiN1hvWGFJc2xOR0p6RUtBK21TeFVhdGp0ZXFyQ0lVQmxpdUkzQlg3RWNtcmZOenBCWDZSWStvN0ExQnk2VFM5bVh5eTNwdU9EV292eE9SektzdkJPbmlsYUFOR3dkMVc1SjJGVk9PbEt4SVdWaTdqNmdMZy9GV3lRcExxU3hjYmozM3FrekpUbDBxTEkxbEs3VzdiOFU2S3NpemNSc1VtSlNLT01zN1J5WHV5V3NmMnJjOU81bzRnakpBMDZoY242N1Z6U2JGUnl4RldWVWFQZ3F2TlhYU21iQ0NWRXY1a2hZM0hjZXdwTTJPNDJobWgxWHA1VWpzOE9KVklGRzdLRzJIY0Q1cXQ2bWhmRndKTVpHUkkzQWZUeFkwakw4V1BLTWlONkwrcTR2djdWYmlDUEg0Um9aQ0pHSTFLcDJCYnRXYjArVHRYL3Nqd2N3em1KUVRHa1Brc0RxRHNiazc3R3JISmVxbmpLS1pVRXlnS3dUNmYzTk45UlFZaUxGckhpYktOMUJWZS9hcVJjUmdzTENYZDlicmZXUWJLRDhqdlZxTWZVVkhQenl2QmxxelUrSThlSzZ3NkYvc2pKNEh4V094R01pSmdRMnVxM0ozKzVyblhTZmhibnN1TWVITXNxT0dqdnBrODl0SlVlNm52V3k2RTY4d2E1MDhHSXhINVNGNC9STWRsRGovQUNxVjFINHM0cDg3WExja0J6WEdTTnBFS2pVRitmZ1ZKQ2VUR25GSXJac0duMWVUMXB5Nk12aVBDWEFZQkpZc3d6VEVUNGN5Z3hwaG92WDlybXRqMFQwUmcrbDJ4ME9IZWFXTlRxUTRpeGNFamU1RmFQRHpZcUxBUjRuT3NQQkZpRWladkxBL1VPOVM4alZqazBHSkp0TE5xa2sxYzNOUVMxRTVSMnMxdEo0L1Q0NXJMRmNsbmhuTFlXTUFraU5idHZjMi93QmFXekJnZ1FsVS92SGNmdlF3UUx3SXlnTTJ3UUtPL3dBMGd1NitaR24xbHZVbHVQbXFodGtQRlJ2aVlaRVdVTHEyMU1kS25mM3IxQjB0Z2NPZW5zQU1VU0poQ2dKVVhEZWtiaXhyemZERWt1YzVmQTZxY1BOaUlrZU1pNHNXQU5ldk1KMDdMazhDNFJNdncwOFVlMGJEYjA5aFZ2QkZ1eml2MUJKUm5FK0xxZ1hZbmIySXBKNzBzN2pmMGdlOUFEdllnZkc5NjZGbm1oMXY4S2pLZnhDOUNiR3paa1BwNUIwdFdVOFdIT0k4U09xcDIxTXo1dGl6Zi84QWV0ZXRoK0VlUFYrSXJvRlhVVy90SzkvL0FDTldPOFRCcDYxNmhVRWtybTJPdWY4QTkrMXFuLzhBV2huN3pIRFlXN0dobzFYQk5FUC9BRm93TzE3Zk5RandCVHhjajVBcFRGaURiZSt3RnVhUnAwOTcvRlczVEdBWE5Pbzh1d2hLaEdsOHh0WFpWOVgrbEFHNWd3d3k2UENZUUtENUVLb3hiKzhlZjg2THFmQmlicDhUSWhKZ25WU3g3QmhhblppSnRVd0ZpMGhZajIzcXp3dUdHWjRUTXNFekhWTERxVXR3Q09LamJIUmZKenpMcFRGbU1UaGRMYml3N2kxVzJNekpZVVpWQythMjk3OFZTNFpTa3BaanAwRmxIdmNiVXpLemVaY05jMjMrYVZKU05CWlhHTklYSTVsa1ppd2RpZFhOTHd5aVIyR202OS9pbWNOQzA4aitYR1ExdVR4VnRoTUlJNFV1UUw3ay9OSytBaEZ5R1V3N09OUnNWQXVEZmlyVEF4aFlsTml5M3Y4QXZUc1dGYVJBeEFVRVdzdzlKcDJOakJoV1ZRYnExd1U0cUZzdFJ4N1I2Sm5ONVkzdTQ1dU5sRkhQbmJScVl2TloyWlFTcGI1NStLZ3lZaytVNERBc043OXhSWWJBK1paNXBsUXVOVjJGTnFQeVRiNXJoQW1teEdac05hL1pYYmFwdUZ5K04xSmtmUklTTGozb1I0R0pNUUE4Z0F0WU1GSnFRWVlZRldPVEdSb1RkUXpjbW12ajhTV04zY3lkaTU0OE1nWndvQTlGd2RyZjcxVzQzUGZQZUpjT3R4SGNlWTQyL25UUWRIak1Ra1Z3TDNCTzMzdlJSNE9KUExKbkZqdHBUY1VuRDdKSjVXL2JFV2t5cExyZVJRVHNHUVhER2ovT09zOXhjQmw5QVUydDdtbzY0ZElDTkxrV1BLOGMweTJJdExkZG12YS94VGxGTWpjM0Roa2pGNGdrSlptWWdiTTI5NjFYUkdISzRXRUtwRE94YTdiVzNyRVl0aXRrdUpBV0ZyVjFIcGJDS2lSeHFDeEM3T1RzdDZoek5SZzBhSGpWdnpXelVBaEpkSitrN1hIdlQ0VUJnTFhVbjZhYVJXZFZKRyszcTdFMCtFMGgyWWNtMXgyckdPL2p3aEJpQ00yazNCN0ViVXhNeEdreHA2RkoxRDVxVGE2M0lLcVRwQi8xcGxrWWk3bXgzRi84cVFHUW5EaDlpQ0FMSDJONnBzNEpraDBxQnF1ZFArSVZieUs2U0JTb0JJSjFNZVRWYm1PSFl4QXNxTWx6cE9xMVdNZjJaV3BpM0ZuT01jbW1TUWVVd1lIWU4yclhlR21MYUdTUUt0N2tYM3RXWnpaTDRrbTRVWHZxUE5UdWk4UytFeGh0ZG93NEIxY0MvZXRPVVhMRWN4cForbHEwZDZRWGdGbTFNT2JIaW5wSFdXSXJhM1oycU5nSE1rY1pBRGhiYkR2VDBaUUdWQmNibXkxa05jMGQrbTVSTS9pblpNeUxxMXdRVnU0MnRYUmZDZlBXNmQ2eHlyR3h0c0psamtGLzBOc2E1N25FUUUwWnY1akgrUUh0VS9KOFd5emdnT3Jtd1d4NEk0cTFobHRrbVpXdHhlcGlsQm52bnFESzQ4N3liR1lObEVpeUlTZy94V3VwL25XUThPc2RveDAwSllsTVVvWUx3QTZiTis5WC9oMW5nNmk2S3liTU5YcmZEb2tqWC9Xb3NmOEFLc2ZqSVg2YzYwa1pDSTRFbVhFUnIyMFA5WDlhN3JITDFJSThNMUVQUnl2K0dkUDcwS0pHRWloMTNWaGNmYWpxT3FROWdvVUtpNW5tTU9WWUdYRllna1JSajlJdVdKMkFBKzlDVnVocmFTdGtzRUVkcisxNkw3aTFjK3hQVzJZWTkyRVduQVIzOUdrYW1JK2ZZMGpDOVU1cEFUNW1OV1pEMmtTcEhqa2xaRThzVWRFNzBLemVVZFp4WXBWWEZLSWJtM21nM1g5NjBhbTZnZ2h3MjRJNEk5eFROclJKRnFYUWRDaCs5NkZKUSt3VUtGQ2tDd0NnR1BBQU5BSGUzZXM3MXoxZkIwZGt2NW9nVDQyZHZMd3NIQmtmZTM3RGttbnhXL2hESlNTVnNvZkUzcmhzdERaRmw4aFRNSm95K0luRzM1YUk3YzltSTRIdFZaNFI5STN3ME9aWXFQVmhZV0l3RWNvK3JmOEE2aHYvQUVySzlBOUxZdnJiUEpwY1pNOG1Cams4M0g0bHZxbmxKdjVLbjJzUVNld0ZxN0oxVjFSbDNRblRzK1pZMWxqd2tDK1hGQ214a2I5S0tQOEFhcHNzMWhnUTZYRlBXWlVxNE0zNHUrSmkrSGVSRDhyYWJPOFZkTVBCZS9sKzhqZjRWcnlwTlBPN1N5eXlIRXp5c1hsa0ozZGlkeWFzT28rcE1kMWRuV0p6Yk5KU2NSUGNMRUcyaFR0R1BnVlVUTUkvS0FOeXczTmNUcTlTODA2K0QyenhQalk2SEN2L0FMRFR1UE1BOHNrMjR0YWptWFZDR0NBTDNCTkZLMGcxTUNiKzRGTnNHWkNYWm1CN0FiVm1IU0xnS1VLSkM0VWJIY1crS1ltZExnS1RyYmNFRFlVOUk3ZXU0QVVpKzVwa0t3ak1ZTis0SUhGTUN2a04xTGtPVjN0dTF1S0VJSktCQUZCdVRidlJDUGZVNXN1MTdkNlVHRWphVllLNmc3Y1hGQWdURUVrR3lOZlkvRlVlZXVzMkpoWFhaU0xxdnZWNU9GbGtTNmxsSTdiVlE1bHBseldBTGFQUmU1UCtWQVNmRkU5MVJVUzYyVlZGbUI1cUppVTh1Tnk2bU5yWFZlUWFsZWNqS1FGRGFXQkYvZW1abmtJbHQ2OVg2aDIrS1Rza3IyaXNDSTNqbVZ5RURyWlF5N2NiMVI0amZEU0JVOHdxd3RibXdxN3ltVXhPRWtVK1h2YldOcm5pcUtkbnc4azhBWVJ2Y2pVRDgwcTRaRk5WRm1ZemxFak1oRGF5NjZnTGJHcTJOTkV5dFloZnF1QmNnKzFXZlViYVVLcUNOSjVKM1g0cWwvdDNDNFQwdjlSQTFnN1ZxUlRjVGtkUTBzbkxMc2hIalN6aEpUd1I3MVVaNUFqb2tqTVZqVzRZRVh1M3ZUMkZ6UEQ0a0NTQ1pIalU2U3Ayc2FrdkZEaU1OSkhQWkN3SXVON1UzbE1aTnJMR29tTmVHUWtPR0RNTDNXMWhiM3B2QlRERFkxRzNjTVFHWld0ZXJQSDRaNFJvT3JRaWdhZmNkaldleFVJamxCWWtNU1FiOS9hcmlXNVVZV1NUd3lVanRmVHVKOHpMb1RITHFDbmprTjl6V3Z3RW1uRmpXTEFrY2ZQY1Z5WHc2emFWTU8wQU91TmRqRXZJK2E2WEJNa2NVY21xVDBjdi9wV1JtVzJSMytneStyaFRKL1YzVEM5UzVZOGNNM2t6QWFnNmMzN1Y1cXp6Sk00eVRIUzRQRTRlZldIdVdJTm4rYTlQWVhNMmpsVXJZUHNUdnl2dlQrWnd3NXFITFJ4TTVIMVNLR0lId2FmaXorbVFhM3gwZFUwOTFIbURKZWdzNTZteHNZaWhsaXd4Y2E4U1Zzc1k5OSthN24wcDByZ09ob1JCZ3RCeFRqMTR0bHZJZmZlckp6TGhFQ20zbEw2VlNNV0IrL3hVYVNWbUlBVWF2Yy81VTNMcUhrNFEvUitLeDZTTnQyeHJNUitmWmNNcmFpVzhvT1R6YzNyUkdQeU1Pc0d3S3JZdDJBSHRWTms4UnhPTWxjRWVYRUxLUitwKy93REtyZkV1MjVacnR4cXRWYW1iRVA1SFlkWDVVRnpZbmNGRGE5S2FkaGgyQ2JtOTJhL2FtQTJtQ05kTmdwQjU3ZTFKbG5LcS93Q21NZzJGTkZzbDVmT0d6L0tJNHhZbkdRYWlmYlVLOTUrVUNCYXgyRzlxOEZkUExIL3hCa1NnRm1mR3hBbi9BTXdyMzVHb1ZiZjUxdStPeCtvblo1NytxSnBaSUh3a2E3Y2dFZDZUWWhTQVRZamY0bzFGaHYzMys5R3BOaUI5UHNhMERnanJ2NFMzdCtJem9FZ25mTWhiN2FHckYrSStJT0o2NTZtbUEzZk5jWnFIWWZ4bTRyWmZoU0gvQU8wVDBBUndNeEczL2thc0oxeFk5WTUrRC84QTNIRm0vdjhBeFdxZi93QmFFZjVNemg5SUhlL05HUllYdlFDSFJjRDcwYXJxTmdRVDdWQ0tIR05WaURlL2V0ZDRkNFpVa3pIR09CZFl2SWlaaCtvbmUzN1ZrQ2p5U0xERWpOTzdCWTFBdnFZOFYydCtrWThoeTNEWmRoSmRheEtIeEpsSHBlVWpjcWZqaW1zUmxYaUlsVkFxZ2dIbC9ta1E0aDRNWGh3SGEwaktoRi9jMC9pb1pJY0xMSE1DbkRFbmptazRhMzVoTHFHMHNHWDUycGxXSXV5TDRsOU1ESU02R0t3MFIvc3pNUDhBcFNxUFNKUUJyVDdqbTN6V1Bod2ZtNzMwRUg2cjMvYXZZblRQUjJXZGVlRGsyVlp4aFBPd3FYeENPZlEwY29GeTRiMzdWbU9rZkFUb3FYSFlhREg1Wk5pb3RheUdXWEV0NmxBM1d3NHBxbWtYVTdQT1VadzJIZEI1Z2IwMmNxYjIrNHJSZFA1RG1PZkxJbVU1TmpjMGlSeUZlR0JtVmdPOTdWN1c2RjZINlN3RU0wbUE2ZHk3Q3c2OWFBUkJtYTJ3Qko1cmRZR2I4ckFzR0ZDNGFKRHRIQWdSUVAycGtwMlRMTHM2UENVWGg3MVhpYjZPa3MwdXEyS3lRc0FEOFZaWk4rRy94SjZoSUs1SXVCZ2NiTmlwUW44eHpYdCtYR1R1b3ZPNXQvaXBrVGtmVVQ5NzB4U0ZscUpNOEplSi9neDFONE01UmhNNXowWVBGWUdlYjh1MG1CWXlDRjdYR3U0R3gzQSsxYzNtNmxlTEVSK2pVSDNYMEMxZlNMcUxJY3M2dnlETWNpemlIOHpsZVlSZVhPZzVYMlpmOFFPNHI1OCtLM2hKbVhnLzFRK1RadnFmTEpTeHkzTlF2b21RSFlYOXdDTGozcWVHMlpBODgxMFVXTTZyeEx3Z2dGaWx3ZElBc0tyQjFISU5GNEEyMjVKdWFtNDdJcG9jc2x4MGswUlFxRkJVYnQ3Vm5OTEZRTjEzNXRVcmdvOERIcUp2c3VVNm9tUXBxdzBaUzFqdHVLdHNINGh4WVFRZzVha3Vsckh0ZXNnQmZnNlQzKzFHcWthdDdFLzVVamdtT2hxY2tlam9FbmlObHM3cXI1WjVZNUp1S2JoeHNQVUVyUlpaZ01UTmlkSmN4NFpTN0FEazJGWWErNjNYanZYYVB3bTRpREFlSXVhNHA1bmlraHlpZVZBaCtxdzN2L25Rc0tza25xNXlWdEdEZ2M0L09jTGhRcnd6TElHOG1RRld0OGcvTmRveVJERkVTeEZvOWpwOS9hdEQ0M1JwbTJCNkJ6MVlvNU1USWpCcG80d0pIdUJhNUhJRnFwTWtSVmlPcENzYkhadm1zL1dyYTBrZFo0SC9BR0xleTFpMUlpM3VSdnRmdFRrUkVaMUZ6NnZwVTdpOUFIUVRjM1cxaFJ4S05CdUJJdjhBZDFiaXNjN3NYWXlNYk9DR1gwK3dOUldPbzIxTXhEV0lxVEl5cWdVQUFEZ2UxUmlGRGpabVZleTdHNXBCV3FJMGl4U3JJeEpCdnNDZHhWVmluUWdJYk55UUdIelZqUDZXZHIyMG0yazhpcWpGdUdrdU5sSXRWbkgwWmVkdmFaRE9JaTB6U09ORWdPMFkzRnV4cURrMGgvdEJFWXMybHhjS2JLZTlYV2NnUnk2UVRZV3NlNXFpdzh1akVjRXVHdUxHMWFjWlhDamtjbnN5cVNPOWRMNG9OZ3RRYTloc1BhcmVZV3hhQWJ0ZnR0V1U2SXhSZkRNaXQ1cWdnV3RiVDhWcXNVaFp3Nm9kWU45dHIxa3lYdU8vd1MzWTB5dXo1QVltYU5iSXB1U09hcU1ETkpoTWNwREV4cXltNTVJclRZMkpjUkFFVFlNUDVIMk5ZN0ZvbUduMU41aVNxUVBMSTJxU0VxWkJuUFkvNGFlb0V4bVY1amxMTXcwU0RGUXE1NFJoNmgreEZiWHhFd0FraHdlTDN1eE1ETUJ2WnR4L1d2T0g0ZWVwdjdFNnl5eVNSd3NXTlk0V1M3ZlZxNy9zYTliNXhndnorWFR3QzNxRndRT0NOd2E2L3dBZmt1SEo1RjUzVCtsbmJYVEluUytNZkdaSmhoS2RNMElNVW54YmorbHF0cXl2U3VLTVdOZUFoUUoxdVRmZld2YitWYXFyMGxUTUNMdUtCV1Y2MHdlUHg4K0dhRFcrRWdGM1JScTFNZU5xMVZBQXJ3U05yYkNraTlyc0pRM281ZDA3MC9pYzR4c3NEckxnNDRDSGxkaFltLzZSZXRjT2hNdWlER0dYRUk5OXl6bHdmMk5hUDMrZWZtajI3N2lueXlOOURWaGpGY25OOHh5YWZBWWlUQ3U2c0NOVnJiU0w4V3JRZEdabEsvbTVkTXhabzFEeGwrUXZ0U2VzNXdNVGc0bFlCMFZ0VnVRRDgxQzZSTExudGlDZE1MWExjZ2JXcVY4eEk0UGJLamJBMzlqOXFGRGJidFFxdVdXQ2hRcHVXWllGYVNSZ2tTRFV6TWJBRHVhUkszUWhHenJPY0xrR1Z6NC9HeUNQRHdLWFluOVgrRWZOY1F4S1pyNG05V3NpaDBubmoweGx2cHdPSFBML0FBeDdEdWFuZGI1L2p1dE00aHdtRlJuZ1dUeThGaGxGL05ZbmVWdmdXL2F1bzlGOUp4ZElaUDhBbDJrRW1MbEhtWXZGSGZXMzM3S28yRlcwbzRvYnZrcGM2akpzUkl3R0F5M29ycDJPR0lSNFhMOERFU3p0c050eXg5Mko5K2E4citKM2lQTjRpWnlaMEx3WlZobTA0TER0L1dRajM5cTAzamY0b25xekh2a09WeWs1TkE0ODlrYi9BUENKQjdIKzZLNVM4enlwcVlEVU5pZTVya05mcTNPVzFNOWQ4QjRqL0h4ck5rankrZ0pJSEExUjM1NXBFbW8ySUZoMnVLVEd4NVk3ZkZFemhocEY5UjRJN1ZoWHpiTzQ1YjVCTXpGSHNiRWIyOTZaMHNxZ3EyMm01RjZKMzgxQ0hEYzJ2YTFDUXJwc0JZZ1dGSUtBc2ZxSVY3RGcwMFp2TGNCV0JjN2tlMUVXVjJJY1dGdmVrcXl5UnNCcFZpYkEzcGdxZkE0ekFBbFR1ZWFQUnF2NWgyUDZ1NHB1SVhMS2JHeDVwY2NvQmJVbXBXRnIrMUFuWWJTaFY4eHg2R09qU09RYXovbHJMbXNnWUVLdDl5YXZKekZESWJGaUxYdFZKaGZMT0ptZHhyZG03bWhnMFN0MGo5MUF1TnQvM3BsU0RMWW0xeGZiaXBKTGtNVlpTTzRKcUhxVm1zVklON2JkNlJEbTY0RllWaStJRVRFaTV1RHlMVlVZOHJGbUU2RFMzbHRxSU81cTFqWFNWS1hVV043am5lb0dQQlROWnlWUldrQUh4VGtWOGpiUmh1czVHaEtFRlRjYXJnL1ZYT2N3WjhRV3V4Wm0rb2tlMWRRNnh5ZkU0cU9Kc1BwOHkzbC8rdFlYSDVjd1ZQUTZTcXRtSkcyMWJHQ1MyMGNINVRGTjVHMGlqd3VaVFpXNUFZQlRZMlplYTMyVDUrbVpRUm8vbCtkN25nMXorV0VraHRpRGUxNlBMTXlmQlRtd3R2ZTVxek9Gcmd4OU5xcDRwN1dkRXhxaVZTck1XWmhjbTMrVlpuTjhNekl6YjNIcUpOaGFydjhBdEJaNDBtaVhTZkx1VnZWZm1VY2VKd1pJMmtjQUc5UVF1THBtbHFKeHlRWTEwam1CdzJhSVZZb2pHek1EM3J0K0FsYVlSbStvRmI2U05qWG5mSzhVdUJ6S05tVWxBMW1YM05kMjZYeFF4T1RwSWplWjZyYWI3b1BhcTJyalhKc2VDemUxNDJ5OWpJV1FPQUN3dUcrQjdVcUxIeVJ5dElHRnJmUWVDS2lTVENKUWltNVk5dVRVV1ZYeERsRTRVN0crOXF5K2pzYkx0OFpGbUVRZUs2c0Q2eDdEMnF2ekJFaHdzc29WaVJzb0EzTEdwZVhZWllsWjNHM0cvWVZYcVlzeHprcUpIRVdIRnlPMTZLdGl5bDdhTExMNEJnTUxFanNFazArWStrZC9tbnpPbUhZaG1aUjlSamJuN2lxdkc0Nk5RWXRiTHBPMXhlNCs5Uko4ZkpqUUcxUnlFbXczOVFBcVNtUktTWEJlNFhNWS93QXRHV1VBT2RRSkZSY1RqZk94VW5xRWlqOUs3QVZCODloaElGV04zZERZc285TnZpbjhIaG5rdVp5QkU5eUNOcldwbEVpZG1sNkNoL3RIcnJwckJyZlUrUGp2OWh1YTk3T0dMc2RZWGM3SDcxNFQ4SVpZNWZGcnBGRUJLREhuOS9TYTkxT0kyZGkyNXZYVStLMnFEczh4L1ZEY3MwVDRUa3Q2TFdzdjBnYjNIejdVV3dKNys1N1VZRnZwUE5GYlkyUGZmNzA4NUU2eitGZGpIK0lyb08yOXN3NC84alZoZXN0K3E4ODRBT1B4TzUvL0FDclZ0UHd1TTBQajkwUXhGOUdQTngvNUczckY5WEMvVStlQURjNCtjZy9IbU5VMzdLRy91TS9jaGRON2dmRkZjQWduK2RBRURZZnZRTGVoemNBRGZlb1J4dFBDakxVeGZWa2VOblhWSGcxSmpCM0huSDZiL1lYcnArSlpHa2tjNmdCd1R2eHdmNjFtUEQvS29zdDZXaWtjS1pjU1RpSG1YdDJWZjVWcThJWkpNT2p5V0JEaEN4SDczcU5zQ296MklLY0xoemQ1cDFNMDRQWlI5SUg3MVc1WGc1Y3l6VnNQaDFKYU9JeVdIWUtMbW4ybmZNc2RQakg5TFNQcFVleUx4Vjk0WVlONDU4ZmlWQS9OWWtNcWx1UEtzYjIrZDZhM1FKSG9yd254VWNuUitIMkJTWERnTU96WDVwVUdYdGwwZUpqRnpJb2ZUYmdld3FxOE9NQStYZEJZT0puTFNobTAvd0NFQTdDdE1aa3hFU09uRCtsd2ZlcWplMHRSNFJiOU56cXVDWUtOV2tEWTlxdnNQUDZBUi9Lc2owNi81Yjh6Ri9kY2tENHJSNFNZTkV0ajIrcW1ickI4azE1cmdhYURTaSs5TXV3UDAwTDAvb09FT2w5anAyRlZQV0hTbVRlSWZUV0k2ZjZod2d4V1dUWElLbjF3U2RwRVBZajJxd0xlcjRvM0YxQUZoOTZWT25ZMTB6eXpIK0IvRlJkVFlNZjhWWWZFZE14VG96bVZXRS9sMzlTNmJXdVJ0ZXVGZU12UWNuaG40bTlRZE9GZEdIZ21FbUdhOTlVRGdNaHY5amI5cStqUWE1dVRlM2M4RzNldk0zNDVPamhQaE9uT3RJVUFQLzhBS3Njd0J1U0FYaVkrd3RkYXVSbTMyUVNSNUpaU0dOelNrMzU1bzJ0YzJIZjNKb2d0M3VQVFV2Q0VGQmp2ZXJucEhxM05PZytvWWM2eWVWSWNkQXJvUE1UVWpxeTJaR0hzUlZLclhZNzNwYW5jbmE5dS90UzM4aXJvOVJkYjU3SG5YUXZoYk1vV0dmRllHVEhHRmVGSklVZ2ZGNzBNcmljWWFNYVZVSURjZGdmaXNIMHJtdUl6cnBmcFdIRXQ1d3kvQ25DUW9vM1ZDMTcvQU02NkpoYmFZMFFnbHVEN2ZGWTJybHVsWjZSNFBGc3dqM3FoTjNZM0oyc09CVDZnQ1MvMU1lQ0thQ3NYUHAxRy9xK0tVT2Jwc3BHay9lc3g5bldwV0tzcEI5TmllTDBuRTdzYnFGWVc5WTN2dHhTcEI1WnVGMVdISHZURXNoS00xOWwzdDdVZzZSQnhEbVFGM3N4dmE0cW54cTNGclhKNHE2ZHlzYmVtd1kzMWUveFZMajM4MCtsU3FrMkZ1MVdjWm01MVNLWE5FUjJLc0RkUnZiazFtWEFXZlNWQWl2dVRXdHpCQTBUYWxHdFZzWkY0ck00cUxWUElnWTZ5QnBJNzFvWStqazlVdmRaMExvVEVtWjlHdGh2ZmF1a1NTZWRHTFhJSEczZXVQZEY0b1lmRndrTzJrKzU3Q3V1WmZLSmNPQTNwWnR4OXUxVWNxcG5XK1BudnhKZlFGaU11RkROc1FleDczckw5UlJIem1jRWdnYmdubjVyVlJSa1NTSXdhNUY3RGlxWHFEQ2wwQjFYMGpiVjMrS2lnNmZKY3pxNGNDdWtjNU9GbGdKWUJvV0UwUmpCMkttNEorZHErZ2ZUT2R4OVNkTzVmbWlFRmNYQXNoOXRWckVmNTE4NGNreFl3Mk5FY3BhT1BVTEczZS8wMTdRL0RUMU8yWTlMNDdLWjVBODJBbjF4RHY1VGIvd0NkNjMvSFpOczlyUFB2UDRWbHdLZGNwbXhudzM5bWRRT1ZpMElIRTZ1TjdnN0d0Y3JpUUJoOUozdlZIMVJHSVZ3K0xXUm93Rzh0amJZQWkxeis5cWw1Rk41bUJWQzJwa3VwK1IyTmRQTDNjbm5VT0pVV1ZDaFErOVY3c25YZENKWlVoaVo1RzBJb0pMVzRyTVk3cWVXYVpvY09oZ2pHd2xHNVAycHpyVEhmbDRzTGgyQklsWXMybHJjVlRqQUhNVEJIaHBaSTVwRGRXMklYM3F4Q05jc3JaTW5OREFoYVRDM2U4MDBseVFEZGliN1ZydW5zcWJBd0hFWWtIODFNdGlwdDZSMkcxU010eWZEWlRDRmhqSmNuMVNQOVJQYy9GVDdBVTJjbDBoMElOY3NGQ2hSRWFpQUwzK0tpTEQrd3diRW40NVBINzF6WHFucTFjOHhrbUF3UlpzRmhuME95N21lVHNvK0FhdXV1TStaTUsyQ3d0eDVpbnpwb2phd0hJRlEvRHZwSVlaRXpmRXhHSml2L0FDc0Z0bEg5OWgvZVBZVk5IMjhsU2NuS1NoSG9zdWgranY3RFdYTU1VcW5OTVdvWFRiYUZQN2krMTlybjRybi9BSTUrS3ZraWZwaktKVDV6V2p4K0pITVNuOUNrZHo3OXEwdmpMNG5wMFBsYllMQnlMTm51TGp0RkgyaFE3RjI5dml2TExTdkt6dkk4czhqeUZua1kzTEh1YXdQSWF1bnNpejBEOVBlSFUycytWY2ZBUWppaUlSUDRhM05sNS9tYVJLeDArbGJEdmJjMFJheFpRUHFOdDZqMmVOamMyVlRYTVNkdXowOUt1QlRPQnBVRUl6ZGpUaVhVRW9MRURrKzlORUlybEhRc2IrazBsMERFcUN5VTBjR1hhUmJGdCtlTDcwbHBGSTQ0SDFIdlFWcnJlL3hjOTZRQVFvdDlRYTFKWXRCSzJxVFlLeDlyVTFMSXBYU1VCYmI2UmExTGt1SWdvSVlnblVUU1ZWa1M0QzNMQUFEbW1pQ0FOREo1WTlKNEo0dlVvRGl5Mkk3VkdUYUlYT29pL3dET25idXRtdmF3b0ZqMlI4WHFSZGFDemNFQ3F6TDdzMG1vQUFIVVh2ejhWTnhNeklraFU2cmtFLzdWQndZUllpOWpmVWZTM0FvWVBza1M3Qmh1UzI0KzFSa2RmTUhsaGk0N1B4YW5aQ0hiU3hJSzhIc0tqQll2elRlV1N0ckVqM3BFRWtMZ2tMU1Nla1dKdUwzL0FKVldaM01rZU1jNkZCS0Flb25pclFHTlRwZTRBYTVKNysxVWZXVHFaTUNiNldkU3VsZTRxU0t0bFRVTlJ4dGo3UnhteWdGbzJHdGlSL2xWVm1XWExpbzJqa1ZFV3gzQTdIM3ByQ1o4WUpCQlBxdWRsWXJjQWZOV1FsWEdRbDBjYmc3amUrOVMxT0x0RktUeFpZMHptSFZIVFQ1Wk1TcWhzTzMwRWR2dldUeE9HYUlGV0E5Ty93QjY3YmlNUEJqY05KaHA3a2RpdzN2WE5lcThtL3N6RjZOeUdGMUo1L2F0VEJsMzhTWnh1djBIcGUrSlhaUmpTUVZMc0d0YTE5aDhWWmlkaEZyYXdCTnRKKzNOWktRdEJJdXE0SVlhcmMxZVFZeFd3L2xUV1pBYmlTMTJIeFZpY1ZmQmtZOG53eURqTmFTYTJVSmMra2plOWRMOExzL2psdEJPVEZLaC9ob045WithNXZpZlZFU3AxQlRwdmFuTWl6ckZaSm1VV0pnS2hvenVYSGJ2VWVXQ3lRTHVpMUgrUHFFL2hub2JHU0ZDTHJwY2JsazNzUHZUK1c0VmpKcVdNbGRPb2ZQelF5WjhQMVJnbzhkaDVFZUFLTmFBN2cvL0FIcVJtRFN3NE5zTmhZeXNqTi9FYzdLdnRXQTQwNlo2ZmluSEl0NmZCSHpqRnNGancySEllUjlpU2RrOTZabXhNV1c0TVFZZThqTjliRURlb00yWllUTGtLTWZPeElGMlljS2F6dUx6aWVWdzBicnFZV0JQYjdWSkdESzJYVVFYVEorS3hSczYrcHcyNERkcVRoOFFZTUlURWw1Q3B1VDcxVUxNV2FOWGVReWo2emNlcXJTS1VlbXlrQm5BRGMzcVhhVW81ZDd0Ri9IaXZ5V0hnVFF6T1ByTzlPbkh5WXFmUnNWdllIZ0RhcTZERVJQS3FZbWZVaUtWQ0x5S2ZpWkVsSWhBWmUwakhnZi9BSHF2UnBRbWJ6d25rTVBpcDB4S0FFOHFaNVBzQWhyMk12VXFNTGxsdlhpZm9PVTVmMWZsK0lVbDNSWEpjVjJNOVpzcE9obXQvd0IxYXVrbW9SNVBQdlArN09xVm56RnYvdFNXNE5HMjdDM04rYVVRYkcxYWh4cDAzOE5KSThjK2p0UkpQNS90N2FHckg5WkEvd0RGV2VXMkg1MlkyLzhBTzFhejhPVDZQRzdvMC9UYkdrRS8rUnF5dldaUC9GZWRobEF0aTVSdC93QjdWSy94RzNjalBMYjFVaVg2RC9yUmdhazJCRldYVG1WTm5PZjVmZ0xBQ2FRYXRYOTBibi9Lb1dPT2k5TGRSUTRicDJlUEVpVjhhcWdHTlVPbTVHemJjRzNhcE9VOVV6NW5nc1psMlg0UEVQUGlQNGE0N0VMb1NCRHM3a2R6YTlxMFhUaXc1UDByMVRqMXM2K3JEeFNGUnVTYkMzOHVhcTQ3WWFHUFRIYlNBQ3l0OVczSCtkUmlFSEV3aUtVWUhESFdTVXcwQVUzNzJINzk2N2IwTjB5bVNUTkE4WVo0b2xqQ3R1Yjk2NWQwTGhVeFBpVjA5QXlha09JTXJnK3lveHJ2T0hBaXhVMDdBWFpqNnZpbzU4SWtqMlhXV1RwaGwwYWZRdjBxT0tDeU5CbXMrSFgxSkpwYTU3ZmFxc1NxY1VpTTlsRzRJNzFaNHBoSy9teEVYRmhxcXErU1pGckdvVEVwSWw5N2hpYXZzQklBREVOOUhGWnlLVUZXYTVZRGh2Y2YvZXJqQVRlVzZtOTFJdGZ2VWJRNThLeTRCOUZCSE5qcE8vZWtCZ3ljMEZheFVXMkpxUVpkanBGd0R3S0FXL0JvTmNrMytuMnBaQTBlMUtuUURTZ2xySGdjMW1mRmpwVStJUGhUMVQwOEZEVHpZWDh4aGQ3V25pOVNuK1FOYWdBaGFjdytJR0Z4S3lnWDBzTnZjZDZsakxramFQbGRFeGVOVzkvMG5zZS85YU1ndHdkLzcxYjN4NTZNL3dDQWZGdnFITEVSMXd6NGc0bkRsdjFSeWVvSGI1SkZZUUMzZS96VitoZ1FGcjMzTkZJU0kzSTl1ZmFqVTcwcElqaVo0WUIvNGtpcmYyM3BzblNId3B5U08zZEU0Uk1JbVdZY0ZvL0toQnVCOVZ3SzZESEdZbzFXdzFLMTl1VDgxa09sWVZpS00xeXdVUmo0QTJyWDRabTJCSmEvQnJCMUVya2V0ZU1odHdqMExvcmtXTjEzdU9mM3BUdDVsbmE2aGp4cHNMMGtoeExzYis0TzFPQnZNWUlWM2JlM1lWU05sY0RZQ3Nsd3JrRGU0cHR4cllNb3Rma1g1cDNrT2R3VjRLOTZhZnpIS29XQVpia0dnVmtUR0NJU05hTXFnM1ZiM0ZVZUlrSGxzVUFVaGpmYXJyR3hPVVVJZVR1YW84VkUwbUVacmc3a2tEazFaeG1acVh3UjVQNGtNZ1lzTGkxd0t5V1lCUE1KUzZFSG4zclg0WFNJcEhCTGtmb2J0dFdjekdFSmlaSkNWSVlDeXJWM0d6bk5aRzRwam1VTTJIa2owc3ZxN01iVjJqcDZkc1hob1NWWFFGMGgxNXY5cTRvQUZWQTVLRlFML2Y0cnBmUitJSnd5S1hDM1BLSGc5cWh6cjVORHhrcXVKcnNYSjVlS1Y5YldHei9JcU5tY0N5TG9JREtCcXVUYmFwT0tZNGlJRWdFOGJDa1N1eHd3MWVwbEJVS1JWTmRuVHlYdG81NUluNVRIM3NDb3VkTitEMk5lZ1B3MWRZTmt2V3VCZ2xiVkRtQy9sR2NqZlVUZEwvRjlxNFJudUJBbUxrRUphNXNiRVZhZEdaM05sK1lRWXVLWXZKaHBGbFhhMnltNHRXaGdsc21wSEw2M0R2eHp4cytqdWFZUDg3Z01UaDJHcFdVamYzNUZaVHBITURGalk0eTVZU29VWlR0cFphMFBUT2NwMUhrR1habkh1dUtnU1VXUEZ4dVA1MWpjMy84QW9QVTJMVVI2cjZaNFFwc1NDZDdmdlhhWTU3NEhqMm9qNlU2Znd6b2xDOXFhd21JWEdZWkpvL29kUXd2VHRyZjUxRzFYQTk4ak9Kd2VHeG1sWm9vNVY1VVNMZmJ2WTFGd21SWVBBNGdUd3EwY2dVcUVKMkcvYXFqUCtvNUVrYkM0SW1QUXdMekVhZ2ZjQ3RIaHBoaWNQRk90aUpGMVg5NmtiZFVNOXNtT2JBVzcwS0Y2Rmp0WTJCNE5SMVpMZGhoU3gyM05aM3FYcUE0WlRoY0szOFVpMHN3TnZLRlNjOHpjeFJ5WVhEeUJKeUxOSmZaS3Fza3lSc3htTFRIL0FKU052cUkzbGIzKzFUUmo4bGVjdmlJbkl1bi9BTzBXZ3hPSjlXQ2lPcUlOc1hiM0k5cWY4UnV2TUg0ZVpESmpwZ3NtTmtVcmhNSU5qSy9hM3NCL2xWbDFQMU5sL1JtU3k1bmozRVdIaFd3VWJHUThCVkg4cThrOVk5WFpqMXpuODJaWmdubDZ2VGhvOVhwaFR0WWUvdldYcmRVc1NjVjJkVDRUeEV0VlAxWkwyb3FzenpyRlp6bW1NeCtZU05QanNTd2VSbmJiaytsZjdvQTRxSEl4bFgwQXFGSFBGREVzWjV0N2M3c0tSSXJYMEsycFZGeC82MXlVcE9UdVI3Qml4eHh3V09LcElRNThzQUEzYWpSUzZFRVhCNXB1emVna2VrWHNmYzBzU3RhOXRKUE5STWxFUEdFVldMTmNHNVUwVXNwWi9NU3hPM3BQRkpZdXVrdjlkOWgyL2VqWFF3SWZjN2ZUVGJGb0lzdmxrRUJlNUh6U1A0aWdrMjFmVUI3ZTFEUVNHSkFzTmliNy9GQkNGQVZpYlcrcW1palNxV0pKTmd2cUErYVROQ2JCaDZYNUI5NmVrVURnM0hjY1VaaVdXeUFIL3dBeG9Fb2lwR3JHK3U1RzJrY1hweHJpSlVERnJHNGIvU2t0RzBiNkNRU08xcWMwS2RoczFyN1VDTGdyY2RieVN4QVZqc1IrOU1ZUlVTQjlROVljY2UxU015YnpJcnVTcEF0dVJVYUFhNGdROXI4M05EQUR0R1hOd3dYVlk3YzB4TkJlVUZtTVRLd0lQdUtrS1dERlZDMlg5WGVvMkxXV1lYWnRRVTZyblkvYWtRcmRnalh6cnNTSE43Mkk0ck0rTDJxSElNb3hVY3ZrR1BGYWJqZzdIYXRQaG1lTlhKL1hzYkhnVm5QRnlBNG53eXg4WmpMSER5eHpSbS9zU0wvMXF6Zy9OSXkvSXB2VFNjVG1oNmlseElsTW11S2NqZEwray9hbXBNK3hHSEN5d082cURzaXR0cTdtc3Jnc3pNa1lFaE43YzhtckNOazhwRllpOTc3VnRPQ1o1cXRYUDRabzhOMTlqOFBJclRLdUloYjZ3L0lQdUt2c1pqY0gxSmxwY2V1WkJaQ1Iycm5zOFNGVGNrQWp0NzA1a3VhU1piTWl1MTBKc1IyRk5salhhUlp4NjJjL1prZGljendtaVhUcHNXRzQ5cWlZS1FZYVNSSDlTa0RTYjhWb013VkowODFHTEJyaXM5aVlyK201REtkcjFJdWV6UHlMYk50RXlVTVV0Y0cvZTlNUnRad05PM2Zla3d6aDFHOTI0dFMyRjdFbTNhbjdhSWwzWmI1QjFIbW5UZUovK240eHNPamZwTzZuN2l0U3ZpSG5XTlJvWjVRbDl6S09YKzlZUkRkbEsydU52VWF0Y0ZQK1VsRHRvY050NnR4VUU0UWZ3YW1uMW1hSHRVdURUeDQ1OFVMeXV6T2JFa2JiVkptbEQyUWp5ZjdpcnlUODFBd2pJeW5WSHBzUWJLUFRVODRjUEw1Z1E2U2RtMVcwbXF6UytqYXh5bEpXMk81ZkZKaUpScVVsL3dCVE53UC9BTDFmd3gzeGtheHNXMExmVmIwajRxdHk1bXVndHBKTmhjMU1peEVneGN1bXpNUUl5UndMVldrald3VkZXeC9EaGhMSzZ3WFpSdXhGU29KQy93REVObzF0NmxIZW9XQnhibUIxeEFaVElkNUFkU2o3RG1sbkN1NUhyMVFvZlVlQ3dxdTRtaERJSnpycmFEb21UQzQzRXpMRVpsWll3cE9vajNxbmI4UitIVWtBenVQY0xXTjhkTXhpeEdkNVJnWXdGancrR0xuYTVKWTF6aFV1UG8vcld6cDhTMld6ejN5R3BjdFJMNUcxWVhJc2ZUc0RTaWJnMi9sU0JmYmM4NzBkN0UxY09iT2hlQUVnWHhkNlhrMUZSK2JJc0J4NlRXYzZ1ZnplcGM4bE5pejR1UWphMzYycTQ4RjNNSGlUa0VxWEJTY3NMZStnMVE1K3hrem5NWkQrdVptdWYrNG4vV3BKZmlOcjNGTUZhOWgvV3RwNFpZTHlzVGpzM2R0SmdUeTQ3OXlSdmIrVllsamFNKzk5aFhUOHV5Lyt5T2o4RmhndHNWSzRhUSsycmtmeU5Rc2NiZFkwd3ZRT1c0YVNNcXVZWTd6M0o3cUFUcC9uV2ZTY3Rob2dMcU5UWDczRjlxMGZVa2dndzJUWVNNRXc0Ukx0L3dCemNWbE1OTmFCaHlRNUFVOXFqQTFQaHlVUGluazhnT2srWEtnK1NVTmRtelNaWU0xa3dZSlZkSTIvMXJpUFFPSVNEcjdKR2NnRzdCYjl5Vk5kVzZreG9oNndLTmNySkVOejJZQWJWSE5XT1RKR0huY1lpV01HMHNmSGU5UGYydzJDdzhoREV1amZRMVFNcGw4ek9XbmNhUi9kSGVvT2ZrbVY3YnE4b1VEdnpVVGlTZnlkVXdFcGZBWWQyQTlRRGdEdjdpcmZCQXg0alllamFzNWg4UnBrd3NNWkNvaWdXTmFhQUFBQlFicUxYcUpvazdSWjRjZ2oxMHNQZVVHMWdkZ0tSRzRMSGJ0UzBGL1YyRFdwYkcxUTZBUmNrN1U4b3VwOXFRUU85T3hqMDdjVUFKMDIzNXBpVmJiNzg4VktHMXdlS1JJbW9mN1U2SzVHTThxZmpnNlBqaXhIVFhWY1NHK0pWc3N4YktQL0FCRjlTTWYydi9LdkxiQWo3OTYraVhqejBYLzh3ZkJmcWJLMWoxWTdCeGpOTUl4N1NSWEovd0R6UzFmTzN6Uk5Ha2lLUXJxRzNyU2c5eTVJMkdxaFNmZXJMcG5DREY5UjVmR1RwVXlhajgyM3FzVTN1YTAzaDNnamkrb2RZQ2t4UXMyNS9hbVRmdHRsblRSM1pFanR2VFVWa1Z0eXhYVnFJMkI5cTBPR1M0QitrN2tnbmlxakpRWUlvNGlReUVBWFRzYXVJbFY5UHJZTmUyNHJuc3ZNbWV3YVdPeUNTRFVGNVJxUHFKKzR0YW4wSjdyK3c0TklnVW9vN0VIMVc1bzFVNnpZOSs1cXVYdm1nakdubGtpUWkzQXBLZ2hWT3pYTzV0OFVzQmk3MlhYcDdqdlVYelh1b0E1NStLQkxJZUxKV0NRbjA2WkxibnRWSmlXS3N2bDIwMzdWZVprZ1pOSjRiZTlVR1lCWVlRQ2RLWE5yVlp4bVZxclNvR0ZqQ3d2cVVBc1RjM3FseGFFcXlnQXVvSjM5cXVjTkdXMHJ1YnJxNXF1ekNBQnhhK3BqYTFXWVBtakp6eHVDSzlmU1l6Y0RXTGtPTDFyZWtjUU1NeFV0cUFhK2tEaXNxQ2tNbG5ERFZjQTI0TlhIVG1MT0V4bXBpek5xSjlmRmp0U3pXNkpGb3BlbmxzNjdCSitZVUxjcnJGN2dkcVJFNGprbGozYlRzUzFSY3Fta1pGVFloUUxFZDZtNGwvSm5WckFpVUFYUEFOWngyaWRwTXpQVVdIU1pSZENYQk5ySCtockw0V2M0REdRbzM4SVh1VzdFSHRXN3pqQnEvblczRnRtSHVlYXhHWTRLNVpOYnRHdTF5TnhWckd6SDFVWGRvOXFmaFY2eE9iOUlZM0lKNUJKaWN0bDh5RVgrcUJ6Y2Z5WW4rWXJjZUtXR0VPRndPY0lWMTRhVVF6TVJzWTM3L1lIL0FEcnlUK0duck4ra3ZFbkxOY3hmQzR0VGc1YjhXZjZmNU1CWHVIUHNsanp2S013eXlaVlpNUWpSa25pOXRpUDN0WFhhSEp2Z3JQSi9ONmJibGJpVlhSbVpERlpjOERNQkpDMTFUa2FUeFZ2bXVHeE9Jd2hqdzBnalluMVAzTmNpOEsrb3BJOGRoUHpONDU0MmJCVG9UWWhodGMvYXUxYzk3VzJxL05VN01MRFAxSUhQTTB3R1lZSERsSklXYU5ia0JWMUQ3M3E5Nkh4NnpaWCtWWnJTd0UrbnVRVGZldEt5MlFqWXIzTjZaWERRcElaVmpSU2JBbFZBSi9sUTVXRU1lMTNZN1luZ1hQWVZTWjVuWDVZTmg0WkY4OHFkVW8zQ2YrdEhuV2VMaFdPSGhKWjdFdXcvOE1WVzVSa3E1bWl6U2Y4QTRPVGNrOHVhV0srV09jdWRyQmsyVVM1aEw1OHgvd0NVZjF2cTVrYjMrQlYzbnVkWUhwZktKc2RqcFZ3MkZnWGcrLzhBZFVkNlhuR2Q0SHBuS3BjZmpwa3cyQ3c2WGE1Ly9OQTduNHJ5bDRqK0pPTjhRODFHS2xXVEM1VkViWWJCRnVSMmtiL0VmOUt6ZFpxMWlqVWV6b1BFK0l5YXlhYlh0QzhRL0VUR2VJT2NOaU1ScXcrWFJiWVhDQTMwRCs4ZmNuK2xaTXlGVlc1Rmh4ZWt1M3BzVGMzdVQ3MHd6bHBCL2QrYTVHZWFXU1RrejJEVDZlR21oc2d1QWpiV2R1ZCthYlY5SklBUHFOcWR4Rm1kQmF3YmxoU0VsYUV1TkFLa2FiKzN6VU5scGNDRmVRU0M0MUhmYWpSMkpQcE5oNzBDU3hGbDI3dGVsTTQwWFlsbE95MnB0anJHMGJWR0hMRWtudHZZVWJBU0FpTTZHdGNFYlhveXF4Z2diQWl4QTcwUlZwU2wvUUk5d2ZpbWlqUVV0cXVwdFlYQXBXeFp3ckRSZllIbTFFanhscE8rMXdLU0NndFk2U1J0ZWdCVFJ4dnBPclNuWUhtaVZpQnBZWDE4RzlxWE1Xa1dQVUZZTC9kNXFOTE03SW9DYkcraGgyb0U1Rk80Z05pVHFQRmpjMDFNM2xJb3RkdjcxNk9RZ2xOWHRZZ2U5SXhFUkxLcEFJNTlQYjcwQ0VITWw4MTlLcUNnRzVQdlRjU2FJRHEzMitraXdXbk1VK3hWZ1ZPcTl4UWZhSXF6L1hiYTFEQVRkZEZpeTI3Mk85UjhVSTFnL2h1R3NmVUw4MDZGczZycEJVN1h0elVaVlVPNlcwbGYxMjVwRUlNb2RERlFTZGdSWVgycFhWR0FrekRvL044UG84L1hoMllSZzJiYmZtbHd1RWxJMkcybys1K0tuNFBUaWI0ZGl5aVJTak1UWUFFVkxqZTJTWlZ6eDNZNVIvZzhtdGhtOHNTNlNGdDlxRUdObGhzUXBkUGIycXlqQ29aY0sxeVlaR1JnM3hWWG1FQmlzVVBvYllBR3VtK0R4dkluQzEvSll4WXdZaGQyQzM3RTBtV05RcmNqN2lxTXhIalVkWHYzcWRCbVVrTnhNMTBVZlV3MkE3MFZ5TlUrTExmQTVnMFNyQkl3MGpaYmptbk1RaWtHeTJZYjNxTm1tVTQvS2x3Ylk3QTRyTHZ6TVludzdZaUlxSjBQMHNwT3hCcFVHTjgxSTFaZDdIbjNHMU5jWEVtamtzanlSQ0ZpUmF4Ri9UM3B6elJJVlFYMGFlZTROTGxRQWtkdWFpdHJVMzFiZGdQYWxHT1RKaTZTTnQvOUttWWVSZFNxb0JZYmdHcTlIQTJBL2xTMG1NYmxoeGExNll5YkhLblpyOEhqU291MFRLb3R1RzUvYXJtRFRMTkg2bWtpWTIwOEViYzFsc2x4cU04U1NuVHpjbnZXMHl0Y09TcFgxU0RibXFXWGc2UFNUOVRoTWw0YUNGSHNkVmhleld2eFVyRFRMaDRwSm5CSWE5dHU5TVRSeTRQQ01VSVRVYkFqZ1hQZWs0ekhTWUpFaTBERVF0NlFCMjl6VldyT2dpdHE1RXJJSkJGRUdlVzYzUGFwa0U3TTBLc3JLdTQzTzlWRDVnazM4UWp5ME93U00ySXFUZzhlSWNPK0l1THhveE9yZSsyMU8yV3l1OVFvN21jcDhTTVltYWRjWmc0T3FPTUpDbHVMQWIxbjB3eU1MaGRYelNubmJGNG1XY3RkbmtaMnYzdVRScjhNUUsxOGFxTkhudWR2SmxsSXIrVHZSNmdUNy9GQzI5NlRwdmZmWTl4VHltYlB3a0pQaURrcXF4all6SFlEZjZUVk5uMWhuR1BHbTRXUmgvVTFkK0VlM2lGa1J2WWVhYk4zK2cxUlo0U3VjNWdBTlE4MXpmdjlScVNYNGpYK1RJdVJaYWMzenJDWU1MczczWSt3RzVycGtrNXgrZVlkWXpjZWFGQ3Qyc0IyL2FzbjRjcitXR1paaVVKYUNIeVlpZVN6YzFxTXF3N2Y4UjRQVXVsMFZTMXpmY201cUZqalY1OVArYXpMRnl0WXFycEhwVTIzQTVySVlXUmhQaUVQQWNuZi9PcllZaHB4ampkZFR6RjcvWTdWUm5YL0FHbmNjdXB1bzIzcGlBc1lzMkdVNWxnY2MxM0dIbERBTHp2dFhZdXI4WEhtMlc0TE5NRzEyQ0xKZTkvVDNyZytNZlFTaFB5Unp1SzZiNFpacXVaOUt5WmZpR01qd2dxc1pINkNPYUpLMEtqVTVkbW8vTndTUnVDa2dCdjl4VG5VbXBac3ZNYkJ4K2JSckUvenJLWkppbXdHSmd3N3I2NFpSR1EzQUY5cTFYVUNwL2FHVllkdi93QWJyTEtPUmJjMUNTZkJ2c214eGtFa3NpTmRkN0x1UUsyT1RZL0Q1cmc0OFZocE5jWU9oeGJlNDk2eW5UU21QcHFiRmtidUdYVngrMU1lR3VhUjRYRzRyTDJlenl5R1NJNnZxUHRVVWtLcE02UmhpTmdkaDN0VWdMNmtIWVhxUEN1bGxKSXZZaDdkalVsVkIzQnBnOWpvRnh2elQ4YWdwWVd2VWZXRkYrYWtRTUN0OU5xVklRSWpjKzFKTEZUdDlxVXhCMk5JWGRqZmdVNVVtTmFzZHdJaGx4cVJZZ0F3VFhobFU4TWplbHIvQUxFMTh3dXJlbjVlaytxczV5U2RCRkpsK01sZ0srd0RHMzlMVjlNWlNWY0VDN1hIOHY4QTNhdkVmNHd1blA3RDhhSmNmSEdFaHp6Q1I0NEtPTmU2dWYzSXE3aVpFK0djU0FCYjIzMkpyZGVGbURmODlqWnhzaElUVjNOamVzS3hzTmhlNDcxMUx3bndnank1WlBxTXpzYmU5TXp1b1VqVzhiRGZtaWpxT1doQ2lpUFlGdDlXMjlXa0NPSm1MZ093NEE1cUpnMDB3N0M0dndlYjAraWFwR3ZlOXJnZzcxenNtN1BXc1VhU0pES3lPTE1OSnZjRG43VTRyb3B1NDBBbm1ta1BtQTdhZjg2RWNmNWtxaWR2ZW1FNjVCRkVVYVN4VnJDNElwa3F2bHFRTnp1YWtQb1JMcGRRVi84QVlwaUpmTVc1SUZsSW9FYW9oNHBkU2hSNmhZM0I3Vm04MFlxVlJrOUkyQkIrYTBHSkNvbHJzMTFPb0dzem5ERjRqdVFZeUNxanZWckR6Wmw2dDNFazRSbGVhd0RGTFd1ZTFScFkxRFdDQnQ3M3ZZaW5zTGlqcEtsV1ZqR0dHbjMrYVZJSmxXTlJHRkxENmlMMU11T1NpMXVoVEtuRkJKQytsU0NyYnJmYWloSncyT0NyTUNqMkl2NysxU2NmaEZTWWtJd2xhMTdHOTZnZ0VyYVFFa051cThXK0tsWFBabXYvQUZ6dEhVZW1NU0h3dzhxVVB2ZDFINlQ3R3RCajBEd2hWVUJObVAzckJkSlk1RlpURzF4TDZUMkJJcmVSWWg4VStsa0FpVzJzVlFta25TT3QwODNQR21ONHlHVDhwRTBrVWtPb2EwZGg5UTcyckdZeEFrcm81ODFHSk43MnJhc1ROSTBFMHJ5R01FUmI3S1BpczNuV0dESDZTUXUvdFNLVk1mbWh1Z3pOWkhqcGNDN3lZZFRHVmNHTmlkd3c0SXI2UStGL1ZrZld2UWVUNXZHd1o1b2xTY2czMHlxTE1EODNyNXE0cC95T0xReDdSTzl3Ry9TYTlaL2d5NjdYRUxuSFNja2djcXY5cFliZm5VUXNnSDJOcTM5RmwydWp6cnpPbmM4ZTVkbzB2VjJGL3dDR2ZGVEh3QXF1SHpHSCswY09MMkd2NlhGL2U0RFYyYnAzTkJuT1I0VEY4bVJBSHQyWWMvNVZ6ZjhBRVhsRERwakxPcHNOSGZFWkhpZzB2emg1VG9jSDNzYkduL0EvcU5jWGhzZmxMdHFraVA1bU5iM3VyYzIvY0N1cWt0OGR5UE04Y3ZUeSttL2s2bmZXdTMyck85UzlSakFZYWFIRDJNd1E2NUwvQUVmSDNvWjkxWEJocDN5L0R6b2NXbHZNWTdDTUg1OTZxc3J5RTUvS3o0aXpZSlh1WmVES2Y3bytQbW9vcjVaYmxQbHFJNTA1bEUrWXRGTk16RENLUmZXZitxVDg5eFdtelRNOEYwNWxNMk54czZZUEE0WmJ0SVNBQUxjRDVOTHpETWNGa09XUzR2RnlKZ3NGaGsxTzUyQ0FEc081cnlsNG8rSk9KOFI4eVVJV3cyUTRkaitYd3dIL0FGUDhiZmZlcy9WYXFPTlViL2l2R1QxczF4d0k4UlBGSEdlSk9aNnpHK0h5U01uOHJoVy9VQitwdmsxajliU0N4OVJwSmFRdVN5aFI3K3dwdVJtYTVRV0lISnJrY21WNUpibWV5YWZTdzBzRkNIU0RkdDlnZEs4aWtlYXBBSWpOcUtSblZFR29IdDk2U0diVVMxZ0FQU1JWZVR0bHRkQmtsMXVIQVZUdFJURXRJRkxlbmtuNW9tUmlpdUFMRGtlOU56WFFhNy9HbjQ5NmJZdERqa1JrZ1hIZi91cExYTERTUFMzNmY3dEVJMkNlbmV4L1ZTeVRvdnd4NHBBb1c3czZDeVdJNXYzcGxKR2hrdXdEN2JyZWlhUnRJSk5xRHNHUm1HNXZmWVVENkd3VlVGdklLdjhBZWkwRTJOZ04vcE5MTTZ5RlF3czNzZTlKZG5UV0ZJdHNkKzN4UU5mQWpVeFpTcmNHa1BJeThMcXMyd0hGT0hUSEdSYlNiWE5SbmxCSVVBRWtjZzBEV3h4Z2J1YkQwaTlxT1F5UmFDQU5PekdkZVB0VEFZTTJsMk8xN205T1NEWGhRcTM5OUpOQUxsRmZpOFQ1a2hCSUx0eXcrOU9ueXlxaEJxSUczeWFTOFlYWUM3Y24zb0YxS2xMRUtQN3ZONkJVdnNLWlJFMnluMUQzNzFGWmJ1QTdBTTIxdmFwVThKWll6cUFCNEFPOVFabVZwRlZDWkdCNzBDQ0NtaVczT2ozcVhCSXNWMlVhZFd6Q29nVmhxYmE5N0VHcEdHUUJmekRFaHpjQkJ2djcwcEUrZURnM1hXV25MdXVNMVJiTEZMSjU2Z2V6QzVySzRwQzdMR04wSHFKcnFQakxnUkhtZVdZKzRQNWlEeXlSN2c3R3VaRWFpUzR1NU93N1YwbU9lNkNQSk5maTlQUEtCRDh2VmM4Ry9la1l1SWZrcGpjN1J0MitLc1B5MXhjMnVEdlNwbEFnbVVEVUNoRnYycVZOb3k5bEkrcS9RL2huMDE0c2ZodjZGeW5xZkxJY3d3clpKaDlFamkwa1RCVFpsY2JpMWZNRHEzcGVMSU1kbUVtQnhYbjRYQ1l1YkNTSzMxUjZKR0NuNUJBNXI2di9BSWE4VEhqZkFUdy9lNWFIK3lZa2t2N0M0UDhBU3ZtcjRyOU9TZENlSy9XUFQySVJkV0N6S1grR1dCQmpsL2lyZjluRlhjc0Z0VElNYzlyT2FSVHJpRXVmcXY2aDgwM010amRkeHhTc2JnR3dVdm13M2VHMndINmZnMFNTckl0aFlOenBOVVM0bXBCeEVLdS9BRmhUbTJnbmtrVTB5NlpOK2JjSGlqRGFyQUg3anRUR0YwU0F3VmdSZlVOeFkxb01uNmxiQnVQUUhBTzk5aUt6aUJRTDhINE42VWlIMGxXdXA3R210S1haY3c1cFlYY1RvcmRSd1pnTU5Fc21wWE9wMU8ybTFQeTR0aE5kSkVDaFRhNTRIelhQTVBhT1g4d1NRUUxBRGkzYzFQd09JV1VGbTh6YzNJTlFQRWErTFh1YXFSbzQ1RWduM2REY0JRQWIwMTFYbW41RHB2SDZBVWxjTGh4SVAxWFA5S2lZQ1ZGY1JsTHFEc0R3djcxVDlkWmdzMGtXSFNObExzWE56c2JEdlJHQzNDWmMyM0ZKbVNWRmpqVVczUWJpckRCWlNjeGg4MEhTTDZiRTAxaGNOcUpqVlQ1am13VTl6VnZqTWZGa0RwZ253dXFhTkI1cEJ1TlhlcjdhTURIQnRXekgzMkIrS085eHRzS1N1NlhQYmF3b2dRMXplM3hTRkZkbXU4S1ZDOWZaSWJuUzBwLy9BTlRWUG5sdjdWekM5d3dua3RiL0FMalYxNFZGUCtQTW1NcElqRWhKK1BRYW84MURTNXBpVUY3eVlsb3g4a3YycVNYNGpmM3RHdDZXdzR3dVI1WWtteXl6TmlweUIrbTNwL3lxeHlXY1NadTBqTjVrVEVsSlVidVFUWS95cVJnRS9MUmppUlNCRXFkZ3FpMXFwOE5IRmhaWUpGaVFTdE1XQWpOZ1JlMjRxQWNpemt0SGlIdzRKQktCcjhhdm1vMllOcWgxTHA4eUVnZzhHcE9aYVk4UTByV0VnYnl5UU4xdndLUTJpVUZYQUVadXAyM3ZhaWhhS3pHRzBoSkZnZTQrYTBIUldQeEdXWXlmRllkdjRzUURJcmZUSXY2bEkveXFoWlNTaUVocEVKQnZ3U0tsWk00VHpwdFRlaGdiRHRla1kwNkpqY3lneFVzT013NElMMlprSElZZnBJcTE2aDZnaXdtWVlIRnl4bVRCSmh5WFdNK29FbmNWa3VvTXF4V0V5Ujh3eTBFWXBWRXpBY09CL2tmbXFyQjUydWZRSTZEU1F2cmlZN3FUeVQ4VTJySDN3ZW5zcnpMQll2b0hMY1JnQ1pzSmk0eklnSjNGdWIxUmREWU1yMW1zMnNHTmJ1b3R4WE5mQ1RQY3dPRE9VMmNaZmhmTmZ6Q0RvVzdYc0Q4M3JxUFJJY1o4UmNFdWQzSFllMVFOV0NPc1JzRUpGdE81YmIyTlRFc1FiYjJxRDliTW5LMjAwL0RJWFVINlFOalViSjJPbVE4QVhxVkJJMm5jYlZCa2NoM3NCWk9UVW1HVCtFRGU5SU5IbVBlbXc0VmozQm8yY011MTcwMDdoUURmZSs0b0FUaUc0WUVnZzdFVjUxL0cxa0g1L3BEcGJQeEVMNFBGTmdwVzc2SEYxRi9ZRUUvdlhvWjVydHVvSzFpZkducHBlci9CenJETE5DTk9tRS9PUU0zQ3ZFUTIzellHcHNVdVNPU1BuaklkS2tqc3JiZk5xN1o0ZFlFWWZMc0dyeGdxSUZLNnI3RWovZXVLSXI0bDRGQzNhU1JMRDdzSzlDOU94akN1WTl5VTJXeDV0UnFwVWpvZkM0N3pXYVhBWE1hc2IzdndPMVR3b1pyZy91TzlSMERKQWx3WkNQY2IvZW5oSG9EYXJGZUxubXNLWFo2aEQ4UngwU09TeEpESFlIdFJycGlMdHF1MTdBaWlWQTBhZkxFbnZ0U1Q2WlcwOFcyQjVwaEtod2dPRlFqajFINzFIblVBTnBGMkE0K0tXeXU0UEtXRmo4MGx5em9lemdXSDJwUWtpdHhnMElMb3VxeHVMOXF6R2RxV1QxR3lNUmEzeFdueHMxMVlFa2diM0ZaWE1aVHAwNjJJTFhWVzdEM3E1aDZNVFdTcFVTTUZhVGl5dFlFaHU0cDR6cEdHVXMyZzcySGFvMkNiV0RaenJ0YS94VTFUcXdnZGcyNXNXRlNzcVFmdElrOWlTNnQ2N1dEZDdWV1NhWUpJbEFKVzk3Zk5XMHlNaUZiM2NHMzNxRGkwQWFPKzE3ajdVcWRGYkpGVlpiOU5UV21NYXFJeURlM3Q4MTBUS01aNXlFS05WeHVUN2ZOY3V5aVlpZUtSN0tDTnoyRmI3SXNTVUlVL1ZmWWdiR3EyVmMyYldnbmNLTG1aUHkrSWljcnlMMzl4VmZtOEluamtqWTZrWVhCVHQ5NnNjVi96VU5sRFhVNmxQK24ycEVqUlRZS09SMHRjV050cm05cXJtckxsVWMvek9CZktrV1QvQUtha2FsdHVmYXJid3M2eWJ3ODY0eVhQNFpESERnc1RiRWdkNEdzSEg5UWYycHJPOElZNVNRcFpYSGNjZTFaMmFJeUpJakFNcktWTitHdlYvRE9tbWNycjhDa25GOUgxRnpyS01IMWQwOWpNdWwvallMTWNLeUJoeHBkZnFIendhOGI5Q2RTWnQwdmlwc0Jya3crYVpSUExnWnNRbTVLcWRPL3Z0WTEzYjhLWFh6ZGIrRStEZ3hVZ2t6VEpuL0l6Zzg2VkEwTWZ1dFlmeFc4RDg4Nmg4ZnNKSmt1ckJaTG5lRkdKekxISnNJSGlKRGl3L1U2NlFLN3ZTWlU0YzlIalhrTUVvemFYYU5YNGJaVGllc01WNWp5dEpsTURCcDhTNDN4RWhOeWludjhBTmRpeHVNd2VRNVkySnhNaVlQQVlPTml6dFlCRkIzdFRXQ3dXVzlJWkFzRVJUQTVWbDBGeXpHd0NBYnVUN24zNzE1VjhXZkZ4L0V2SG5CNFZqRjAzQS84QUNoMVdiRWtmVEl3OXJDNHFuck5WR0ZtejRqeGVUVnlqRjlmTEhmRS94VW44UjhmNVdIRHhaQmgzdkRDM014L3Z0L3BXSGwxU29DR0tKM1Vja1UwanN5S3FzcTZPeTdBL3RSU2E1bjh4V3VSdFlWeHVUSzhzbTVIdE9sMDJQUzQxREd1aDJTVmg2VVcra2Q5NzFIRFhRT0NiRWVvR2xNM2t2cVY5U3NPYU9hSnRjWkNqU1J3S3JTTHNleHBtTG5pMStMMFp1QXBVYWlQU2FEcW91Q3BHL0JwSjBndHFIQnFNa0ZFK1V4QkZ0dDZMWmo2ZHcyeFB4VGJTZXNoaHRhLzdVYk1RQ0xXVWJpZ0dLTEI1alo5aC9lb21jbGpZRTJGeWFJU1JhanB0ODJvamlFUjlXbzc5KzFBbG9VOHRrc3dIeDgwYmtxZ0lVcUI3VTNwTFdCY213NU5Ndkl6c3FGUVNSOXFCOW9XN0t3MTJ1UjNwbVFsRkJWbExFM0lwRXMwYVJzTFhYaTNlbzRsVUtBZGtPNi9OQkVUWmY0Z09sdnFGdCtCVUtaZE9oZ3cyMkpGRzJseHBSUXBKNXZSTzY3cUFDT0Q5NkFFckt4TGk1QXZZaTNJOTZlVWdJMjFpM3BEVTJyR1dNaXhWZ2JmY1U4c3AwRkdWV0FCc1JRQ2RFV1I3WWxWYzI3RzlTQkdGdXF1RHBPeEhCcG1OaVgxa0J5MXhZajJwVHlEVXVrYi9BS2dCUUxiRWVoVElyMkRFN0VkcWl6NlFGQ29XSGRscDh1UXhKQXVSY2tpb3p6cXBaQStnWDV2dFFJTkt5dEtGc1N2ZlZVMkJMa2doWTR5Q1FhZ0lOdk0xQnlwL25VekE0ZGk3aEFkeGZjN0dsR2ZKbGZFakp2N1Y2Y2N4cXNrdUZrRXFqMnZ6WEhzVms4c0pPcUprR3pjVjZGekhCTFBoSlZ2bzgxV1d4NE4rS3hjMldMTGduajBMNW1rb3hJdVFSV25oejdWdE9SOG40MVpKK291emxVMkI4dTlpQ0NhalBFeFNRRCs2Vi9ldE5qOHViREdSZFdvSDBiMVh2aFI1YWxMV3RwL2F0QlR1ampzdUJ4YlI5UVB3alkrUE0vdzA5QnlxTGY4QUt2QWUzMHlFVjViL0FQaUM5Q1lmcDN4VHlIcXFDSm9WNmx3anhZMjQ5UDVpR3dRays3Si9sWHBEOEVOLy93QkZybzRmVnBseGlFSGovcnR0VlA4QWowNlFicVQ4UG1KeDBFVFRZdklzZkRtVVlUMi82Y2hQeG9ZMXN5VzdHcU9kNVUyajVzWWx0S2FReEJ1YjJPeHF2eEx3aGtkeFluZnpCL3RVN0VPbW9NZ0NwcEdrL0JxdG0wdmRsdXR0cjlqV2UwaTFHVFRGcVNYQjFpYnZjSGVrK2FHSVVOMnVSVUtmMENOZ3hWenlSdGVsUVlwaElZM1VNb0Y3MjNwamlTNzdaTmpmMXF2MHNlQXZlbmxsRGhnRFptMkI3Q282YVFBdXV6RVhCUElwSlpsZXgxQVg1WGcvTkkxUkpHWEpkUU1wVlVETGNla2c4QWQ2dGNQaElzT3lQTTRLdnRZR3N6RGpDakVnNmJnN2lySEJTcXdDNnk3RVhOelVUalpmeHlWMmFCY1VRUkdGQ3dydUY3M3JQWXFPWEhZNlNhUWs2VGE1OXFzUklwaEl2cFkrL0lxUmxlV1JlVk5tR0xIbDRERGtHUm0yRG5zbzl5ZjlhUmNkRThsNmtlK0J2RFllRHA3QUpuV1BDV3NWd3NEZlZLNTcyOWhXUWZGUFBKSk5NMzhXVmk3WDMzTlRlbzg3azZneDNueWFZNFVBaWhpSENJT05xZ1lhSm5qSjIySkZXSVJ0WEl6TTJmYkxaRXFWTmliY1VHWmU0SSsxRTdBcUxqNzZhV3UzQTdVRkkxM2hWSWtQWG1UU1NFTENKV0RNUmV3MG50VlZqR1Zlb3l5WE44WDZWOTd2MnFUNGZLejlUWmFvSkphUnIyNUhwTk1vaC80cGhSdHkyTlN4OS9WeFQ1ZmlOL2NkQnhhakJ3c2lrRnRaVzEvY1hOVWJsVWtoVk55UDd2SXEwekZHODl5dGc1TGI4MkY2cjN3K2pER1c3RXFiY2MxQlk0bVR6L21FRWpvYkU2cm5iNG9tL2lBN0E5enRlNHBSUld3eGF4SVJRUVBtaUt0Q3NURUZHNVpnZjZENHBRdGtPVkFXdXRqMkJIK2RESmxLWmppRnVURzY2YkFiZmVqS2JzVUJQY2c4MUt5TER4dG5FTVkzRW5vTitSUU43T2s5S1RMaThDY0hNVElxWGlkVHk2bXVaNTFrYzNTUFZXS3dTWGlqUDhiQ1NNTmlwMzAvTmRJNlN3VFlUTzJ3a2oyL01xeUNRYmxXRzROdjNvZU12Uy9uOU41Wm1jUkw1aGhYYmRlOFk5NmFueVBTRDhNT3JaWmVuc2ZsQ3hKR1laQk9WR3hHclkvdFhYUEM4Q2JNc1JpaXRoQUxEdmV2UG5obTV4SngyS0I5Y2tTaFdYc0FlRFhlZkNBUExsR1p0Y2d2T1FxOXlCVU0xVEZqMmRIeTdGbVl6azNVWHVwTlRFblVnaENTUnlLcDh1a0p3b0krclVRZm1weUwvRlJyalVRYjFDeWRrdVNYU25jM1BidlRtSG1HaEFXY2JuYTFRblBvQ2R4elRzYmxOTy83VTBRbWVlZFlJWWdmSW9ubnZxRjczK0tpdXhaUnlGdnZUckU2RjI0b0FEeWtNTHJmMnNhZHdySkpqSUZtQ3ZCSVRGS3JjRkdHazNIY2IxRUIxTjlKdmZtamtpMnV1N0FuUzRwOGV4R2ZQZkhkSnZrWGl2anNpOVJYQTVqTUw2YlhSQ1RmN1d0WFcrbVZiVHJMQUNRc1VMYzJwM3hyeVFZVHg5ekhIRUJUamNxam5aZ0xXYytna2Z5cVRrOFA1ZUNKUDBGQjlZNHFQVk02M3dlTjd0eUw2RjNpYU1oN3U2Z1hQQUZQSzZ1U0xFcWYxa2JWSHczcExoVTlSdGEvRlNWaUVaWUJRTlJ1Unp2V1N6MEtIUTdoeEhlK3RRQUR0ZmU5UjFqVU5xM1lnN2p2YWxrcnJYVXZxdGZVQnVLWEg2NVcxbjFoTy9lbUVvaHRDc3phR0JJOUlGSW5CYmUyOXVCVHJoWFJpUloxTmdCdmVreVdObkhwN0VlOUxZUGtxTWRHREF5cUNCeXlnVms4eVFtUndqK29wc080clk0NE1zWlpVMUVnMzBOdUt3ZWRLMWtjM0Q2ckZyNzJ2dFZ6QnpaZ2E3aFdQWWQyQ3hxMWl4SHAzcVZIS1VoMEtXQ0UyMHQ3MVVZV1h6VU9vc2RJdUR3UWFzWVpYa0JCc0ZBQjM1TldHaktoa3RFcjBnT2JzZE8yM2VvK0tJYkRCcjkrU09LUHpBWTBZc0hqYmIwN0ZUODBjaUtFS2xTeXQ2YmczdWFhaVNmdVhCR3dXS2FDZVAwN2QrOTYzbVJZd1NNZ1VuYzI1MnJuYVA1Y2hJSkFUaXRaMC9qUkpJQ1pWVlY3S0tUTkcwVDZITHRkSFI4TktYUUc1WThiVXdMbG5oUDBvM3B1TnZlbThya3V1bFpBVkl1UGVuOFk1aWRHSjlERFlIdlZENE9ydE1wTTBoZGRUYWxhNHNkKzFZckZZYjh2TXkyY0JXMXFEdVAycm9tT3d2bUlyZ0RTZVZGWXpPTVBvbEZ3UVF4RlR3bFhCbWF6RGF0blQvd3ArSVM5RmVMT0R5N0Z1QmwvVXNmNUtRc2JLa3kzZUkvenVQNVY3enV3OHhTZElCdnViZnYvQUoxOHBXa3gwYng0bkw1UCtZZ2xXV0poc3lzcHVDUDVWNlo4WHZ4WGpQdkNySjhtNmNrZUhxTE9zUDVlYXlpNnZnMVVEekFEYjZuc1J0Mk5kSnA5UnN4MDJlYStTMEVzdW9XMWNNSDRnUEhTSHJuTUorbHNpeFRESXNMTmJGWW1KdlRpNUJ6SGYrNnBIMk5jcFF1VmlrVlZHMXRRUEE5aFdJeStXTER3Unh4dHBzTFc5dmUvdnZWOUhLWmNNdWlTNFRacmJiMWk2bkpMSksyZHg0L0JqMDJOUWlqUythRkFLN240UGFwSG5xaWdJK2hqdU43bXFBVExHTGsySnRZRTdWTVdjbUsrb1hYWUthejIyYnNIZlJhK1paR0FXeTN2dlJseTFsTFhaZC8ycUhoOFlwWUFTQnJyWTZod2FjT0xET0ExeVVHNXRhNHBMSmJwa2tOdUc3YzJOTGttV1EvUVYxY2JiR29yWWlPVmIyT3gvcFNKcGd5ank5VEViZ2UxSU9zZHhESzVISUkyTklSOXh2OEFVTGJuWVUwcmFnSGFUY1g5QjV0NzFIWlVqQUNrbXozdGZtOUFsazdXaVJscENEdnBCRklNbXZ5d04xMDJDaW1Ja1M3STRJRCtvYjdDMVIxWnc0QkkwazZWTjZBSkM0cC9TWEdrWHRaOXFSTmltOVd3RWdOZzNONmJrbFZwVTFLKzUwMnZlMUpZRzRkR0RLRzlLam1nTENWN0xxWmdTRk43YjNvMGFKa0Y3aExYUzQzcHVSa0R1d1VBOTdVbU9SU3VxMTJYaTN0UUpZK3haWWd5NlFiN2FqUnpzQkdTRkY5cmxLWjBoWmJGZzdIbjcwcVJ5cU9RR0o3cUJRSlk2L3JhNGt1b0hhZ2t1aDBDTHEyOVY2QVlGVVVEMnUzK2xBQUI5ZHJBWEZ1OUE0YllFeXJwTmh2dHhhbExaWTFjaytyWTBsWERTc3hKMDN2cFliVTdpR0hsZzNCVzF3cTlxQlVSc1U1VlFHT3hGZ0NPUlRDbFFDdnB0YjJxVGk1dk5LQzYrbjlRSEcxUTBDaWRTNStwU2R1TFVEWkJTQnBRVG9zQjdiYlU1aEVhY2l6TVZBMkJCM3FPUWdYNlNiMnNiOXFmUXRIY0tReXI2a2IycEdNWEpLbEFLT3BKMHJ3T2Y1Vm1zYmh2T3hEcW8wQnpxdXAvbmV0U0pDbzFhQllpNVBZajJGVVdLVlkwWjRVWlFIMVhQQTl4VWtKTk95RE5IY3FNZm5lVGhwbTBDOStOdTlaWTRIUk13Y2FTVDZsNHQ4VjFHYU1FMzBhZ053RkhhczltV1FuRVlwcE5TNkgzM0c5YUdQTjdrbWN2ck5FbW00bnVUOEQ3L3dEN05tUlJrV0VlTXhxMjl2NHhycVBpaDB5bldIaHoxUGtic1VUSFpmTkZkZWI2TDdmdUs1UitCc2tmaDV5K003ZVZtV05YL3UvaW11K3FSZXhBWlQ2U0R4YnYvU3VzeHU0SG1PVmJjclI4UlVEeG9JMnVXUUZHMWNoZ2JmNlZDbTJUMzN1Zml0NTR6OU9TOUllTHZXbVN5Z0xKaHN6bVlLb3Q2R2JXcEE5ckdzRmlCWXZ2Yi9XcUV1eVN5Sk1kWUp1TGpnVWxHL2pLZmkxNmNsQ3N2QlVkNll2L0FCSW1DKzk2YUZrMXhlRnRXOTFxTkRpcE1PVjlXcFIrZzFJK3FJanZiZzFBQ2p1RDhmRk5ZOU10VmVQRUd5WFJndTYycDVIOGhsTjlOK0xHcS9EMjJPNVA5YWVTUUFnbGYycENXT1RhYXZLSUpzVGhrbGRTa1VoTjVXRzIzTzlWZlVPZHZtalJZYUp5dVh3SDBSY0RWM1kvZWl4WFVXTXhHV3JnbzI4dkNLUFVvL1ZWV1FXSnNCY0FiVXlNYkxHWE54dGdOdkdvT29qZGh2UWlMcXAwbXd2d0RTbUd3Mk9uaS96VFViRUFnZGozcWV6TytLSy9WWm1YdDdVTmZ0dFNyS1dOZ2Zha0E5anZmdlVZODFQaDdKK1g2cnkrUmVGYytrY25ZMUhXUXlkVVliUWhVcmoxMi9WLzFOcVYwTTF1b2NEMkljMlA3VTJnZGVxTUo1Z0lEWTVEZnVUcnB6NkVYNU0zT2JLeHhJQTlDaG1Bc2VkKzlNbEcvc25GYURZRGU1cC9NM3RqNVZ1YmhtdFM4SkhxeStWSkF0OUI5UHVhaVJJS3doOHlGRkMzVTJPLzJwcU8zNWYwMmV4T3EvdFI0RkMrRWdKWWZTQ1RUV0pMRkpHRG5VV0drRGhhQkdpTWRRMUVHd0krb2I3Vko2YzFITjhHVkJZdklBRytEVExQSEhMWlArbGYxWDcxSzZlYlRuMkNjRzE1VTIvZWtmUWlPa1p2aFJsOCtCekNLOFRZZVpRMjV1UmZtdFoxdmw4bUw2WWduQytodFNzRk93dU5qOXFsNS9rVWVhWkppSTEwaVJvU3dOdHlSdmFtT2w1MzZuOE01Y0RNV1I0YldITEZnZmVvQ1N1RGtuaHRoZjdPNmo2aHl3dUZWb0JpSVI3aTQyRmQ4OEtwVWl3MmdBZ3VXYzNJM3JoQ3NNbzhRc0ppSkYweHlxMGNoSDZBUllBLzByckhodGpraHhlRlJTVUYzWFF4MzJQSDNwWi9aR25SMFhLc1M2WTdFNFhabWprSnQyMzcxYVNUaXpNRzdpc2hsZU1hTHFQTUlsT29FS0VKTzlxdmhMYUFyNVpLdHNUZW9tUzlvdUZ4SWVUamMyRzFPcklHa3N2YXE3QlNPd2prR3dJdGZ1YWxZZDJKTnpjSG5ha0RvbUg2Q0craysxU2xBRUNodnFxQ3Jmd20ydlRzY2plV29QRkFkaXlnVTN2YTlQbU1oQ3c0RnY1MHd6cXdGellqZW4wbHVDbzc3ajVwVStRU3BuQWZ4Snh4UDF0MC9CSEdxNGs0SFU3QWJsUzVzRFdjd2dMS29ibXdRKzIzZXJQeHR4YTVqNHU0azZyakNZV0xEcUI5Vjdra2YxcXZ3NkZGV3dBVlFSNmpjbTlWTlJJOUI4TmoyWTFJczROVWRrSkQ3MjJQYW45V2lUY2tqOU5ONGE3UkVhUVBTQmVsSW9qNE43SGU5WjUyYTZITkpZc1NBR050eFFkRUxXUmlHSHYzcENsbVlxYnJiZ2U5TERmdzdKNm12YTFNRkdrZitJVmIwRG05SmJWTW9EZnd5YjdEZWpMSFM1ZGRTazIwKzFCM3ZjSW9WRGJjZGpUZ0lPTVFyRzQxMllxUUFLd1dld3E1dnJ2SWpBYlZ2c1VsOWxXNUhZbmsxanMyd3Q1WmdiTDMrNXExZ2Fzd2RmRnlqd1o3Q3ZKck4zQ2c3WGFwc2VJYU1KcGNscjd1MjEvaW9jRWZtSFF6SFYrazA3SEcwSk1jNUI3NmVhdk01cURsQjB5MHUrcG1hTldGOTdIM3B6VUlXU3l5QldOckx6KzFRWXBTSWdTQnB2Y1gycWRKS0NwWlNXMWRnYWlhTDhIYTVJN3dyS1FVWXJmbS93Qis5VGNqa0VVck1iQlZOdVBxcUxJeDhnRGRXdmNBamMwbUtORXhDa2dveldKRjZjK1lpUnFNMDBkUXlpYUtiVWx6cUFCQjQvYTlYT0lYejRValZoNWk3NlgvQU5EV055YkhOcFVQZFNUYjBqbXRsQXdlSFhKSHBOclg5L3RXYkpVenNjRXQwVXlPbGpHNnFXa1lEZFQrbXM1bmVGTXNaYllCVGU1SE5hV05TbUpNWUpRV3FGbW1BSmdrUW56QTQyQnBGMlB6eDNKbzV6T3pZWncwYmFHSXNDS0tUSHlUaEdjcnErbmpuNXFkanNOSkRJTmFvdDJOckhZVlV5eFJvaE5qcVU3QWNmZXJ5bGFPWXk0OWo1TEF5ZndoY0JTTjdyM3FYREpvTE5kMGNqalY2U0tvWWNhc1pBZlU2amxUM3FTTVZaRUlzNk1RdHU0MzcwalZrZVBMVE5aZ3NTNVNPd1NZTWQwa0c2MjcxTmd4QXhFN29vTnI4Z1d0V2R3bUlFZkFVNmQ5ZDkvdFZ4aHNVandhdGVtNTk3MUJPUEp0NGNpYTVaWkxMcU82bFFUd0RVb05kUVJJUVJ4cTNGUW84VkhHeFpyTTF4Y2NHMVNQUFJnZExBQW0rKzlRZEYxTk44RDUxZVZIY1d1ZGlwMk5IWnlkUUlWN1dPOU5xM2xpNWZ6SWp1QXZhaktLNlhVZWtudjJwQ1FVZ2tiV3dVTnBIcUtuaW1KTklrWm5KdUFEcFhlbHJlNVJMalVkN1VvbHZNQk9rTnhlZ2FEell4cVQxRUZneHZ5UC9TbTJKWFM4bG1BazlJMDIreHA0T3JNNGxGenNBeSs5UjhWSUxIV2J2ZXhER3dBb0hETG9RTGh0SkJ1UWFJU0MrcStrcU8zZW5KNDFZS29KU3cydWFiWlNnSlVpUWdXdFFOc1FIVWtzRHoyOXpTNGJ1eldCQUEyUGFtVUFYNnJrRTMycDVJeWtZQ1NoVzFFaFQzRkF4QkZnR0RLUFRwMG40cFRTRkYzY2cyMkk5dm1rU3JaZ0JjRWkxTGlVYTNERDBsZDBJMkZBL3dDUnhUcURYWWJFRUVjVXNDUnJCVkd6WEpKcExOY2tHSWhyRDdjYlVjbXFJSWdOeXcxQS9QdFFPQUpGVzNMV045NlV6S1d0b0JMZlBGTnJLRVd4WTJzUmUzZWx1TEV1QnRZQmpRQXhpakdKSkNXS3FDUWROUU5MeVNxcWowY0J2aXBza3BVbGJwNmphekRuNXFMSytvWFZOQVUzdFFSc1NyRUZZNUNxZ1hBdjcwdE5DRmRUMklQcUE0cER5QUFzbWwyQjNRKzlKaU92V2JYQVVFWDk2QnBjWVlJMFVZWVhBdVFBZGwrOVZiUmFaSGpzcklOeWV4SnExd2pRdWtkMXVMV1kvTlZqSXNtWWdBa1JIVUNCM05PUXMvZ2hSeHlRcVlYZFdsUys0SElORThLWFZHVUZoK3J0VDArSDBZdEdWOUJJc1dOSEpFc2s5dEZ0ckVqaTlTdzdSVXlRVlA4QW85Wi9nbVlEd1NhRlNUNUdhNHBlTmpkcjdWM20xalllMWNRL0JyQzBmZ1ZnM2FQUjV1WTRzMy92V2tJLzBydDdiRVh0N0c5ZHZoLzYwZUo2dmpVU1BDWC9BTVI3dzJnd0dhOUw5ZTRYRHBHTWRyeXZNR2pTelBJQnJqZHo4aTYvdFhpV2NXSkRFc3dGcjIycjZ4L2pCNlBYclg4T25WMkh0STJJeStKTXpnOG9haVpJanNQNU1mNVY4bThTeXltTjFZbFdVSGJpM3ZWYk11Um1QbVBJd0F6QUJpRGZhb3pEUXczdmJ2VW9Hd0JJR3EzQXFOS0NFUGY0cXUreFNZcERhU0RZQVZCZlRyWWRyM0cxVG9qL0FBZ1FPQVAzcUxLbDVuUHhlMU9Gc2NqWmlBTGkvTjdVL0VMTUNkN2RxWVM0dVJ6YmNVK24xaTNwMnNUU0Npa0JCdHlEU3JzcW4zcEtNYjIwOGlpVUhhKzl3UnRRSllHN1d1ekRsZTFNZ3N0N09WM3ZiYW4rVllLUnBPL0ZSbTA2amNjMDBRaEZyOGJVUWJRQ0NMaWowN1VvbjA3YzBnOHZPa0NSbldGQzNWZzl3UnlOcVVIRDlVNFppdHorYlhWck5oOWROZEprSE5zTGRpbzFmV09iMFRPRTZnaWE5eitiREUydUI2cWN4cTdObmpzVGZIemsyTmkyd1BOV0dXRUFxbWxtTHFMTDgxUTRuRUorY1p5TDNZNy9BTCsxWGVXdXk0aFVZRWh5RGJWMnRVQThWZ2RFV0ZFUmpzVmRnYkc0NXBpVVBGSElxMkJHelhPOU94SXlZekVSMktBdUpBdCtCUWR2Tm5BQXY2aTN2dGJhOUtoQ0ZJaDFnTnVWK0tkd0R0RGlGS0FDV0NTT1FGZDdEVjMrS2o0ZytYNnI3TnNkNmV5WVIrZGloZlp3b0pZMnRZN1VvSHF6QnFtS3dpeWxSZU1CM1ZlQ3BBdldWOE5uL3M3cWJxVElIVm8wWU5ORUR2WU54YXRKMHRNWk12dzZPZk1SNGxiV1RZRzQ0RlpmcVMrUjlmNU5tT0hKUjVKUHlzNnMzMUE4VlcrU1Y5SE9PdjhBSy9KeGlJRk1iTUdKc2Q5YW13dldnOE1NOVhIU1lPU3hWaXpKSU50U3VOcm43MDU0dVlFd1ppTkthSWpKckVoNVc0ckllSDh3d3VMeHl4K1lHTGlibjFlMVNOV2lLanNlQ3h3aDZsbWE5eTV0Yzl5TzFiQ012c3R5Q056N2I5cTVuQm1BR2M0ZDlCSUxBRmsrbXQ1RGloZmtnTnNLaGFvbVRvdnNKTVJENVkyS3NSdFV5QldDdDI3YlZVWUtVbkVNRS9VTGk1M3ZWd2tvUkk3aTdNYkc5TkZic21ZYy93QUszSnAyNTBFa1d0VE9HVzZ2NnJXTnJVdG5HaXpiRTAxZ2hTKzFyMzNxVGdRSmNYRUwyVldHcjdkNllJTVVWN1hOcVlueGd5N0xzZGozR3BjTEE4eFVHeElDbWxRNkt1U1BNbWQ0dE00NjY2anhiUythc3VOa0ViWE5yS2JEK2dxMGdRT0xFYXhwdnA0QXJMOU9JMHVCL01hU1RpSGFmMW42YmtuZjVyVnhNNUViRjFVTU4ySTIvYXFPZnM5UjhmSGJpaWlaQnZHU3FuU28zVzFPb045Ukgyb0lCRXV5dVVJdnpScEV5UksrcTkyNUp1Qi82MVVaMENGS3pKSm9jalVSZGxBLzFwSVVMSXBOOXpkQUtKYnU3RmlUdnVlTlgvMnBVcnNzNEdyWlJaYVlLSVc1YlM1RnI3T2U5SnRhTmlmVXhHNEgzcFJtVllXSUcrcTUyNHBvdnBZV0pKQTRBNUZPRUkrSVF0SUNEYjR0V2F6bU40V0xxZ2RHT214NUZhZkVLZktKWWxiSFVHOS9pczdtdDhSR2txbXpoLzA3aS9lOVRZdXpQMVVmYVpIR0JZNWwzWlFXMGtqdFIrWDVhNmJsMTVEazgxSXpXSlhjc3VuMUc1VWlvK0tUVEFoOHNqVHRkVHRXbEhvNUNTcWJCRzdCaEU0QUY3YXZhckgwR050dFJXeEtnN0Q5NnFybGxScmtXUDFWWTRhUm1qY1BGNWNSOW11YVNRN0ZJUnBINWVSbEpJN2R5S2VpZFpJMUphNEkvY1ZHSWpDL3dXMURncWR1OUNLRTZ2VUJjRzFsUDZhU3JRdTczR3B5aDFoYUp0TjFQREE3bXR6bGN6U3FDeFpvU1BwTnVhNW5rekI1VEVMaGdkYUFuYTFiakpYMGtKWmk1VzRBUHArYW81VlIwK2l5WEZJdjhjVEdna2lVbVZYM0I3aWxTQXZHSkJHYkU3bmtyKzFHZ0dMZ2NvU0hKdWkvcEZ1YVp5OXZNTEIzSzZXN0hpb0U2TnE3UmtjK3daRXhaR0VpY2xEdFkvZXN2UEZKSEsydEJZaTRBTmREemJEaUpHT2tNa2piblQ5SXJINDNDaEEyZzZpbzBtNDM1dlUwSmNtTHFzVGZLTTFpWkdWbExNcURqamltdlA4QUphNnNRaDNzdkpOVDhkRXhqZllHNStnamNWVllpTUtDRmJleHVUMnEvSGxITTVyZ3kyanhCUEJLRWdBcUR6VjFnY1N4VFFKV2kwMkdrQUdzVGhNVjVYbVhja0czcE5YZUJ4Y2lRRWdyTGQ3YjdNS1RKakxPbnpxMVp1NEozVlE3UEd6ZlRyWWIvd0FxbjRlUlN1b2FHMWNnY21zdGwrTkRxd2NFbStxMTcxY1lTV0o4U2t2clVXOUJJNE5VWlJPbHc1VTBpMmoyaVh5MUpYVis0Rk9Nc2lHVHkyc25aVzcrOVJGbVhRaGluR3BpZFpJcVNBU3FhV05oeVYvMnFFdWpoc0Uxb3hGeHZha0dSRlpsY0VvUnNmbWdKVlEyU3pFbmU2LzVVVHFXZTZpOFpGck5TQ2owQ2VUNWgxM3RiWTkvdFFMaHdMb0RjM0NubW1vanJzeFlhZ2JIL3dCS2ZlTDFLNnlhbVliMzlxQUk0ZUp3UklqQjdjamltR1ZXVFVVOVM3V0p0Y1ZNdUVqWXV3QWNiSDJxRlBFclJCUVN6M3ZyRGMwQU5QS095ZVVpN2JDOXpTNDNWcFN1Nm0rNHR6U0NqT3JFTnFZN0FFN0NoQUdpQVF0NjczYWdpL2NPU2ttVU5xUHQvd0J2M3BLeU1qUGYxRmhjajNvcDV2TFhTd0FSajZpZTRvbVlQSVFDTlFYajNvSEVoR0N6cXhUU0dVQzVONmRrWWhoR1FYUkR6M04vYW9Tc3hleTNLamsxSTBvenBJV0p0c1ZCdCs5QUJoUkV6bzVObFlia2NpbkppcFBvSkM4R21rUmhNRkxFcHZaaWI3MDlacERzVTFLTFhZV3VhQ1JFUEVxSGNKSUxxdzBqVHlhWWloOHdQRURjTCt4cVRKSVRZdW9Xd0lMZk5OWWFlODFwQ3ZxMkZ1VFFNZGZJMWlFUVlra2hiQVdBOXpVZTVaZEtpMStWcVZqbzJhVmlib29BdDhWRWpSVmZYdVRhNEIrbzBFZkY4RnJnVUFnVlFkQURiaHFqNGhHbHg2TWxvOUwyS3I4ZDk2VmdHRFJzZFdyY0VtMVB1TmVZSVJmYlluc2RxQjBsYUkrWTRXU2VFc2luekJjMkk1M3BLVExpY0lyckhjbjBzZVBVT2F0Y1FycUFGVXJmZGROVkVlakRyaThNMjF5WkVZOS9lcEk5b2p6ZmluL1o3RC9DRnY4QWg3NmZZZzNmRlkxN2YvdnpYWWlkOTY1UitGVkF2Z0QweXF4UEJ2TyttUmROd1pTYmozRmRYc0J4WGRZdit1SjRYcW5lYVQva3JPcDhBYzI2YXpqQWhkVFluQlR3cGZqVTBiQWY1MThTUHl6WUpHdzgyMHNSYUo3ZTZteHI3bXhFQ1ZDYld2ZmYzcjR0ZUorU2pwM3hKNnN5dFpkY2VIelRFSWplNDFYL0FOYWl6RVdNeDF5TGtFa24zbzI0a1pnTEh0UzNKMUg5UitLVG9Hb2FnYmtHcWhNT3dFQ0lFN0FiMnByRVJuemp2c3c1cHpDbFhJUThrNlRUV0tUVTZsU1BMQktqNzByQUdITmphMnBnYmpWVC9tYnN4SXVkeUxjR29xQzZtOXR0cWtLakt0eHg3M3BCbzdHMTdrQURWeGZ0UklkSStOK0tLTWxnUUNUMnNUUnRmNCszdFFJRnFJWmQ3MGgwdTdFOXpTcjJ1VDZUN25nMFhtLzlwK2FBSzIvcS93QXFNTFp0dWFTMjQyM0lxVmswUDUzTnNGRGEvbVRLR0hhMXhjZnlwZzhzK2syVmMwdzVaclcxY2p2YW1aVHB6Mk94TnZ6Q2FUKzlTc3FjRHFiRUZBRVVZaVZRQjJXNXRhb2t4Yiszb3d4WFYrWlRqdHZ0VDJOTlBkbnpGbDAzdVR2MzVxMFNRUG1RN0RUOVZySGlxVmxVNDVwR0JZQnpZWDcxY0xocFVkV1RjazdEVDIrOVJNY1RwbGY4ekhNRGU5dWU5TjRwaUhhUlNvSXVDcWprMUlXT3lJeE93M0NqZXhwcWVOVTh4cG1Jdno2U0xmSXBBSUdNVU5CR2lXSGRnZUwrd3AvcGlLU2JNSVNGVm1hNmhMWHVmbW9zb0xDenNpQ3hzUjIyMnJWNUJrOHVHeWZwbkh3QlB6VXN2cFZqcDF0OS9rWDVvRU95ZEVZa1liQVlmQnpOcWtoUTZnUnNQWUNvWFhPRGZOY0k2NFlsWjQyODJBOTlZM3NUVmRET2NCalpVa2phTFd1b2hqWWc5eGZ2OTZkeDJPbE1rWHEwNkJ1dDcxQis0bFhSQTZ6blBVdlNtQXhEcVlNUXkrVzYzOUljYy8xRmN3eWpORncyZXhTM2FQWGVJNmpZWHZYVnMwUVNaTkNVVmRaa0w2WDJGNzF4dnFYQ0hEWTNGaFVLQjI4d1dIME43Q25wV0lkV3dRRDR6RDJiVG9mZjUzcm9lVll0Y2FSWmhaU2ZWOCsxY2h5UE0zelhJTUhqVzBpZVNPekJPN3FiSDdjQ3VtOURldkk1SkNwTE81OU43NmJEbW1OVUJzbzNVTkU5Z1dCSXZ4YXJsSDFLaEk3Ym1zdERpVmJDcUhCdTI0MnJTWUtRL2wwSTN2WVdQTnFpWTRza2NhQ1FmUjJwYXR1UDZWR2hzRXNWdFlkK0tkSWJVQjdjMGc1RDhoMXFRVHZXTDhXYzJiSXZDL3FERXF3RHlSTEFvUE4zWUQvV3RteEZpQjlWcTVYK0liR1J4ZEhaYmdQTkN2anN3VFZxSEtJUVRTL0JQcDRxZWFNVGxtQWpYQjRXQkFDRFlLeTlqV2l3Nmd6S0FVSUM3S1J4VkxxRWN1a05yTGJxb0hhcmlLTlhqSktGU0xXQ25lL3ZXWmtQVmRKSGFraXlTVlFXTFhGellLUmVpRFdCQkY5N24vdHBKdXFCYmZwL2U5T3FRWXZMS2pVdzJOVmZrMXdtQjhwMjh3TUwyM0hORVFKYkxxRnh1dmFqQ2tPUjVnZlRhd1FjZmVtNUxzeElZUGMyQTQzcFFFRFQ2bDFXZjlSN0g3VVFEeGx5WlBUeFlIdFNpcENIVmZ6RitxNTJvS2dlMitxdzVGQXJHcGdHMUMrdGxGeFZOam9UcEdsRmpKdXhCRnJWY2Irb2hnRGJZZTlWV1pSNlhHcFM0WVd1ZHJmYXBJRlhOK0prc3pqZGpId3RpVHFKdmVvU2t0RUZlNU4rZmVyYk5NTUZrWmR6YzJWVHdLckpOY0x5SVFCcDJWN2JHdEtQUngrb2o3eUVkeVdrNVU4RHRWaGhwRExFRnNTV1BDKzFRNUQ1YzUxSUxzUWJxZTlxR0Z4U280anVTU0FTQnhUaXFwYlhSTnhMS0d1RytORnFiVStYY05jWEY2V2ZNbGRVQTIxV1cvTk5zNWsxcXdDc3ZvQ2U1cHFWajdzbVlHVklNWEd4WWdFZSs5YkRLSjJKQjFzRkl0Zi9BSHJuOGJpTmlXYStuWXBhNUgyclVaTmk0OE91c0xKQzNCMzFmdGFvOHNMTlhSNU5zcU9sNEdlOFkwc3B1TlJDbjlxWUo4bVUzU3lsaHYycUpsVW9rU09iZU5TQUNkUUkxZTFXRWlBeWEyMWx2YnRXYTF5ZGhqZG9QU1VOMnQ1Uk5yTU5qV1p6TEJhR2JWc2Q3ZzlnZUswYXNjVkJwazJWZGdSemYzcUhtT0dKakljbHRSRm1ITzNGNkl1aUxKRGVqRVpwbGtpbzRSa21JVzYrdmtXcko0dUJvMWtKdVcwRDBnWC9BSzEweVhDd1NwSVdZcU9GREM1ck9acGxIOElyWlVaWDlEallINzFleFpLNE9jMW1rY3VVWUNSM2prV01hZzk3bDdjKzFTampHU05aTEFiZXIvZW04OHdjdUN4RTJxNThvYWpiMzcxVmVlNFVYRjBPKzlhTmJrY3BOdkZLbWJITE0xZFVWZk1TUkExOWFpeCsxYWZKODRWSXBJM2R3RmExK2E1R3M3M0FHa2dHNFVHMVhHVTUweVRYbVUrekJUeFZlZUMwYUdsOGlveVNrZGtpeENUUm9pTXBON2pVbHQ2bEMwZ3ZpRkN0ZTRhTnQ2eVdTWjJYMEJIQnNOaklPQldud3pwTkJZc0dBNE5pQmZ2V2ZLRzEwZHBoekxJazBTMDlhUDVqRWxSdFliQVVRQXNOQU9oeFlrOWpTVWFUY0FBUmtXc3ZCcE1obE1jU3FmTGErNjgzK0toTGZZL0VwOG9TeVdCQk93RnRxZWloVlJkWkxnNzZqeUtqb3pGVGZaZjFxZHhUb2xRcnNxMkF2Y0Rla0FETDVZWW9GS25zM2VtNTEwd2pVZ2EzNmsyL2FuNUpEWnRtc1YyMm9talR5N01vWUVYRnFBS3h3Mmh3aXBwNUlVK29VMFdzaXNycXpXOXVCN1ZLbWRlNmhlMWh0VGFSeCtvVzBBYlVBMEF5SXF1VlBydllhdHhUVEJTRktIMUU3ZTN6VGhpdEdkSlFIKzhPNHFMOU92U0J0d1QvQUtVRWMraWJGT0l0Y2JBbnRjZHpUdW5XZ09uUzRIMDlyVkV3eXY1YXNMZ2xyQU1lYWxKcFVFV0lVTDJOeVRRRmpzTVljMjFXRWh0cHRmaWpuaUtTQzVzU05qMnFORFBybUEweUU5N01OaFJzbmwzQUw3YmduZWdrVHRFZkVsR1VFWGtZYldQQXFQRzVqazNRTXg0UGI3MC9pM05yb2ZOWTc3aTFxaHlTTXlCMjlKQnN3b0ltUHpNOHJzM3FKSXVTVFRUQnBGalMra0RlN1VHeElkQ0hSdE43QWltNDVvblIxUzlpT1gvMHA3NklwT3BGaGdoNVo5YitXYjZTQjdDcGJXL01nSy9tSnRZamFxeUdTNDFycVprSStyaTN6VmhHeUxKRXlIekVBMUEreDdpbWsxM1JOMVNPR3NWc09BZTlVMmZTTmhzSytJS2trUnVoSTdYVTFjSklNUTdzVkRLcEczRzlVL1Ywb1hJOFUzcExzdjhBMCs1TlRZbGNraURWUzI0cFArRDNuNExZTVpmNFE5R3dhaTFzdGlOanp2YzF0TFcyN0Rhc2wwYkltVjlMZE40T2RsaU9HeXlGaVMzdU5xMWNaRHhxd3NRZHdSWGRZL3dSNFRuZTdKSmprYkJaVUo0QnI1SGZpdTZYbjZUL0FCQjliWWVmRC9sNHNWamZ6K0h0eDVVZ0JCL3BYMXZBdWR2L0FFK3hyd3AvOFREcGhJc2YwSDFKRGFQRXpKaU10a1UyT3BVQWtCUHo2cmZ0VWVkWEViajdaNGRadlZxQjJHMjIxSmF3a1N4UHplbFNsZG00SHgzcHBsTEFFYjcxUUpSekNYU1lxUUFDK3g5cVRpMXU2M0lGbVBGSEF0c1FRRGNrWHB6TUFQS3NvYXluK2RBcEdaaHVQa1U2b0xQL0FJUWZwOTZadGF3SXRUeFlvb0IzVWk5eHlLQUhsWU9XWWo0bzFPbFFPRk8xNlNDeWdHMjk5L2FqSkRGZWQ5clVDQVlXOUZyM3BLUENCWXhGajcycFRBQmdkeWJXRk5oMlhhOXFXa0JXOW1zZTlYSFNHSE1tY3d5a2VpSWczK2IycW5YMTM3Mzk2MGZTMFRSUlI0aFZkZk5tMGgyUHBGaFVZOGk1VDZzNm50M3hFbjdDNTNvcENmOEFpR0JtSUpFNkxkZSsreHB6SWtEWjRWT3p0aVhIMzNwdVlBWjRFdnYrWkNqK2UxTExvRFRJb2JHK3F4MGtrZ0N4TzlhR0NNUTZDNXVoSHBKN2sxbXJhOFM2c2JNcHRXbldOWkkxR2xpQUZLMysxUmdTNGtlS1dOdGl0aUxkcjFIeEtzVmtZa0VXK21wYXd1LzFTYUZadHFyY3dsdEV3Rm1qYTRQd0JTSWFVdU11WUdheWg3TUFTZTNldW85T1lxQVpYbGVDeGE2NGpBSDhzYjZHN0VIdFhLNXZURzI0MUVYRjk5NjZMMHppVmtsUkY5VGZsbEllMzBtbFlocW1nMVRhVnhEVEJUWUxLTndQYWp4Y2tpTGRZZ0dKK29Hd0ZOcGlXT0xNZXU4aFVXYlR3MVNzWW1wSVJLMWo1bXB2WWdEL0FEcUZrcUhzV0RObE1ZRmlObERmNy92WE5PcGNMK2JsWkU5QWM3b0R1R0hjMTBxZkZhOHN4QjBGWXpzcDJzTGRnZmV1ZDUrbWxZNVNMdVpBeFBCQTdDbGlER1BEM0czd3VPd0draVNOaE9oWHNDTE1EOXJWMmpvMTBnNlBublJpcDFzQ25ZZkkrOWNDeVNSc3I2MndiN0JNU1dqZE5XMjROcTdqMDVLRDBQbUN1RHJSemNKczNJdFlVU0JGOTB4aWt4dVNra01ySzVCOHc5cTFtVlRzK0VBUDFydGNiN2RxNXAwTmpyNFYwTEt4Wi9Vckg2YTZIbEoweW1JRFNXWFZ6dHRVTWlTS0x4YmxGUFltOU9velNPMTlyaW8wTHJMRXd1UnBPMjlLaWxDRHVHcGpDaVhwMXFnQk9rbmZmZXVML2lBeEg1cnFucFRCUElxUnhZZVRFU0plNU56WVdIN1YyUFdGbUFEV3VDSzRGNHFZK1BOUEZuRnhoMVpNRmhvNEN3SDNOdjYwTjBqVDhkaTM1NHNxWURENWdrWFVIRnd2dVJWdkJKNm04djFxdnFGdjlhcThPRjFsTFhRTno3VmM0U1gxTUdzaFBJSHRXWk44bnFPbmlTU1dSVmM4bmxxY2lrS1NFb3BsMHJ3ZmVreG9GanVvSWp2Y0VtOTZFYnBxWXFENnRpQi9uVUxORUtEV2daajZTMTdoZTFKTHhoVWRvaUc5eWR4VHNjY1kxZXZjOGIzcGtOTEp1Z0RzRGE1NHBCdENYc0hZaFJZMzVibWlWd0l6ZVFvNVBwMjJJN2loSktwVUFEZmdpa0hhTndWMUtvRmgzcG80QlZHWWhDTjloYzFXWXNKdUNUcC9UMzNxeGtzcENCYk5hd1plTGZiM3FMaVFiRU1DbWtsdU42bGp3UVQ1VE01bUVjclFBbFExemJVS3JaVklqakQzQ2pZQWo2cXRzUXR2NFpPd0lZTXhzZUtyMmV5aENyTUxFalVkcXVRbHdjem5ncklHSWdaa0lSRmxYOUlQTnZhb01ZQ2tSWDh0bDNJQTQrS3M5N2xUdXQ5bEIvMXFESXFSeWhRbDdrNmpmZ1ZaaTdNbkxIbXgyQVJ5T3c4d29OenZ6U213NWpsWFFReHZZQTk3OTZqeE5ad3l1RVV2YTNQeFVoSW5VdVhrRWpNeEs2RHVLR0NWOEVYRXhQSGlKTmw5TnRSWDNxM3dVcExKNWhJQzJzMXY4NmdZZ1RTcE1yV1RTQXpFRGUxSnkvRW5EVHFvZmpZcTI5T2tyaVNZWjdNaXM2UmxHTjlWd1F5OFdHKy92YXRQaGcySUFVWFpBdTRQTllQSU1ib2RTVkFhK3hHd0krYTJ1WFlxVHpESWhENmhzbzdWbHpWTTdUUzVOOEJ5RWVSSytHa1lyK3BMRzQrMUl4SUNob21CWW14dU8xTHhpQlpmT0JBbWozS2s3TUtOeHJpdXY2Z0dJYmUxVnpSWlhTeHhGZkx0NlFOd1Y3MVZZakRxUzZPQzF4cEZoL0kxY3Rxa0xXVTM3RTdnVXc4VWJLWGR5cnIydHNhY25SV3l4VWx5WWJQc3FXVWFWZ1k2Z0l5T1E1K2F4dWFaUi9aczVXVnRWaUxraXc0NC9hdXZ6NFlTYXhyc1dGd0dGckdxSE9jZzgySzdJc2djMkxYdldqajFId2MxclBIeHlLNG5Kbmc4dVM1QUlRYnNwNTMycGhYWkdOamQvcURqL1d0Um1tUXlRZVpKSEdUb080WWR2aXN4aTQvSkxIUzFtM3R3UUt2eG1wOUhHNXNVc0V1VFE1Tm5KaHhrWjg3K0YrdFcrSzZObHVjUTR4ZzBSSVplU0Q2U1B0WEVvcGlTdGpzR0ZtYmJidld0eVBPREhPVjlDcmNYYS8xRDRGVjgyRytUWjhkcjNCN0pIWU1QaVYxalV6ZXJkQ05nYWN1Njd0YmZZZkZVdVdadEJpSWJCNUYvU0ZJQnZWeERQRThhcXA5VjkrOWpXUzAwK1R1c2VSU1ZvazRWd1dMa2FUdjNwOVhVMkxNTi9SWTFFUk5MZnhQNGdQNmwycDRUaU9LMWlleE51QjdVMG1qOWpoUXRFR0RNeEFzRko5SkZLRHBxOHRsc1R2YnR4eUthUnpvS0V1SSs5SmFVaVJRRFpncCtiajJvSFVoR0oxUkJpNlgwK3c0cHRkSUtTTGJXVGUzWnFlbmxrY3N3WUUyOUsrdzdnMUhrYlQ2a0FBQXViYjBEUm1adExIV3Vsd2RXNHNDRFRMc3JxV0tncU45dDZrejNuaFZWQURydnBKdnEvblVKV1dGaWpGbzdnL1R3TnFDTmt5SFV4amphUnRWK3k3RDJvNXBnb2lYU0RLU0xNT0tqUStZa2NRQmRiM2E3Y2oycVkwckFDVmxGaHNwMDdtZ2N1aEVlc1NNN2xkWHNyZjFxUWl0STJyUmRyV08vOWFpRlF6cWRybmNNUi9TblFWdnNEZTFtTjloUUpBZGwwV1pTUUZ0Y3NLcnlZeWQ3S0xlMTZrUzcraGlFQkcxK0RVRnJzWFJScXNMbFFPM3ZTaVNFU01HWU5yRXFXM1cxZ0R4VWRaQkRNMW1EQmpzbzUyN1ZQVENHU1FLQWp4YWJsamNGYWlUd1JSeXFRTGhkaUw3M3FXMVJYa2h6ekN0MUpJdWJIZnRVK01Nc1lXd1pGT3dYazFYSXF0WWF0TG4xRHZhcCtBS3JHc1pjbmErNUpOL2cwd2ZFdEd0R1ZDdUdKRzZMMnFsNm1Wbnl5ZTZXQnRkVzVJdnZhcmVOUE1YUnFDT045UTUvblZUbnJySmgyRHZxSWtSTGQ5MkZUWXZ6UkRyWC93REhrLzRQZXVRSmhzendtV3FpV3djV0doUk5YMVcwQzkvM3ZXelJRcWdBV0FGaGJzS3l2VEdIWERZUENwMkVLZnQ2UldyUTZsQkJ1SzduSCtDUERNajk3QWVLOHgvL0FCRHNpanpQd0JqelA4cVpzUmxtYVFTK2FvdjVLTVNyay9CMnIwNGVLNXYrSkxwcVhySHdCNjh5aUYxamtteXQyVjMra2FDSkRmOEFaU1Azb255cUdSN1BqM01wRExjQ3pIYjRwdGdBVFp0Z2JHL3ZSeHY1a01NbmVSUVRjMzdVbHZUcnR5TmdLekZTWlpDMUNPVVdjamJ0VXJFNlhoWUhjMitvKzlReVNGdmJVQmI3MU9rQ21JZ25rWHBHT0s4azJGL1dSNzArbW5UNmJBZDdVMXEvaEEyOUoydlRrR2xiMnVTUmUzYWdCMVhabENrK2k5LzJwejA2U0xXdCtxbTQ3aEczMmIrbExKVy9GemJlMUF3TXRhMXhlNXVQaWtYdWI2U2FNNzc2dDdYQXRTYnR1Tk9xM2NFMEFWYk5vUWx0aGF0aGwrSC9BQytId01SVnRVYWFtQk8xeWZiN1ZsY0hBMkx4c0VHblVYa0FJUHRXdk1vL1BBYWpzL1A4aFRDU2lreWVieXM4MWtYS3p0eDdYb1R5Qjg2RWlycEJ4UXRma0hWVGVTa2pPckM1UG5PZHovaXB6RjJmcUlsUmRCaUZKSHplbk1ZdXpRd2wyeGNsN2F0UjJJK3F0Umx6Nm8xVUFpTnVXNXR0V1p3b0puY2dYZEwydjk2MG1Da0xRUjJDL3dBTTdLRHo3MUd4eFl0SXFJcU9UclUrazJ2ZjVxb3pLTXRNMGFqVXE3TjJCUHZWaEppU2tieVdBS3FmVTNIN1ZUTkl6SkxMS0RJekM2a0hiZnRUQkdVMlk0dG9zUEtRQmZheEk3M0gvcFhRTWhuYUtjTGNmOUpiazdXRnE1bm4yS1dHRThBaGxWYjhFNmhmK2xkVHcwYXg0cVE2VmFGNHhlL2JZRVV0Q0kwR0hkL09keFlScUxtWDU5NnM4ZEtabzRSZlh5ZEs4bS9lcVhCWWxBaGErc0VBMkgwa0hiK2xXbmxOSGkwQllBckdiRlRmYys5UlNWOUQwU01UQWZ5Y2VIVVgwMk9vZlRiN1ZpK28xYVdTV0VXZnkzdnQyRmJQSHpMZzhBOHNoSVJmU1dIdldOMEhGNCthVFNTejdoU2VSVGtLWTNNeXd3VWM2Z1J5d09IRnZjTjcxMkxwYkgvbU1teDdyZFZ4WVdUVmZpNi83aXVUNHhQNDBxZ1hWeVFUOXEwZmhobUpiQTQvTFcxSDhzUVZ2L2RJcFdyQkc0Nk1ramdiRnRNdHlIRnlEWU52L25YVE1CT1RQSE1xblFicnB2c0s1WjB2aUJIamNUdHFMS0xnanVLNk5nNS9Nd1NGZ1ZZQzRJTnQvdFVFdXg2TlhGdXBQYnVUM3BSa01VZ0pJSVBIM3FGaHNRMDhmSTJGaUxVK1hCRVJRM045NllPUlp3S1RpWUVJdVdZTnNPTis5ZVpzL3dBU3VhZGQ5U3pxeXRyeHJDNDloc0xWNldna2ZDSEdZbzZSNUVEemM3SFNwTnE4cGRQek5pc0krS1lheE5JMHRpZnBKTithaXlkSFFlSGplVnN2TU15S1pHUlFSc0NDZm1yN0NBc3pNUUdDaXhLaXFiTHg2a1ZsUnRaSkxlNCthdWNNZEVicnBJUy9Lam1zeVhaNkpwdWliaHdSc2JGbDN0OFVjcWxUZHJDUi9wSzB5THFyT1VjcjJ0U3l3bGRpQ1ZzTDZiVTE5RjlDeXgwdXVqU3lrQWtjVWk5cEpBcDlRQUlaZUtES3dKVS9UcXZzZDdVYWJEMC9UZXd0dGVtQ2tabENTc290WWkrcjVvT3pJaWtBRUNqQ0FzVmNCaUJkV0ozdDgwa2ZVRmJhL1lVQXhsa0VtL21xdXNYVW1vZUowM0RNdXB1Q1Nia21wYzBXalY2ZlFPTnIyTlFzVkNjTWkzdnFiOVJIZnRVaUtrbHdWdVlDSlNiNkxnY01PU2FydEQ2OURnaFNPT2JiVlo0c05aZ1dRc3kyUGUxVmhBaGNveElhMng5eFZ5SENNWE1sWkNtSlViV1VFN0VWQ21iWE15dXQySytwaFZwaUNJc1F2bVdTUFNMRGtWV3RIZVVGZ1FDZVFiM0ZXSXRVWTJWTzZFT0VWdzhZQ3JhNUo5KzFIZzd5emtEVGJzYjhudlN5eXVXQVcrMWpidFRFSURZcFdZV0FzTGtiQSsxT0l1Rkt3NXdCTkkyclRmMGduZTlOUnNSTFpoNWFxUzNvM3ZlcE9MV09URU9VUmxqQUlKVWJFKzlSWThPWTVDaUZkRGoyTy83MUoycUdTYjNHZ3lXWm1KTFBwUzJvYTlqWVZ1TW94ak94Wlkxakd3OHhUY0g3VnpqTFpqREsyaFNFVmJYNXVUeUsyV1NZbVR5dzJuU0JiU2x1M2U5VU1zSzVPazBHYXVEWlJuelk1bExxeFpiQUViay9laXc4eWpETGYwN2tFSHNSMnBqQ2ZUcU4rTDNISzBjaWpEeUd4SlU3Mlk4L05VSytqcDdzRXNSTmlyYVRZbXkxR01pbUhSdWJIdjNxYmlBL21Cd2c4c1czSEZRM1VUV0Y5SVU4RHZRTmFzYVVCN3JmU2JXOVpwdVRBSk1GVXNGSUJHcnRlbjBFY2l0cUFZZzJIM3BUUUFJVlZyV055RFRsd1J1S2ZCbnNabHhsamN1aVAvZTN0dFhQK29lbW1oV1JsRHNBMTFKNEFycnNtRmpERlRHSEZ0aWVQM3F2ekxMZk9XWFNnME1wSVh0Vm5GbWNaY21OcXZId3p4ZkI1K3hzVFJUc3JDemdjamdqNEZIaE1ldGt2cEFCc0FlZCs1cmM5WWRLR0sySWlpWTNPclVDTEN1ZjRtQm9YTEZWdWVHVS9WVzFDU3lMczg5MUdHV2t5Y25ST2xjK2h3K0lqamxZRy9vVmxGeFcrd3VPV1JMQkFFTFgxRG11RFlISHRoR1ZpMncvU0s2UjAzMUJIaTRZNFJPY080SXZ0Y0g5Nm81OFAwZEo0elh0MUNSMFNMSFJSeEVOSWJEOU5xYWh6WkMraGRLU0RkdDdnL2FzNW5PSXhEUnhpS0xRQllsaWZxRlpmTXNXMFdJZHpNVlZUYlkyTnpWUll0em82RE5yWGlkVWRXanhyWWdBcXdDbjFFTnRwRk9RdjVhRXkyVTNJVnJmVjdWemJKODlUOHdGTThqS3ZwOWU0Yjk2MVdCenhjUzJqWHJhMWlML0FPVk5uaTI5RStEVnh5L0plQ1l5UmdBQlhKM1llMU5ZaHZKakFVL3czTmllNU5OTmlvSm9RNmVsaHo4ZmVrZm1Xa0pJQlMxckhzS2dvdnlhYTRIWFYybDArbGJnQUZ1TnFyM2FSWkEvbEZ4Y3JjY1ZLRTVKc1dWOVg2cWo0aVFzd2V4UlJmYTFnVFJSRkxvWExNbm9ZQ1JpT1FUM3FWclFhVnZZYzZXN0h2VWZ6Zk9WU1dDZkE3MCtWQzZiNlFwRnp2elNENFVQS1NrRWgwK2tqWSsrL2FpdDVpTkdvc0NCenRUU1FheUpCRURwQkZ0VnJDa3pPd3NYNFlXQi93RHRRU05KRHVJQ2doV1c0QTV0ZW8wMWhlUUF0dU5nTFdwME1YUlYrbmEyeDJwRWpzd3ZmVDIrOUJFK2hEWWdzeHNOR3JuMk5SVElVbEtOR0RmZFdPMjFQTmlBVmlZMlFyc3hYZW84c2JrYXhmWTNCTysxT1JESVdZekJGcEtDNTJEM3BVTWtrYk1XUU5ZQUFYdHZRYVdPWUZ0ZDFKMUZRT0thQUE4eStvRUVlazl3ZjlxVWFpOGl4Z0VZWkdDdTQraTNIeFF5ekwzenpyUHAzSzBEazRuTW9vMlZCZHRJZFNkdmdWQndrOWtaYmxDVGUxcTJYZ0hDYzE4Y3VuUTZsL3l2bjRwZHQ3cU9TZjNxM3BZYnNzVVozbE12cDZXZGZSN1FueS9NOHJtWXh4cmk4T2hzc2lpei9ZMWE1Vm5NZVBReE9yUVloRFl4djMrMVBZQ1h6WVNHWW16RWcvZmVuSmNEQk0ydG93SC9BTHk3R3UyU3BIaXplN2tmSTdiQWtjR3F2cXJKVDFEMHRuT1ZDUVJIRzRLZkRlWWQ5T3VNcmY4QXJWa0VBMGtrbXd0ZW5FMGx3U0xvZHFPR0M3UGhsTmhIeXhwOEViTzJIbGZEbHZmUXhXLzlLYnZwQ2hkaU9iOFZ1UEcvS29zajhaT3VNdnd5ZVREaDg0bldOU09GTFgvMXJFU3JZT3RyZTVySmFwMFhCQUdwMkpzUFludlVpSDFRMk81UCtkUmdTVFlpNDdVL2hSb0RBblVTZHFCcklzZHVHWGhpTFVwSE1MRlNCcE8vN1VVemFjUk9BTGVxMi96UkhmMDhrQzIxTm9jT3JJbXUxOXZidFR2blJNbXZVb1BCQk5RZ2JIU1J0eFMxd2l0ZVR5ejhIc0tjTUowZm9TNlNLeUhzVHZTUFVQOEFwU0tpODJ2M3FFOEl1Mzk0ZGpRV0s0M0lGQUUzcHFQenNiSk5zd2dRa0U5eWF1bURERlJPTmxEQUZiYlhxRjAxRCtYd2MwdGhlV1FxTGYzUnlhbU0rdWFPeE96WDM3MHdsc3FNa1VmMnVDQWRSbllnZmMwV0pJYnFBZ2NOT28yKzlKeXA3Wm9xa0ZqNXhOd2R1YjB2RWhtemtxbzBxY1FEWWR0KzlQSTEyYVBEWFhFT3hJMWRyKzE2MFdGMWZsdzZCUUFiQWdiL0FEVkRoaGUxeW9JWWczcTdobGZ5MTBNd1Vla3FHSE5STWV5VGlRZnljYWdFTnpaanhWYm1DcVkwS3NDTEJqYmJUVStYV1VSRlVhUWJtNTlSMjcxVjV6TXNRUWhqcUxCQ09RRFRVSVkzcWFYVmlZb2dWS2tGaVZQQjdWMFRvZnFEKzE4dGpFa21xV09JSThZdHF1QjgrOWNzelhFSEVZK2RtQVVCOUlGcmNHdEI0ZXdqRjlWNUpCSXZtUlM1Z29aQWJhaHBPeHAxQ0k3RmdYUmhoOVRLa1k5QkIyQUhzZm10RGg3dEpJWTNBVTJRSHVheUVHVllaTXlTSUdVSzVZNlRMNkZhKzIxWHZUa0F3K2I0V0FxeFZwZ1hESFZxdHliOXFpZkFwYzlRWWJ6Y3RURGx0UXZxY0hrbXNwaVkwVmtNYmFDbnZ6OXE2TDFYbDR0SDZpSGI2UXV4VWRyMXpyUGNNK0N4T2duUTdHeTMzdDgwaWRnWlhObWNURjBHa3FkVnZlbk9ocDFnNnNtaUQ2Umo4TTNwUGQxMy93QXFYanRVK2hXSTFLQ3JOeHFGVUdWWmkyVlp4Z0p5eW9NUE9VWnBBYmhXOUovb2FsWFFxWjJIcDkxZkZNV1pqcHVUWWR4N1Z1OHV4SWtnV09Ra1NjclhPc29KdytKeGNhc1kzSkxEVi9kUEJIM3JYWlRNd2lSeUFXQTBxUWQvbW9HaDZadU1qeEZvcG9mTVh6QWR6YmlyVERsVmtYZlZ0ZTN6V1p5U1hWakpGY2szVUVFYlZvb1pGL05GYm5Tb3NiLzZWRSt5UmRFTHI3TlRrUGg5bitQdVZJdy9sQSt4YzJyenZrZUhYQjRTTmRKQlJRQUc0dUs3WDQrWTVzUDRmUTRaQ2tqWTdHeHhTQmh6R0FUL0FKZ1Z5SEJTSFNnZEVhRmx1TGNqNHFISjBkUjRpRzNsbGhnN0pIdWRMZHllNHE5aGRWaGhFWkJOdjNGVTJBQWRHT29xTEhtcldBbFlJMmRGTmh1UWQ2elpkbmQ2ZDB1U1dGdVFRV0Z4dnE5NmNFL0tFaFR4eDJxT1hZSW9KQi9WY25qNHAxaUNHWUN4cGpMOFJTYWl3VUM1TjkvZWhMREs3YWlQU3E2UXZIN1V0bEpJWldLQWdHOU42cmFpMW5XOTc5NllLUmtYU3hKVXEzK01VbVE2RllzcFUzMkk5cWVsZVZ5bzliQUM0dWIycEY5UktYdi9BSVRRSll3WkdWRzlWbU8yajNGUXBtOVdoOXdmV05SM0JxYTZNb3V6Mlc5aFVDYlVUZGg5QjBuMk5TeEsyUWc0blRzVFlwWTYxdnVhcXlSaUVWR1YxQXV1c2poYXM4ZU5Jc0FvRGJobEYvMnF0ODUvTFZXVWdqc1RWdGRHTG0vSVN4Unp6c1JwM0h0dFVDUlRHVkVaVm1EZnpxZkpFRVZkV29ReUc2bU0vd0NkUXNTbXBVTEJDRHVTQnVha2owVU1rYlJHa0FaSkdLc2pIKzZPTjZZdXlZZ09XRWhjamIzcVpoSGFUQ01mU1dMYWJCckVWR21EUnpCU3JJeUhVV08rMVRKL0JTYURuaVlZaTZmWFlrQUhhMVJ4SXJrRlI5SnN4UFkvYXBjczdTSVZYVEhJM0RIdlRUUkFCdGlHc1FRZmNkNmNpT2FYUW5BNnNQaUVZRUt1NWI0clQ1WmpXRWR4cjFjcy93Q25UN1ZsY0t3akZsR29IZGczZXJiRE1IS2tQWTZnQU85cWl5cTBXOUxOUStUcFdUNHM2Z0FicXdzV3F5eFR2aVlUTG9WaEdQU2ZjZTFaUEtzVWNPc0s2aWcxY25lMWE2Q1pXdzJod1JHTjlqWUcvZXMxcWp0TUU5OFV3UlRLOEFBWUJDTjFOUkJHandzcElWZGV4T3hIM3B6QzZZcEpZR1FPYmVnLzVVbkVxRHFaeG8zc3dHKzlSTXRrVFVubUFnaFh1UUNPQ2ZlbkNVY3FnY2VaK3MwMUtpUmdNMHBZMzJBMnRTb3BFNWRUdU52YzBFVFJNaHNZdE9vQlYyOHprWHBMb0NxcUNHdWJFMjJwcFhDK2lQMEkzNkdONms3QVhYYVJSYmJpMUtIUlU1bGwwZUtpQ01GMmU5Z05xNVoxbDBaK1RFa3NhZ1FnNmp0c0w4V3JzazBsMnRwSUJISjNIMnFIaThIQlBHSThRcXloaGZjYkNyT0xNOGNrWkd1ME1OVERyazh6WWlBNEtaanBHamczTzRQdlZ2a2VPOGlhS1F5blNoRGFlemZGYUhyM280NVJNN3A2NEpHWWF4Mjl0cXcwQ3RCTVVZL2NudDlxMm95amxWbzg3eVJubzg5UGc5RTlQUjRiUDhrd3pPNGhSbExORW01dmZtc3QxZGtjOE9wNHdqNk9BdzVBNXBQaGQxQ3JZT1REdUZZUmtpNTJOaWIxMExNOHRnekRDaXlieXI5VnVHSGY3Vmt1VHhaZjRPOHh3aHE5TnUrVGlNT2FuQ0ZmVjZRZjBBRmEwR1I1MEJJTlFTVFUzcEwrazFSOVM1ZEpnY1hMNWNXZ0tUZFFMRDdpcWlQRUxEaWRhMkJKRjJPK2s5NnZxS21qbDQ1bnBzbTA2N2hjUXJxWllVS3E1c1FONm1yTXgxTVdEM052YTM3VmhNdnoxc002a1NqeWd0Zzl1LzJyUVlUTkh4N3hxaWlUekJyREEyMnJObmkyblU2YlZ4eVI3TDVtamRBUWhVamxpYkNtQThyRWdGZzNiMklvbFlwQ0dlTUNTOWlwUGFrVFRSSzIydFZZalVvTlFsOXp0RW1PVStZcVNKNmdkOUhmOTZtaXl1YlEyQVBMSFlWVmx4ckJDaHRYQ0sxVDQ0a1o5R3ZTVzdFOS9hbTBQeHRrcEpCSkhxdmRyOER2VERtT015Ry9PdzlnYWVnak1hTXFnNmlkemJpb3VLaE1lb1hWN2IzUDZ2bWtMVXVoY2NsMU9va20xcld0YWhPdjhOU04xdmE1cUtwWTNmME1xMmJlclJZeGlNT0dmUXFGU1YrQ0tWcDlrTm9yYnM0TVJLNmRSQVliVTB6c3NURWs2bEhGSGlVamRpRWE3Ylh2dHVLWllTeU0xM0J2d0J5S2RmQXlZOUMza24rR0Ywc291QUtKa0V3Rm0yVys5SEdXY2lPTm1NZGdBVFVuUWl3S1FWSkIzb1ExTGprVEZka0xydnJYUUw4MTFEOEptWEhHK0tXYzQ0RnltWFpmNWFrbmE4cmJmNVZ5bVZuaUxGUWlzaDJiM0ZkOS9CeGxlbnB6cW5PWFM3WXpIeHdSU1dzMm1OVGYvd0RPTmEyaGhlVk01VHoyWncwKzM3UFR1RGtPa0c5cmJGZlkxYksyb0ExU1lTUU5wdHNmMUE4MWRSbTYycnFrZVdyamdWM3BHSGo4dVpWTGxsSnVxOTdkNlhSYmhsSXNHQnVHN2loY0QzM1o4ZmZ4RjQ1YzA4ZU92c1NwQVU1dExHTGpteHRYTldzeEozVnUxKzMzcjByK1Byb21IcEx4NWx4bUdqU1BEWjlnbzhmcFdQUW9sdVZZRHNXOU43L05lYkpGMWFia0VIdjhWbVpJdFNMUzU2STRKVTN1VGJZN1UvQVFDN2JyWThFYzAweDNIdHVCdnhUc0xhbllrZ2tnV0ZORVlNV0Q1NnVTTE4yUDJxS0ZBRnRKQkhjVkx4QkRwR0NScUJPMXVLaTZnUVNvR3hzYmlnV3dmWGJ2dHVhblhERUcxMXRiZjNxR3lsTDJ0cDA4QTdtckNIWlVPazNDalpxQm95Y1ByUXNBYmphNTl2Y1V6K1h0enpVODZtQ3NDRnQyQXBQOE1mVXR6M29BbTRLSVE0SERvNEt1RkZ3ZGhmdlVteG14TmhjbFRiY1cycE5neWxXdU80VDN2VDJ1U1hFcnFERUcybys0cU5JZVp6SzJDWS9UcTBEem0yUGJmbWw0bTM5dkFXTnZ6S2xtdnMyOU41S2JZOXk0RDNrYlNEeFltamtqSDlzUm9TU0JpRkE5eHYzcDRpUnJZVkd0NUdRcmU5amZjYjFaeE9CSUF5Z2F5TE9vL3dCYXIxZXdLMjFBa2dqdVFLbEhHSmhsZTVZUWdLQXFpNFVIa21vaFNkaXZUalBMWUVNaEFMTHplczkxSGpQTWVkZ3lwQmdsMXVBTDZuT3lpLzhBcFZqbm1ZL2twUHphRkZFbGlyWDVhMjIxWXpxSEV5R09EQnNHalhlZVVFV1ptUEJiL2FsUUZQWnBQVTJ4RzUrVFdvOE81dnkzVlBUc3YwWHpBQVNkaHNmOTZ5NEY5SkIyUHRWNWxCT0dYSVp5TmEvMmdQVDlpS2RWZ2Q3eVhMVGplclV3VWdVa3F3c200djdtcjVNb2t5N0ZZaWVPTVR5WWR4R2RCc3U0dnQ3MW44anhuNUxyS1BGbmlPVXFWWGF3UEkrYTZGREt1WnZpWlk0UFRJK3pKOVBGcXJ6QUtYRjRiUEVUUWpSNHFOYitYSnNEL3dEYXVYZFErZkptRXNqRm1sMzJIeFhVMXk5Um1QbWEvTVNKVHZ6Yyt4cm52VytGQ1R5VG94MTY3TU9BQjhVeUl0R01tWWVXU3dMS3ZmdldieGNPbkdUeHNRelBGckRNYmdYN1ZlMi9pcW91UzNZbmdmYXF2SC8vQUljdHlBTkpRV0d6YjFaQm5RT2tjeEdQeXZMWjJ2OEE5TXhTbGg5TEx0Yjl4VzF3WVlRc0ZzVGJVQXB0dFhML0FBN2RYVE04SksybVJBczBhazhnN01CVyt3K09SY0RoVUJYVkMya2tiSFIyQk5SU0JjTTJtVzQweFRZVW9mNGJHekExc3N1UG1rdGU1dGNnMWdNSElyTEhwMDNIcUtzTnY1MXRNdWxEQWxEcEpUU0NEVURSS25aejM4UWVNLzVycHZLdUZUWGl5UnZzUllWenJCUm1HUnRaYlNWQUY3YlZwZkdiSHRqUEVYOHZEdkZoY0dzTEZ0d1NkeUt6dUJJVlJJWWdyRzNlL08xUVpPRWRoNDFOVWFQTHBWMHhveDlUQzJyaXdxeXcxbGVaVkEyTjdydmVxNUdhT0ZRcktGVWdNYmMxYkpLTllTeUF0OUlYdldXK3p1Y1NwSURxb0pWa0FCRnhZYlU0QVFxa0gwcUQrOUV4L2pPQzlnRnRZanZTbVBxVmR0eHNGL3pwclpjQ1ZDSFk2cnBhOWllOUtDa0tnQkFjbmUrOUdnVVNidVQzS3Qyb2d3SklUNkMzRk5Bak1tbWFheThDekxjN21rK1dJNHRKc0dTemFRZmVpa2NvNExrb3pIbWphRHlydGZjYmFqdnFvR2RETTdMS0ZKVTZoOVBzYWl6eEVxQWJPMXo2U2FseU13c0NRcFVlbGViMGlRNmZNMUxxWmhxdGFwRTZJWjhsTmlHRWVHM1VoUyt3VVZWSkdXZVJkUnVwMUM0M3E4a25pMHRGTkZjTXBWYm0xajcxVU9xdzRpU0hmV1IyTldvOUdQblh1STgwN2s2Q3AxcTNDN0MxSVpsMXRwMVJGUmF4M3ZUOG9Ha2FpVWIzUFAzcUxZaC9USnJJQjlSMk5UUjZLTW44RVo0MWxrSldORkQvQUtnTEVIN1UxaUxDY0JpZk1VRFN3WGI5eFV1VU9IUmhlUzZpOTdEOTZieFpKT2dwcHZ3M3ZUbDJWSktrTVRIelhHa3BNdHhxMDdiL0FCVWFXS0l5SUdrZHRMRUsxK0wwdGl3YTQ5R2s5aFJHTU5hUm0yWWtzVU53S2xLakduMVJTcnFOeXB1YmNtcHFxTVZEcEIwamNnbmcvd0RyVUt4RHFUWjczdVJ1YWxSU2VsN2pTcCtuYmcwclNhNUhZM1Q0TDdMSnhoemhya3lYUDBxZS93QTF1c3J4TFBENUxGV1hndjJIeFkxelhDU291aU5tMHVQVXBIUDJOYlBKTVUzbVF0clVnZ3FRMzZQa2o1clB5eG82alE1cjlyTkN3Q3JDOWl3M1hVcDc5cWNhTzhSMUZsTjdIL2U5TGpkWjhPNnhxWGlCSUlYazAxaG9uS1dOaXFuVDViRzFyOTZxTTM3R0RIS0xlcGJBM3V3dmNmRk1MT3pPeXN4MFdOZzQvd0FxWGlYUXg2Q3JGeXhVQmUxUnlUSERGY1dZSFQ2dWFRamsydVNWRVl6SEdGSWF3K3UzSjlxZEVqQUFHeTNGdm1vRWJlWC9BQTQ5VHNOeW9wOFNLVU45UTN2ZHVmdFJRM2NQdThqc2tpdWlEVGE0R3dvbkxxZ1BvQjJ1MS9xcGdUN203ZVZGM0FHOU50NWJ1U205L3AxYkNsb095cjZweW9acGhadGZyV3gzVTdBOXE0WG5XQmJENHhtdDZBU0xEYTN2ZXZRT0xJa2owdFpFSi9UeGYzcmwzWDJWbHNUTE9zWlpaRjlUSndMZTlhZWxudDRaeVhtOU1wUjlTS0tEb3JPdjdOelNKblZHakxXREhqOTY5QlpSTEhqY09ycTdFdGNsZjA2ZSs5ZVg4SmlHdytMTHF3QlBwMGdlbTFkdDhQTTc4eks1SVMybFlRRmV4dmNIMnAycWgrNUZUd2VxcCtsSXNlc01raW55NTUyalpYRWRsNzZsOXhYSE1aaFd3azhrZW02V0JzUjZyZmV2UkRzOG1GQ2FVbFVtMW5IMEw3V3JsZlhQVHFRek5pQmFBZ0VNOXRqN0NtNlhMeFRMM2x0RnVqNmtERTRYRXRoWENySnB1TlRiM0IrSzBtVjV3SkdoUjE4cHVBeW0xaFdUWDBlbGw5Uk53RDJxYmdKeEhxZm5leFdUL1NyODRwcXptTUdhV0tYWjB2QzR4Sm0wbVJnMXdMbmVwNzRobzNWbTBzM3RiY1ZpY0RtY2I0WU15RU1XK2xyZ0VWZXhZOVoyVnJLUFRhMnJlczE0NnRuV1lOV3BwSXZNTVk5VWF5b0FHTzNZaXArRzFtUmQxYVRVYkZoWWxmYXFZNHAyc0ZPcXdEV2ExWEdEeExOS1RMT0dMSjlURGI3VlZrYStPYVpQUlFOQjBXUmIzSWNtM3hUVTQzc3pKcTdXdVJUc1RFS0xIYnN3SEgzRk55Z3F2cUFmVjZkUkczM0JxUG91M2NTbnhjQ3hnbGJyS2R6cE54WWU5SnkvRk1BSTVGWTNCdTJxK241cDdINFpaRUpVQ1ZVWHRzYjFFd2NCODVaU2hVQmQxL3ZWSjJqUGxKcVJjZVl0bkRSTDUyMW52VGNwZDRXRWg5Tjl0Tk5TR09TN0tuSkZpYUtQZStsZ0hKMUtwMjRwcE8rZVJLbGtNWjFrZ3RjNkxiL3RVcU9TUVJTUjYwTEgxSGJnZHFiaGtSWFV0b1ZnTlJZRGo0b1NJWDBqeTlQNmpJRDlRcFYyQ2FYREkyWXlBUXpTU0FrSUxnTnRld3IxeitHekFTOVBlQ2ZUU1kyTUREWS96TWRGTEh2cDh4aVFHL3BYajdPVkp5ekVTWEdyeXlCck5oWHZMdzdVWkwwSjAxbHl4cjVNZVd3TDVKSHBQcHVSOTYzOUJIbHM4LzhBMUxrNGlrYS9DcUhDNkhERUhmZTlYR0hKdVJmY2JXTlp6RFlkWncwbVh1WTVFYmZDeWJFZkFxMndPTy9OekxGS2pZZWRSWW93NSthNkNMNE9DZlpia1dvcldONmJSeXczMk43V3B4dlNiVXJIV2NBL0dkNEZUK01uaGdjZGxLdkoxUDA0SHhlQmhEYllpTTI4NkszdVZCSStSYnZYeTIwaDR3NHVBM0FJc2I5N2o3M3I3a0EyTy9xWHVEeHovclh5Ry9FdDBDbmh0NDVkVzVOaFl6SGcvd0F6K2N3aUJiSUk1ZlZaZmdFa1ZWelIrU3hCbkxDZ1VLd0hCc1RRV3pHN0ZkUHlPYVhJcEpJSHBWdlZZbitsQm9qNlF3QkhQMnFtT1l5KzVmWGNrRGJUN1VraFU5U0MxeGF3cVE2bGlTRFllOU15RDA3THlMM29FRUVEVmRRU2ZtcHNVTWhpUnRPb2cyc0R6VUYxQkF1U050NzFPaEVnU0lnbFNDTEU4VUFTUnl4SkdzTmF3N1UwVnV4T3UxemUxS1pUcmtCVUtOWk9yM05JMWI4WCtiVUFXVE5xR29ONmlPUFkwOURJZk5XdzBQZXgxYjIycVBNcTJkUTdBYS81L05MTHVqeG5TTkpOOVVadlRCNVE1U1BNeHdDYjZaV3VlQjlWUHpLRnp0RHFMV3hVWTh3Y0c1cG5MR2FQR3ErNXRJK3dwMndPY3dnbXpIRVIrbzhXdlRnTmc4VEdWMFIxQkxHMjMwMDVGaTFpZ2JXVlVzdWs2aDZRQjNOQjFWWFoxWldCWWczTm1GVitPUG00V1pSSXlxeDNOdGxIYzFHQkN6WE5rVER3WStPRVM0YUZpbUhFby82c245NjNzS3lXS3hFMktua214RXJ5WWg5M1pqZlVmZjdWSnpMSE5tR0pWeVNJNHhvaVRzRjk3Zk5SQUQ1ZW0zN2tVdEFCV0NBQzZyWThFMk5YOFlhTEorbnl4R2hzWnJ1RHY5UTRxZ0lGMTFXWUR2VjdtSk1XUVpJVjJLblZlMTdlb0duSUR0V0pKVE1aR01qRmhKcUlCOVRiaTRIOHhYYjhyd0NZZkpjTjVJVmlFc3pMeHF2M3JodUhtV2JNOEppRVFORzBzWkVpbjZTZmYzcnR1WEZvY3N3Y2FuUXVqK2U5Vlppb1RpTUFjTEl6UmtJMXZXQjlMSDNyQmRiNEJzeHlxWXJFdm5vTldwUllrZTFxNk5qU2p4NnlTRmJ2MnJFNXJQTkNrbXNXalpyRmp0Y1ZIRjhqamliNHdRQjMxQXZZaXc1RlExdE5GcVlXazEzSDI5NnZldE1tZkFzY2JBeXk0WmgvR1ZSYlRlcWVGWW5WRVhUcFlYQnZlM3hWdTdRVlk3bFdhRElPb3NEaVpMU0pMSjVEQlJjTWpiQW43VjBscGZMbkdHOHN5aVp3cFZkckwzcmt1ZURUbHVJblFqellXQkVhamkzQnZYU2NGbXk0akRaVm1hZ2xjVkJISWhIWWtBUGY3RWYxcHIreHJWRzdpVjR0MkRERGxBaXNQcHQyL2V0ZDAzaUZrd0dHWUY1Q2oyTnVTTDFqc1JQSmdzdHk3RENRbkVTdVc4cm5RdnVmdldrNll4TDRTYkVHUUVLc2J0WURZMlVtOVFNbHg5MGNhNnl4YVpsMTFudUxaWEt2aVNxbFRZQUx0eFRtRWI2UzE5SllXWmZuYmVxUEtKdnpVa3Mwc2pGWnBaSkRxRnp1eDcxZlpKS0E2aDdIVTFnRzROVk0zUjNXaGpXMDBzU0toWlF0d29zTDJLa2oycVpHcXp1a202U3J5dHJXcURoWUx1ZjRZT2syS0J0anZWZ0VPc2szVUhqYi9Xc3Q5bll3SGk0ZVlQcUJJMktrYzBrSWhMZXUxOWdGNVB4VFZ4SEliS1NSWWszdmVuZ21uV3ltNUg2VDcweGxvZEI4c0t5c2wySkdvcUxqNG9pcExrTUQ1bnZjQUdrNnIrbHJCZ1JhdzJHMUo4cmc4c1R5ZXcrS1FCcDB1Yk5ZbmMyUGExTkU2VmR6ZXg3bnRUa2kydWdJV1JoenozcGlaMjBhUHFJMkk3VW95UTJ1cG1DN252ZnZVZVp0UllseWx6YTN6VXFWVlY3N29XSHB2dlVhZFdBVUh0MmJmZm05UElHbStTRGlBbGlyWElGaUd0ZXhxc3hBV2JFdEl0bWExckgyOTZ1c1RwVnlDV3M2M0VqTFpRZnRWTmNPR1Z3ditFZS95UGlyTUh3Wm1WY2pGNUVsUUJyRTNGeUw3ZTlNeUVTTGExd05pZVNmbXBJdy93REVBa0kwa1hOdVJVRHkvTWtaR0Z0UjlJSnNUVTY2TTJYREhKUW9nMUsvbUxwMDNJc1I5Nml2RTlrM0pKRmdMN0gvQUdxUjVtbG5SbVZmZExVbG9tY0VoRHFBMkpQYWxzaG5UWEJGa1pnMXp0cXN1a20zeGFrVHdhUXlycEk3aGFmMWx6cGZTQ0xXdjhWR25GbVpnclN5S1FFTWZIMk5UZkJVa2lNUExDa3JJeXlYMDdYQ3JVbUtKaE1ZdFExbmV4Ylp2dFRPdlhIWXg3Mk4xNHNiME1NUkU5bld5VzJERzVKKzlQZlJGSGlWazZJR0p0b3RaQzZ0WVBxWDcrLzdWb09uOFVxcWlzcnFtNWJVTHMvdGFzeEc0OHhBbG1rajlRQTMxZkZXdVRUT2pMcnVUdVEycmpmZ1ZYeVJ0R2pwOGpqbFRYUjBQTHNUS3NaSUxJVk9vQmYxVlBuWnZ6VWJ0cFR6RTNKOTZ6dVQ0MFEyWlVNcmNmeEQvbFdoVmxtaVoyUTZFWGEvTi9lc3lYZEhaNDJwcXhuRUFpWVhLcXhOdHFqVGFnU1NRNklkd1RiOTZkYThvUXJZajlSdjlKOTZobVVTT1ZrQnNHOVNxTzFOQ1gwRnY1cFZDV2trUHBJN2ZlblZkVWZReEVqRFkyL3pwcFdadEpWR0g5TnFVQ29aU0k3bnZia0NuZERLSFl5SXc2dVF4OXh5S2JKQUc5anAzQXZUWUJUMXFDWExmdmFqZitLenNFVldJdGIzQjcwQlpIeFNySXJlaGdwWFZ1ZGhXVjZtd3Y1K0JSSFpiZ3FRVFlHd3JWRUJGQWtiekFQU1k3Y2ozQnFtek5JaGg1RmtScEZZK2hiV0NuNzFZd3kyeXN6dFhCVGcwY1N6Q0NWWlNRUWlFNzZSYmV0bDRmNTgyQ3g4YUhUbzAyR25jRS80cXErcWNFdUd4QlJScExHK2xlVkZ1NHFueXFkOEppVjhzbFNwMURmWWZmM3JZYVU0bm4rT1QwdW90SHB2RDJ4MEthSExNVTFQdnV4OWhhcWJxSExJczF5MlFQQzFuMnNUOUpGUmVqTTdPWVlHSFZwWjlOeE9tMWo3V3JSNlBNV01hd29QdnVDS3c3ZU9YQjZUajI1OEo1KzZnd0w0SEdzanI1UlhZRS9xOTZyRW04c2xtSTlnT2JWMGpyckl0YXZKb2tsS3lIVStuYzM3MXppYUJVZXdYVFpyTmMzSk5iZUtheVJQUE5kZ2xneU1zb1paTlF0TTF5UllLM2F0RmhNd2VLY1JtQkpCWUZTVGV4NzNySFJPeXMzcUZyM1B1S25ZYkdOR3drVTZaQVFOUk93RkxPS2FJY0dhVVRjdGlUQXdPaTB4SUlVTnNCV2h5ckgyblZnak5mNnJyY2Z0V0R3R0xqbENXaVpYL1cxNzMrUldueWZIYVB5OGJ5RlNQVmM5Nnpja2FSMUdqenVWR3ZXUjN1R2t0L2h0YS93YWJsamtJWXF6V1EvOU04ZnRRdzhnbUFZWGUvdHNLY2xSamM2dE1nUHBBM0JIelZKblVSNWdSR2JXYkZ3cjlneTdDbzBuS3NkSzZqb0pISStRS2tZbVRXV1FzR0xiTFlVdzJtT1pDSVdLbGR5VDlSSGFucm9yVFNzY090RUthaFliV1BOTmEyaklVTnBkZHlXc2RxVWJpNVZENm0zdWR6dDJQYW1nUi9EM1ZiZzNrSkZ4UlZnMk9KcE1ZRndUZXh2M1B2U3J0RVNoZXdQZmUzN1ZIajF2TU5DM1ViY1d2ODA3SWhYVnNTeW5aU2JnMHE0R1g4a1RPRkxwREhKT29pbmtVTUhJc0JxRzkrMjFlNnVuZW9NQm1HVTRMeUpWa2lNTWFvNkc0c0ZBdVA1VjRzNlN5MDVwNGlkSDVmTEZITkJpTXdqdWoyM0hKQkh0WHNucWJ3Z2xnbG16UG9UR0psMGlzNWJLTVdDY05LOS9wVnVVdWV3cm85Q3FpMmVhL3FHZTdLb21xZ2xEVEsycTloczZubjk2dFJpbjh0Slpya0R1T1IrOWNpd2ZpUGljdGh4RUdmNVROa21iNFBlYkFZZzdPbnZFMndmOXQ2MldNNnhud21TUVpsQmttS255NGhiWXBaRksySXVTeThxQld1blJ5RE5oQm1zQlluODFIY2NBdGEvODZFZldtVFlxV2JEeDVuaG14dUhRU1M0YldQTVJUd1N2TnRqdlhJczk2MHdHWjVIUGpFZUhNd2pnakI1ZEF4YVplNmh2ZjVIdFdWNnQ2NzZLNkpod1hVdWE5SjVsZ01aZzBhTk1ZdUdadk9ndGNoMkhBQjI5Vks1cGRqMHJQUW1PNnFWY3RtbndVYVRZZ0wvQ0U3NklaRzdCbTVBMzVBTmVBUDhBNGdJVEdlSVBTdVo0Z1I0UFBzVmxUeDVoZ1kzRHh3aFc5REsvTEJybXhJSEhGZDY2Ri9FekgxUGlwOHo2a3l2QzlOOUt3d0s4R0hseEN1OGNLblY1ems4bGhZYWZ0YXZEL2pSMVRpZXZ2RVBQZXJqaUd4K1U0L0ZPTUk3Ry93Q1dnQlBsUXNCOU5sdFVHVEltaWFLYVpncm5aVkd0UUxqYmo1cHZ5MUxNZFRDMis1cGR4Y1dVYkN4MzdVblVHQklVaFQ3N24rVlZDUmlYMHlxZHl0ajM3MHc2MklGN0gySnFVU1Z2Y0Q2ZGlLWktnNmJyWUVjSGx2dDdVQ0VhUUM1Qk4vVHhWaEZOZUdNbEdJU3hJOXhVSng2cmJLYlcrS2x3UnErSDlaMEU3YXUzeFFBK0xNV0xjRWs2VjdiMEVqSnZZMkY5aFJMYUo1RklGZzFnYlVuVVZKRjkrOUFEK2F5Nk1KTXhDcVhHZ0FNZjZHcUNHYVdDM2x5YUZHd3R4ZXBFZWNTdEZLdUpDNHFKaDlGdEp2OEFGSjh2QnpPdWlSc0xxRjIxaTRGTUhqbVd1VGkwMHRkbWI2aGV4dnpUNm5UbnNZTFhRWWxRZnRlbytYQXE0Vys2bTZzZGdmdFVnRlo4N2dBRElyNGlNWEErUmVuV0J1WlZXVEVNMm00WTJDbm0xVVBWV1pKRGthWWVQV2s4OGhXMjF0QXE3eHdHSGllU1IwamhEbjFHUVhJNHJCWjlqMXhlWnMwYnM2UmpRaHRjSDUvZW1VQkFRYVVBSXQzRktQcEtnQWdIZWt1UWROamNBV08xcUcyM3YycFFFdC8wbk45SXNiRUMrOVgrZkFuSWNvUzIybmU1OVBhcUppUUNiOWp0VjFuWVpjbHk4WEN4c2dlNTMzdFJkQWRoeWZWRG4rWDRUVUcxZVE2TUJjZlNMai8xcnUyRklHRmhZcTdoYkxmOTY0VmxNLzhBK3NlVEUra05IQ1hNWXRkZEc5ZHR5L0gvQVAwN0NFc2hSaDZkSjlKRi93RE9xdVJBbVdFWkV0NDIzTnlQZ1ZoZXM4SHFrRTZnV1VFc09OdmNWdFpWME14QVZmZzFtT3N5b3cwakd4QzIxRURmU2Zhb2wyUE9TNTVpUE15eWFGLzRvbCtzZzJJK3dySlplR3drb2pZQW13WkxIY2I3ZnlyV2RRUVJ3eUlFREE2TEMvOEFTc25tUVRET3NzWTB6UjNCTjdBcmJ1ZmVyaUV1aGVldXZrZVFxM00ycG05eVI3MWYrSGVPbHhYVGh3VE12bVlGMnZaZUl5d05oOFZsYzRrTWl4VGhTVmJVcEo3WDlxVjAzbWpkT3ErYTZHYUdERUpITWg0TWNnTy83V3ZUbXVCRzdPMTRQTUhsektLWW9HamdYMUMrd0JOclZwczZ4SXlicFBPY3dpY2gxdzVWUXB2WUhiL1dzUEJwL0pUdmhwa09HeGtJZEpSL2QzM1B6VnoxMWl4aFBDWllBNWtiR3l4SXNpL1RKYTVQK1ZWV1djSE1rYzd5TUJNdk9oZEthQ29CK2Q2dnNoSUdoWFErWkdicnAzdjhHcy9reE1PRFZRMnBDK3JVT1FQWTFvTXBVTUdsMXNGWS9VQlZMSzdPL3dCR2txTkRoNUdSN0FxcCtvM0d3MzRxeFVnb2RLUm00c0ZONzM5NnFzTUZBZFZETkdBQnhhNXF4d3UwbWtzUUxiQXIvUzlaelIxZU5waCtwbVFYMUJqWXNvdGFuRkVpbGdvMU1kdFE5cUlrbFN5ank3bTFnZUtDaG95bWdzK3ZheW14L2YzRlJzc1VQb3hETVkwQlVqWXlEdlRRWXNWSkRIU3RocE93K2FNUDZBQklkS216QlJzS0F1N2hiZWtHNEE3clRyUWcwN084UmRRc2FqZjFjMHpKS2hSM1EyWUMzcTRQelVoNVBPVm93MnJiUUFmODZpU05wVWgxVm1PeFFMY0FEajdVVURRek9IZUlLek1XdU40eHVmdFRjcEoxQU42VzJQdUQ4MDlOS3pRa1hObTVIWWZBcU03QkVVT3BRc2Jla1hCKzlPU0swK0JsNUdRRFJ1bzJJWS96cXRtaWpFb0JqSlRrYWJBZzFaWTBIU3FCRVhjWDFDeHQ4VkFuVFFVc0ZWZ0N0clhQeFU4VE56Y0VTVkxxSkxOZGRtTi8wMUd4T2wzQUxFTUJzUXQ5Sy83MU9ZK2lJRW9RQ0F5Z2tYcGxuWlpuMGFiazl0Lzg2bnZpaWhKV1E1SXdBVHFTK3hYVnNTZmtVMFo1RWs4d2dtT3gxNkI5TnU5alQ4eStjaGRnWGE5anA1SHpVWFhLamVwaE1FN2FlUjhtbFJVa25ZSFZUR3oyTEZ3R1ZsM08vSDJwSVVtUlpkS28zZSt4RnZtbmRZWXNiaFh1Q0ZYaGg3VWw0eUlmTEFBUldMcnArbmVwRXlGeHNod3h0SVpJdDdLUFRMc0JUU3Bjc0dabEVXOTlqZWxDTllyajFXdnZvNHY3MGx5STJEcHBiVVFyQTloVXI2SzBoMkpHYzZyTjZocTBtMWlCODFKd3JBdXpTSm9CMllBL3lxdlpqRE9QS2NoYjZTcmR2dFQrSHU3blM0SUozdWVUVEdyUVFuVFJyY0JLSkdSZzJtKzU3ai8wcllZQ2R4QWpsektQK213QjJJK2E1OWg1WjR4cTh0SmsxY0tiYWZtdExrT01ENkZWZ3NodnFGdVQ3Vm5aWTgyZGhvODFwSTB1Snc2cklBVURLMzZRZDdWWDR1OEUwaWxURXJXRmxOOXFzMElEMkdsU3kyQWJ0Vlhpb0dSbUt4czBhZ0V0ZllHcTZOYVNWV2lPOHFNYnF6SUNOcmlsSkpHcE83T3hITk1OTElwUXNMU0VlcGpSSEZLVmJleEcxZ09EVHV5c3BmWktqUVJxeFNTM2MzTzlLY1lpT1lTSXF2R3k4SDZnS2lSTU5tYVJVWUM5eXU1cWNrcnlJRzh5ek1MazM0OXFCeXBpWDBNaGlrUzhEQy9tQmJPRzl2dFZkakltQ094UkRJaTNYZXIyTnpKaDFqQU9sVzFONmhzYWl5WWRYTEM1UXQzMDhpbFRvU1VOeW81SDFoZ3lFWm5qUlpta0JZZ2szRnRyVmlDSGhuMUtRZHI2bHZhdXQ5Y1pTaXdPOFliMEc3Qmh4WExNUWRMeUxHUFNOdERWdFlKYm9ubkhrOFR4WmpiZEhaMmNIaWxSSnpHOGpiQitEWFhNSE9rK0REQ0lHUWVra0grdGVlTXR4QWlhTXVnUFlmRmRaNkd6NUpVa2liRUF6QVdCSTlKSHRWWFVZK2JSdmVIMWlyMDVHc3hXRWJIWDFOR3JvaEZqZit0Y2Q2cnlJNWZpbkJReHlTa3VHQnV0cTdiWUNJRUM4aDJhM0FySjlXOU9ybUdHV1dOZ1psWWgxUDBuN1ZCZ3k3SmJUWDhucFk1OFc1ZG5GRHJpWUM0QkozUGMwN0RNVE56dUtsWnRnSk1KaVhVb1l3RDZmYXE2TUVTa2tlcis5VzBxYXRIbmNrNFNjWmZCY1lJMmt1aFBydnNHc2EwV1U0dGtZS3VvSWJhZ2QyRnU0ckhRekJuc1diVUFDQVIzcXl3K0taWlBPWXNTTnJxYmIxRE9HNHU2ZlVQRzB6c09YekhFWVVHeWtuMWVsdHg5eFVxT2JTUUZZK2s2bXNPYXcrUVp5WXNQclZ4NXR3b1ozM3Q3V3JVWWZHd1lxTkNXMU9vTndGNVB0V1BsZzRzN3ZUYWhUZ3JaSm5iWEtic1NySDA4YlZGZDlMYVJkckg2Z2VLbDRXYUpHUmwwcktTYmF4dFZmaVlQeWp5RmdFQk83THhlbS9CTk4xeVNpZ01US0ZPaHR4N2cycXZsbFhjbUxWWVczSkFOVEkzYUNOOUV0OVEyUHpVSEVFZXJVQnVENldhbGlReWZ0c2tqL3dEQnhkR1I3aFExOWpTVVU2a0lKRVMzdjczcHBRV3dvS05kN0FnTTExQnBjS2xBRkpJYnV6TGRhZWx5UjduUlo5Q1o3aHNrOFN1bjgyeGMyR3dXRndMTk04Mkp1WWsyMko3ZzEzWEIvaXM2Ulh4QXlmQnhlSUdXdmtXYk5MRmpZbzRISXdlSXVORGlRalpHdXdyeWYxRVRqTXN6NFNTQzBrTEtHN0MzOTRkcTRWQVFzS2VpMjFtdndhMzlOTnhqU1BPUE1SMzVyWjlHdXZ2eGllRVNabGlzdGVmTTgyeGVIY3h5WXhNSjVtSFp3ZVZ1ZlZ0M0ZxcGNUK09mdzB3K0NVcGxQVVdjVFFNRml3U3hwaDRaQmJuNCt4dlhnZUdRbVZBR3N0K0tsQTNacjNPbzFkZVJuUGJJbnNuTi93RDRpK0x3ZUxEZE5lSG1YNGJCaFNsczJ4RE14L2FNZ2YwcmpQalgrS0hyRHgwaXdXRnphTEJaTmxPRTFNdUN5cnpGV1V0WWZ4R1lrc0I3Vng1anFBWlR5ZnBJcHhwZEZnV1pSZS9wSEZNYzIreFZGUjZKUytWTkd3bloyWWdjblpnTFdXMzdWS2g2aXhtQldaTUdSaDBtaWFHVzZnbDBZV0tuNDlxcm51MWhjTjNPcllVM3IzdURkdUJmdFVkSWtmUWxBVjA4RUl2QjVINzBuV2Rhc2RWenRTeVNENlRaano4MG5VRnVRUDhBeW1sR0I3eGhneEozc2VCdFRSQ3F2SUxFN0VkcVcvOEFFWDJZOGx1RFRiblR1YkRjZWxlOUFDV0kzVVdPbjlSRlNZRjF3aSt4NzM0TlJyYVJaZlNwUHFVMUpoajh4Q0FkQXRhNW9IVVNKVG9sa0JMS1ZJSnNMM290TE51STlWKzVrdFFZR082TTJvYlhLMEZpVzJ5K1lQN3hvR2xCKysvZWtNeEs2UllmZmVsTGZ0NmlSWUVlL3ZRSHBGMkd3N2ltRHlYbDZuelYxQUJPYk54ZjdVZU5MTE5JcXNWc2RqOG5la1lNaFpZeTNCYWp4WVU0aVd6WFhVYk1CdFFCRVlsbDNKWWc3Z0VrWG94c3UvTkVMSGJTUnZhNDROS3ZZQUViZTlBQXNTTDMwbnVLRjdjMERzUnZ0Uk5leHR2UUFVZ0ZqWUFrQW43MWVaNFAvbzJXdmRudkdTQU5nb3R2dlZHTlRhU0FMV085K2F0czJMUDA1bHJhOWlHV3dQRkFIWHNoY25GNUxJc21waGhrMHNHdDZkSUJGZGh5NmVNWWZCcVFXamFNcW9ZYmcxeExLc1Zya3kyWFFTeVlhSWJDNEFDMkxiVjJUTEkyZ3lmTDlLR1RXdDdjRzl6dlZmSXVCS05MaFhVT29sQWNBY0hlcTNxR0dQRUNkQkdIVmtzTnRqVHVCeEtUeVBZazZXOVF0dnhUZVlEem83SWhRZGd4c2JWRFhKTDBqaDJicTZ5RlhKMUorazk2enViUmhveXF0c1JjWDVKN2l0cjFibHJRWWlUeTQyVkdUekF1clViSDNyRTQ2UXVwTzJwUVFCZnRWdVBReGxaaThRejRURFI3c3NaOWZ6VDJDQm02YjZuUllsY1J4Uk8ycjlGbXNDUDJOUjdERHdoV1lldFN3NzNQYXJIcGVGc1RsUFZBWTNQNWZ2dVRzVHNQYTRxVytCQzI4TU9wNFB5a3VRWXFVTE13TDVlNzdJNVBNVit4dnhXdzY2eFVnNkg2VndMeUQ4d2NSTExJeS9wdGNXdDhWd0RNU3pSNFZyNkdJM0ttMWoyUHhYUThCMU5pT3JjaXlRVGZ3NWNDajRaNUNObjN1R0h6YXErU05JdTZTTzdJWDJDYTJIUlkwV05uQnVBTGE2dXN0SmJEQ1hTeWxMS3FuM3FraEVoZ1ZZanVvMGxxMEdWYVpJSXpkd1R1eWsvMXJMeUhlYVJjbHpnNUh3emhDUzZBZ21MdFU5ZFVqa3I2R1hmeSt4TlZxUnNzaU1qRmhMOVJQNmJkNnRJdlNYZTl5UWJzZS96VkdSMHVMZ2RZQ1NZWGxVRzNxUzIxNmFWVkVxcVpTVkgwc1AwbWxSUm9xN2pXQjZpQjMrTDAyMmxmTXNTUWVQOEFhb21XN0pid2VTaDFFT3NvMURUeVNEYmVpZjB1aFZRV3RZS3gyRkhBcXBKR3hHbDc3azhYdFRic0VNbXBmVHlXVDlYeFFPZkFjS0JvaGRiRWczRnRxaXk2OFBMc1NkdDdqdFV3T3JSS0NDVGUrOU1ZbU5rS3FOUkFGeUFiaTN0ZWdXWFZrU1VyTHBETlp6dUZ2MnFIUDVreW9CcUc5ckExSVlNN2VXcDBnR3dIZW01R2FNeUt3Tmh0dWQ3MUltVVpja1p5UjZYWFV5YkZHR3grOVFIQWttMWVVZ1UzRjlYZjQrS25sbVdOOTJzQmNINXFEaVNaWEphRVJCaHRZM3ZibjdHckVWeFpSeXV4Z2txQ3dRRUFhWDMvQUswek1xb2dRTGNxTnQrYWYzR0lVcUJ1dXJUN2p0VEpWbWxMTHFWaWR2N28rOVNMa295QklFWkhrV1Rld3NGTnJWR2x3OGl5T1BxMnVUYXBUSnFiUUNsaVQ1aURtbVdTUkVSa1NTNC9WeXR2WTFJaGtvMmlKaDNjU3ZINVN5SzMwWE5ySDNOUFNSQXJhVUZkUE5oY1UzRU5lS2E1MUtSY2dEWVZKVmxLNlN6SUdJc2JYc0tkd1YxSDVLK1VLVUlBVkEzcUROdHErS2l1UE9qYTRVTXRpU050Nm5ZalRIWVJLWm5Cdi9FVTdnODAwcUpFN0s0REIrRlBJcVN5dE9OdXl2RHRJRkVxcXJINmU0Sis5UElqcW9YU1dYVUw3Ylc5cWJRZVZxajVDbjZXL1VQY1VuQ1loWUozRWV1UjIvdWczc2Zlbk5jRlcxWmNaY1E1RVpiU1ZiZlUxeWZhMVhlRXhOcEZOaXNnYXpsVCttczloakcwWDB0RTE3Z2tDOXU5V2NjcWFnVWtKWURjRWdBVlZuQTJ0UGsybzMrQXhDT1ZBWWFQMGwrUDVVOWo5TXp2WmpKSElQckcya2lzOWx1YU9XdzhrcUIyWDBFSDBpM3ZXbFdTT2FKVlJnRUp1TCsvM3JQa3FaMCtMSXNpS0hIUU1qS3lGV0I1dWQ5dTlSbGtIbVdqWXRHdzNKOTZ2SmNNRjFvKzQ5enpWRzhCd3psWkxBY3FDTjZSUDRHVGkxeUdqdkdDRmZYdnNHNy9BQlZsaHBqSS9tYVFGWmZWdmZTUlZPUVkyR3FFU0lEZTR2ZWxSekNOMlpmVGJmVGZ0OGlwTnBGQ2FUTkJwSVFNZEpEY3N2QXBVMHFvbG1pVmpmWlZPNSthaTRTVnlQcTBvNHVVdGNIN1ZNVlZLM2ppWmdSdHYrcWthb3ZRYWtpRm1HRUdPaG04NklLb0E5STJON2JHM2V1RzlXNVJObG1QY3pNemhocUIxM2I3ZkZlZ1NoTWhXWFVwT3g5Z1B2V1A2NTZPT2JZWm5nVSthclgyNUkrOVd0TmsydW1jL3dDWDBqMUVOMEZ5Y1R3ODdvdGkxdmcxZjlPWnAvWjJMVDFmd3kxLzZWVFkzQlNZREZ2RTl0YWZYYzNGNmFpeElqa0Z5VUJPL3Q5cTE2VWtlZjQ1eTArUzJlaCtudW9WeHVHMXRZNmovZXVmdjlxczU0QTZpRnhvaFp0U09CeWUrMWNXNlY2b2JBNGtKTzY2U2RJSlVnb1BjZTlkbHl2TXNObXVERGVhcktvMFhJSWEvdUJXSG54T0VyUFN0RHJZYXZFb3ZzNTMxemtLck94dzZFanNyYkFIM3JuVStHTU9vTGNwZmNIdFhmOEFPOHVpelBETXFKRzgraXhaallnRGcvTmNkenpLNUlKejVzUGxzTGhiSDZqODFkMDJTMVRPYTh4by9UbHZqMFoxRHJhelhGanllOU9xNTBKcVVCYjdFTnZURWlsSkpOU2xsdjJhMjlMRGk2YWwxRGNiSGcxb3RVYzBuUmVZREdIREY1bDlKVUJXc3czRis5YTdMTTl3K0xSaDZvVlhjSGtrMXp2Q3VGYjBPV1l0NjFQQXEzeTZaRm5qbUEvaXhnaGd6V3VQaXEyU0NrYTJtMVVvY002akRtY2Nza1FXTW9tbXdabDVhbk1ZMGJDUWcrZ0RmVjcxajhxemFYVUxPRmRtRElqRzkvZ1ZiSEh5ejM4eitHaGF6QmQ3R3MrVU9UcWNXcVU0Y2srRlFZMkFJdW8yRithU0l6cExlV2hKR2tLeHViMUVkcFRGNXFNQ2x3TmZCSDdVK3hlTXE1VlRxM1c1dFRkdEVpbXBJTlNzVUxJMGVoMTBqU2VhbEhFTkdrbWxtVnd1b0g1cGlQRWFJdDR5TDdXSnZ2N2sweG1Ea1paaVhjRlpBdnAwdDJvUzVRbVNXeU5vem1ZMmZwek9wSHRyYUZyMlBKOTY0bEgvQU5NZHRlOXV3cnQ4Y1kvNGN6RVNoZ1RoWkQ2dU9LNGZEYnkwRnJXV3hHazdWc2FkOEhCZVZYdml5VEJaWkF4QVVIaTMrZFAySkNpKzE5dm1vaXVBeVdzV3ZianRVb3JvREJkeWVQaXJyT2VrcVk0eERNQVBTM3Qyb2E5YzNlMXVEMnBEK2xBYkhTTmhiazA0cmhpTzdmNHVMVWk1R2ppbXdMWElLZS9la3RkMkFVRFNSdUJSeGpVTDMxYWpZQTBtOWc1WUdOVjIvZWg4Q2dZR3dCQTIycEpKQnNvdXg1RnVCU2pzbGg5RmlXSi9wYWlqRndEYXhBdHZRSUZLRnNCOVM5aVJ2ZWthajNzZm52U3VCeTFnZDcwblVGQklETnErbS92UU9vSUFqVmNOcXQ5TjZkdzZlYXBKYmZnZzloVFZ5R0JKdVFOelQyQ1pkRE1HK3IwZ252U3BXRmtoby9MQ0pxSkpYVnR4YWpVMkgwLzFvanBNWVlNR1ZyajdiOFVsSmRyQU5ZYmJDa0NpaWlPcjFjRHVLTmpjRUh2UW9Vd1Vld0pBbEJ1ZlRZaWw0ai9xekZmUUMzYWhRb0FocTRJdFkzOXlhT1UyVUg1b1VLQUYvb3ZSWDA2VGE5elFvVUFJSUJJc0xFR3A4K0s4M0lzT0NMbUtSNDkvWWloUW9BNmhsY2hpeXZKcGh3MENyWWU0V3UxZFBEejhseXQyWmdKWXJtM045NkZDb01uUUQrVlNpVE5DOFpZYWlWMHNkdHF0OFlRMDF5THR3TDhDaFFxRWxmUnlqcjBmbDh6TTVKSmFGVTByc0MzdWF3R05qVXZxS0xhNUp0OXFGQ3JjZWlObEVScWZEUWo2VlZ3U2Y2Vm8rZ0V2Z09vcGYwSERNaFg1Q25laFFvbDBJY3p4eEZvRkY5NzF1dWpJMGp5UENGNzZYTERTdkFPKzlDaFVjK2pUMEgvWWF6Q0V6NFowWUt4aFlEVWYxZmV0RGxwTXNVRWdzaVNQcTBLT1BpaFFyTXlIYjZUc3RjTTdlZTJzMmRTUUN0V1NnakRySVR1UGptaFFxaEk2VEVPeEJaMUszS2tJWHVQaWtwYVY5SEFJQm9VS2laYUpMTmVVZkl0U1BOSmxXTWdhVHR0UW9VRDMwTjNVRFZ2YzdOVE1zaU1qeHNwdW9KMjczOTZGQ2dXWFJBRU9wZ21zcnFHeEEzRk40bGhCSGQxRFdGaVY1Sjk2RkNucnNvc1l4QUlqVmpaZ3d2WTAweWxtYUx6R0hEYlc3aWhRcTB1aWprSUtrUzRqU1ZzUWRtQnNiVUpHRTh6UjJJbGtPa1BmaWhRcVJkRk9RZ2hrdElvVWxpVUpZVURhSlZDK2hqK3RleG9VS1ZqVjBSMWo4NmM3QmQ3RmJiTjhtanhER05qQzRWbEF2Y2JVS0ZJUlI2SVdMWXJoVmtVbFZ2Zlk3MUNneG5tQXV5NndEWUJ1YUZDcDRsTEx3eHZFeVJ2S3dDbEJ5QU8xTllSZzgwaHRzUlllNG9VS21aVmZhTE9MRUZjVXFXQnQ2YWtzZ2tVeHlvc2hHNGJnMEtGUXZzMElkRnhsdU5Ma0p1VUMyczFhaks4WUhWSXpHQ2kra1g1b1VLenBkblI2UG9zcFJxaURMc1ZHbmVvV0l3djVoV0VsaVVXNFBlaFFxTDVOS1JSWXFFbHcyb2k1dGFrRUdJQml4c3cwMkZDaFVxS0RTM01rNFBFT3NpZ2srallFR3I2SldqRWo2dFRDeDNvVUtheTFqNkhDVkpjaTltTzRKcGJLR2taRHQ2UHBIRkNoVWJkUzRKNEsxeVlIcjNwR0RGdkxpb1JIRXhUVXdLOG11UEVERGx0WTFsV0kwM3VLRkN0dlR0N0R6ZnlNSXJQd2c4RkkxbXQvMHorajU3bTlibnBqcWViQXlzOFVzdW1FS1NHdHVQYWhRcVRNazRsZlJTbERKVVdkYWdsT0l3VWJxbzFIMUdWdnFzZTFZbnEvSW9sa1p5NTBrajFjc3QvYWhRckowLzVuYWF0S1dtdC9SelhNY09NSmlWaWF6cVVOdHVONmlGTllLQzFyM3NSdFFvVnZRNlBPSjhUWWNRVkpkRnRnTGtqM3FUSExacktUcWphd1lqZ0doUXBTU0pvTXBielppVHVRQVNmYjVIelYxaDhXak5oMjlZTHNVYjV0M29VS3o1cms2WFI4cEZ6aDhUNTBNaXhxRUVJRE1UeTE2YU9KWjVRUG14dlFvVkEraldrcTZGeHl0cWtZaFdXNDJiZW9XZVNOTEM4Vit3WUMyd0YrS0ZDa2oyUTUvd0RyQ0lhVEpNZkViWGx3anI4Q3dyei9BQnUyZ0crd0J2NzBLRmFtRG80N3luY1A2LzhBMGNnS3lPcFVIbjlScVZxc0dJdmNHOUNoVnRuT1M3SEJJQUhCM1cvRkVxZndoWThFODgwS0ZDN0dqc1FEQWtDMmxRYVROTXVzTHVWUFkwS0ZLK3dFdklxMlZsT29jV08xT0ZsYlViZHFGQ2tBVHF1MXJmYW1wZlNUOGJtaFFvSGhFL1dWSHBIQU5PNGZaTlpIcE93SHNmZWhRcDBSaEphUHlGQ29kamNtL3dCNk5TVXVBU04rMUNoVFNUNFAvOWs9XCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return normalizeComponent; });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzPzI4NzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHsgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgdGhpcy4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290KSB9XG4gICAgICA6IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICBpZiAob3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgICAvLyBmb3IgdGVtcGxhdGUtb25seSBob3QtcmVsb2FkIGJlY2F1c2UgaW4gdGhhdCBjYXNlIHRoZSByZW5kZXIgZm4gZG9lc24ndFxuICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgbm9ybWFsaXplclxuICAgICAgb3B0aW9ucy5faW5qZWN0U3R5bGVzID0gaG9va1xuICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzPzI0ZmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxvQkFBb0I7QUFDbkMsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0EiLCJmaWxlIjoiMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiAnQG1lZGlhICcgKyBpdGVtWzJdICsgJ3snICsgY29udGVudCArICd9JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW2ldOyAvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuICAgICAgLy8gd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuICAgICAgLy8gSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXG4gICAgICBpZiAoaXRlbVswXSA9PSBudWxsIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSAnKCcgKyBpdGVtWzJdICsgJykgYW5kICgnICsgbWVkaWFRdWVyeSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJztcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcbiAgcmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === "undefined") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve "head" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }\n                // }\n                if (typeof target === \'function\') {\n                        return target();\n                }\n                if (typeof memo[target] === "undefined") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(9);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== "undefined" && DEBUG) {\n\t\tif (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === "object" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = "head";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = "bottom";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error("Couldn\'t find a style target. This probably means that the value for the \'insertInto\' parameter is invalid.");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === "top") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === "bottom") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === "object" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error("[Style Loader]\\n\\n Invalid value for parameter \'insertAt\' (\'options.insertAt\') found.\\n Must be \'top\', \'bottom\', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement("style");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement("link");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = "text/css";\n\t}\n\toptions.attrs.rel = "stylesheet";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === \'function\'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don\'t add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === "function" &&\n\t\ttypeof URL.createObjectURL === "function" &&\n\t\ttypeof URL.revokeObjectURL === "function" &&\n\t\ttypeof Blob === "function" &&\n\t\ttypeof btoa === "function"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join(\'\\n\');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? "" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute("media", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn\'t defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += "\\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";\n\t}\n\n\tvar blob = new Blob([css], { type: "text/css" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanM/Njg0NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQU8sQ0FBQyxDQUFROztBQUU5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQSxLQUFLLEtBQXdDLEVBQUUsRUFFN0M7O0FBRUYsUUFBUSxzQkFBaUI7QUFDekI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCA/IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpIFxuXHRcdCA6IG9wdGlvbnMudHJhbnNmb3JtLmRlZmF1bHQob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.7\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n  function isUndef (v) {\n    return v === undefined || v === null\n  }\n\n  function isDef (v) {\n    return v !== undefined && v !== null\n  }\n\n  function isTrue (v) {\n    return v === true\n  }\n\n  function isFalse (v) {\n    return v === false\n  }\n\n  /**\n   * Check if value is primitive.\n   */\n  function isPrimitive (value) {\n    return (\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      // $flow-disable-line\n      typeof value === 'symbol' ||\n      typeof value === 'boolean'\n    )\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject (obj) {\n    return obj !== null && typeof obj === 'object'\n  }\n\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType (value) {\n    return _toString.call(value).slice(8, -1)\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject (obj) {\n    return _toString.call(obj) === '[object Object]'\n  }\n\n  function isRegExp (v) {\n    return _toString.call(v) === '[object RegExp]'\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex (val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val)\n  }\n\n  function isPromise (val) {\n    return (\n      isDef(val) &&\n      typeof val.then === 'function' &&\n      typeof val.catch === 'function'\n    )\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString (val) {\n    return val == null\n      ? ''\n      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n        ? JSON.stringify(val, null, 2)\n        : String(val)\n  }\n\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber (val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap (\n    str,\n    expectsLowerCase\n  ) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase\n      ? function (val) { return map[val.toLowerCase()]; }\n      : function (val) { return map[val]; }\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array.\n   */\n  function remove (arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1)\n      }\n    }\n  }\n\n  /**\n   * Check whether an object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn (obj, key) {\n    return hasOwnProperty.call(obj, key)\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached (fn) {\n    var cache = Object.create(null);\n    return (function cachedFn (str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str))\n    })\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase()\n  });\n\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n  function polyfillBind (fn, ctx) {\n    function boundFn (a) {\n      var l = arguments.length;\n      return l\n        ? l > 1\n          ? fn.apply(ctx, arguments)\n          : fn.call(ctx, a)\n        : fn.call(ctx)\n    }\n\n    boundFn._length = fn.length;\n    return boundFn\n  }\n\n  function nativeBind (fn, ctx) {\n    return fn.bind(ctx)\n  }\n\n  var bind = Function.prototype.bind\n    ? nativeBind\n    : polyfillBind;\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray (list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend (to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject (arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res\n  }\n\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n  function noop (a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function (a, b, c) { return false; };\n\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n  var identity = function (_) { return _; };\n\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n  function genStaticKeys (modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || [])\n    }, []).join(',')\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual (a, b) {\n    if (a === b) { return true }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i])\n          })\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime()\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key])\n          })\n        } else {\n          /* istanbul ignore next */\n          return false\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b)\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n  function looseIndexOf (arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) { return i }\n    }\n    return -1\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once (fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    }\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = [\n    'component',\n    'directive',\n    'filter'\n  ];\n\n  var LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch'\n  ];\n\n  /*  */\n\n\n\n  var config = ({\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  });\n\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n  var unicodeLetters = 'a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved (str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F\n  }\n\n  /**\n   * Define a property.\n   */\n  function def (obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = new RegExp((\"[^\" + unicodeLetters + \".$_\\\\d]\"));\n  function parsePath (path) {\n    if (bailRE.test(path)) {\n      return\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\n  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = ({}).watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', ({\n        get: function get () {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      })); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative (Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n  }\n\n  var hasSymbol =\n    typeof Symbol !== 'undefined' && isNative(Symbol) &&\n    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/(function () {\n      function Set () {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has (key) {\n        return this.set[key] === true\n      };\n      Set.prototype.add = function add (key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear () {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }());\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = (noop); // work around flow check\n  var formatComponentName = (noop);\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function (str) { return str\n      .replace(classifyRE, function (c) { return c.toUpperCase(); })\n      .replace(/[-_]/g, ''); };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && (!config.silent)) {\n        console.error((\"[Vue warn]: \" + msg + trace));\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && (!config.silent)) {\n        console.warn(\"[Vue tip]: \" + msg + (\n          vm ? generateComponentTrace(vm) : ''\n        ));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>'\n      }\n      var options = typeof vm === 'function' && vm.cid != null\n        ? vm.options\n        : vm._isVue\n          ? vm.$options || vm.constructor.options\n          : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (\n        (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n        (file && includeFile !== false ? (\" at \" + file) : '')\n      )\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) { res += str; }\n        if (n > 1) { str += str; }\n        n >>= 1;\n      }\n      return res\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree\n          .map(function (vm, i) { return (\"\" + (i === 0 ? '---\x3e ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n              ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n              : formatComponentName(vm))); })\n          .join('\\n')\n      } else {\n        return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep () {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub (sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub (sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify () {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) { return a.id - b.id; });\n    }\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget (target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget () {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n\n  /*  */\n\n  var VNode = function VNode (\n    tag,\n    data,\n    children,\n    text,\n    elm,\n    context,\n    componentOptions,\n    asyncFactory\n  ) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance\n  };\n\n  Object.defineProperties( VNode.prototype, prototypeAccessors );\n\n  var createEmptyVNode = function (text) {\n    if ( text === void 0 ) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node\n  };\n\n  function createTextVNode (val) {\n    return new VNode(undefined, undefined, undefined, String(val))\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode (vnode) {\n    var cloned = new VNode(\n      vnode.tag,\n      vnode.data,\n      // #7975\n      // clone children array to avoid mutating original in case of cloning\n      // a child.\n      vnode.children && vnode.children.slice(),\n      vnode.text,\n      vnode.elm,\n      vnode.context,\n      vnode.componentOptions,\n      vnode.asyncFactory\n    );\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n\n  var methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n  ];\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break\n        case 'splice':\n          inserted = args.slice(2);\n          break\n      }\n      if (inserted) { ob.observeArray(inserted); }\n      // notify change\n      ob.dep.notify();\n      return result\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n  var shouldObserve = true;\n\n  function toggleObserving (value) {\n    shouldObserve = value;\n  }\n\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n  var Observer = function Observer (value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk (obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment (target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment (target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe (value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (\n      shouldObserve &&\n      !isServerRendering() &&\n      (Array.isArray(value) || isPlainObject(value)) &&\n      Object.isExtensible(value) &&\n      !value._isVue\n    ) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive$$1 (\n    obj,\n    key,\n    val,\n    customSetter,\n    shallow\n  ) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter () {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value\n      },\n      set: function reactiveSetter (newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || (newVal !== newVal && value !== value)) {\n          return\n        }\n        /* eslint-enable no-self-compare */\n        if (customSetter) {\n          customSetter();\n        }\n        // #7981: for accessor properties without setter\n        if (getter && !setter) { return }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set (target, key, val) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n        'at runtime - declare it upfront in the data option.'\n      );\n      return val\n    }\n    if (!ob) {\n      target[key] = val;\n      return val\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del (target, key) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid deleting properties on a Vue instance or its root $data ' +\n        '- just set it to null.'\n      );\n      return\n    }\n    if (!hasOwn(target, key)) {\n      return\n    }\n    delete target[key];\n    if (!ob) {\n      return\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray (value) {\n    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\n          \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n          'creation with the `new` keyword.'\n        );\n      }\n      return defaultStrat(parent, child)\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData (to, from) {\n    if (!from) { return to }\n    var key, toVal, fromVal;\n\n    var keys = hasSymbol\n      ? Reflect.ownKeys(from)\n      : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      // in case the object is already observed...\n      if (key === '__ob__') { continue }\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (\n        toVal !== fromVal &&\n        isPlainObject(toVal) &&\n        isPlainObject(fromVal)\n      ) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal\n      }\n      if (!parentVal) {\n        return childVal\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn () {\n        return mergeData(\n          typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n        )\n      }\n    } else {\n      return function mergedInstanceDataFn () {\n        // instance merge\n        var instanceData = typeof childVal === 'function'\n          ? childVal.call(vm, vm)\n          : childVal;\n        var defaultData = typeof parentVal === 'function'\n          ? parentVal.call(vm, vm)\n          : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData)\n        } else {\n          return defaultData\n        }\n      }\n    }\n  }\n\n  strats.data = function (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn(\n          'The \"data\" option should be a function ' +\n          'that returns a per-instance value in component ' +\n          'definitions.',\n          vm\n        );\n\n        return parentVal\n      }\n      return mergeDataOrFn(parentVal, childVal)\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm)\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook (\n    parentVal,\n    childVal\n  ) {\n    var res = childVal\n      ? parentVal\n        ? parentVal.concat(childVal)\n        : Array.isArray(childVal)\n          ? childVal\n          : [childVal]\n      : parentVal;\n    return res\n      ? dedupeHooks(res)\n      : res\n  }\n\n  function dedupeHooks (hooks) {\n    var res = [];\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n    return res\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal)\n    } else {\n      return res\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) { parentVal = undefined; }\n    if (childVal === nativeWatch) { childVal = undefined; }\n    /* istanbul ignore if */\n    if (!childVal) { return Object.create(parentVal || null) }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent\n        ? parent.concat(child)\n        : Array.isArray(child) ? child : [child];\n    }\n    return ret\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props =\n  strats.methods =\n  strats.inject =\n  strats.computed = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) { extend(ret, childVal); }\n    return ret\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined\n      ? parentVal\n      : childVal\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents (options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName (name) {\n    if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + unicodeLetters + \"]*$\")).test(name)) {\n      warn(\n        'Invalid component name: \"' + name + '\". Component names ' +\n        'should conform to valid custom element name in html5 specification.'\n      );\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + name\n      );\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps (options, vm) {\n    var props = options.props;\n    if (!props) { return }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val)\n          ? val\n          : { type: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(props)) + \".\",\n        vm\n      );\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject (options, vm) {\n    var inject = options.inject;\n    if (!inject) { return }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val)\n          ? extend({ from: key }, val)\n          : { from: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(inject)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives (options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n        if (typeof def$$1 === 'function') {\n          dirs[key] = { bind: def$$1, update: def$$1 };\n        }\n      }\n    }\n  }\n\n  function assertObjectType (name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\n        \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n        \"but got \" + (toRawType(value)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions (\n    parent,\n    child,\n    vm\n  ) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField (key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset (\n    options,\n    type,\n    id,\n    warnMissing\n  ) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) { return assets[id] }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (warnMissing && !res) {\n      warn(\n        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n        options\n      );\n    }\n    return res\n  }\n\n  /*  */\n\n\n\n  function validateProp (\n    key,\n    propOptions,\n    propsData,\n    vm\n  ) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue (vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      warn(\n        'Invalid default value for prop \"' + key + '\": ' +\n        'Props with type Object/Array must use a factory function ' +\n        'to return the default value.',\n        vm\n      );\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData &&\n      vm.$options.propsData[key] === undefined &&\n      vm._props[key] !== undefined\n    ) {\n      return vm._props[key]\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function'\n      ? def.call(vm)\n      : def\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp (\n    prop,\n    name,\n    value,\n    vm,\n    absent\n  ) {\n    if (prop.required && absent) {\n      warn(\n        'Missing required prop: \"' + name + '\"',\n        vm\n      );\n      return\n    }\n    if (value == null && !prop.required) {\n      return\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(\n        getInvalidTypeMessage(name, value, expectedTypes),\n        vm\n      );\n      return\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn(\n          'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n          vm\n        );\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType (value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    }\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType (fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : ''\n  }\n\n  function isSameType (a, b) {\n    return getType(a) === getType(b)\n  }\n\n  function getTypeIndex (type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  function getInvalidTypeMessage (name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n    message += \", got \" + receivedType + \" \";\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n    return message\n  }\n\n  function styleValue (value, type) {\n    if (type === 'String') {\n      return (\"\\\"\" + value + \"\\\"\")\n    } else if (type === 'Number') {\n      return (\"\" + (Number(value)))\n    } else {\n      return (\"\" + value)\n    }\n  }\n\n  function isExplicable (value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n  }\n\n  function isBoolean () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n  }\n\n  /*  */\n\n  function handleError (err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n      if (vm) {\n        var cur = vm;\n        while ((cur = cur.$parent)) {\n          var hooks = cur.$options.errorCaptured;\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n                if (capture) { return }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling (\n    handler,\n    context,\n    args,\n    vm,\n    info\n  ) {\n    var res;\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n      if (res && !res._isVue && isPromise(res)) {\n        // issue #9511\n        // reassign to res to avoid catch triggering multiple times when nested calls\n        res = res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n    return res\n  }\n\n  function globalHandleError (err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info)\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError (err, vm, info) {\n    {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n\n  /*  */\n\n  var isUsingMicroTask = false;\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n  var timerFunc;\n\n  // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function () {\n      p.then(flushCallbacks);\n      // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Techinically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (\n      perf &&\n      perf.mark &&\n      perf.measure &&\n      perf.clearMarks &&\n      perf.clearMeasures\n    ) {\n      mark = function (tag) { return perf.mark(tag); };\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        // perf.clearMeasures(name)\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap(\n      'Infinity,undefined,NaN,isFinite,isNaN,' +\n      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n      'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\n        \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n        'referenced during render. Make sure that this property is reactive, ' +\n        'either in the data option, or for class-based components, by ' +\n        'initializing the property. ' +\n        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n        target\n      );\n    };\n\n    var warnReservedPrefix = function (target, key) {\n      warn(\n        \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n        'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n        'prevent conflicts with Vue internals' +\n        'See: https://vuejs.org/v2/api/#data',\n        target\n      );\n    };\n\n    var hasProxy =\n      typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set (target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n            return false\n          } else {\n            target[key] = value;\n            return true\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has (target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) ||\n          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n        if (!has && !isAllowed) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return has || !isAllowed\n      }\n    };\n\n    var getHandler = {\n      get: function get (target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return target[key]\n      }\n    };\n\n    initProxy = function initProxy (vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped\n          ? getHandler\n          : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse (val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse (val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n      return\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) { _traverse(val[i], seen); }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) { _traverse(val[keys[i]], seen); }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    }\n  });\n\n  function createFnInvoker (fns, vm) {\n    function invoker () {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n      }\n    }\n    invoker.fns = fns;\n    return invoker\n  }\n\n  function updateListeners (\n    on,\n    oldOn,\n    add,\n    remove$$1,\n    createOnceHandler,\n    vm\n  ) {\n    var name, def$$1, cur, old, event;\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      if (isUndef(cur)) {\n        warn(\n          \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n          vm\n        );\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook (def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook () {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData (\n    data,\n    Ctor,\n    tag\n  ) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (\n            key !== keyInLowerCase &&\n            attrs && hasOwn(attrs, keyInLowerCase)\n          ) {\n            tip(\n              \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n              (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n              \" \\\"\" + key + \"\\\". \" +\n              \"Note that HTML attributes are case-insensitive and camelCased \" +\n              \"props need to use their kebab-case equivalents when using in-DOM \" +\n              \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n            );\n          }\n        }\n        checkProp(res, props, key, altKey, true) ||\n        checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res\n  }\n\n  function checkProp (\n    res,\n    hash,\n    key,\n    altKey,\n    preserve\n  ) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren (children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children)\n      }\n    }\n    return children\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren (children) {\n    return isPrimitive(children)\n      ? [createTextVNode(children)]\n      : Array.isArray(children)\n        ? normalizeArrayChildren(children)\n        : undefined\n  }\n\n  function isTextNode (node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n  }\n\n  function normalizeArrayChildren (children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') { continue }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) &&\n            isDef(c.tag) &&\n            isUndef(c.key) &&\n            isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  function initProvide (vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function'\n        ? provide.call(vm)\n        : provide;\n    }\n  }\n\n  function initInjections (vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\n              \"Avoid mutating an injected value directly since the changes will be \" +\n              \"overwritten whenever the provided component re-renders. \" +\n              \"injection being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject (inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        // #6574 in case the inject object is observed...\n        if (key === '__ob__') { continue }\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function'\n              ? provideDefault.call(vm)\n              : provideDefault;\n          } else {\n            warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n          }\n        }\n      }\n      return result\n    }\n  }\n\n  /*  */\n\n\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots (\n    children,\n    context\n  ) {\n    if (!children || !children.length) {\n      return {}\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) &&\n        data && data.slot != null\n      ) {\n        var name = data.slot;\n        var slot = (slots[name] || (slots[name] = []));\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots\n  }\n\n  function isWhitespace (node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' '\n  }\n\n  /*  */\n\n  function normalizeScopedSlots (\n    slots,\n    normalSlots,\n    prevSlots\n  ) {\n    var res;\n    var isStable = slots ? !!slots.$stable : true;\n    var key = slots && slots.$key;\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized\n    } else if (\n      isStable &&\n      prevSlots &&\n      prevSlots !== emptyObject &&\n      key === prevSlots.$key &&\n      Object.keys(normalSlots).length === 0\n    ) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots\n    } else {\n      res = {};\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    }\n    // expose normal slots on scopedSlots\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (slots && Object.isExtensible(slots)) {\n      (slots)._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    return res\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function () {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && typeof res === 'object' && !Array.isArray(res)\n        ? [res] // single vnode\n        : normalizeChildren(res);\n      return res && res.length === 0\n        ? undefined\n        : res\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n    return normalized\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () { return slots[key]; }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n    if (!isDef(ret)) {\n      ret = [];\n    }\n    (ret)._isVList = true;\n    return ret\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn(\n            'slot v-bind without argument expects an Object',\n            this\n          );\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes)\n    } else {\n      return nodes\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  }\n\n  /*  */\n\n  function isKeyNotMatch (expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1\n    } else {\n      return expect !== actual\n    }\n  }\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInKeyCode,\n    eventKeyName,\n    builtInKeyName\n  ) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName)\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps (\n    data,\n    tag,\n    value,\n    asProp,\n    isSync\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function ( key ) {\n          if (\n            key === 'class' ||\n            key === 'style' ||\n            isReservedAttribute(key)\n          ) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n          }\n          var camelizedKey = camelize(key);\n          if (!(key in hash) && !(camelizedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[(\"update:\" + camelizedKey)] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop( key );\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic (\n    index,\n    isInFor\n  ) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n      return tree\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(\n      this._renderProxy,\n      null,\n      this // for render fns generated for functional component templates\n    );\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  }\n\n  function markStatic (\n    tree,\n    key,\n    isOnce\n  ) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners (data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn(\n          'v-on without argument expects an Object value',\n          this\n        );\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  function resolveScopedSlots (\n    fns, // see flow/vnode\n    res,\n    // the following are added in 2.6\n    hasDynamicKeys,\n    contentHashKey\n  ) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n        res[slot.key] = slot.fn;\n      }\n    }\n    if (contentHashKey) {\n      (res).$key = contentHashKey;\n    }\n    return res\n  }\n\n  /*  */\n\n  function bindDynamicKeys (baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a speical value for explicitly removing a binding\n        warn(\n          (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n          this\n        );\n      }\n    }\n    return baseObj\n  }\n\n  // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n  function prependModifier (value, symbol) {\n    return typeof value === 'string' ? symbol + value : value\n  }\n\n  /*  */\n\n  function installRenderHelpers (target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext (\n    data,\n    props,\n    children,\n    parent,\n    Ctor\n  ) {\n    var this$1 = this;\n\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent);\n      // $flow-disable-line\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent;\n      // $flow-disable-line\n      parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(\n          data.scopedSlots,\n          this$1.$slots = resolveSlots(children, parent)\n        );\n      }\n      return this$1.$slots\n    };\n\n    Object.defineProperty(this, 'scopedSlots', ({\n      enumerable: true,\n      get: function get () {\n        return normalizeScopedSlots(data.scopedSlots, this.slots())\n      }\n    }));\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode\n      };\n    } else {\n      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent (\n    Ctor,\n    propsData,\n    data,\n    contextVm,\n    children\n  ) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n      if (isDef(data.props)) { mergeProps(props, data.props); }\n    }\n\n    var renderContext = new FunctionalRenderContext(\n      data,\n      props,\n      children,\n      contextVm,\n      Ctor\n    );\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n      return res\n    }\n  }\n\n  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone\n  }\n\n  function mergeProps (to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  // inline hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init (vnode, hydrating) {\n      if (\n        vnode.componentInstance &&\n        !vnode.componentInstance._isDestroyed &&\n        vnode.data.keepAlive\n      ) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(\n          vnode,\n          activeInstance\n        );\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n\n    prepatch: function prepatch (oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n      );\n    },\n\n    insert: function insert (vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy (vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent (\n    Ctor,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    if (isUndef(Ctor)) {\n      return\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n      }\n      return\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(\n          asyncFactory,\n          data,\n          context,\n          children,\n          tag\n        )\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children)\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\n      (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n      data, undefined, undefined, undefined, context,\n      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n      asyncFactory\n    );\n\n    return vnode\n  }\n\n  function createComponentInstanceForVnode (\n    vnode, // we know it's MountedComponentVNode but flow doesn't\n    parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options)\n  }\n\n  function installComponentHooks (data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1 (f1, f2) {\n    var merged = function (a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n    merged._merged = true;\n    return merged\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel (options, data) {\n    var prop = (options.model && options.model.prop) || 'value';\n    var event = (options.model && options.model.event) || 'input'\n    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n    if (isDef(existing)) {\n      if (\n        Array.isArray(existing)\n          ? existing.indexOf(callback) === -1\n          : existing !== callback\n      ) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType,\n    alwaysNormalize\n  ) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType)\n  }\n\n  function _createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType\n  ) {\n    if (isDef(data) && isDef((data).__ob__)) {\n      warn(\n        \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n        'Always create fresh vnode data objects in each render!',\n        context\n      );\n      return createEmptyVNode()\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode()\n    }\n    // warn against non-primitive key\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n    ) {\n      {\n        warn(\n          'Avoid using non-primitive value as key, ' +\n          'use string/number value instead.',\n          context\n        );\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) &&\n      typeof children[0] === 'function'\n    ) {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(\n          config.parsePlatformTagName(tag), data, children,\n          undefined, undefined, context\n        );\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(\n          tag, data, children,\n          undefined, undefined, context\n        );\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (Array.isArray(vnode)) {\n      return vnode\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) { applyNS(vnode, ns); }\n      if (isDef(data)) { registerDeepBindings(data); }\n      return vnode\n    } else {\n      return createEmptyVNode()\n    }\n  }\n\n  function applyNS (vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (\n          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n  function registerDeepBindings (data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n\n  /*  */\n\n  function initRender (vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin (Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this)\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n          _parentVnode.data.scopedSlots,\n          vm.$slots,\n          vm.$scopedSlots\n        );\n      }\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        // There's no need to maintain a stack becaues all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      }\n      // if the returned array contains only a single node, allow it\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn(\n            'Multiple root nodes returned from render function. Render function ' +\n            'should return a single root node.',\n            vm\n          );\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode\n    };\n  }\n\n  /*  */\n\n  function ensureCtor (comp, base) {\n    if (\n      comp.__esModule ||\n      (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n    ) {\n      comp = comp.default;\n    }\n    return isObject(comp)\n      ? base.extend(comp)\n      : comp\n  }\n\n  function createAsyncPlaceholder (\n    factory,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node\n  }\n\n  function resolveAsyncComponent (\n    factory,\n    baseCtor\n  ) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp\n    }\n\n    var owner = currentRenderingInstance;\n    if (isDef(factory.owners)) {\n      // already pending\n      factory.owners.push(owner);\n    } else {\n      var owners = factory.owners = [owner];\n      var sync = true;\n\n      var forceRender = function (renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          (owners[i]).$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n\n      var reject = once(function (reason) {\n        warn(\n          \"Failed to resolve async component: \" + (String(factory)) +\n          (reason ? (\"\\nReason: \" + reason) : '')\n        );\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              setTimeout(function () {\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            setTimeout(function () {\n              if (isUndef(factory.resolved)) {\n                reject(\n                  \"timeout (\" + (res.timeout) + \"ms)\"\n                );\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading\n        ? factory.loadingComp\n        : factory.resolved\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder (node) {\n    return node.isComment && node.asyncFactory\n  }\n\n  /*  */\n\n  function getFirstComponentChild (children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents (vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add (event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1 (event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler (event, fn) {\n    var _target = target;\n    return function onceHandler () {\n      var res = fn.apply(null, arguments);\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    }\n  }\n\n  function updateComponentListeners (\n    vm,\n    listeners,\n    oldListeners\n  ) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin (Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on () {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n        return vm\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\n            \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n            (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and you cannot use \" +\n            \"v-on to listen to camelCase events when using in-DOM templates. \" +\n            \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n          );\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n      return vm\n    };\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    }\n  }\n\n  function initLifecycle (vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin (Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      restoreActiveInstance();\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent (\n    vm,\n    el,\n    hydrating\n  ) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n          vm.$options.el || el) {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'compiler is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure((\"vue \" + name + \" patch\"), startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, {\n      before: function before () {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  }\n\n  function updateChildComponent (\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(\n      (newScopedSlots && !newScopedSlots.$stable) ||\n      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n    );\n\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    var needsForceUpdate = !!(\n      renderChildren ||               // has new static slots\n      vm.$options._renderChildren ||  // has old static slots\n      hasDynamicScopedSlot\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n      toggleObserving(true);\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree (vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) { return true }\n    }\n    return false\n  }\n\n  function activateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    } else if (vm._directInactive) {\n      return\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook (vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n    popTarget();\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState () {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n  var currentFlushTimestamp = 0;\n\n  // Async edge case fix requires storing an event listener's attach timestamp.\n  var getNow = Date.now;\n\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  if (inBrowser && getNow() > document.createEvent('Event').timeStamp) {\n    // if the low-res timestamp which is bigger than the event timestamp\n    // (which is evaluated AFTER) it means the event is using a hi-res timestamp,\n    // and we need to use the hi-res version for event listeners as well.\n    getNow = function () { return performance.now(); };\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue () {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) { return a.id - b.id; });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      if (watcher.before) {\n        watcher.before();\n      }\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn(\n            'You may have an infinite update loop ' + (\n              watcher.user\n                ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n                : \"in a component render function.\"\n            ),\n            watcher.vm\n          );\n          break\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks (queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent (vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks (queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher (watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return\n        }\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher (\n    vm,\n    expOrFn,\n    cb,\n    options,\n    isRenderWatcher\n  ) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\n          \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        );\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get () {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep (dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps () {\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this.deps[i];\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run () {\n    if (this.active) {\n      var value = this.get();\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate () {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend () {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy (target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter () {\n      return this[sourceKey][key]\n    };\n    sharedPropertyDefinition.set = function proxySetter (val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState (vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) { initProps(vm, opts.props); }\n    if (opts.methods) { initMethods(vm, opts.methods); }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) { initComputed(vm, opts.computed); }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps (vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n    var loop = function ( key ) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) ||\n            config.isReservedAttr(hyphenatedKey)) {\n          warn(\n            (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n            vm\n          );\n        }\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\n              \"Avoid mutating a prop directly since the value will be \" +\n              \"overwritten whenever the parent component re-renders. \" +\n              \"Instead, use a data or computed property based on the prop's \" +\n              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop( key );\n    toggleObserving(true);\n  }\n\n  function initData (vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function'\n      ? getData(data, vm)\n      : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      warn(\n        'data functions should return an object:\\n' +\n        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n        vm\n      );\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n            vm\n          );\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n          \"Use prop default value instead.\",\n          vm\n        );\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData (data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n      return data.call(vm, vm)\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {}\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed (vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (getter == null) {\n        warn(\n          (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(\n          vm,\n          getter || noop,\n          noop,\n          computedWatcherOptions\n        );\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed (\n    target,\n    key,\n    userDef\n  ) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get\n        ? shouldCache && userDef.cache !== false\n          ? createComputedGetter(key)\n          : createGetterInvoker(userDef.get)\n        : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\n          (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n          this\n        );\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter (key) {\n    return function computedGetter () {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value\n      }\n    }\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter () {\n      return fn.call(this, this)\n    }\n  }\n\n  function initMethods (vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\n            \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n            \"Did you reference the function correctly?\",\n            vm\n          );\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n            vm\n          );\n        }\n        if ((key in vm) && isReserved(key)) {\n          warn(\n            \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n            \"Avoid defining component methods that start with _ or $.\"\n          );\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch (vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher (\n    vm,\n    expOrFn,\n    handler,\n    options\n  ) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options)\n  }\n\n  function stateMixin (Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () { return this._data };\n    var propsDef = {};\n    propsDef.get = function () { return this._props };\n    {\n      dataDef.set = function () {\n        warn(\n          'Avoid replacing instance root $data. ' +\n          'Use nested data properties instead.',\n          this\n        );\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (\n      expOrFn,\n      cb,\n      options\n    ) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options)\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n        }\n      }\n      return function unwatchFn () {\n        watcher.teardown();\n      }\n    };\n  }\n\n  /*  */\n\n  var uid$3 = 0;\n\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$3++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + (vm._uid);\n        endTag = \"vue-perf-end:\" + (vm._uid);\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(\n          resolveConstructorOptions(vm.constructor),\n          options || {},\n          vm\n        );\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent (vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions (Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options\n  }\n\n  function resolveModifiedOptions (Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) { modified = {}; }\n        modified[key] = latest[key];\n      }\n    }\n    return modified\n  }\n\n  function Vue (options) {\n    if (!(this instanceof Vue)\n    ) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  /*  */\n\n  function initUse (Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initMixin$1 (Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initExtend (Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId]\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent (options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(\n        Super.options,\n        extendOptions\n      );\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub\n    };\n  }\n\n  function initProps$1 (Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1 (Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters (Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (\n        id,\n        definition\n      ) {\n        if (!definition) {\n          return this.options[type + 's'][id]\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition\n        }\n      };\n    });\n  }\n\n  /*  */\n\n\n\n  function getComponentName (opts) {\n    return opts && (opts.Ctor.options.name || opts.tag)\n  }\n\n  function matches (pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name)\n    }\n    /* istanbul ignore next */\n    return false\n  }\n\n  function pruneCache (keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry (\n    cache,\n    key,\n    keys,\n    current\n  ) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created () {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed () {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n\n    mounted: function mounted () {\n      var this$1 = this;\n\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) { return matches(val, name); });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) { return !matches(val, name); });\n      });\n    },\n\n    render: function render () {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n          // not included\n          (include && (!name || !matches(include, name))) ||\n          // excluded\n          (exclude && name && matches(exclude, name))\n        ) {\n          return vnode\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n          // same constructor may get registered as different local components\n          // so cid alone is not enough (#3269)\n          ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n          : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || (slot && slot[0])\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI (Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () { return config; };\n    {\n      configDef.set = function () {\n        warn(\n          'Do not replace the Vue.config object, set individual fields instead.'\n        );\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    // 2.6 explicit observable API\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get () {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext\n    }\n  });\n\n  // expose FunctionalRenderContext for ssr runtime helper installation\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n\n  Vue.version = '2.6.7';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function (tag, type, attr) {\n    return (\n      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n      (attr === 'selected' && tag === 'option') ||\n      (attr === 'checked' && tag === 'input') ||\n      (attr === 'muted' && tag === 'video')\n    )\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false'\n      ? 'false'\n      // allow arbitrary string value for contenteditable\n      : key === 'contenteditable' && isValidContentEditableValue(value)\n        ? value\n        : 'true'\n  };\n\n  var isBooleanAttr = makeMap(\n    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,translate,' +\n    'truespeed,typemustmatch,visible'\n  );\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : ''\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false\n  };\n\n  /*  */\n\n  function genClassForVnode (vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class)\n  }\n\n  function mergeClassData (child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class)\n        ? [child.class, parent.class]\n        : parent.class\n    }\n  }\n\n  function renderClass (\n    staticClass,\n    dynamicClass\n  ) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass))\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function concat (a, b) {\n    return a ? b ? (a + ' ' + b) : a : (b || '')\n  }\n\n  function stringifyClass (value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value)\n    }\n    if (isObject(value)) {\n      return stringifyObject(value)\n    }\n    if (typeof value === 'string') {\n      return value\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function stringifyArray (value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) { res += ' '; }\n        res += stringified;\n      }\n    }\n    return res\n  }\n\n  function stringifyObject (value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) { res += ' '; }\n        res += key;\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap(\n    'html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot'\n  );\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap(\n    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n    true\n  );\n\n  var isPreTag = function (tag) { return tag === 'pre'; };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag)\n  };\n\n  function getTagNamespace (tag) {\n    if (isSVG(tag)) {\n      return 'svg'\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math'\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement (tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true\n    }\n    if (isReservedTag(tag)) {\n      return false\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag]\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return (unknownElementCache[tag] = (\n        el.constructor === window.HTMLUnknownElement ||\n        el.constructor === window.HTMLElement\n      ))\n    } else {\n      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query (el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        warn(\n          'Cannot find element: ' + el\n        );\n        return document.createElement('div')\n      }\n      return selected\n    } else {\n      return el\n    }\n  }\n\n  /*  */\n\n  function createElement$1 (tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm\n  }\n\n  function createElementNS (namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName)\n  }\n\n  function createTextNode (text) {\n    return document.createTextNode(text)\n  }\n\n  function createComment (text) {\n    return document.createComment(text)\n  }\n\n  function insertBefore (parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild (node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild (node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode (node) {\n    return node.parentNode\n  }\n\n  function nextSibling (node) {\n    return node.nextSibling\n  }\n\n  function tagName (node) {\n    return node.tagName\n  }\n\n  function setTextContent (node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope (node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create (_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update (oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy (vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef (vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!isDef(key)) { return }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode (a, b) {\n    return (\n      a.key === b.key && (\n        (\n          a.tag === b.tag &&\n          a.isComment === b.isComment &&\n          isDef(a.data) === isDef(b.data) &&\n          sameInputType(a, b)\n        ) || (\n          isTrue(a.isAsyncPlaceholder) &&\n          a.asyncFactory === b.asyncFactory &&\n          isUndef(b.asyncFactory.error)\n        )\n      )\n    )\n  }\n\n  function sameInputType (a, b) {\n    if (a.tag !== 'input') { return true }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n  }\n\n  function createKeyToOldIdx (children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) { map[key] = i; }\n    }\n    return map\n  }\n\n  function createPatchFunction (backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt (elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n    }\n\n    function createRmCb (childElm, listeners) {\n      function remove$$1 () {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove$$1.listeners = listeners;\n      return remove$$1\n    }\n\n    function removeNode (el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1 (vnode, inVPre) {\n      return (\n        !inVPre &&\n        !vnode.ns &&\n        !(\n          config.ignoredElements.length &&\n          config.ignoredElements.some(function (ignore) {\n            return isRegExp(ignore)\n              ? ignore.test(vnode.tag)\n              : ignore === vnode.tag\n          })\n        ) &&\n        config.isUnknownElement(vnode.tag)\n      )\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm (\n      vnode,\n      insertedVnodeQueue,\n      parentElm,\n      refElm,\n      nested,\n      ownerArray,\n      index\n    ) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn(\n              'Unknown custom element: <' + tag + '> - did you ' +\n              'register the component correctly? For recursive components, ' +\n              'make sure to provide the \"name\" option.',\n              vnode.context\n            );\n          }\n        }\n\n        vnode.elm = vnode.ns\n          ? nodeOps.createElementNS(vnode.ns, tag)\n          : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true\n        }\n      }\n    }\n\n    function initComponent (vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert (parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren (vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable (vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag)\n    }\n\n    function invokeCreateHooks (vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) { i.create(emptyNode, vnode); }\n        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope (vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        i !== vnode.fnContext &&\n        isDef(i = i.$options._scopeId)\n      ) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook (vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else { // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook (vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n          idxInOld = isDef(newStartVnode.key)\n            ? oldKeyToIdx[newStartVnode.key]\n            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) { // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys (children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\n              (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n              vnode.context\n            );\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld (node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) { return i }\n      }\n    }\n\n    function patchVnode (\n      oldVnode,\n      vnode,\n      insertedVnodeQueue,\n      ownerArray,\n      index,\n      removeOnly\n    ) {\n      if (oldVnode === vnode) {\n        return\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n      ) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n      }\n    }\n\n    function invokeInsertHook (vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || (data && data.pre);\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true\n    }\n\n    function assertNodeMatch (node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || (\n          !isUnknownElement$$1(vnode, inVPre) &&\n          vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n        )\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3)\n      }\n    }\n\n    return function patch (oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n        return\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode\n              } else {\n                warn(\n                  'The client-side rendered virtual DOM tree is not matching ' +\n                  'server-rendered content. This is likely caused by incorrect ' +\n                  'HTML markup, for example nesting block-level elements inside ' +\n                  '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                  'full client-side render.'\n                );\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(\n            vnode,\n            insertedVnodeQueue,\n            // extremely rare edge case: do not insert if old element is in a\n            // leaving transition. Only happens when combining transition +\n            // keep-alive + HOCs. (#4590)\n            oldElm._leaveCb ? null : parentElm,\n            nodeOps.nextSibling(oldElm)\n          );\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm)) {\n            removeVnodes(parentElm, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm\n    }\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives (vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives (oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update (oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1 (\n    dirs,\n    vm\n  ) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res\n  }\n\n  function getRawDirName (dir) {\n    return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n  }\n\n  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n      }\n    }\n  }\n\n  var baseModules = [\n    ref,\n    directives\n  ];\n\n  /*  */\n\n  function updateAttrs (oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr (el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n          ? 'true'\n          : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr (el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (\n        isIE && !isIE9 &&\n        el.tagName === 'TEXTAREA' &&\n        key === 'placeholder' && value !== '' && !el.__ieph\n      ) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass (oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (\n      isUndef(data.staticClass) &&\n      isUndef(data.class) && (\n        isUndef(oldData) || (\n          isUndef(oldData.staticClass) &&\n          isUndef(oldData.class)\n        )\n      )\n    ) {\n      return\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters (exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n      } else if (\n        c === 0x7C && // pipe\n        exp.charCodeAt(i + 1) !== 0x7C &&\n        exp.charCodeAt(i - 1) !== 0x7C &&\n        !curly && !square && !paren\n      ) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22: inDouble = true; break         // \"\n          case 0x27: inSingle = true; break         // '\n          case 0x60: inTemplateString = true; break // `\n          case 0x28: paren++; break                 // (\n          case 0x29: paren--; break                 // )\n          case 0x5B: square++; break                // [\n          case 0x5D: square--; break                // ]\n          case 0x7B: curly++; break                 // {\n          case 0x7D: curly--; break                 // }\n        }\n        if (c === 0x2f) { // /\n          var j = i - 1;\n          var p = (void 0);\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') { break }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter () {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression\n  }\n\n  function wrapFilter (exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n    }\n  }\n\n  /*  */\n\n\n\n  /* eslint-disable no-unused-vars */\n  function baseWarn (msg, range) {\n    console.error((\"[Vue compiler]: \" + msg));\n  }\n  /* eslint-enable no-unused-vars */\n\n  function pluckModuleFunction (\n    modules,\n    key\n  ) {\n    return modules\n      ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n      : []\n  }\n\n  function addProp (el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  function addAttr (el, name, value, range, dynamic) {\n    var attrs = dynamic\n      ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n      : (el.attrs || (el.attrs = []));\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr (el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n  }\n\n  function addDirective (\n    el,\n    name,\n    rawName,\n    value,\n    arg,\n    isDynamicArg,\n    modifiers,\n    range\n  ) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker (symbol, name, dynamic) {\n    return dynamic\n      ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n      : symbol + name // mark the event as captured\n  }\n\n  function addHandler (\n    el,\n    name,\n    value,\n    modifiers,\n    important,\n    warn,\n    range,\n    dynamic\n  ) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\n      warn &&\n      modifiers.prevent && modifiers.passive\n    ) {\n      warn(\n        'passive and prevent can\\'t be used together. ' +\n        'Passive handler can\\'t prevent default event.',\n        range\n      );\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr (\n    el,\n    name\n  ) {\n    return el.rawAttrsMap[':' + name] ||\n      el.rawAttrsMap['v-bind:' + name] ||\n      el.rawAttrsMap[name]\n  }\n\n  function getBindingAttr (\n    el,\n    name,\n    getStatic\n  ) {\n    var dynamicValue =\n      getAndRemoveAttr(el, ':' + name) ||\n      getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue)\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue)\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr (\n    el,\n    name,\n    removeFromMap\n  ) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val\n  }\n\n  function getAndRemoveAttrByRegex (\n    el,\n    name\n  ) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr\n      }\n    }\n  }\n\n  function rangeSetItem (\n    item,\n    range\n  ) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n    return item\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression =\n        \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: (\"(\" + value + \")\"),\n      expression: JSON.stringify(value),\n      callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode (\n    value,\n    assignment\n  ) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return (value + \"=\" + assignment)\n    } else {\n      return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\n  function parseModel (val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        }\n      } else {\n        return {\n          exp: val,\n          key: null\n        }\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    }\n  }\n\n  function next () {\n    return str.charCodeAt(++index$1)\n  }\n\n  function eof () {\n    return index$1 >= len\n  }\n\n  function isStringStart (chr) {\n    return chr === 0x22 || chr === 0x27\n  }\n\n  function parseBracket (chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue\n      }\n      if (chr === 0x5B) { inBracket++; }\n      if (chr === 0x5D) { inBracket--; }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break\n      }\n    }\n  }\n\n  function parseString (chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model (\n    el,\n    dir,\n    _warn\n  ) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n          \"File inputs are read only. Use a v-on:change listener instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"v-model is not supported on this element type. \" +\n        'If you are working with contenteditable, it\\'s recommended to ' +\n        'wrap a library dedicated for that purpose inside a custom component.',\n        el.rawAttrsMap['v-model']\n      );\n    }\n\n    // ensure runtime directive metadata\n    return true\n  }\n\n  function genCheckboxModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked',\n      \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n    );\n    addHandler(el, 'change',\n      \"var $$a=\" + value + \",\" +\n          '$$el=$event.target,' +\n          \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n      'if(Array.isArray($$a)){' +\n        \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n            '$$i=_i($$a,$$v);' +\n        \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n        \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n      \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n      null, true\n    );\n  }\n\n  function genRadioModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n    addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" +\n      \".call($event.target.options,function(o){return o.selected})\" +\n      \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n      \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + (genAssignmentCode(value, assignment));\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(\n          binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n          'because the latter already expands to a value binding internally',\n          el.rawAttrsMap[binding]\n        );\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy\n      ? 'change'\n      : type === 'range'\n        ? RANGE_TOKEN\n        : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', (\"(\" + value + \")\"));\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents (on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1 (event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler () {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    }\n  }\n\n  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1 (\n    name,\n    handler,\n    capture,\n    passive\n  ) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n      handler = original._wrapper = function (e) {\n        if (\n          // no bubbling, should always fire.\n          // this is just a safety net in case event.timeStamp is unreliable in\n          // certain weird environments...\n          e.target === e.currentTarget ||\n          // event is fired after handler attachment\n          e.timeStamp >= attachedTimestamp ||\n          // #9462 bail for iOS 9 bug: event.timeStamp is 0 after history.pushState\n          e.timeStamp === 0 ||\n          // #9448 bail if event is fired in another document in a multi-page\n          // electron/nw.js app, since event.timeStamp will be using a different\n          // starting reference\n          e.target.ownerDocument !== document\n        ) {\n          return original.apply(this, arguments)\n        }\n      };\n    }\n    target$1.addEventListener(\n      name,\n      handler,\n      supportsPassive\n        ? { capture: capture, passive: passive }\n        : capture\n    );\n  }\n\n  function remove$2 (\n    name,\n    handler,\n    capture,\n    _target\n  ) {\n    (_target || target$1).removeEventListener(\n      name,\n      handler._wrapper || handler,\n      capture\n    );\n  }\n\n  function updateDOMListeners (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (isUndef(props[key])) {\n        elm[key] = '';\n      }\n    }\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) { vnode.children.length = 0; }\n        if (cur === oldProps[key]) { continue }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if (\n        // skip the update if old and new VDOM state is the same.\n        // `value` is handled separately because the DOM value may be temporarily\n        // out of sync with VDOM state due to focus, composition and modifiers.\n        // This  #4521 by skipping the unnecesarry `checked` update.\n        cur !== oldProps[key]\n      ) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue (elm, checkVal) {\n    return (!elm.composing && (\n      elm.tagName === 'OPTION' ||\n      isNotInFocusAndDirty(elm, checkVal) ||\n      isDirtyWithModifiers(elm, checkVal)\n    ))\n  }\n\n  function isNotInFocusAndDirty (elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try { notInFocus = document.activeElement !== elm; } catch (e) {}\n    return notInFocus && elm.value !== checkVal\n  }\n\n  function isDirtyWithModifiers (elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal)\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim()\n      }\n    }\n    return value !== newVal\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData (data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle\n      ? extend(data.staticStyle, style)\n      : style\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding (bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle)\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle)\n    }\n    return bindingStyle\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle (vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (\n          childNode && childNode.data &&\n          (styleData = normalizeStyleData(childNode.data))\n        ) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if ((styleData = normalizeStyleData(vnode.data))) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while ((parentNode = parentNode.parent)) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && (prop in emptyStyle)) {\n      return prop\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name\n      }\n    }\n  });\n\n  function updateStyle (oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) &&\n      isUndef(oldData.staticStyle) && isUndef(oldData.style)\n    ) {\n      return\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__)\n      ? extend({}, style)\n      : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition (def$$1) {\n    if (!def$$1) {\n      return\n    }\n    /* istanbul ignore else */\n    if (typeof def$$1 === 'object') {\n      var res = {};\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n      extend(res, def$$1);\n      return res\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1)\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: (name + \"-enter\"),\n      enterToClass: (name + \"-enter-to\"),\n      enterActiveClass: (name + \"-enter-active\"),\n      leaveClass: (name + \"-leave\"),\n      leaveToClass: (name + \"-leave-to\"),\n      leaveActiveClass: (name + \"-leave-active\")\n    }\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined &&\n      window.onwebkittransitionend !== undefined\n    ) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined &&\n      window.onwebkitanimationend !== undefined\n    ) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser\n    ? window.requestAnimationFrame\n      ? window.requestAnimationFrame.bind(window)\n      : setTimeout\n    : /* istanbul ignore next */ function (fn) { return fn(); };\n\n  function nextFrame (fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass (el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass (el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds (\n    el,\n    expectedType,\n    cb\n  ) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) { return cb() }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo (el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0\n        ? transitionTimeout > animationTimeout\n          ? TRANSITION\n          : ANIMATION\n        : null;\n      propCount = type\n        ? type === TRANSITION\n          ? transitionDurations.length\n          : animationDurations.length\n        : 0;\n    }\n    var hasTransform =\n      type === TRANSITION &&\n      transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    }\n  }\n\n  function getTimeout (delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i])\n    }))\n  }\n\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n  function toMs (s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000\n  }\n\n  /*  */\n\n  function enter (vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      transitionNode = transitionNode.parent;\n      context = transitionNode.context;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return\n    }\n\n    var startClass = isAppear && appearClass\n      ? appearClass\n      : enterClass;\n    var activeClass = isAppear && appearActiveClass\n      ? appearActiveClass\n      : enterActiveClass;\n    var toClass = isAppear && appearToClass\n      ? appearToClass\n      : enterToClass;\n\n    var beforeEnterHook = isAppear\n      ? (beforeAppear || beforeEnter)\n      : beforeEnter;\n    var enterHook = isAppear\n      ? (typeof appear === 'function' ? appear : enter)\n      : enter;\n    var afterEnterHook = isAppear\n      ? (afterAppear || afterEnter)\n      : afterEnter;\n    var enterCancelledHook = isAppear\n      ? (appearCancelled || enterCancelled)\n      : enterCancelled;\n\n    var explicitEnterDuration = toNumber(\n      isObject(duration)\n        ? duration.enter\n        : duration\n    );\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb\n        ) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave (vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm()\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(\n      isObject(duration)\n        ? duration.leave\n        : duration\n    );\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave () {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return\n      }\n      // record leaving element\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration (val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\n        \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n        \"got \" + (JSON.stringify(val)) + \".\",\n        vnode.context\n      );\n    } else if (isNaN(val)) {\n      warn(\n        \"<transition> explicit \" + name + \" duration is NaN - \" +\n        'the duration expression might be incorrect.',\n        vnode.context\n      );\n    }\n  }\n\n  function isValidDuration (val) {\n    return typeof val === 'number' && !isNaN(val)\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength (fn) {\n    if (isUndef(fn)) {\n      return false\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(\n        Array.isArray(invokerFns)\n          ? invokerFns[0]\n          : invokerFns\n      )\n    } else {\n      return (fn._length || fn.length) > 1\n    }\n  }\n\n  function _enter (_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1 (vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [\n    attrs,\n    klass,\n    events,\n    domProps,\n    style,\n    transition\n  ];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted (el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated (el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple\n            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected (el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected (el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\n        \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n        \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n        vm\n      );\n      return\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption (value, options) {\n    return options.every(function (o) { return !looseEqual(o, value); })\n  }\n\n  function getValue (option) {\n    return '_value' in option\n      ? option._value\n      : option.value\n  }\n\n  function onCompositionStart (e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd (e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) { return }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger (el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode (vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n      ? locateNode(vnode.componentInstance._vnode)\n      : vnode\n  }\n\n  var show = {\n    bind: function bind (el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay =\n        el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update (el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (!value === !oldValue) { return }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind (\n      el,\n      binding,\n      vnode,\n      oldVnode,\n      isDestroy\n    ) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild (vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children))\n    } else {\n      return vnode\n    }\n  }\n\n  function extractTransitionData (comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data\n  }\n\n  function placeholder (h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      })\n    }\n  }\n\n  function hasParentTransition (vnode) {\n    while ((vnode = vnode.parent)) {\n      if (vnode.data.transition) {\n        return true\n      }\n    }\n  }\n\n  function isSameChild (child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag\n  }\n\n  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\n  var isVShowDirective = function (d) { return d.name === 'show'; };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render (h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n      if (!children.length) {\n        return\n      }\n\n      // warn multiple elements\n      if (children.length > 1) {\n        warn(\n          '<transition> can only be used on a single element. Use ' +\n          '<transition-group> for lists.',\n          this.$parent\n        );\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (mode && mode !== 'in-out' && mode !== 'out-in'\n      ) {\n        warn(\n          'invalid <transition> mode: ' + mode,\n          this.$parent\n        );\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild)\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + (this._uid) + \"-\";\n      child.key = child.key == null\n        ? child.isComment\n          ? id + 'comment'\n          : id + child.tag\n        : isPrimitive(child.key)\n          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n          : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (\n        oldChild &&\n        oldChild.data &&\n        !isSameChild(child, oldChild) &&\n        !isAsyncPlaceholder(oldChild) &&\n        // #6687 component root is a comment node\n        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n      ) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild)\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild\n          }\n          var delayedLeave;\n          var performLeave = function () { delayedLeave(); };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n        }\n      }\n\n      return rawChild\n    }\n  };\n\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    beforeMount: function beforeMount () {\n      var this$1 = this;\n\n      var update = this._update;\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1);\n        // force removing pass\n        this$1.__patch__(\n          this$1._vnode,\n          this$1.kept,\n          false, // hydrating\n          true // removeOnly (!important, avoids unnecessary moves)\n        );\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n\n    render: function render (h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c\n            ;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n            warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children)\n    },\n\n    updated: function updated () {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n            if (e && e.target !== el) {\n              return\n            }\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove (el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return (this._hasMove = info.hasTransform)\n      }\n    }\n  };\n\n  function callPendingCbs (c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition (c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation (c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating)\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log'](\n            'Download the Vue Devtools extension for a better development experience:\\n' +\n            'https://github.com/vuejs/vue-devtools'\n          );\n        }\n      }\n      if (config.productionTip !== false &&\n        typeof console !== 'undefined'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          \"You are running Vue in development mode.\\n\" +\n          \"Make sure to turn on production mode when deploying for production.\\n\" +\n          \"See more tips at https://vuejs.org/guide/deployment.html\"\n        );\n      }\n    }, 0);\n  }\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n  });\n\n\n\n  function parseText (\n    text,\n    delimiters\n  ) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while ((match = tagRE.exec(text))) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push((\"_s(\" + exp + \")\"));\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    }\n  }\n\n  /*  */\n\n  function transformNode (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\n          \"class=\\\"\" + staticClass + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n          el.rawAttrsMap['class']\n        );\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData (el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + (el.staticClass) + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + (el.classBinding) + \",\";\n    }\n    return data\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1 (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\n            \"style=\\\"\" + staticStyle + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n            el.rawAttrsMap['style']\n          );\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1 (el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + (el.staticStyle) + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + (el.styleBinding) + \"),\";\n    }\n    return data\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode (html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent\n    }\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap(\n    'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n    'link,meta,param,source,track,wbr'\n  );\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap(\n    'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n  );\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap(\n    'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n    'title,tr,track'\n  );\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + unicodeLetters + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp((\"^<\" + qnameCapture));\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  // #7298: escape - to avoid being pased as HTML comment when inlined in page\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\n  function decodeAttr (value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) { return decodingMap[match]; })\n  }\n\n  function parseHTML (html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('--\x3e');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n              advance(commentEnd + 3);\n              continue\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n            continue\n          }\n        }\n\n        var text = (void 0), rest = (void 0), next = (void 0);\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (\n            !endTag.test(rest) &&\n            !startTagOpen.test(rest) &&\n            !comment.test(rest) &&\n            !conditionalComment.test(rest)\n          ) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) { break }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text\n              .replace(/<!\\--([\\s\\S]*?)--\x3e/g, '$1') // #7298\n              .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return ''\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (!stack.length && options.warn) {\n          options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n        }\n        break\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance (n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag () {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match\n        }\n      }\n    }\n\n    function handleStartTag (match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n          ? options.shouldDecodeNewlinesForHref\n          : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag (tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) { start = index; }\n      if (end == null) { end = index; }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName &&\n            options.warn\n          ) {\n            options.warn(\n              (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n              { start: stack[i].start }\n            );\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.]+/g;\n\n  var slotRE = /^v-slot(:|$)|^#/;\n\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  var emptySlotScopeToken = \"_empty_\";\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement (\n    tag,\n    attrs,\n    parent\n  ) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    }\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse (\n    template,\n    options\n  ) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n    maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce (msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement (element) {\n      trimEndingWhitespace(element);\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      }\n      // tree management\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\",\n            { start: element.start }\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"'\n            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n\n      // final children cleanup\n      // filter out scoped slots\n      element.children = element.children.filter(function (c) { return !(c).slotScope; });\n      // remove trailing whitespace node again\n      trimEndingWhitespace(element);\n\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace (el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n        while (\n          (lastNode = el.children[el.children.length - 1]) &&\n          lastNode.type === 3 &&\n          lastNode.text === ' '\n        ) {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints (el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\n          \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n          'contain multiple nodes.',\n          { start: el.start }\n        );\n      }\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce(\n          'Cannot use v-for on stateful component root element because ' +\n          'it renders multiple elements.',\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start (tag, attrs, unary, start$1) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated\n            }, {});\n          }\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\n                \"Invalid dynamic argument expression: attribute names cannot contain \" +\n                \"spaces, quotes, <, >, / or =.\",\n                {\n                  start: attr.start + attr.name.indexOf(\"[\"),\n                  end: attr.start + attr.name.length\n                }\n              );\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2(\n            'Templates should only be responsible for mapping the state to the ' +\n            'UI. Avoid placing tags with side-effects in your templates, such as ' +\n            \"<\" + tag + \">\" + ', as they will not be parsed.',\n            { start: element.start }\n          );\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end (tag, start, end$1) {\n        var element = stack[stack.length - 1];\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n        closeElement(element);\n      },\n\n      chars: function chars (text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce(\n                'Component template requires a root element, rather than just text.',\n                { start: start }\n              );\n            } else if ((text = text.trim())) {\n              warnOnce(\n                (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n                { start: start }\n              );\n            }\n          }\n          return\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text\n        ) {\n          return\n        }\n        var children = currentParent.children;\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n        if (text) {\n          if (whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n          var res;\n          var child;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment (text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root\n  }\n\n  function processPre (el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs (el) {\n    var list = el.attrsList;\n    var len = list.length;\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement (\n    element,\n    options\n  ) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = (\n      !element.key &&\n      !element.scopedSlots &&\n      !element.attrsList.length\n    );\n\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element\n  }\n\n  function processKey (el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\n            \"<template> cannot be keyed. Place the key on real elements instead.\",\n            getRawBindingAttr(el, 'key')\n          );\n        }\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\n              \"Do not use v-for index as key on <transition-group> children, \" +\n              \"this is the same as not using keys.\",\n              getRawBindingAttr(el, 'key'),\n              true /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef (el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor (el) {\n    var exp;\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\n          (\"Invalid v-for expression: \" + exp),\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n  }\n\n\n\n  function parseFor (exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) { return }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res\n  }\n\n  function processIf (el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions (el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\n        \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n        \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n        el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n      );\n    }\n  }\n\n  function findPrevElement (children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i]\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\n            \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n            \"will be ignored.\",\n            children[i]\n          );\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition (el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce (el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n  function processSlotContent (el) {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          el.rawAttrsMap['scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          el.rawAttrsMap['slot-scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n\n    // slot=\"xxx\"\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    }\n\n    // 2.6 v-slot syntax\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\n                \"<template v-slot> can only appear at the root level inside \" +\n                \"the receiving the component\",\n                el\n              );\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\n                \"v-slot can only be used on components or <template>.\",\n                slotBinding$1\n              );\n            }\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.scopedSlots) {\n              warn$2(\n                \"To avoid scope ambiguity, the default slot should also use \" +\n                \"<template> syntax when there are other named slots.\",\n                slotBinding$1\n              );\n            }\n          }\n          // add the component's children to its default slot\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n          // remove children as they are returned from scopedSlots now\n          el.children = [];\n          // mark el non-plain so data gets generated\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName (binding) {\n    var name = binding.name.replace(slotRE, '');\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\n          \"v-slot shorthand syntax requires a slot name.\",\n          binding\n        );\n      }\n    }\n    return dynamicArgRE.test(name)\n      // dynamic [name]\n      ? { name: name.slice(1, -1), dynamic: true }\n      // static name\n      : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n  }\n\n  // handle <slot/> outlets\n  function processSlotOutlet (el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (el.key) {\n        warn$2(\n          \"`key` does not work on <slot> because slots are abstract outlets \" +\n          \"and can possibly expand into multiple elements. \" +\n          \"Use the key on a wrapping element instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n    }\n  }\n\n  function processComponent (el) {\n    var binding;\n    if ((binding = getBindingAttr(el, 'is'))) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs (el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name.replace(dirRE, ''));\n        // support .foo shorthand syntax for the .prop modifier\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) { // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          if (\n            value.trim().length === 0\n          ) {\n            warn$2(\n              (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n            );\n          }\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n              if (name === 'innerHtml') { name = 'innerHTML'; }\n            }\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n              if (!isDynamic) {\n                addHandler(\n                  el,\n                  (\"update:\" + (camelize(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(\n                    el,\n                    (\"update:\" + (hyphenate(name))),\n                    syncGen,\n                    null,\n                    false,\n                    warn$2,\n                    list[i]\n                  );\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(\n                  el,\n                  (\"\\\"update:\\\"+(\" + name + \")\"),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i],\n                  true // dynamic\n                );\n              }\n            }\n          }\n          if ((modifiers && modifiers.prop) || (\n            !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n          )) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) { // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else { // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(\n              name + \"=\\\"\" + value + \"\\\": \" +\n              'Interpolation inside attributes has been removed. ' +\n              'Use v-bind or the colon shorthand instead. For example, ' +\n              'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n              list[i]\n            );\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]);\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component &&\n            name === 'muted' &&\n            platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor (el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true\n      }\n      parent = parent.parent;\n    }\n    return false\n  }\n\n  function parseModifiers (name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) { ret[m.slice(1)] = true; });\n      return ret\n    }\n  }\n\n  function makeAttrsMap (attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\n        map[attrs[i].name] && !isIE && !isEdge\n      ) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag (el) {\n    return el.tag === 'script' || el.tag === 'style'\n  }\n\n  function isForbiddenTag (el) {\n    return (\n      el.tag === 'style' ||\n      (el.tag === 'script' && (\n        !el.attrsMap.type ||\n        el.attrsMap.type === 'text/javascript'\n      ))\n    )\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug (attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res\n  }\n\n  function checkForAliasModel (el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n          \"You are binding v-model directly to a v-for iteration alias. \" +\n          \"This will not be able to modify the v-for source array because \" +\n          \"writing to the alias is like modifying a function local variable. \" +\n          \"Consider using an array of objects and use v-model on an object property instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  function preTransformNode (el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (!map['v-model']) {\n        return\n      }\n\n      var typeBinding;\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + (map['v-bind']) + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0\n      }\n    }\n  }\n\n  function cloneASTElement (el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [\n    klass$1,\n    style$1,\n    model$1\n  ];\n\n  /*  */\n\n  function text (el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  /*  */\n\n  function html (el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize (root, options) {\n    if (!root) { return }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1 (keys) {\n    return makeMap(\n      'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n      (keys ? ',' + keys : '')\n    )\n  }\n\n  function markStatic$1 (node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (\n        !isPlatformReservedTag(node.tag) &&\n        node.tag !== 'slot' &&\n        node.attrsMap['inline-template'] == null\n      ) {\n        return\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots (node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(\n        node.children.length === 1 &&\n        node.children[0].type === 3\n      )) {\n        node.staticRoot = true;\n        return\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic (node) {\n    if (node.type === 2) { // expression\n      return false\n    }\n    if (node.type === 3) { // text\n      return true\n    }\n    return !!(node.pre || (\n      !node.hasBindings && // no dynamic bindings\n      !node.if && !node.for && // not v-if or v-for or v-else\n      !isBuiltInTag(node.tag) && // not a built-in\n      isPlatformReservedTag(node.tag) && // not a component\n      !isDirectChildOfTemplateFor(node) &&\n      Object.keys(node).every(isStaticKey)\n    ))\n  }\n\n  function isDirectChildOfTemplateFor (node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false\n      }\n      if (node.for) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n  // KeyboardEvent.keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // KeyboardEvent.key aliases\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers (\n    events,\n    isNative\n  ) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n    staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n    } else {\n      return prefix + staticHandlers\n    }\n  }\n\n  function genHandler (handler) {\n    if (!handler) {\n      return 'function(){}'\n    }\n\n    if (Array.isArray(handler)) {\n      return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value\n      }\n      return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = (handler.modifiers);\n          genModifierCode += genGuard(\n            ['ctrl', 'shift', 'alt', 'meta']\n              .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n              .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n              .join('||')\n          );\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath\n        ? (\"return \" + (handler.value) + \"($event)\")\n        : isFunctionExpression\n          ? (\"return (\" + (handler.value) + \")($event)\")\n          : isFunctionInvocation\n            ? (\"return \" + (handler.value))\n            : handler.value;\n      return (\"function($event){\" + code + handlerCode + \"}\")\n    }\n  }\n\n  function genKeyFilter (keys) {\n    return (\n      // make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" +\n      (keys.map(genFilterCode).join('&&')) + \")return null;\"\n    )\n  }\n\n  function genFilterCode (key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return (\"$event.keyCode!==\" + keyVal)\n    }\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return (\n      \"_k($event.keyCode,\" +\n      (JSON.stringify(key)) + \",\" +\n      (JSON.stringify(keyCode)) + \",\" +\n      \"$event.key,\" +\n      \"\" + (JSON.stringify(keyName)) +\n      \")\"\n    )\n  }\n\n  /*  */\n\n  function on (el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n  }\n\n  /*  */\n\n  function bind$1 (el, dir) {\n    el.wrapData = function (code) {\n      return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n\n\n\n\n  var CodegenState = function CodegenState (options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n\n\n  function generate (\n    ast,\n    options\n  ) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: (\"with(this){return \" + code + \"}\"),\n      staticRenderFns: state.staticRenderFns\n    }\n  }\n\n  function genElement (el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state)\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state)\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state)\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0'\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state)\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n        if (!el.plain || (el.pre && state.maybeComponent(el))) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic (el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    var originalPreState = state.pre;\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n    state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n    state.pre = originalPreState;\n    return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n  }\n\n  // v-once\n  function genOnce (el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        state.warn(\n          \"v-once can only be used inside v-for that is keyed. \",\n          el.rawAttrsMap['v-once']\n        );\n        return genElement(el, state)\n      }\n      return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n    } else {\n      return genStatic(el, state)\n    }\n  }\n\n  function genIf (\n    el,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n  }\n\n  function genIfConditions (\n    conditions,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    if (!conditions.length) {\n      return altEmpty || '_e()'\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n    } else {\n      return (\"\" + (genTernaryExp(condition.block)))\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp (el) {\n      return altGen\n        ? altGen(el, state)\n        : el.once\n          ? genOnce(el, state)\n          : genElement(el, state)\n    }\n  }\n\n  function genFor (\n    el,\n    state,\n    altGen,\n    altHelper\n  ) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n    var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n    if (state.maybeComponent(el) &&\n      el.tag !== 'slot' &&\n      el.tag !== 'template' &&\n      !el.key\n    ) {\n      state.warn(\n        \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n        \"v-for should have explicit keys. \" +\n        \"See https://vuejs.org/guide/list.html#key for more info.\",\n        el.rawAttrsMap['v-for'],\n        true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" +\n      \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n        \"return \" + ((altGen || genElement)(el, state)) +\n      '})'\n  }\n\n  function genData$2 (el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) { data += dirs + ','; }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + (el.key) + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + (el.ref) + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:\" + (genProps(el.props)) + \",\";\n    }\n    // event handlers\n    if (el.events) {\n      data += (genHandlers(el.events, false)) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += (genHandlers(el.nativeEvents, true)) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + (el.slotTarget) + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data\n  }\n\n  function genDirectives (el, state) {\n    var dirs = el.directives;\n    if (!dirs) { return }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']'\n    }\n  }\n\n  function genInlineTemplate (el, state) {\n    var ast = el.children[0];\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn(\n        'Inline-template components must have exactly one child element.',\n        { start: el.start }\n      );\n    }\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n    }\n  }\n\n  function genScopedSlots (\n    el,\n    slots,\n    state\n  ) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return (\n        slot.slotTargetDynamic ||\n        slot.if ||\n        slot.for ||\n        containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      )\n    });\n\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    var needsKey = !!el.if;\n\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n      while (parent) {\n        if (\n          (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n          parent.for\n        ) {\n          needsForceUpdate = true;\n          break\n        }\n        if (parent.if) {\n          needsKey = true;\n        }\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots)\n      .map(function (key) { return genScopedSlot(slots[key], state); })\n      .join(',');\n\n    return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n    while(i) {\n      hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0\n  }\n\n  function containsSlotChild (el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true\n      }\n      return el.children.some(containsSlotChild)\n    }\n    return false\n  }\n\n  function genScopedSlot (\n    el,\n    state\n  ) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\")\n    }\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot)\n    }\n    var slotScope = el.slotScope === emptySlotScopeToken\n      ? \"\"\n      : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" +\n      \"return \" + (el.tag === 'template'\n        ? el.if && isLegacySyntax\n          ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n          : genChildren(el, state) || 'undefined'\n        : genElement(el, state)) + \"}\";\n    // reverse proxy v-slot without scope on this.$slots\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n  }\n\n  function genChildren (\n    el,\n    state,\n    checkSkip,\n    altGenElement,\n    altGenNode\n  ) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot'\n      ) {\n        var normalizationType = checkSkip\n          ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n          : \"\";\n        return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n      }\n      var normalizationType$1 = checkSkip\n        ? getNormalizationType(children, state.maybeComponent)\n        : 0;\n      var gen = altGenNode || genNode;\n      return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType (\n    children,\n    maybeComponent\n  ) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue\n      }\n      if (needsNormalization(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n        res = 2;\n        break\n      }\n      if (maybeComponent(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n        res = 1;\n      }\n    }\n    return res\n  }\n\n  function needsNormalization (el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n  }\n\n  function genNode (node, state) {\n    if (node.type === 1) {\n      return genElement(node, state)\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node)\n    } else {\n      return genText(node)\n    }\n  }\n\n  function genText (text) {\n    return (\"_v(\" + (text.type === 2\n      ? text.expression // no need for () because already wrapped in _s()\n      : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n  }\n\n  function genComment (comment) {\n    return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n  }\n\n  function genSlot (el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n    var attrs = el.attrs || el.dynamicAttrs\n      ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n          // slot props are camelized\n          name: camelize(attr.name),\n          value: attr.value,\n          dynamic: attr.dynamic\n        }); }))\n      : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')'\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent (\n    componentName,\n    el,\n    state\n  ) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n  }\n\n  function genProps (props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n      if (prop.dynamic) {\n        dynamicProps += (prop.name) + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n      }\n    }\n    staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n    if (dynamicProps) {\n      return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n    } else {\n      return staticProps\n    }\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines (text) {\n    return text\n      .replace(/\\u2028/g, '\\\\u2028')\n      .replace(/\\u2029/g, '\\\\u2029')\n  }\n\n  /*  */\n\n\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + (\n    'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n    'super,throw,while,yield,delete,export,import,return,switch,default,' +\n    'extends,finally,continue,debugger,function,arguments'\n  ).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + (\n    'delete,typeof,void'\n  ).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors (ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode (node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            var range = node.rawAttrsMap[name];\n            if (name === 'v-for') {\n              checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            } else {\n              checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent (exp, text, warn, range) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\n        \"avoid using JavaScript unary operator as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n        range\n      );\n    }\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor (node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier (\n    ident,\n    type,\n    text,\n    warn,\n    range\n  ) {\n    if (typeof ident === 'string') {\n      try {\n        new Function((\"var \" + ident + \"=_\"));\n      } catch (e) {\n        warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n      }\n    }\n  }\n\n  function checkExpression (exp, text, warn, range) {\n    try {\n      new Function((\"return \" + exp));\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        warn(\n          \"avoid using JavaScript keyword as property name: \" +\n          \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n          range\n        );\n      } else {\n        warn(\n          \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n          \"    \" + exp + \"\\n\\n\" +\n          \"  Raw expression: \" + (text.trim()) + \"\\n\",\n          range\n        );\n      }\n    }\n  }\n\n  /*  */\n\n  var range = 2;\n\n  function generateCodeFrame (\n    source,\n    start,\n    end\n  ) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = source.length;\n\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) { continue }\n          res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n          var lineLength = lines[j].length;\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break\n      }\n    }\n    return res.join('\\n')\n  }\n\n  function repeat$1 (str, n) {\n    var result = '';\n    if (n > 0) {\n      while (true) { // eslint-disable-line\n        if (n & 1) { result += str; }\n        n >>>= 1;\n        if (n <= 0) { break }\n        str += str;\n      }\n    }\n    return result\n  }\n\n  /*  */\n\n\n\n  function createFunction (code, errors) {\n    try {\n      return new Function(code)\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop\n    }\n  }\n\n  function createCompileToFunctionFn (compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions (\n      template,\n      options,\n      vm\n    ) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1(\n              'It seems you are using the standalone build of Vue.js in an ' +\n              'environment with Content Security Policy that prohibits unsafe-eval. ' +\n              'The template compiler cannot work in this environment. Consider ' +\n              'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n              'templates into render functions.'\n            );\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters\n        ? String(options.delimiters) + template\n        : template;\n      if (cache[key]) {\n        return cache[key]\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\n                \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n                generateCodeFrame(template, e.start, e.end),\n                vm\n              );\n            });\n          } else {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n              compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n              vm\n            );\n          }\n        }\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n          } else {\n            compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n          }\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors)\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\n            \"Failed to generate render function:\\n\\n\" +\n            fnGenErrors.map(function (ref) {\n              var err = ref.err;\n              var code = ref.code;\n\n              return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n          }).join('\\n'),\n            vm\n          );\n        }\n      }\n\n      return (cache[key] = res)\n    }\n  }\n\n  /*  */\n\n  function createCompilerCreator (baseCompile) {\n    return function createCompiler (baseOptions) {\n      function compile (\n        template,\n        options\n      ) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function (msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function (msg, range, tip) {\n              var data = { msg: msg };\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n              (tip ? tips : errors).push(data);\n            };\n          }\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules =\n              (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(\n              Object.create(baseOptions.directives || null),\n              options.directives\n            );\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      }\n    }\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile (\n    template,\n    options\n  ) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    }\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode (href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      warn(\n        \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n      );\n      return this\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (!template) {\n              warn(\n                (\"Template element not found or is empty: \" + (options.template)),\n                this\n              );\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile end');\n          measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating)\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML (el) {\n    if (el.outerHTML) {\n      return el.outerHTML\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(1), __webpack_require__(6).setImmediate))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmpzP2JhNGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLFNBQ2lEO0FBQ25ELENBQUMsb0JBQW9COztBQUVyQjs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsK0JBQStCO0FBQ3ZELHdCQUF3QixpQkFBaUI7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUNBQWlDLEVBQUU7QUFDdkYsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYzs7QUFFN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyx5Q0FBeUMsd0JBQXdCLEVBQUU7QUFDbkUsNEJBQTRCOztBQUU1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQixFQUFFO0FBQ3ZEO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFNBQVMscUJBQXFCOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUF1QjtBQUMzRCxtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QyxpQ0FBaUM7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLHNDQUFzQztBQUN0QztBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUZBQXVGO0FBQzlGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCOztBQUU1QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIseUJBQXlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHlCQUF5QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQixFQUFFOztBQUV0RDtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQjtBQUNoRCx1QkFBdUIsK0JBQStCO0FBQ3REO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCO0FBQ0Esd0JBQXdCLGlDQUFpQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLDJCQUEyQixFQUFFO0FBQ3pFLE9BQU87QUFDUDtBQUNBLDRDQUE0Qyw0QkFBNEIsRUFBRTtBQUMxRSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLHNCQUFzQjs7QUFFdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RTtBQUM5RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrQkFBa0I7QUFDNUQsT0FBTztBQUNQLDBDQUEwQyxrQkFBa0I7QUFDNUQsT0FBTztBQUNQLDBDQUEwQywwQkFBMEI7QUFDcEUsT0FBTztBQUNQLDBDQUEwQyxpQkFBaUI7QUFDM0QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EscUNBQXFDO0FBQ3JDLHFDQUFxQztBQUNyQyw2Q0FBNkM7QUFDN0MsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZSxFQUFFLHVCQUF1QixVQUFVLEVBQUU7QUFDdEY7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCw2Q0FBNkM7QUFDbEc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBNkM7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxLQUFLO0FBQ0wsMkNBQTJDO0FBQzNDOztBQUVBLG1DQUFtQyx3Q0FBd0M7QUFDM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxtQkFBbUI7QUFDN0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0Qyx5QkFBeUIsYUFBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUY7QUFDbkYsOEJBQThCO0FBQzlCO0FBQ0EsNkJBQTZCO0FBQzdCLDBCQUEwQixpRUFBaUU7QUFDM0YsY0FBYywwRkFBMEY7QUFDeEcsUUFBUSxLQUFLLDBDQUEwQztBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxrQkFBa0I7QUFDakUsd0JBQXdCLCtDQUErQztBQUN2RSxtREFBbUQ7O0FBRW5EO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUyw0QkFBNEI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0IsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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KiBWdWUuanMgdjIuNi43XG4gKiAoYykgMjAxNC0yMDE5IEV2YW4gWW91XG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVnVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyogICovXG5cbiAgdmFyIGVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSh7fSk7XG5cbiAgLy8gVGhlc2UgaGVscGVycyBwcm9kdWNlIGJldHRlciBWTSBjb2RlIGluIEpTIGVuZ2luZXMgZHVlIHRvIHRoZWlyXG4gIC8vIGV4cGxpY2l0bmVzcyBhbmQgZnVuY3Rpb24gaW5saW5pbmcuXG4gIGZ1bmN0aW9uIGlzVW5kZWYgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRGVmICh2KSB7XG4gICAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBpc1RydWUgKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gaXNGYWxzZSAodikge1xuICAgIHJldHVybiB2ID09PSBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzUHJpbWl0aXZlICh2YWx1ZSkge1xuICAgIHJldHVybiAoXG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICAgKiBPYmplY3RzIGZyb20gcHJpbWl0aXZlIHZhbHVlcyB3aGVuIHdlIGtub3cgdGhlIHZhbHVlXG4gICAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0IChvYmopIHtcbiAgICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSwgZS5nLiwgW29iamVjdCBPYmplY3RdLlxuICAgKi9cbiAgdmFyIF90b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG4gIH1cblxuICAvKipcbiAgICogU3RyaWN0IG9iamVjdCB0eXBlIGNoZWNrLiBPbmx5IHJldHVybnMgdHJ1ZVxuICAgKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCAob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gIH1cblxuICBmdW5jdGlvbiBpc1JlZ0V4cCAodikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbCh2KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB2YWwgaXMgYSB2YWxpZCBhcnJheSBpbmRleC5cbiAgICovXG4gIGZ1bmN0aW9uIGlzVmFsaWRBcnJheUluZGV4ICh2YWwpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQoU3RyaW5nKHZhbCkpO1xuICAgIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG4gIH1cblxuICBmdW5jdGlvbiBpc1Byb21pc2UgKHZhbCkge1xuICAgIHJldHVybiAoXG4gICAgICBpc0RlZih2YWwpICYmXG4gICAgICB0eXBlb2YgdmFsLnRoZW4gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiB2YWwuY2F0Y2ggPT09ICdmdW5jdGlvbidcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAqL1xuICBmdW5jdGlvbiB0b1N0cmluZyAodmFsKSB7XG4gICAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgICA/ICcnXG4gICAgICA6IEFycmF5LmlzQXJyYXkodmFsKSB8fCAoaXNQbGFpbk9iamVjdCh2YWwpICYmIHZhbC50b1N0cmluZyA9PT0gX3RvU3RyaW5nKVxuICAgICAgICA/IEpTT04uc3RyaW5naWZ5KHZhbCwgbnVsbCwgMilcbiAgICAgICAgOiBTdHJpbmcodmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gaW5wdXQgdmFsdWUgdG8gYSBudW1iZXIgZm9yIHBlcnNpc3RlbmNlLlxuICAgKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAgICovXG4gIGZ1bmN0aW9uIHRvTnVtYmVyICh2YWwpIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgICByZXR1cm4gaXNOYU4obikgPyB2YWwgOiBuXG4gIH1cblxuICAvKipcbiAgICogTWFrZSBhIG1hcCBhbmQgcmV0dXJuIGEgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGEga2V5XG4gICAqIGlzIGluIHRoYXQgbWFwLlxuICAgKi9cbiAgZnVuY3Rpb24gbWFrZU1hcCAoXG4gICAgc3RyLFxuICAgIGV4cGVjdHNMb3dlckNhc2VcbiAgKSB7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1hcFtsaXN0W2ldXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBleHBlY3RzTG93ZXJDYXNlXG4gICAgICA/IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG1hcFt2YWwudG9Mb3dlckNhc2UoKV07IH1cbiAgICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAgICovXG4gIHZhciBpc0J1aWx0SW5UYWcgPSBtYWtlTWFwKCdzbG90LGNvbXBvbmVudCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gICAqL1xuICB2YXIgaXNSZXNlcnZlZEF0dHJpYnV0ZSA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCxzbG90LXNjb3BlLGlzJyk7XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmUgKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICB2YXIgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGFuIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICAgKi9cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGNhY2hlZCB2ZXJzaW9uIG9mIGEgcHVyZSBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgICB2YXIgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiAoZnVuY3Rpb24gY2FjaGVkRm4gKHN0cikge1xuICAgICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIENhbWVsaXplIGEgaHlwaGVuLWRlbGltaXRlZCBzdHJpbmcuXG4gICAqL1xuICB2YXIgY2FtZWxpemVSRSA9IC8tKFxcdykvZztcbiAgdmFyIGNhbWVsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbiAgfSk7XG5cbiAgLyoqXG4gICAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gICAqL1xuICB2YXIgY2FwaXRhbGl6ZSA9IGNhY2hlZChmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuICB9KTtcblxuICAvKipcbiAgICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAgICovXG4gIHZhciBoeXBoZW5hdGVSRSA9IC9cXEIoW0EtWl0pL2c7XG4gIHZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShoeXBoZW5hdGVSRSwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBiaW5kIHBvbHlmaWxsIGZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3Qgc3VwcG9ydCBpdCxcbiAgICogZS5nLiwgUGhhbnRvbUpTIDEueC4gVGVjaG5pY2FsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBhbnltb3JlXG4gICAqIHNpbmNlIG5hdGl2ZSBiaW5kIGlzIG5vdyBwZXJmb3JtYW50IGVub3VnaCBpbiBtb3N0IGJyb3dzZXJzLlxuICAgKiBCdXQgcmVtb3ZpbmcgaXQgd291bGQgbWVhbiBicmVha2luZyBjb2RlIHRoYXQgd2FzIGFibGUgdG8gcnVuIGluXG4gICAqIFBoYW50b21KUyAxLngsIHNvIHRoaXMgbXVzdCBiZSBrZXB0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBmdW5jdGlvbiBwb2x5ZmlsbEJpbmQgKGZuLCBjdHgpIHtcbiAgICBmdW5jdGlvbiBib3VuZEZuIChhKSB7XG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICByZXR1cm4gbFxuICAgICAgICA/IGwgPiAxXG4gICAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgICA6IGZuLmNhbGwoY3R4KVxuICAgIH1cblxuICAgIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgICByZXR1cm4gYm91bmRGblxuICB9XG5cbiAgZnVuY3Rpb24gbmF0aXZlQmluZCAoZm4sIGN0eCkge1xuICAgIHJldHVybiBmbi5iaW5kKGN0eClcbiAgfVxuXG4gIHZhciBiaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRcbiAgICA/IG5hdGl2ZUJpbmRcbiAgICA6IHBvbHlmaWxsQmluZDtcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiB0b0FycmF5IChsaXN0LCBzdGFydCkge1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBleHRlbmQgKHRvLCBfZnJvbSkge1xuICAgIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0b1xuICB9XG5cbiAgLyoqXG4gICAqIE1lcmdlIGFuIEFycmF5IG9mIE9iamVjdHMgaW50byBhIHNpbmdsZSBPYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiB0b09iamVjdCAoYXJyKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2ldKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIGFycltpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICAgKiBTdHViYmluZyBhcmdzIHRvIG1ha2UgRmxvdyBoYXBweSB3aXRob3V0IGxlYXZpbmcgdXNlbGVzcyB0cmFuc3BpbGVkIGNvZGVcbiAgICogd2l0aCAuLi5yZXN0IChodHRwczovL2Zsb3cub3JnL2Jsb2cvMjAxNy8wNS8wNy9TdHJpY3QtRnVuY3Rpb24tQ2FsbC1Bcml0eS8pLlxuICAgKi9cbiAgZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuICAvKipcbiAgICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAgICovXG4gIHZhciBubyA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7IHJldHVybiBmYWxzZTsgfTtcblxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgc2FtZSB2YWx1ZS5cbiAgICovXG4gIHZhciBpZGVudGl0eSA9IGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHN0cmluZyBjb250YWluaW5nIHN0YXRpYyBrZXlzIGZyb20gY29tcGlsZXIgbW9kdWxlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGdlblN0YXRpY0tleXMgKG1vZHVsZXMpIHtcbiAgICByZXR1cm4gbW9kdWxlcy5yZWR1Y2UoZnVuY3Rpb24gKGtleXMsIG0pIHtcbiAgICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gICAgfSwgW10pLmpvaW4oJywnKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHR3byB2YWx1ZXMgYXJlIGxvb3NlbHkgZXF1YWwgLSB0aGF0IGlzLFxuICAgKiBpZiB0aGV5IGFyZSBwbGFpbiBvYmplY3RzLCBkbyB0aGV5IGhhdmUgdGhlIHNhbWUgc2hhcGU/XG4gICAqL1xuICBmdW5jdGlvbiBsb29zZUVxdWFsIChhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgICB2YXIgaXNPYmplY3RCID0gaXNPYmplY3QoYik7XG4gICAgaWYgKGlzT2JqZWN0QSAmJiBpc09iamVjdEIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBpc0FycmF5QSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgICAgIHZhciBpc0FycmF5QiA9IEFycmF5LmlzQXJyYXkoYik7XG4gICAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5ldmVyeShmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoZSwgYltpXSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpID09PSBiLmdldFRpbWUoKVxuICAgICAgICB9IGVsc2UgaWYgKCFpc0FycmF5QSAmJiAhaXNBcnJheUIpIHtcbiAgICAgICAgICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgICByZXR1cm4ga2V5c0EubGVuZ3RoID09PSBrZXlzQi5sZW5ndGggJiYga2V5c0EuZXZlcnkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvb3NlRXF1YWwoYVtrZXldLCBiW2tleV0pXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGEpID09PSBTdHJpbmcoYilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZmlyc3QgaW5kZXggYXQgd2hpY2ggYSBsb29zZWx5IGVxdWFsIHZhbHVlIGNhbiBiZVxuICAgKiBmb3VuZCBpbiB0aGUgYXJyYXkgKGlmIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGUgYXJyYXkgbXVzdFxuICAgKiBjb250YWluIGFuIG9iamVjdCBvZiB0aGUgc2FtZSBzaGFwZSksIG9yIC0xIGlmIGl0IGlzIG5vdCBwcmVzZW50LlxuICAgKi9cbiAgZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChhcnJbaV0sIHZhbCkpIHsgcmV0dXJuIGkgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIC8qKlxuICAgKiBFbnN1cmUgYSBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBvbmNlLlxuICAgKi9cbiAgZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxuICB2YXIgQVNTRVRfVFlQRVMgPSBbXG4gICAgJ2NvbXBvbmVudCcsXG4gICAgJ2RpcmVjdGl2ZScsXG4gICAgJ2ZpbHRlcidcbiAgXTtcblxuICB2YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCcsXG4gICAgJ2Vycm9yQ2FwdHVyZWQnLFxuICAgICdzZXJ2ZXJQcmVmZXRjaCdcbiAgXTtcblxuICAvKiAgKi9cblxuXG5cbiAgdmFyIGNvbmZpZyA9ICh7XG4gICAgLyoqXG4gICAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAgICovXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBzdXBwcmVzcyB3YXJuaW5ncy5cbiAgICAgKi9cbiAgICBzaWxlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICAgKi9cbiAgICBwcm9kdWN0aW9uVGlwOiBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAgICovXG4gICAgZGV2dG9vbHM6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgICAqL1xuICAgIHBlcmZvcm1hbmNlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAgICovXG4gICAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogV2FybiBoYW5kbGVyIGZvciB3YXRjaGVyIHdhcm5zXG4gICAgICovXG4gICAgd2FybkhhbmRsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICAgKi9cbiAgICBpZ25vcmVkRWxlbWVudHM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQ3VzdG9tIHVzZXIga2V5IGFsaWFzZXMgZm9yIHYtb25cbiAgICAgKi9cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBzbyB0aGF0IGl0IGNhbm5vdCBiZSB1c2VkIGFzIGEgY29tcG9uZW50XG4gICAgICogcHJvcC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICAgKi9cbiAgICBpc1Jlc2VydmVkQXR0cjogbm8sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICogUGxhdGZvcm0tZGVwZW5kZW50LlxuICAgICAqL1xuICAgIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgICAqL1xuICAgIGdldFRhZ05hbWVzcGFjZTogbm9vcCxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAgICovXG4gICAgcGFyc2VQbGF0Zm9ybVRhZ05hbWU6IGlkZW50aXR5LFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYW4gYXR0cmlidXRlIG11c3QgYmUgYm91bmQgdXNpbmcgcHJvcGVydHksIGUuZy4gdmFsdWVcbiAgICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAgICovXG4gICAgbXVzdFVzZVByb3A6IG5vLFxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSB1cGRhdGVzIGFzeW5jaHJvbm91c2x5LiBJbnRlbmRlZCB0byBiZSB1c2VkIGJ5IFZ1ZSBUZXN0IFV0aWxzXG4gICAgICogVGhpcyB3aWxsIHNpZ25pZmljYW50bHkgcmVkdWNlIHBlcmZvcm1hbmNlIGlmIHNldCB0byBmYWxzZS5cbiAgICAgKi9cbiAgICBhc3luYzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEV4cG9zZWQgZm9yIGxlZ2FjeSByZWFzb25zXG4gICAgICovXG4gICAgX2xpZmVjeWNsZUhvb2tzOiBMSUZFQ1lDTEVfSE9PS1NcbiAgfSk7XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIHVuaWNvZGUgbGV0dGVycyB1c2VkIGZvciBwYXJzaW5nIGh0bWwgdGFncywgY29tcG9uZW50IG5hbWVzIGFuZCBwcm9wZXJ0eSBwYXRocy5cbiAgICogdXNpbmcgaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1My9zZW1hbnRpY3Mtc2NyaXB0aW5nLmh0bWwjcG90ZW50aWFsY3VzdG9tZWxlbWVudG5hbWVcbiAgICogc2tpcHBpbmcgXFx1MTAwMDAtXFx1RUZGRkYgZHVlIHRvIGl0IGZyZWV6aW5nIHVwIFBoYW50b21KU1xuICAgKi9cbiAgdmFyIHVuaWNvZGVMZXR0ZXJzID0gJ2EtekEtWlxcdTAwQjdcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDNGLVxcdTIwNDBcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkQnO1xuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCAkIG9yIF9cbiAgICovXG4gIGZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICAgIHZhciBjID0gKHN0ciArICcnKS5jaGFyQ29kZUF0KDApO1xuICAgIHJldHVybiBjID09PSAweDI0IHx8IGMgPT09IDB4NUZcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSBwcm9wZXJ0eS5cbiAgICovXG4gIGZ1bmN0aW9uIGRlZiAob2JqLCBrZXksIHZhbCwgZW51bWVyYWJsZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbCxcbiAgICAgIGVudW1lcmFibGU6ICEhZW51bWVyYWJsZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2Ugc2ltcGxlIHBhdGguXG4gICAqL1xuICB2YXIgYmFpbFJFID0gbmV3IFJlZ0V4cCgoXCJbXlwiICsgdW5pY29kZUxldHRlcnMgKyBcIi4kX1xcXFxkXVwiKSk7XG4gIGZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICAgIGlmIChiYWlsUkUudGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIW9iaikgeyByZXR1cm4gfVxuICAgICAgICBvYmogPSBvYmpbc2VnbWVudHNbaV1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9ialxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIGNhbiB3ZSB1c2UgX19wcm90b19fP1xuICB2YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuICAvLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG4gIHZhciBpbkJyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGluV2VleCA9IHR5cGVvZiBXWEVudmlyb25tZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhIVdYRW52aXJvbm1lbnQucGxhdGZvcm07XG4gIHZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgVUEgPSBpbkJyb3dzZXIgJiYgd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGlzSUUgPSBVQSAmJiAvbXNpZXx0cmlkZW50Ly50ZXN0KFVBKTtcbiAgdmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG4gIHZhciBpc0VkZ2UgPSBVQSAmJiBVQS5pbmRleE9mKCdlZGdlLycpID4gMDtcbiAgdmFyIGlzQW5kcm9pZCA9IChVQSAmJiBVQS5pbmRleE9mKCdhbmRyb2lkJykgPiAwKSB8fCAod2VleFBsYXRmb3JtID09PSAnYW5kcm9pZCcpO1xuICB2YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xuICB2YXIgaXNDaHJvbWUgPSBVQSAmJiAvY2hyb21lXFwvXFxkKy8udGVzdChVQSkgJiYgIWlzRWRnZTtcbiAgdmFyIGlzUGhhbnRvbUpTID0gVUEgJiYgL3BoYW50b21qcy8udGVzdChVQSk7XG4gIHZhciBpc0ZGID0gVUEgJiYgVUEubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKTtcblxuICAvLyBGaXJlZm94IGhhcyBhIFwid2F0Y2hcIiBmdW5jdGlvbiBvbiBPYmplY3QucHJvdG90eXBlLi4uXG4gIHZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbiAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvcHRzID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob3B0cywgJ3Bhc3NpdmUnLCAoe1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KSk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yODVcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0LXBhc3NpdmUnLCBudWxsLCBvcHRzKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG5cbiAgLy8gdGhpcyBuZWVkcyB0byBiZSBsYXp5LWV2YWxlZCBiZWNhdXNlIHZ1ZSBtYXkgYmUgcmVxdWlyZWQgYmVmb3JlXG4gIC8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG4gIHZhciBfaXNTZXJ2ZXI7XG4gIHZhciBpc1NlcnZlclJlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFpbkJyb3dzZXIgJiYgIWluV2VleCAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBkZXRlY3QgcHJlc2VuY2Ugb2YgdnVlLXNlcnZlci1yZW5kZXJlciBhbmQgYXZvaWRcbiAgICAgICAgLy8gV2VicGFjayBzaGltbWluZyB0aGUgcHJvY2Vzc1xuICAgICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXSAmJiBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfaXNTZXJ2ZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9pc1NlcnZlclxuICB9O1xuXG4gIC8vIGRldGVjdCBkZXZ0b29sc1xuICB2YXIgZGV2dG9vbHMgPSBpbkJyb3dzZXIgJiYgd2luZG93Ll9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIEN0b3IgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KEN0b3IudG9TdHJpbmcoKSlcbiAgfVxuXG4gIHZhciBoYXNTeW1ib2wgPVxuICAgIHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFN5bWJvbCkgJiZcbiAgICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxuICB2YXIgX1NldDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vICRmbG93LWRpc2FibGUtbGluZVxuICBpZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAgIC8vIHVzZSBuYXRpdmUgU2V0IHdoZW4gYXZhaWxhYmxlLlxuICAgIF9TZXQgPSBTZXQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gYSBub24tc3RhbmRhcmQgU2V0IHBvbHlmaWxsIHRoYXQgb25seSB3b3JrcyB3aXRoIHByaW1pdGl2ZSBrZXlzLlxuICAgIF9TZXQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFNldCAoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIFNldC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gaGFzIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICAgIH07XG4gICAgICBTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoa2V5KSB7XG4gICAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgICAgfTtcbiAgICAgIFNldC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBTZXQ7XG4gICAgfSgpKTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciB3YXJuID0gbm9vcDtcbiAgdmFyIHRpcCA9IG5vb3A7XG4gIHZhciBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gKG5vb3ApOyAvLyB3b3JrIGFyb3VuZCBmbG93IGNoZWNrXG4gIHZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG4gIHtcbiAgICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgICB2YXIgY2xhc3NpZnlSRSA9IC8oPzpefFstX10pKFxcdykvZztcbiAgICB2YXIgY2xhc3NpZnkgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHJcbiAgICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgICAucmVwbGFjZSgvWy1fXS9nLCAnJyk7IH07XG5cbiAgICB3YXJuID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgICAgaWYgKGNvbmZpZy53YXJuSGFuZGxlcikge1xuICAgICAgICBjb25maWcud2FybkhhbmRsZXIuY2FsbChudWxsLCBtc2csIHZtLCB0cmFjZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKChcIltWdWUgd2Fybl06IFwiICsgbXNnICsgdHJhY2UpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGlwID0gZnVuY3Rpb24gKG1zZywgdm0pIHtcbiAgICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgICB2bSA/IGdlbmVyYXRlQ29tcG9uZW50VHJhY2Uodm0pIDogJydcbiAgICAgICAgKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvcm1hdENvbXBvbmVudE5hbWUgPSBmdW5jdGlvbiAodm0sIGluY2x1ZGVGaWxlKSB7XG4gICAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICAgIHJldHVybiAnPFJvb3Q+J1xuICAgICAgfVxuICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgICAgPyB2bS5vcHRpb25zXG4gICAgICAgIDogdm0uX2lzVnVlXG4gICAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgICAgOiB2bTtcbiAgICAgIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IG9wdGlvbnMuX2NvbXBvbmVudFRhZztcbiAgICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgICBpZiAoIW5hbWUgJiYgZmlsZSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBmaWxlLm1hdGNoKC8oW14vXFxcXF0rKVxcLnZ1ZSQvKTtcbiAgICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gKFxuICAgICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgICAgKGZpbGUgJiYgaW5jbHVkZUZpbGUgIT09IGZhbHNlID8gKFwiIGF0IFwiICsgZmlsZSkgOiAnJylcbiAgICAgIClcbiAgICB9O1xuXG4gICAgdmFyIHJlcGVhdCA9IGZ1bmN0aW9uIChzdHIsIG4pIHtcbiAgICAgIHZhciByZXMgPSAnJztcbiAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgIGlmIChuICUgMiA9PT0gMSkgeyByZXMgKz0gc3RyOyB9XG4gICAgICAgIGlmIChuID4gMSkgeyBzdHIgKz0gc3RyOyB9XG4gICAgICAgIG4gPj49IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzXG4gICAgfTtcblxuICAgIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSBmdW5jdGlvbiAodm0pIHtcbiAgICAgIGlmICh2bS5faXNWdWUgJiYgdm0uJHBhcmVudCkge1xuICAgICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgd2hpbGUgKHZtKSB7XG4gICAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSB0cmVlW3RyZWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAobGFzdC5jb25zdHJ1Y3RvciA9PT0gdm0uY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICAgIHZtID0gdm0uJHBhcmVudDtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgICB0cmVlW3RyZWUubGVuZ3RoIC0gMV0gPSBbbGFzdCwgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlXTtcbiAgICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdHJlZS5wdXNoKHZtKTtcbiAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdcXG5cXG5mb3VuZCBpblxcblxcbicgKyB0cmVlXG4gICAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgICAgPyAoKGZvcm1hdENvbXBvbmVudE5hbWUodm1bMF0pKSArIFwiLi4uIChcIiArICh2bVsxXSkgKyBcIiByZWN1cnNpdmUgY2FsbHMpXCIpXG4gICAgICAgICAgICAgIDogZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpKTsgfSlcbiAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoXCJcXG5cXG4oZm91bmQgaW4gXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIpXCIpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciB1aWQgPSAwO1xuXG4gIC8qKlxuICAgKiBBIGRlcCBpcyBhbiBvYnNlcnZhYmxlIHRoYXQgY2FuIGhhdmUgbXVsdGlwbGVcbiAgICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAgICovXG4gIHZhciBEZXAgPSBmdW5jdGlvbiBEZXAgKCkge1xuICAgIHRoaXMuaWQgPSB1aWQrKztcbiAgICB0aGlzLnN1YnMgPSBbXTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gICAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gICAgcmVtb3ZlKHRoaXMuc3Vicywgc3ViKTtcbiAgfTtcblxuICBEZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICBEZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gICAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgICB2YXIgc3VicyA9IHRoaXMuc3Vicy5zbGljZSgpO1xuICAgIGlmICghY29uZmlnLmFzeW5jKSB7XG4gICAgICAvLyBzdWJzIGFyZW4ndCBzb3J0ZWQgaW4gc2NoZWR1bGVyIGlmIG5vdCBydW5uaW5nIGFzeW5jXG4gICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgdGhlbSBub3cgdG8gbWFrZSBzdXJlIHRoZXkgZmlyZSBpbiBjb3JyZWN0XG4gICAgICAvLyBvcmRlclxuICAgICAgc3Vicy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmlkIC0gYi5pZDsgfSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3Vicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbiAgLy8gVGhpcyBpcyBnbG9iYWxseSB1bmlxdWUgYmVjYXVzZSBvbmx5IG9uZSB3YXRjaGVyXG4gIC8vIGNhbiBiZSBldmFsdWF0ZWQgYXQgYSB0aW1lLlxuICBEZXAudGFyZ2V0ID0gbnVsbDtcbiAgdmFyIHRhcmdldFN0YWNrID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFRhcmdldCAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0U3RhY2sucHVzaCh0YXJnZXQpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICAgIHRhcmdldFN0YWNrLnBvcCgpO1xuICAgIERlcC50YXJnZXQgPSB0YXJnZXRTdGFja1t0YXJnZXRTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICB0ZXh0LFxuICAgIGVsbSxcbiAgICBjb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgYXN5bmNGYWN0b3J5XG4gICkge1xuICAgIHRoaXMudGFnID0gdGFnO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgdGhpcy5lbG0gPSBlbG07XG4gICAgdGhpcy5ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5PcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm5TY29wZUlkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgICB0aGlzLmNvbXBvbmVudE9wdGlvbnMgPSBjb21wb25lbnRPcHRpb25zO1xuICAgIHRoaXMuY29tcG9uZW50SW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yYXcgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RhdGljID0gZmFsc2U7XG4gICAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICAgIHRoaXMuaXNDb21tZW50ID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nsb25lZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gICAgdGhpcy5hc3luY0ZhY3RvcnkgPSBhc3luY0ZhY3Rvcnk7XG4gICAgdGhpcy5hc3luY01ldGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbiAgfTtcblxuICB2YXIgcHJvdG90eXBlQWNjZXNzb3JzID0geyBjaGlsZDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIC8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcHJvdG90eXBlQWNjZXNzb3JzLmNoaWxkLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWTm9kZS5wcm90b3R5cGUsIHByb3RvdHlwZUFjY2Vzc29ycyApO1xuXG4gIHZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICBpZiAoIHRleHQgPT09IHZvaWQgMCApIHRleHQgPSAnJztcblxuICAgIHZhciBub2RlID0gbmV3IFZOb2RlKCk7XG4gICAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgICBub2RlLmlzQ29tbWVudCA9IHRydWU7XG4gICAgcmV0dXJuIG5vZGVcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0Vk5vZGUgKHZhbCkge1xuICAgIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG4gIH1cblxuICAvLyBvcHRpbWl6ZWQgc2hhbGxvdyBjbG9uZVxuICAvLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4gIC8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuICAvLyBvbiB0aGVpciBlbG0gcmVmZXJlbmNlLlxuICBmdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICAgIHZhciBjbG9uZWQgPSBuZXcgVk5vZGUoXG4gICAgICB2bm9kZS50YWcsXG4gICAgICB2bm9kZS5kYXRhLFxuICAgICAgLy8gIzc5NzVcbiAgICAgIC8vIGNsb25lIGNoaWxkcmVuIGFycmF5IHRvIGF2b2lkIG11dGF0aW5nIG9yaWdpbmFsIGluIGNhc2Ugb2YgY2xvbmluZ1xuICAgICAgLy8gYSBjaGlsZC5cbiAgICAgIHZub2RlLmNoaWxkcmVuICYmIHZub2RlLmNoaWxkcmVuLnNsaWNlKCksXG4gICAgICB2bm9kZS50ZXh0LFxuICAgICAgdm5vZGUuZWxtLFxuICAgICAgdm5vZGUuY29udGV4dCxcbiAgICAgIHZub2RlLmNvbXBvbmVudE9wdGlvbnMsXG4gICAgICB2bm9kZS5hc3luY0ZhY3RvcnlcbiAgICApO1xuICAgIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICAgIGNsb25lZC5pc1N0YXRpYyA9IHZub2RlLmlzU3RhdGljO1xuICAgIGNsb25lZC5rZXkgPSB2bm9kZS5rZXk7XG4gICAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgICBjbG9uZWQuZm5Db250ZXh0ID0gdm5vZGUuZm5Db250ZXh0O1xuICAgIGNsb25lZC5mbk9wdGlvbnMgPSB2bm9kZS5mbk9wdGlvbnM7XG4gICAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgICBjbG9uZWQuYXN5bmNNZXRhID0gdm5vZGUuYXN5bmNNZXRhO1xuICAgIGNsb25lZC5pc0Nsb25lZCA9IHRydWU7XG4gICAgcmV0dXJuIGNsb25lZFxuICB9XG5cbiAgLypcbiAgICogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoXG4gICAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICAgKi9cblxuICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcbiAgdmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7XG5cbiAgdmFyIG1ldGhvZHNUb1BhdGNoID0gW1xuICAgICdwdXNoJyxcbiAgICAncG9wJyxcbiAgICAnc2hpZnQnLFxuICAgICd1bnNoaWZ0JyxcbiAgICAnc3BsaWNlJyxcbiAgICAnc29ydCcsXG4gICAgJ3JldmVyc2UnXG4gIF07XG5cbiAgLyoqXG4gICAqIEludGVyY2VwdCBtdXRhdGluZyBtZXRob2RzIGFuZCBlbWl0IGV2ZW50c1xuICAgKi9cbiAgbWV0aG9kc1RvUGF0Y2guZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgLy8gY2FjaGUgb3JpZ2luYWwgbWV0aG9kXG4gICAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICAgIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgdmFyIG9iID0gdGhpcy5fX29iX187XG4gICAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICBjYXNlICdwdXNoJzpcbiAgICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgICAgLy8gbm90aWZ5IGNoYW5nZVxuICAgICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH0pO1xuICB9KTtcblxuICAvKiAgKi9cblxuICB2YXIgYXJyYXlLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJyYXlNZXRob2RzKTtcblxuICAvKipcbiAgICogSW4gc29tZSBjYXNlcyB3ZSBtYXkgd2FudCB0byBkaXNhYmxlIG9ic2VydmF0aW9uIGluc2lkZSBhIGNvbXBvbmVudCdzXG4gICAqIHVwZGF0ZSBjb21wdXRhdGlvbi5cbiAgICovXG4gIHZhciBzaG91bGRPYnNlcnZlID0gdHJ1ZTtcblxuICBmdW5jdGlvbiB0b2dnbGVPYnNlcnZpbmcgKHZhbHVlKSB7XG4gICAgc2hvdWxkT2JzZXJ2ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmVyIGNsYXNzIHRoYXQgaXMgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICAgKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0aGUgdGFyZ2V0XG4gICAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gICAqIGNvbGxlY3QgZGVwZW5kZW5jaWVzIGFuZCBkaXNwYXRjaCB1cGRhdGVzLlxuICAgKi9cbiAgdmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuZGVwID0gbmV3IERlcCgpO1xuICAgIHRoaXMudm1Db3VudCA9IDA7XG4gICAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpZiAoaGFzUHJvdG8pIHtcbiAgICAgICAgcHJvdG9BdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weUF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMub2JzZXJ2ZUFycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFdhbGsgdGhyb3VnaCBhbGwgcHJvcGVydGllcyBhbmQgY29udmVydCB0aGVtIGludG9cbiAgICogZ2V0dGVyL3NldHRlcnMuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZCB3aGVuXG4gICAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICAgKi9cbiAgT2JzZXJ2ZXIucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiB3YWxrIChvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogT2JzZXJ2ZSBhIGxpc3Qgb2YgQXJyYXkgaXRlbXMuXG4gICAqL1xuICBPYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaGVscGVyc1xuXG4gIC8qKlxuICAgKiBBdWdtZW50IGEgdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAgICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAgICovXG4gIGZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICAgIHRhcmdldC5fX3Byb3RvX18gPSBzcmM7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xuICB9XG5cbiAgLyoqXG4gICAqIEF1Z21lbnQgYSB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gICAqIGhpZGRlbiBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBjcmVhdGUgYW4gb2JzZXJ2ZXIgaW5zdGFuY2UgZm9yIGEgdmFsdWUsXG4gICAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gICAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICAgKi9cbiAgZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCB2YWx1ZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG9iO1xuICAgIGlmIChoYXNPd24odmFsdWUsICdfX29iX18nKSAmJiB2YWx1ZS5fX29iX18gaW5zdGFuY2VvZiBPYnNlcnZlcikge1xuICAgICAgb2IgPSB2YWx1ZS5fX29iX187XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHNob3VsZE9ic2VydmUgJiZcbiAgICAgICFpc1NlcnZlclJlbmRlcmluZygpICYmXG4gICAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgICBPYmplY3QuaXNFeHRlbnNpYmxlKHZhbHVlKSAmJlxuICAgICAgIXZhbHVlLl9pc1Z1ZVxuICAgICkge1xuICAgICAgb2IgPSBuZXcgT2JzZXJ2ZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgICAgb2Iudm1Db3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gb2JcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBkZWZpbmVSZWFjdGl2ZSQkMSAoXG4gICAgb2JqLFxuICAgIGtleSxcbiAgICB2YWwsXG4gICAgY3VzdG9tU2V0dGVyLFxuICAgIHNoYWxsb3dcbiAgKSB7XG4gICAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgIGlmIChwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5jb25maWd1cmFibGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBjYXRlciBmb3IgcHJlLWRlZmluZWQgZ2V0dGVyL3NldHRlcnNcbiAgICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICAgIHZhciBzZXR0ZXIgPSBwcm9wZXJ0eSAmJiBwcm9wZXJ0eS5zZXQ7XG4gICAgaWYgKCghZ2V0dGVyIHx8IHNldHRlcikgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFsID0gb2JqW2tleV07XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkT2IgPSAhc2hhbGxvdyAmJiBvYnNlcnZlKHZhbCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiByZWFjdGl2ZUdldHRlciAoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICAgIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgICAgICAgZGVwLmRlcGVuZCgpO1xuICAgICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgICBjaGlsZE9iLmRlcC5kZXBlbmQoKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogdmFsO1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cbiAgICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgICBpZiAoY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgICAgY3VzdG9tU2V0dGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gIzc5ODE6IGZvciBhY2Nlc3NvciBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVyXG4gICAgICAgIGlmIChnZXR0ZXIgJiYgIXNldHRlcikgeyByZXR1cm4gfVxuICAgICAgICBpZiAoc2V0dGVyKSB7XG4gICAgICAgICAgc2V0dGVyLmNhbGwob2JqLCBuZXdWYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IG5ld1ZhbDtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgICBkZXAubm90aWZ5KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gICAqIHRyaWdnZXJzIGNoYW5nZSBub3RpZmljYXRpb24gaWYgdGhlIHByb3BlcnR5IGRvZXNuJ3RcbiAgICogYWxyZWFkeSBleGlzdC5cbiAgICovXG4gIGZ1bmN0aW9uIHNldCAodGFyZ2V0LCBrZXksIHZhbCkge1xuICAgIGlmIChpc1VuZGVmKHRhcmdldCkgfHwgaXNQcmltaXRpdmUodGFyZ2V0KVxuICAgICkge1xuICAgICAgd2FybigoXCJDYW5ub3Qgc2V0IHJlYWN0aXZlIHByb3BlcnR5IG9uIHVuZGVmaW5lZCwgbnVsbCwgb3IgcHJpbWl0aXZlIHZhbHVlOiBcIiArICgodGFyZ2V0KSkpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgICB0YXJnZXQubGVuZ3RoID0gTWF0aC5tYXgodGFyZ2V0Lmxlbmd0aCwga2V5KTtcbiAgICAgIHRhcmdldC5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBpZiAoa2V5IGluIHRhcmdldCAmJiAhKGtleSBpbiBPYmplY3QucHJvdG90eXBlKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICAgICk7XG4gICAgICByZXR1cm4gdmFsXG4gICAgfVxuICAgIGlmICghb2IpIHtcbiAgICAgIHRhcmdldFtrZXldID0gdmFsO1xuICAgICAgcmV0dXJuIHZhbFxuICAgIH1cbiAgICBkZWZpbmVSZWFjdGl2ZSQkMShvYi52YWx1ZSwga2V5LCB2YWwpO1xuICAgIG9iLmRlcC5ub3RpZnkoKTtcbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIGZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgICBpZiAoaXNVbmRlZih0YXJnZXQpIHx8IGlzUHJpbWl0aXZlKHRhcmdldClcbiAgICApIHtcbiAgICAgIHdhcm4oKFwiQ2Fubm90IGRlbGV0ZSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiB1bmRlZmluZWQsIG51bGwsIG9yIHByaW1pdGl2ZSB2YWx1ZTogXCIgKyAoKHRhcmdldCkpKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldCkgJiYgaXNWYWxpZEFycmF5SW5kZXgoa2V5KSkge1xuICAgICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgICBpZiAodGFyZ2V0Ll9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCBkZWxldGluZyBwcm9wZXJ0aWVzIG9uIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCFoYXNPd24odGFyZ2V0LCBrZXkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgIGlmICghb2IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdCBkZXBlbmRlbmNpZXMgb24gYXJyYXkgZWxlbWVudHMgd2hlbiB0aGUgYXJyYXkgaXMgdG91Y2hlZCwgc2luY2VcbiAgICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gICAqL1xuICBmdW5jdGlvbiBkZXBlbmRBcnJheSAodmFsdWUpIHtcbiAgICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBlID0gdmFsdWVbaV07XG4gICAgICBlICYmIGUuX19vYl9fICYmIGUuX19vYl9fLmRlcC5kZXBlbmQoKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBPcHRpb24gb3ZlcndyaXRpbmcgc3RyYXRlZ2llcyBhcmUgZnVuY3Rpb25zIHRoYXQgaGFuZGxlXG4gICAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gICAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICAgKi9cbiAgdmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbiAgLyoqXG4gICAqIE9wdGlvbnMgd2l0aCByZXN0cmljdGlvbnNcbiAgICovXG4gIHtcbiAgICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICAgIGlmICghdm0pIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0aGF0IHJlY3Vyc2l2ZWx5IG1lcmdlcyB0d28gZGF0YSBvYmplY3RzIHRvZ2V0aGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICAgIGlmICghZnJvbSkgeyByZXR1cm4gdG8gfVxuICAgIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuXG4gICAgdmFyIGtleXMgPSBoYXNTeW1ib2xcbiAgICAgID8gUmVmbGVjdC5vd25LZXlzKGZyb20pXG4gICAgICA6IE9iamVjdC5rZXlzKGZyb20pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb2JqZWN0IGlzIGFscmVhZHkgb2JzZXJ2ZWQuLi5cbiAgICAgIGlmIChrZXkgPT09ICdfX29iX18nKSB7IGNvbnRpbnVlIH1cbiAgICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgICBpZiAoIWhhc093bih0bywga2V5KSkge1xuICAgICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0b1ZhbCAhPT0gZnJvbVZhbCAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KHRvVmFsKSAmJlxuICAgICAgICBpc1BsYWluT2JqZWN0KGZyb21WYWwpXG4gICAgICApIHtcbiAgICAgICAgbWVyZ2VEYXRhKHRvVmFsLCBmcm9tVmFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvXG4gIH1cblxuICAvKipcbiAgICogRGF0YVxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtXG4gICkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgICBpZiAoIWNoaWxkVmFsKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICAgIH1cbiAgICAgIGlmICghcGFyZW50VmFsKSB7XG4gICAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgICAgfVxuICAgICAgLy8gd2hlbiBwYXJlbnRWYWwgJiBjaGlsZFZhbCBhcmUgYm90aCBwcmVzZW50LFxuICAgICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAgIC8vIGNoZWNrIGlmIHBhcmVudFZhbCBpcyBhIGZ1bmN0aW9uIGhlcmUgYmVjYXVzZVxuICAgICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShcbiAgICAgICAgICB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbicgPyBjaGlsZFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogY2hpbGRWYWwsXG4gICAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMsIHRoaXMpIDogcGFyZW50VmFsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZEluc3RhbmNlRGF0YUZuICgpIHtcbiAgICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gY2hpbGRWYWwuY2FsbCh2bSwgdm0pXG4gICAgICAgICAgOiBjaGlsZFZhbDtcbiAgICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0sIHZtKVxuICAgICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgICBpZiAoaW5zdGFuY2VEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsLFxuICAgIHZtXG4gICkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgICAndGhhdCByZXR1cm5zIGEgcGVyLWluc3RhbmNlIHZhbHVlIGluIGNvbXBvbmVudCAnICtcbiAgICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwpXG4gICAgfVxuXG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbCwgdm0pXG4gIH07XG5cbiAgLyoqXG4gICAqIEhvb2tzIGFuZCBwcm9wcyBhcmUgbWVyZ2VkIGFzIGFycmF5cy5cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gICAgcGFyZW50VmFsLFxuICAgIGNoaWxkVmFsXG4gICkge1xuICAgIHZhciByZXMgPSBjaGlsZFZhbFxuICAgICAgPyBwYXJlbnRWYWxcbiAgICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRWYWwpXG4gICAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICAgIDogW2NoaWxkVmFsXVxuICAgICAgOiBwYXJlbnRWYWw7XG4gICAgcmV0dXJuIHJlc1xuICAgICAgPyBkZWR1cGVIb29rcyhyZXMpXG4gICAgICA6IHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZGVkdXBlSG9va3MgKGhvb2tzKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZXMuaW5kZXhPZihob29rc1tpXSkgPT09IC0xKSB7XG4gICAgICAgIHJlcy5wdXNoKGhvb2tzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgTElGRUNZQ0xFX0hPT0tTLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgICBzdHJhdHNbaG9va10gPSBtZXJnZUhvb2s7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBc3NldHNcbiAgICpcbiAgICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICAgKiBhIHRocmVlLXdheSBtZXJnZSBiZXR3ZWVuIGNvbnN0cnVjdG9yIG9wdGlvbnMsIGluc3RhbmNlXG4gICAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICAgKi9cbiAgZnVuY3Rpb24gbWVyZ2VBc3NldHMgKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpO1xuICAgIGlmIChjaGlsZFZhbCkge1xuICAgICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgICByZXR1cm4gZXh0ZW5kKHJlcywgY2hpbGRWYWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZXNcbiAgICB9XG4gIH1cblxuICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgc3RyYXRzW3R5cGUgKyAncyddID0gbWVyZ2VBc3NldHM7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBXYXRjaGVycy5cbiAgICpcbiAgICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICAgKiBhbm90aGVyLCBzbyB3ZSBtZXJnZSB0aGVtIGFzIGFycmF5cy5cbiAgICovXG4gIHN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgICBwYXJlbnRWYWwsXG4gICAgY2hpbGRWYWwsXG4gICAgdm0sXG4gICAga2V5XG4gICkge1xuICAgIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gICAgaWYgKHBhcmVudFZhbCA9PT0gbmF0aXZlV2F0Y2gpIHsgcGFyZW50VmFsID0gdW5kZWZpbmVkOyB9XG4gICAgaWYgKGNoaWxkVmFsID09PSBuYXRpdmVXYXRjaCkgeyBjaGlsZFZhbCA9IHVuZGVmaW5lZDsgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIE9iamVjdC5jcmVhdGUocGFyZW50VmFsIHx8IG51bGwpIH1cbiAgICB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgICB2YXIgcmV0ID0ge307XG4gICAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgICAgdmFyIHBhcmVudCA9IHJldFtrZXkkMV07XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZFZhbFtrZXkkMV07XG4gICAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50ID0gW3BhcmVudF07XG4gICAgICB9XG4gICAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICAgID8gcGFyZW50LmNvbmNhdChjaGlsZClcbiAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkKSA/IGNoaWxkIDogW2NoaWxkXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9O1xuXG4gIC8qKlxuICAgKiBPdGhlciBvYmplY3QgaGFzaGVzLlxuICAgKi9cbiAgc3RyYXRzLnByb3BzID1cbiAgc3RyYXRzLm1ldGhvZHMgPVxuICBzdHJhdHMuaW5qZWN0ID1cbiAgc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICAgIHBhcmVudFZhbCxcbiAgICBjaGlsZFZhbCxcbiAgICB2bSxcbiAgICBrZXlcbiAgKSB7XG4gICAgaWYgKGNoaWxkVmFsICYmIFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICAgIGlmIChjaGlsZFZhbCkgeyBleHRlbmQocmV0LCBjaGlsZFZhbCk7IH1cbiAgICByZXR1cm4gcmV0XG4gIH07XG4gIHN0cmF0cy5wcm92aWRlID0gbWVyZ2VEYXRhT3JGbjtcblxuICAvKipcbiAgICogRGVmYXVsdCBzdHJhdGVneS5cbiAgICovXG4gIHZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAgIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHBhcmVudFZhbFxuICAgICAgOiBjaGlsZFZhbFxuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrQ29tcG9uZW50cyAob3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShrZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQ29tcG9uZW50TmFtZSAobmFtZSkge1xuICAgIGlmICghbmV3IFJlZ0V4cCgoXCJeW2EtekEtWl1bXFxcXC1cXFxcLjAtOV9cIiArIHVuaWNvZGVMZXR0ZXJzICsgXCJdKiRcIikpLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIGNvbXBvbmVudCBuYW1lOiBcIicgKyBuYW1lICsgJ1wiLiBDb21wb25lbnQgbmFtZXMgJyArXG4gICAgICAgICdzaG91bGQgY29uZm9ybSB0byB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lIGluIGh0bWw1IHNwZWNpZmljYXRpb24uJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGlzQnVpbHRJblRhZyhuYW1lKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhuYW1lKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIG5hbWVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZSBhbGwgcHJvcHMgb3B0aW9uIHN5bnRheCBhcmUgbm9ybWFsaXplZCBpbnRvIHRoZVxuICAgKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICAgKi9cbiAgZnVuY3Rpb24gbm9ybWFsaXplUHJvcHMgKG9wdGlvbnMsIHZtKSB7XG4gICAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICBpZiAoIXByb3BzKSB7IHJldHVybiB9XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIHZhciBpLCB2YWwsIG5hbWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMpKSB7XG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YWwgPSBwcm9wc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgICAgcmVzW25hbWVdID0geyB0eXBlOiBudWxsIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybigncHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHByb3BzKSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZShrZXkpO1xuICAgICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgICA/IHZhbFxuICAgICAgICAgIDogeyB0eXBlOiB2YWwgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgd2FybihcbiAgICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUocHJvcHMpKSArIFwiLlwiLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gICAgb3B0aW9ucy5wcm9wcyA9IHJlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYWxsIGluamVjdGlvbnMgaW50byBPYmplY3QtYmFzZWQgZm9ybWF0XG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVJbmplY3QgKG9wdGlvbnMsIHZtKSB7XG4gICAgdmFyIGluamVjdCA9IG9wdGlvbnMuaW5qZWN0O1xuICAgIGlmICghaW5qZWN0KSB7IHJldHVybiB9XG4gICAgdmFyIG5vcm1hbGl6ZWQgPSBvcHRpb25zLmluamVjdCA9IHt9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGluamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRbaW5qZWN0W2ldXSA9IHsgZnJvbTogaW5qZWN0W2ldIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBpbmplY3QpIHtcbiAgICAgICAgdmFyIHZhbCA9IGluamVjdFtrZXldO1xuICAgICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgICA/IGV4dGVuZCh7IGZyb206IGtleSB9LCB2YWwpXG4gICAgICAgICAgOiB7IGZyb206IHZhbCB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiaW5qZWN0XFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzIChvcHRpb25zKSB7XG4gICAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gICAgaWYgKGRpcnMpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkaXJzKSB7XG4gICAgICAgIHZhciBkZWYkJDEgPSBkaXJzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgZGVmJCQxID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGlyc1trZXldID0geyBiaW5kOiBkZWYkJDEsIHVwZGF0ZTogZGVmJCQxIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRPYmplY3RUeXBlIChuYW1lLCB2YWx1ZSwgdm0pIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkludmFsaWQgdmFsdWUgZm9yIG9wdGlvbiBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBleHBlY3RlZCBhbiBPYmplY3QsIFwiICtcbiAgICAgICAgXCJidXQgZ290IFwiICsgKHRvUmF3VHlwZSh2YWx1ZSkpICsgXCIuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gICAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICAgIHBhcmVudCxcbiAgICBjaGlsZCxcbiAgICB2bVxuICApIHtcbiAgICB7XG4gICAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgICB9XG5cbiAgICBub3JtYWxpemVQcm9wcyhjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICAgIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuXG4gICAgLy8gQXBwbHkgZXh0ZW5kcyBhbmQgbWl4aW5zIG9uIHRoZSBjaGlsZCBvcHRpb25zLFxuICAgIC8vIGJ1dCBvbmx5IGlmIGl0IGlzIGEgcmF3IG9wdGlvbnMgb2JqZWN0IHRoYXQgaXNuJ3RcbiAgICAvLyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgbWVyZ2VPcHRpb25zIGNhbGwuXG4gICAgLy8gT25seSBtZXJnZWQgb3B0aW9ucyBoYXMgdGhlIF9iYXNlIHByb3BlcnR5LlxuICAgIGlmICghY2hpbGQuX2Jhc2UpIHtcbiAgICAgIGlmIChjaGlsZC5leHRlbmRzKSB7XG4gICAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGNoaWxkLmV4dGVuZHMsIHZtKTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5taXhpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgY2hpbGQubWl4aW5zW2ldLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBrZXk7XG4gICAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICAgIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgICBpZiAoIWhhc093bihwYXJlbnQsIGtleSkpIHtcbiAgICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICAgIG9wdGlvbnNba2V5XSA9IHN0cmF0KHBhcmVudFtrZXldLCBjaGlsZFtrZXldLCB2bSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlIGFuIGFzc2V0LlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYmVjYXVzZSBjaGlsZCBpbnN0YW5jZXMgbmVlZCBhY2Nlc3NcbiAgICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzc2V0IChcbiAgICBvcHRpb25zLFxuICAgIHR5cGUsXG4gICAgaWQsXG4gICAgd2Fybk1pc3NpbmdcbiAgKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICAgIGlmIChoYXNPd24oYXNzZXRzLCBpZCkpIHsgcmV0dXJuIGFzc2V0c1tpZF0gfVxuICAgIHZhciBjYW1lbGl6ZWRJZCA9IGNhbWVsaXplKGlkKTtcbiAgICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgICB2YXIgUGFzY2FsQ2FzZUlkID0gY2FwaXRhbGl6ZShjYW1lbGl6ZWRJZCk7XG4gICAgaWYgKGhhc093bihhc3NldHMsIFBhc2NhbENhc2VJZCkpIHsgcmV0dXJuIGFzc2V0c1tQYXNjYWxDYXNlSWRdIH1cbiAgICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgICB2YXIgcmVzID0gYXNzZXRzW2lkXSB8fCBhc3NldHNbY2FtZWxpemVkSWRdIHx8IGFzc2V0c1tQYXNjYWxDYXNlSWRdO1xuICAgIGlmICh3YXJuTWlzc2luZyAmJiAhcmVzKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAgICBrZXksXG4gICAgcHJvcE9wdGlvbnMsXG4gICAgcHJvcHNEYXRhLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgICB2YXIgYWJzZW50ID0gIWhhc093bihwcm9wc0RhdGEsIGtleSk7XG4gICAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gICAgLy8gYm9vbGVhbiBjYXN0aW5nXG4gICAgdmFyIGJvb2xlYW5JbmRleCA9IGdldFR5cGVJbmRleChCb29sZWFuLCBwcm9wLnR5cGUpO1xuICAgIGlmIChib29sZWFuSW5kZXggPiAtMSkge1xuICAgICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkge1xuICAgICAgICAvLyBvbmx5IGNhc3QgZW1wdHkgc3RyaW5nIC8gc2FtZSBuYW1lIHRvIGJvb2xlYW4gaWZcbiAgICAgICAgLy8gYm9vbGVhbiBoYXMgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgIHZhciBzdHJpbmdJbmRleCA9IGdldFR5cGVJbmRleChTdHJpbmcsIHByb3AudHlwZSk7XG4gICAgICAgIGlmIChzdHJpbmdJbmRleCA8IDAgfHwgYm9vbGVhbkluZGV4IDwgc3RyaW5nSW5kZXgpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9IGdldFByb3BEZWZhdWx0VmFsdWUodm0sIHByb3AsIGtleSk7XG4gICAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgICAvLyBtYWtlIHN1cmUgdG8gb2JzZXJ2ZSBpdC5cbiAgICAgIHZhciBwcmV2U2hvdWxkT2JzZXJ2ZSA9IHNob3VsZE9ic2VydmU7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgICBvYnNlcnZlKHZhbHVlKTtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhwcmV2U2hvdWxkT2JzZXJ2ZSk7XG4gICAgfVxuICAgIHtcbiAgICAgIGFzc2VydFByb3AocHJvcCwga2V5LCB2YWx1ZSwgdm0sIGFic2VudCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRQcm9wRGVmYXVsdFZhbHVlICh2bSwgcHJvcCwga2V5KSB7XG4gICAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICAgIGlmICghaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgdmFyIGRlZiA9IHByb3AuZGVmYXVsdDtcbiAgICAvLyB3YXJuIGFnYWluc3Qgbm9uLWZhY3RvcnkgZGVmYXVsdHMgZm9yIE9iamVjdCAmIEFycmF5XG4gICAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdJbnZhbGlkIGRlZmF1bHQgdmFsdWUgZm9yIHByb3AgXCInICsga2V5ICsgJ1wiOiAnICtcbiAgICAgICAgJ1Byb3BzIHdpdGggdHlwZSBPYmplY3QvQXJyYXkgbXVzdCB1c2UgYSBmYWN0b3J5IGZ1bmN0aW9uICcgK1xuICAgICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvLyB0aGUgcmF3IHByb3AgdmFsdWUgd2FzIGFsc28gdW5kZWZpbmVkIGZyb20gcHJldmlvdXMgcmVuZGVyLFxuICAgIC8vIHJldHVybiBwcmV2aW91cyBkZWZhdWx0IHZhbHVlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdhdGNoZXIgdHJpZ2dlclxuICAgIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YVtrZXldID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHZtLl9wcm9wc1trZXldICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHJldHVybiB2bS5fcHJvcHNba2V5XVxuICAgIH1cbiAgICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAgIC8vIGEgdmFsdWUgaXMgRnVuY3Rpb24gaWYgaXRzIHByb3RvdHlwZSBpcyBmdW5jdGlvbiBldmVuIGFjcm9zcyBkaWZmZXJlbnQgZXhlY3V0aW9uIGNvbnRleHRcbiAgICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBnZXRUeXBlKHByb3AudHlwZSkgIT09ICdGdW5jdGlvbidcbiAgICAgID8gZGVmLmNhbGwodm0pXG4gICAgICA6IGRlZlxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICAgIHByb3AsXG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICB2bSxcbiAgICBhYnNlbnRcbiAgKSB7XG4gICAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgJiYgIXByb3AucmVxdWlyZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgdHlwZSA9IHByb3AudHlwZTtcbiAgICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlID0gW3R5cGVdO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChhc3NlcnRlZFR5cGUuZXhwZWN0ZWRUeXBlIHx8ICcnKTtcbiAgICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgd2FybihcbiAgICAgICAgZ2V0SW52YWxpZFR5cGVNZXNzYWdlKG5hbWUsIHZhbHVlLCBleHBlY3RlZFR5cGVzKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHZhbGlkYXRvciA9IHByb3AudmFsaWRhdG9yO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdJbnZhbGlkIHByb3A6IGN1c3RvbSB2YWxpZGF0b3IgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFwiJyArIG5hbWUgKyAnXCIuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzaW1wbGVDaGVja1JFID0gL14oU3RyaW5nfE51bWJlcnxCb29sZWFufEZ1bmN0aW9ufFN5bWJvbCkkLztcblxuICBmdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICAgIHZhciB2YWxpZDtcbiAgICB2YXIgZXhwZWN0ZWRUeXBlID0gZ2V0VHlwZSh0eXBlKTtcbiAgICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICAgIHZhciB0ID0gdHlwZW9mIHZhbHVlO1xuICAgICAgdmFsaWQgPSB0ID09PSBleHBlY3RlZFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgICBpZiAoIXZhbGlkICYmIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhbGlkID0gdmFsdWUgaW5zdGFuY2VvZiB0eXBlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSAnT2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSBpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgICAgdmFsaWQgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogdmFsaWQsXG4gICAgICBleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgZnVuY3Rpb24gc3RyaW5nIG5hbWUgdG8gY2hlY2sgYnVpbHQtaW4gdHlwZXMsXG4gICAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICAgKiBhY3Jvc3MgZGlmZmVyZW50IHZtcyAvIGlmcmFtZXMuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICAgIHZhciBtYXRjaCA9IGZuICYmIGZuLnRvU3RyaW5nKCkubWF0Y2goL15cXHMqZnVuY3Rpb24gKFxcdyspLyk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0gOiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTYW1lVHlwZSAoYSwgYikge1xuICAgIHJldHVybiBnZXRUeXBlKGEpID09PSBnZXRUeXBlKGIpXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUeXBlSW5kZXggKHR5cGUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRUeXBlcykpIHtcbiAgICAgIHJldHVybiBpc1NhbWVUeXBlKGV4cGVjdGVkVHlwZXMsIHR5cGUpID8gMCA6IC0xXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBleHBlY3RlZFR5cGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNTYW1lVHlwZShleHBlY3RlZFR5cGVzW2ldLCB0eXBlKSkge1xuICAgICAgICByZXR1cm4gaVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEludmFsaWRUeXBlTWVzc2FnZSAobmFtZSwgdmFsdWUsIGV4cGVjdGVkVHlwZXMpIHtcbiAgICB2YXIgbWVzc2FnZSA9IFwiSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiICtcbiAgICAgIFwiIEV4cGVjdGVkIFwiICsgKGV4cGVjdGVkVHlwZXMubWFwKGNhcGl0YWxpemUpLmpvaW4oJywgJykpO1xuICAgIHZhciBleHBlY3RlZFR5cGUgPSBleHBlY3RlZFR5cGVzWzBdO1xuICAgIHZhciByZWNlaXZlZFR5cGUgPSB0b1Jhd1R5cGUodmFsdWUpO1xuICAgIHZhciBleHBlY3RlZFZhbHVlID0gc3R5bGVWYWx1ZSh2YWx1ZSwgZXhwZWN0ZWRUeXBlKTtcbiAgICB2YXIgcmVjZWl2ZWRWYWx1ZSA9IHN0eWxlVmFsdWUodmFsdWUsIHJlY2VpdmVkVHlwZSk7XG4gICAgLy8gY2hlY2sgaWYgd2UgbmVlZCB0byBzcGVjaWZ5IGV4cGVjdGVkIHZhbHVlXG4gICAgaWYgKGV4cGVjdGVkVHlwZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgIGlzRXhwbGljYWJsZShleHBlY3RlZFR5cGUpICYmXG4gICAgICAgICFpc0Jvb2xlYW4oZXhwZWN0ZWRUeXBlLCByZWNlaXZlZFR5cGUpKSB7XG4gICAgICBtZXNzYWdlICs9IFwiIHdpdGggdmFsdWUgXCIgKyBleHBlY3RlZFZhbHVlO1xuICAgIH1cbiAgICBtZXNzYWdlICs9IFwiLCBnb3QgXCIgKyByZWNlaXZlZFR5cGUgKyBcIiBcIjtcbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIHNwZWNpZnkgcmVjZWl2ZWQgdmFsdWVcbiAgICBpZiAoaXNFeHBsaWNhYmxlKHJlY2VpdmVkVHlwZSkpIHtcbiAgICAgIG1lc3NhZ2UgKz0gXCJ3aXRoIHZhbHVlIFwiICsgcmVjZWl2ZWRWYWx1ZSArIFwiLlwiO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZVxuICB9XG5cbiAgZnVuY3Rpb24gc3R5bGVWYWx1ZSAodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ1N0cmluZycpIHtcbiAgICAgIHJldHVybiAoXCJcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICAgIHJldHVybiAoXCJcIiArIChOdW1iZXIodmFsdWUpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlwiICsgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNFeHBsaWNhYmxlICh2YWx1ZSkge1xuICAgIHZhciBleHBsaWNpdFR5cGVzID0gWydzdHJpbmcnLCAnbnVtYmVyJywgJ2Jvb2xlYW4nXTtcbiAgICByZXR1cm4gZXhwbGljaXRUeXBlcy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSBlbGVtOyB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNCb29sZWFuICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICByZXR1cm4gYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtKSB7IHJldHVybiBlbGVtLnRvTG93ZXJDYXNlKCkgPT09ICdib29sZWFuJzsgfSlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gICAgLy8gRGVhY3RpdmF0ZSBkZXBzIHRyYWNraW5nIHdoaWxlIHByb2Nlc3NpbmcgZXJyb3IgaGFuZGxlciB0byBhdm9pZCBwb3NzaWJsZSBpbmZpbml0ZSByZW5kZXJpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVleC9pc3N1ZXMvMTUwNVxuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgaWYgKHZtKSB7XG4gICAgICAgIHZhciBjdXIgPSB2bTtcbiAgICAgICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgaG9va3MgPSBjdXIuJG9wdGlvbnMuZXJyb3JDYXB0dXJlZDtcbiAgICAgICAgICBpZiAoaG9va3MpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZSA9IGhvb2tzW2ldLmNhbGwoY3VyLCBlcnIsIHZtLCBpbmZvKSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGdsb2JhbEhhbmRsZUVycm9yKGUsIGN1ciwgJ2Vycm9yQ2FwdHVyZWQgaG9vaycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBnbG9iYWxIYW5kbGVFcnJvcihlcnIsIHZtLCBpbmZvKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcgKFxuICAgIGhhbmRsZXIsXG4gICAgY29udGV4dCxcbiAgICBhcmdzLFxuICAgIHZtLFxuICAgIGluZm9cbiAgKSB7XG4gICAgdmFyIHJlcztcbiAgICB0cnkge1xuICAgICAgcmVzID0gYXJncyA/IGhhbmRsZXIuYXBwbHkoY29udGV4dCwgYXJncykgOiBoYW5kbGVyLmNhbGwoY29udGV4dCk7XG4gICAgICBpZiAocmVzICYmICFyZXMuX2lzVnVlICYmIGlzUHJvbWlzZShyZXMpKSB7XG4gICAgICAgIC8vIGlzc3VlICM5NTExXG4gICAgICAgIC8vIHJlYXNzaWduIHRvIHJlcyB0byBhdm9pZCBjYXRjaCB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIHdoZW4gbmVzdGVkIGNhbGxzXG4gICAgICAgIHJlcyA9IHJlcy5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gaGFuZGxlRXJyb3IoZSwgdm0sIGluZm8gKyBcIiAoUHJvbWlzZS9hc3luYylcIik7IH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gZ2xvYmFsSGFuZGxlRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlcnIsIHZtLCBpbmZvKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBpbnRlbnRpb25hbGx5IHRocm93cyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gdGhlIGhhbmRsZXIsXG4gICAgICAgIC8vIGRvIG5vdCBsb2cgaXQgdHdpY2VcbiAgICAgICAgaWYgKGUgIT09IGVycikge1xuICAgICAgICAgIGxvZ0Vycm9yKGUsIG51bGwsICdjb25maWcuZXJyb3JIYW5kbGVyJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbG9nRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICAgIHtcbiAgICAgIHdhcm4oKFwiRXJyb3IgaW4gXCIgKyBpbmZvICsgXCI6IFxcXCJcIiArIChlcnIudG9TdHJpbmcoKSkgKyBcIlxcXCJcIiksIHZtKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoKGluQnJvd3NlciB8fCBpbldlZXgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgaXNVc2luZ01pY3JvVGFzayA9IGZhbHNlO1xuXG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBmbHVzaENhbGxiYWNrcyAoKSB7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIHZhciBjb3BpZXMgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgY2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcGllc1tpXSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlcmUgd2UgaGF2ZSBhc3luYyBkZWZlcnJpbmcgd3JhcHBlcnMgdXNpbmcgbWljcm90YXNrcy5cbiAgLy8gSW4gMi41IHdlIHVzZWQgKG1hY3JvKSB0YXNrcyAoaW4gY29tYmluYXRpb24gd2l0aCBtaWNyb3Rhc2tzKS5cbiAgLy8gSG93ZXZlciwgaXQgaGFzIHN1YnRsZSBwcm9ibGVtcyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnRcbiAgLy8gKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4gIC8vIEFsc28sIHVzaW5nIChtYWNybykgdGFza3MgaW4gZXZlbnQgaGFuZGxlciB3b3VsZCBjYXVzZSBzb21lIHdlaXJkIGJlaGF2aW9yc1xuICAvLyB0aGF0IGNhbm5vdCBiZSBjaXJjdW12ZW50ZWQgKGUuZy4gIzcxMDksICM3MTUzLCAjNzU0NiwgIzc4MzQsICM4MTA5KS5cbiAgLy8gU28gd2Ugbm93IHVzZSBtaWNyb3Rhc2tzIGV2ZXJ5d2hlcmUsIGFnYWluLlxuICAvLyBBIG1ham9yIGRyYXdiYWNrIG9mIHRoaXMgdHJhZGVvZmYgaXMgdGhhdCB0aGVyZSBhcmUgc29tZSBzY2VuYXJpb3NcbiAgLy8gd2hlcmUgbWljcm90YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmUgaW4gYmV0d2VlbiBzdXBwb3NlZGx5XG4gIC8vIHNlcXVlbnRpYWwgZXZlbnRzIChlLmcuICM0NTIxLCAjNjY5MCwgd2hpY2ggaGF2ZSB3b3JrYXJvdW5kcylcbiAgLy8gb3IgZXZlbiBiZXR3ZWVuIGJ1YmJsaW5nIG9mIHRoZSBzYW1lIGV2ZW50ICgjNjU2NikuXG4gIHZhciB0aW1lckZ1bmM7XG5cbiAgLy8gVGhlIG5leHRUaWNrIGJlaGF2aW9yIGxldmVyYWdlcyB0aGUgbWljcm90YXNrIHF1ZXVlLCB3aGljaCBjYW4gYmUgYWNjZXNzZWRcbiAgLy8gdmlhIGVpdGhlciBuYXRpdmUgUHJvbWlzZS50aGVuIG9yIE11dGF0aW9uT2JzZXJ2ZXIuXG4gIC8vIE11dGF0aW9uT2JzZXJ2ZXIgaGFzIHdpZGVyIHN1cHBvcnQsIGhvd2V2ZXIgaXQgaXMgc2VyaW91c2x5IGJ1Z2dlZCBpblxuICAvLyBVSVdlYlZpZXcgaW4gaU9TID49IDkuMy4zIHdoZW4gdHJpZ2dlcmVkIGluIHRvdWNoIGV2ZW50IGhhbmRsZXJzLiBJdFxuICAvLyBjb21wbGV0ZWx5IHN0b3BzIHdvcmtpbmcgYWZ0ZXIgdHJpZ2dlcmluZyBhIGZldyB0aW1lcy4uLiBzbywgaWYgbmF0aXZlXG4gIC8vIFByb21pc2UgaXMgYXZhaWxhYmxlLCB3ZSB3aWxsIHVzZSBpdDpcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQsICRmbG93LWRpc2FibGUtbGluZSAqL1xuICBpZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIGlzTmF0aXZlKFByb21pc2UpKSB7XG4gICAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBwLnRoZW4oZmx1c2hDYWxsYmFja3MpO1xuICAgICAgLy8gSW4gcHJvYmxlbWF0aWMgVUlXZWJWaWV3cywgUHJvbWlzZS50aGVuIGRvZXNuJ3QgY29tcGxldGVseSBicmVhaywgYnV0XG4gICAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAgIC8vIG1pY3JvdGFzayBxdWV1ZSBidXQgdGhlIHF1ZXVlIGlzbid0IGJlaW5nIGZsdXNoZWQsIHVudGlsIHRoZSBicm93c2VyXG4gICAgICAvLyBuZWVkcyB0byBkbyBzb21lIG90aGVyIHdvcmssIGUuZy4gaGFuZGxlIGEgdGltZXIuIFRoZXJlZm9yZSB3ZSBjYW5cbiAgICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgICAgaWYgKGlzSU9TKSB7IHNldFRpbWVvdXQobm9vcCk7IH1cbiAgICB9O1xuICAgIGlzVXNpbmdNaWNyb1Rhc2sgPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFpc0lFICYmIHR5cGVvZiBNdXRhdGlvbk9ic2VydmVyICE9PSAndW5kZWZpbmVkJyAmJiAoXG4gICAgaXNOYXRpdmUoTXV0YXRpb25PYnNlcnZlcikgfHxcbiAgICAvLyBQaGFudG9tSlMgYW5kIGlPUyA3LnhcbiAgICBNdXRhdGlvbk9ic2VydmVyLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE11dGF0aW9uT2JzZXJ2ZXJDb25zdHJ1Y3Rvcl0nXG4gICkpIHtcbiAgICAvLyBVc2UgTXV0YXRpb25PYnNlcnZlciB3aGVyZSBuYXRpdmUgUHJvbWlzZSBpcyBub3QgYXZhaWxhYmxlLFxuICAgIC8vIGUuZy4gUGhhbnRvbUpTLCBpT1M3LCBBbmRyb2lkIDQuNFxuICAgIC8vICgjNjQ2NiBNdXRhdGlvbk9ic2VydmVyIGlzIHVucmVsaWFibGUgaW4gSUUxMSlcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2hDYWxsYmFja3MpO1xuICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFN0cmluZyhjb3VudGVyKSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZXh0Tm9kZSwge1xuICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZVxuICAgIH0pO1xuICAgIHRpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvdW50ZXIgPSAoY291bnRlciArIDEpICUgMjtcbiAgICAgIHRleHROb2RlLmRhdGEgPSBTdHJpbmcoY291bnRlcik7XG4gICAgfTtcbiAgICBpc1VzaW5nTWljcm9UYXNrID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc2V0SW1tZWRpYXRlLlxuICAgIC8vIFRlY2hpbmljYWxseSBpdCBsZXZlcmFnZXMgdGhlIChtYWNybykgdGFzayBxdWV1ZSxcbiAgICAvLyBidXQgaXQgaXMgc3RpbGwgYSBiZXR0ZXIgY2hvaWNlIHRoYW4gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZmx1c2hDYWxsYmFja3MpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2sgdG8gc2V0VGltZW91dC5cbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbmV4dFRpY2sgKGNiLCBjdHgpIHtcbiAgICB2YXIgX3Jlc29sdmU7XG4gICAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgY3R4LCAnbmV4dFRpY2snKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChfcmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZShjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBtYXJrO1xuICB2YXIgbWVhc3VyZTtcblxuICB7XG4gICAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHBlcmYgJiZcbiAgICAgIHBlcmYubWFyayAmJlxuICAgICAgcGVyZi5tZWFzdXJlICYmXG4gICAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICAgIHBlcmYuY2xlYXJNZWFzdXJlc1xuICAgICkge1xuICAgICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgICAgbWVhc3VyZSA9IGZ1bmN0aW9uIChuYW1lLCBzdGFydFRhZywgZW5kVGFnKSB7XG4gICAgICAgIHBlcmYubWVhc3VyZShuYW1lLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgICAgcGVyZi5jbGVhck1hcmtzKGVuZFRhZyk7XG4gICAgICAgIC8vIHBlcmYuY2xlYXJNZWFzdXJlcyhuYW1lKVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxuICB2YXIgaW5pdFByb3h5O1xuXG4gIHtcbiAgICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgICAncGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsJyArXG4gICAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgICApO1xuXG4gICAgdmFyIHdhcm5Ob25QcmVzZW50ID0gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAgICdyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0aGF0IHRoaXMgcHJvcGVydHkgaXMgcmVhY3RpdmUsICcgK1xuICAgICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgICAnaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eS4gJyArXG4gICAgICAgICdTZWU6IGh0dHBzOi8vdnVlanMub3JnL3YyL2d1aWRlL3JlYWN0aXZpdHkuaHRtbCNEZWNsYXJpbmctUmVhY3RpdmUtUHJvcGVydGllcy4nLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfTtcblxuICAgIHZhciB3YXJuUmVzZXJ2ZWRQcmVmaXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiUHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIG11c3QgYmUgYWNjZXNzZWQgd2l0aCBcXFwiJGRhdGEuXCIgKyBrZXkgKyBcIlxcXCIgYmVjYXVzZSBcIiArXG4gICAgICAgICdwcm9wZXJ0aWVzIHN0YXJ0aW5nIHdpdGggXCIkXCIgb3IgXCJfXCIgYXJlIG5vdCBwcm94aWVkIGluIHRoZSBWdWUgaW5zdGFuY2UgdG8gJyArXG4gICAgICAgICdwcmV2ZW50IGNvbmZsaWN0cyB3aXRoIFZ1ZSBpbnRlcm5hbHMnICtcbiAgICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvYXBpLyNkYXRhJyxcbiAgICAgICAgdGFyZ2V0XG4gICAgICApO1xuICAgIH07XG5cbiAgICB2YXIgaGFzUHJveHkgPVxuICAgICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm94eSk7XG5cbiAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgIHZhciBpc0J1aWx0SW5Nb2RpZmllciA9IG1ha2VNYXAoJ3N0b3AscHJldmVudCxzZWxmLGN0cmwsc2hpZnQsYWx0LG1ldGEsZXhhY3QnKTtcbiAgICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmIChpc0J1aWx0SW5Nb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzICh0YXJnZXQsIGtleSkge1xuICAgICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHxcbiAgICAgICAgICAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5LmNoYXJBdCgwKSA9PT0gJ18nICYmICEoa2V5IGluIHRhcmdldC4kZGF0YSkpO1xuICAgICAgICBpZiAoIWhhcyAmJiAhaXNBbGxvd2VkKSB7XG4gICAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQuJGRhdGEpIHsgd2FyblJlc2VydmVkUHJlZml4KHRhcmdldCwga2V5KTsgfVxuICAgICAgICAgIGVsc2UgeyB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmICEoa2V5IGluIHRhcmdldCkpIHtcbiAgICAgICAgICBpZiAoa2V5IGluIHRhcmdldC4kZGF0YSkgeyB3YXJuUmVzZXJ2ZWRQcmVmaXgodGFyZ2V0LCBrZXkpOyB9XG4gICAgICAgICAgZWxzZSB7IHdhcm5Ob25QcmVzZW50KHRhcmdldCwga2V5KTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5XVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpbml0UHJveHkgPSBmdW5jdGlvbiBpbml0UHJveHkgKHZtKSB7XG4gICAgICBpZiAoaGFzUHJveHkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgICAgIHZhciBoYW5kbGVycyA9IG9wdGlvbnMucmVuZGVyICYmIG9wdGlvbnMucmVuZGVyLl93aXRoU3RyaXBwZWRcbiAgICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgICA6IGhhc0hhbmRsZXI7XG4gICAgICAgIHZtLl9yZW5kZXJQcm94eSA9IG5ldyBQcm94eSh2bSwgaGFuZGxlcnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFuIG9iamVjdCB0byBldm9rZSBhbGwgY29udmVydGVkXG4gICAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gICAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gICAqL1xuICBmdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gICAgX3RyYXZlcnNlKHZhbCwgc2Vlbk9iamVjdHMpO1xuICAgIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfdHJhdmVyc2UgKHZhbCwgc2Vlbikge1xuICAgIHZhciBpLCBrZXlzO1xuICAgIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgaWYgKCghaXNBICYmICFpc09iamVjdCh2YWwpKSB8fCBPYmplY3QuaXNGcm96ZW4odmFsKSB8fCB2YWwgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh2YWwuX19vYl9fKSB7XG4gICAgICB2YXIgZGVwSWQgPSB2YWwuX19vYl9fLmRlcC5pZDtcbiAgICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBzZWVuLmFkZChkZXBJZCk7XG4gICAgfVxuICAgIGlmIChpc0EpIHtcbiAgICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtrZXlzW2ldXSwgc2Vlbik7IH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgcGFzc2l2ZSA9IG5hbWUuY2hhckF0KDApID09PSAnJic7XG4gICAgbmFtZSA9IHBhc3NpdmUgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgICBuYW1lID0gb25jZSQkMSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHZhciBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgb25jZTogb25jZSQkMSxcbiAgICAgIGNhcHR1cmU6IGNhcHR1cmUsXG4gICAgICBwYXNzaXZlOiBwYXNzaXZlXG4gICAgfVxuICB9KTtcblxuICBmdW5jdGlvbiBjcmVhdGVGbkludm9rZXIgKGZucywgdm0pIHtcbiAgICBmdW5jdGlvbiBpbnZva2VyICgpIHtcbiAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgICAgdmFyIGZucyA9IGludm9rZXIuZm5zO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zKSkge1xuICAgICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xvbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoY2xvbmVkW2ldLCBudWxsLCBhcmd1bWVudHMkMSwgdm0sIFwidi1vbiBoYW5kbGVyXCIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgICByZXR1cm4gaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoZm5zLCBudWxsLCBhcmd1bWVudHMsIHZtLCBcInYtb24gaGFuZGxlclwiKVxuICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VyLmZucyA9IGZucztcbiAgICByZXR1cm4gaW52b2tlclxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlTGlzdGVuZXJzIChcbiAgICBvbixcbiAgICBvbGRPbixcbiAgICBhZGQsXG4gICAgcmVtb3ZlJCQxLFxuICAgIGNyZWF0ZU9uY2VIYW5kbGVyLFxuICAgIHZtXG4gICkge1xuICAgIHZhciBuYW1lLCBkZWYkJDEsIGN1ciwgb2xkLCBldmVudDtcbiAgICBmb3IgKG5hbWUgaW4gb24pIHtcbiAgICAgIGRlZiQkMSA9IGN1ciA9IG9uW25hbWVdO1xuICAgICAgb2xkID0gb2xkT25bbmFtZV07XG4gICAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KG5hbWUpO1xuICAgICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyAoZXZlbnQubmFtZSkgKyBcIlxcXCI6IGdvdCBcIiArIFN0cmluZyhjdXIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGlzVW5kZWYob2xkKSkge1xuICAgICAgICBpZiAoaXNVbmRlZihjdXIuZm5zKSkge1xuICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1ciwgdm0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1RydWUoZXZlbnQub25jZSkpIHtcbiAgICAgICAgICBjdXIgPSBvbltuYW1lXSA9IGNyZWF0ZU9uY2VIYW5kbGVyKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkKGV2ZW50Lm5hbWUsIGN1ciwgZXZlbnQuY2FwdHVyZSwgZXZlbnQucGFzc2l2ZSwgZXZlbnQucGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSBvbGQpIHtcbiAgICAgICAgb2xkLmZucyA9IGN1cjtcbiAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgICAgaWYgKGlzVW5kZWYob25bbmFtZV0pKSB7XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gbWVyZ2VWTm9kZUhvb2sgKGRlZiwgaG9va0tleSwgaG9vaykge1xuICAgIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgZGVmID0gZGVmLmRhdGEuaG9vayB8fCAoZGVmLmRhdGEuaG9vayA9IHt9KTtcbiAgICB9XG4gICAgdmFyIGludm9rZXI7XG4gICAgdmFyIG9sZEhvb2sgPSBkZWZbaG9va0tleV07XG5cbiAgICBmdW5jdGlvbiB3cmFwcGVkSG9vayAoKSB7XG4gICAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAvLyBpbXBvcnRhbnQ6IHJlbW92ZSBtZXJnZWQgaG9vayB0byBlbnN1cmUgaXQncyBjYWxsZWQgb25seSBvbmNlXG4gICAgICAvLyBhbmQgcHJldmVudCBtZW1vcnkgbGVha1xuICAgICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gICAgfVxuXG4gICAgaWYgKGlzVW5kZWYob2xkSG9vaykpIHtcbiAgICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW3dyYXBwZWRIb29rXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzRGVmKG9sZEhvb2suZm5zKSAmJiBpc1RydWUob2xkSG9vay5tZXJnZWQpKSB7XG4gICAgICAgIC8vIGFscmVhZHkgYSBtZXJnZWQgaW52b2tlclxuICAgICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgICAgaW52b2tlci5mbnMucHVzaCh3cmFwcGVkSG9vayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICAgIGludm9rZXIgPSBjcmVhdGVGbkludm9rZXIoW29sZEhvb2ssIHdyYXBwZWRIb29rXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlci5tZXJnZWQgPSB0cnVlO1xuICAgIGRlZltob29rS2V5XSA9IGludm9rZXI7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhIChcbiAgICBkYXRhLFxuICAgIEN0b3IsXG4gICAgdGFnXG4gICkge1xuICAgIC8vIHdlIGFyZSBvbmx5IGV4dHJhY3RpbmcgcmF3IHZhbHVlcyBoZXJlLlxuICAgIC8vIHZhbGlkYXRpb24gYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSBoYW5kbGVkIGluIHRoZSBjaGlsZFxuICAgIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gICAgdmFyIHByb3BPcHRpb25zID0gQ3Rvci5vcHRpb25zLnByb3BzO1xuICAgIGlmIChpc1VuZGVmKHByb3BPcHRpb25zKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICAgIHZhciBwcm9wcyA9IGRhdGEucHJvcHM7XG4gICAgaWYgKGlzRGVmKGF0dHJzKSB8fCBpc0RlZihwcm9wcykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIga2V5SW5Mb3dlckNhc2UgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgICBhdHRycyAmJiBoYXNPd24oYXR0cnMsIGtleUluTG93ZXJDYXNlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGlwKFxuICAgICAgICAgICAgICBcIlByb3AgXFxcIlwiICsga2V5SW5Mb3dlckNhc2UgKyBcIlxcXCIgaXMgcGFzc2VkIHRvIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAgIChmb3JtYXRDb21wb25lbnROYW1lKHRhZyB8fCBDdG9yKSkgKyBcIiwgYnV0IHRoZSBkZWNsYXJlZCBwcm9wIG5hbWUgaXNcIiArXG4gICAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIGNhbWVsQ2FzZWQgXCIgK1xuICAgICAgICAgICAgICBcInByb3BzIG5lZWQgdG8gdXNlIHRoZWlyIGtlYmFiLWNhc2UgZXF1aXZhbGVudHMgd2hlbiB1c2luZyBpbi1ET00gXCIgK1xuICAgICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICAgIGNoZWNrUHJvcChyZXMsIGF0dHJzLCBrZXksIGFsdEtleSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Byb3AgKFxuICAgIHJlcyxcbiAgICBoYXNoLFxuICAgIGtleSxcbiAgICBhbHRLZXksXG4gICAgcHJlc2VydmVcbiAgKSB7XG4gICAgaWYgKGlzRGVmKGhhc2gpKSB7XG4gICAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgICAgcmVzW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICAgIHJlc1trZXldID0gaGFzaFthbHRLZXldO1xuICAgICAgICBpZiAoIXByZXNlcnZlKSB7XG4gICAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIFRoZSB0ZW1wbGF0ZSBjb21waWxlciBhdHRlbXB0cyB0byBtaW5pbWl6ZSB0aGUgbmVlZCBmb3Igbm9ybWFsaXphdGlvbiBieVxuICAvLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuICAvL1xuICAvLyBGb3IgcGxhaW4gSFRNTCBtYXJrdXAsIG5vcm1hbGl6YXRpb24gY2FuIGJlIGNvbXBsZXRlbHkgc2tpcHBlZCBiZWNhdXNlIHRoZVxuICAvLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4gIC8vIHR3byBjYXNlcyB3aGVyZSBleHRyYSBub3JtYWxpemF0aW9uIGlzIG5lZWRlZDpcblxuICAvLyAxLiBXaGVuIHRoZSBjaGlsZHJlbiBjb250YWlucyBjb21wb25lbnRzIC0gYmVjYXVzZSBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gIC8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQgLSBpZiBhbnkgY2hpbGQgaXMgYW4gQXJyYXksIHdlIGZsYXR0ZW4gdGhlIHdob2xlXG4gIC8vIHRoaW5nIHdpdGggQXJyYXkucHJvdG90eXBlLmNvbmNhdC4gSXQgaXMgZ3VhcmFudGVlZCB0byBiZSBvbmx5IDEtbGV2ZWwgZGVlcFxuICAvLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG4gIGZ1bmN0aW9uIHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgY2hpbGRyZW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlblxuICB9XG5cbiAgLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbiAgLy8gZS5nLiA8dGVtcGxhdGU+LCA8c2xvdD4sIHYtZm9yLCBvciB3aGVuIHRoZSBjaGlsZHJlbiBpcyBwcm92aWRlZCBieSB1c2VyXG4gIC8vIHdpdGggaGFuZC13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMgLyBKU1guIEluIHN1Y2ggY2FzZXMgYSBmdWxsIG5vcm1hbGl6YXRpb25cbiAgLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUNoaWxkcmVuIChjaGlsZHJlbikge1xuICAgIHJldHVybiBpc1ByaW1pdGl2ZShjaGlsZHJlbilcbiAgICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pXG4gICAgICAgID8gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjaGlsZHJlbilcbiAgICAgICAgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVGV4dE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplQXJyYXlDaGlsZHJlbiAoY2hpbGRyZW4sIG5lc3RlZEluZGV4KSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIHZhciBpLCBjLCBsYXN0SW5kZXgsIGxhc3Q7XG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNVbmRlZihjKSB8fCB0eXBlb2YgYyA9PT0gJ2Jvb2xlYW4nKSB7IGNvbnRpbnVlIH1cbiAgICAgIGxhc3RJbmRleCA9IHJlcy5sZW5ndGggLSAxO1xuICAgICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgICAgLy8gIG5lc3RlZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYykpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGMgPSBub3JtYWxpemVBcnJheUNoaWxkcmVuKGMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSk7XG4gICAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIChjWzBdKS50ZXh0KTtcbiAgICAgICAgICAgIGMuc2hpZnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2guYXBwbHkocmVzLCBjKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICBpZiAoaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAgIC8vIG1lcmdlIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgICAgLy8gZXNzZW50aWFsbHkgbWVyZ2VkIHdoZW4gcmVuZGVyZWQgdG8gSFRNTCBzdHJpbmdzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgICAvLyBjb252ZXJ0IHByaW1pdGl2ZSB0byB2bm9kZVxuICAgICAgICAgIHJlcy5wdXNoKGNyZWF0ZVRleHRWTm9kZShjKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1RleHROb2RlKGMpICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgICAgcmVzW2xhc3RJbmRleF0gPSBjcmVhdGVUZXh0Vk5vZGUobGFzdC50ZXh0ICsgYy50ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICAgIGlmIChpc1RydWUoY2hpbGRyZW4uX2lzVkxpc3QpICYmXG4gICAgICAgICAgICBpc0RlZihjLnRhZykgJiZcbiAgICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgICBpc0RlZihuZXN0ZWRJbmRleCkpIHtcbiAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFByb3ZpZGUgKHZtKSB7XG4gICAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICAgIGlmIChwcm92aWRlKSB7XG4gICAgICB2bS5fcHJvdmlkZWQgPSB0eXBlb2YgcHJvdmlkZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgICAgOiBwcm92aWRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbmplY3Rpb25zICh2bSkge1xuICAgIHZhciByZXN1bHQgPSByZXNvbHZlSW5qZWN0KHZtLiRvcHRpb25zLmluamVjdCwgdm0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICB7XG4gICAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgcmVzdWx0W2tleV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICAgIFwib3ZlcndyaXR0ZW4gd2hlbmV2ZXIgdGhlIHByb3ZpZGVkIGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICAgIFwiaW5qZWN0aW9uIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0b2dnbGVPYnNlcnZpbmcodHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICAgIGlmIChpbmplY3QpIHtcbiAgICAgIC8vIGluamVjdCBpcyA6YW55IGJlY2F1c2UgZmxvdyBpcyBub3Qgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgY2FjaGVkXG4gICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHZhciBrZXlzID0gaGFzU3ltYm9sXG4gICAgICAgID8gUmVmbGVjdC5vd25LZXlzKGluamVjdClcbiAgICAgICAgOiBPYmplY3Qua2V5cyhpbmplY3QpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIC8vICM2NTc0IGluIGNhc2UgdGhlIGluamVjdCBvYmplY3QgaXMgb2JzZXJ2ZWQuLi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fb2JfXycpIHsgY29udGludWUgfVxuICAgICAgICB2YXIgcHJvdmlkZUtleSA9IGluamVjdFtrZXldLmZyb207XG4gICAgICAgIHZhciBzb3VyY2UgPSB2bTtcbiAgICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICAgIGlmIChzb3VyY2UuX3Byb3ZpZGVkICYmIGhhc093bihzb3VyY2UuX3Byb3ZpZGVkLCBwcm92aWRlS2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2UuX3Byb3ZpZGVkW3Byb3ZpZGVLZXldO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gc291cmNlLiRwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICBpZiAoJ2RlZmF1bHQnIGluIGluamVjdFtrZXldKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0eXBlb2YgcHJvdmlkZURlZmF1bHQgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgPyBwcm92aWRlRGVmYXVsdC5jYWxsKHZtKVxuICAgICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVzb2x2aW5nIHJhdyBjaGlsZHJlbiBWTm9kZXMgaW50byBhIHNsb3Qgb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0XG4gICkge1xuICAgIGlmICghY2hpbGRyZW4gfHwgIWNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHt9XG4gICAgfVxuICAgIHZhciBzbG90cyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBkYXRhID0gY2hpbGQuZGF0YTtcbiAgICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICAgIGlmIChkYXRhICYmIGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5zbG90KSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLmF0dHJzLnNsb3Q7XG4gICAgICB9XG4gICAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAgIC8vIHNhbWUgY29udGV4dC5cbiAgICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICAgIGRhdGEgJiYgZGF0YS5zbG90ICE9IG51bGxcbiAgICAgICkge1xuICAgICAgICB2YXIgbmFtZSA9IGRhdGEuc2xvdDtcbiAgICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2xvdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKHNsb3RzLmRlZmF1bHQgfHwgKHNsb3RzLmRlZmF1bHQgPSBbXSkpLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBpZ25vcmUgc2xvdHMgdGhhdCBjb250YWlucyBvbmx5IHdoaXRlc3BhY2VcbiAgICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICAgIGlmIChzbG90c1tuYW1lJDFdLmV2ZXJ5KGlzV2hpdGVzcGFjZSkpIHtcbiAgICAgICAgZGVsZXRlIHNsb3RzW25hbWUkMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90c1xuICB9XG5cbiAgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlIChub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmlzQ29tbWVudCAmJiAhbm9kZS5hc3luY0ZhY3RvcnkpIHx8IG5vZGUudGV4dCA9PT0gJyAnXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBub3JtYWxpemVTY29wZWRTbG90cyAoXG4gICAgc2xvdHMsXG4gICAgbm9ybWFsU2xvdHMsXG4gICAgcHJldlNsb3RzXG4gICkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGlzU3RhYmxlID0gc2xvdHMgPyAhIXNsb3RzLiRzdGFibGUgOiB0cnVlO1xuICAgIHZhciBrZXkgPSBzbG90cyAmJiBzbG90cy4ka2V5O1xuICAgIGlmICghc2xvdHMpIHtcbiAgICAgIHJlcyA9IHt9O1xuICAgIH0gZWxzZSBpZiAoc2xvdHMuX25vcm1hbGl6ZWQpIHtcbiAgICAgIC8vIGZhc3QgcGF0aCAxOiBjaGlsZCBjb21wb25lbnQgcmUtcmVuZGVyIG9ubHksIHBhcmVudCBkaWQgbm90IGNoYW5nZVxuICAgICAgcmV0dXJuIHNsb3RzLl9ub3JtYWxpemVkXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGlzU3RhYmxlICYmXG4gICAgICBwcmV2U2xvdHMgJiZcbiAgICAgIHByZXZTbG90cyAhPT0gZW1wdHlPYmplY3QgJiZcbiAgICAgIGtleSA9PT0gcHJldlNsb3RzLiRrZXkgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5vcm1hbFNsb3RzKS5sZW5ndGggPT09IDBcbiAgICApIHtcbiAgICAgIC8vIGZhc3QgcGF0aCAyOiBzdGFibGUgc2NvcGVkIHNsb3RzIHcvIG5vIG5vcm1hbCBzbG90cyB0byBwcm94eSxcbiAgICAgIC8vIG9ubHkgbmVlZCB0byBub3JtYWxpemUgb25jZVxuICAgICAgcmV0dXJuIHByZXZTbG90c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSQxIGluIHNsb3RzKSB7XG4gICAgICAgIGlmIChzbG90c1trZXkkMV0gJiYga2V5JDFbMF0gIT09ICckJykge1xuICAgICAgICAgIHJlc1trZXkkMV0gPSBub3JtYWxpemVTY29wZWRTbG90KG5vcm1hbFNsb3RzLCBrZXkkMSwgc2xvdHNba2V5JDFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBleHBvc2Ugbm9ybWFsIHNsb3RzIG9uIHNjb3BlZFNsb3RzXG4gICAgZm9yICh2YXIga2V5JDIgaW4gbm9ybWFsU2xvdHMpIHtcbiAgICAgIGlmICghKGtleSQyIGluIHJlcykpIHtcbiAgICAgICAgcmVzW2tleSQyXSA9IHByb3h5Tm9ybWFsU2xvdChub3JtYWxTbG90cywga2V5JDIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhdm9yaWF6IHNlZW1zIHRvIG1vY2sgYSBub24tZXh0ZW5zaWJsZSAkc2NvcGVkU2xvdHMgb2JqZWN0XG4gICAgLy8gYW5kIHdoZW4gdGhhdCBpcyBwYXNzZWQgZG93biB0aGlzIHdvdWxkIGNhdXNlIGFuIGVycm9yXG4gICAgaWYgKHNsb3RzICYmIE9iamVjdC5pc0V4dGVuc2libGUoc2xvdHMpKSB7XG4gICAgICAoc2xvdHMpLl9ub3JtYWxpemVkID0gcmVzO1xuICAgIH1cbiAgICBkZWYocmVzLCAnJHN0YWJsZScsIGlzU3RhYmxlKTtcbiAgICBkZWYocmVzLCAnJGtleScsIGtleSk7XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplU2NvcGVkU2xvdChub3JtYWxTbG90cywga2V5LCBmbikge1xuICAgIHZhciBub3JtYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlcyA9IGFyZ3VtZW50cy5sZW5ndGggPyBmbi5hcHBseShudWxsLCBhcmd1bWVudHMpIDogZm4oe30pO1xuICAgICAgcmVzID0gcmVzICYmIHR5cGVvZiByZXMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHJlcylcbiAgICAgICAgPyBbcmVzXSAvLyBzaW5nbGUgdm5vZGVcbiAgICAgICAgOiBub3JtYWxpemVDaGlsZHJlbihyZXMpO1xuICAgICAgcmV0dXJuIHJlcyAmJiByZXMubGVuZ3RoID09PSAwXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogcmVzXG4gICAgfTtcbiAgICAvLyB0aGlzIGlzIGEgc2xvdCB1c2luZyB0aGUgbmV3IHYtc2xvdCBzeW50YXggd2l0aG91dCBzY29wZS4gYWx0aG91Z2ggaXQgaXNcbiAgICAvLyBjb21waWxlZCBhcyBhIHNjb3BlZCBzbG90LCByZW5kZXIgZm4gdXNlcnMgd291bGQgZXhwZWN0IGl0IHRvIGJlIHByZXNlbnRcbiAgICAvLyBvbiB0aGlzLiRzbG90cyBiZWNhdXNlIHRoZSB1c2FnZSBpcyBzZW1hbnRpY2FsbHkgYSBub3JtYWwgc2xvdC5cbiAgICBpZiAoZm4ucHJveHkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxTbG90cywga2V5LCB7XG4gICAgICAgIGdldDogbm9ybWFsaXplZCxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb3h5Tm9ybWFsU2xvdChzbG90cywga2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNsb3RzW2tleV07IH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHYtZm9yIGxpc3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gICAgdmFsLFxuICAgIHJlbmRlclxuICApIHtcbiAgICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGlmIChoYXNTeW1ib2wgJiYgdmFsW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0ID0gW107XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHZhbFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICByZXQucHVzaChyZW5kZXIocmVzdWx0LnZhbHVlLCByZXQubGVuZ3RoKSk7XG4gICAgICAgICAgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0RlZihyZXQpKSB7XG4gICAgICByZXQgPSBbXTtcbiAgICB9XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIDxzbG90PlxuICAgKi9cbiAgZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gICAgbmFtZSxcbiAgICBmYWxsYmFjayxcbiAgICBwcm9wcyxcbiAgICBiaW5kT2JqZWN0XG4gICkge1xuICAgIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgICB2YXIgbm9kZXM7XG4gICAgaWYgKHNjb3BlZFNsb3RGbikgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICAgIGlmIChiaW5kT2JqZWN0KSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoYmluZE9iamVjdCkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvcHMgPSBleHRlbmQoZXh0ZW5kKHt9LCBiaW5kT2JqZWN0KSwgcHJvcHMpO1xuICAgICAgfVxuICAgICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlcyA9IHRoaXMuJHNsb3RzW25hbWVdIHx8IGZhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBwcm9wcyAmJiBwcm9wcy5zbG90O1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZXNcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyBmaWx0ZXJzXG4gICAqL1xuICBmdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICAgIHJldHVybiByZXNvbHZlQXNzZXQodGhpcy4kb3B0aW9ucywgJ2ZpbHRlcnMnLCBpZCwgdHJ1ZSkgfHwgaWRlbnRpdHlcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGlzS2V5Tm90TWF0Y2ggKGV4cGVjdCwgYWN0dWFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwZWN0KSkge1xuICAgICAgcmV0dXJuIGV4cGVjdC5pbmRleE9mKGFjdHVhbCkgPT09IC0xXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBleHBlY3QgIT09IGFjdHVhbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSdW50aW1lIGhlbHBlciBmb3IgY2hlY2tpbmcga2V5Q29kZXMgZnJvbSBjb25maWcuXG4gICAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICAgKiBwYXNzaW5nIGluIGV2ZW50S2V5TmFtZSBhcyBsYXN0IGFyZ3VtZW50IHNlcGFyYXRlbHkgZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICovXG4gIGZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICAgIGV2ZW50S2V5Q29kZSxcbiAgICBrZXksXG4gICAgYnVpbHRJbktleUNvZGUsXG4gICAgZXZlbnRLZXlOYW1lLFxuICAgIGJ1aWx0SW5LZXlOYW1lXG4gICkge1xuICAgIHZhciBtYXBwZWRLZXlDb2RlID0gY29uZmlnLmtleUNvZGVzW2tleV0gfHwgYnVpbHRJbktleUNvZGU7XG4gICAgaWYgKGJ1aWx0SW5LZXlOYW1lICYmIGV2ZW50S2V5TmFtZSAmJiAhY29uZmlnLmtleUNvZGVzW2tleV0pIHtcbiAgICAgIHJldHVybiBpc0tleU5vdE1hdGNoKGJ1aWx0SW5LZXlOYW1lLCBldmVudEtleU5hbWUpXG4gICAgfSBlbHNlIGlmIChtYXBwZWRLZXlDb2RlKSB7XG4gICAgICByZXR1cm4gaXNLZXlOb3RNYXRjaChtYXBwZWRLZXlDb2RlLCBldmVudEtleUNvZGUpXG4gICAgfSBlbHNlIGlmIChldmVudEtleU5hbWUpIHtcbiAgICAgIHJldHVybiBoeXBoZW5hdGUoZXZlbnRLZXlOYW1lKSAhPT0ga2V5XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciBtZXJnaW5nIHYtYmluZD1cIm9iamVjdFwiIGludG8gYSBWTm9kZSdzIGRhdGEuXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICAgIGRhdGEsXG4gICAgdGFnLFxuICAgIHZhbHVlLFxuICAgIGFzUHJvcCxcbiAgICBpc1N5bmNcbiAgKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0b09iamVjdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhc2g7XG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAga2V5ID09PSAnY2xhc3MnIHx8XG4gICAgICAgICAgICBrZXkgPT09ICdzdHlsZScgfHxcbiAgICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaGFzaCA9IGRhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLnR5cGU7XG4gICAgICAgICAgICBoYXNoID0gYXNQcm9wIHx8IGNvbmZpZy5tdXN0VXNlUHJvcCh0YWcsIHR5cGUsIGtleSlcbiAgICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICAgIDogZGF0YS5hdHRycyB8fCAoZGF0YS5hdHRycyA9IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGNhbWVsaXplZEtleSA9IGNhbWVsaXplKGtleSk7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpICYmICEoY2FtZWxpemVkS2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuXG4gICAgICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICAgIG9uWyhcInVwZGF0ZTpcIiArIGNhbWVsaXplZEtleSldID0gZnVuY3Rpb24gKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHZhbHVlW2tleV0gPSAkZXZlbnQ7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgbG9vcCgga2V5ICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyBzdGF0aWMgdHJlZXMuXG4gICAqL1xuICBmdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICAgIGluZGV4LFxuICAgIGlzSW5Gb3JcbiAgKSB7XG4gICAgdmFyIGNhY2hlZCA9IHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKTtcbiAgICB2YXIgdHJlZSA9IGNhY2hlZFtpbmRleF07XG4gICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gICAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUuXG4gICAgaWYgKHRyZWUgJiYgIWlzSW5Gb3IpIHtcbiAgICAgIHJldHVybiB0cmVlXG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgcmVuZGVyIGEgZnJlc2ggdHJlZS5cbiAgICB0cmVlID0gY2FjaGVkW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKFxuICAgICAgdGhpcy5fcmVuZGVyUHJveHksXG4gICAgICBudWxsLFxuICAgICAgdGhpcyAvLyBmb3IgcmVuZGVyIGZucyBnZW5lcmF0ZWQgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IHRlbXBsYXRlc1xuICAgICk7XG4gICAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgICByZXR1cm4gdHJlZVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnRpbWUgaGVscGVyIGZvciB2LW9uY2UuXG4gICAqIEVmZmVjdGl2ZWx5IGl0IG1lYW5zIG1hcmtpbmcgdGhlIG5vZGUgYXMgc3RhdGljIHdpdGggYSB1bmlxdWUga2V5LlxuICAgKi9cbiAgZnVuY3Rpb24gbWFya09uY2UgKFxuICAgIHRyZWUsXG4gICAgaW5kZXgsXG4gICAga2V5XG4gICkge1xuICAgIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICAgIHJldHVybiB0cmVlXG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgICB0cmVlLFxuICAgIGtleSxcbiAgICBpc09uY2VcbiAgKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHJlZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodHJlZVtpXSAmJiB0eXBlb2YgdHJlZVtpXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBtYXJrU3RhdGljTm9kZSh0cmVlW2ldLCAoa2V5ICsgXCJfXCIgKyBpKSwgaXNPbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gICAgbm9kZS5pc1N0YXRpYyA9IHRydWU7XG4gICAgbm9kZS5rZXkgPSBrZXk7XG4gICAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbiA9IGRhdGEub24gPSBkYXRhLm9uID8gZXh0ZW5kKHt9LCBkYXRhLm9uKSA6IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICAgIHZhciBvdXJzID0gdmFsdWVba2V5XTtcbiAgICAgICAgICBvbltrZXldID0gZXhpc3RpbmcgPyBbXS5jb25jYXQoZXhpc3RpbmcsIG91cnMpIDogb3VycztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgICBmbnMsIC8vIHNlZSBmbG93L3Zub2RlXG4gICAgcmVzLFxuICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFkZGVkIGluIDIuNlxuICAgIGhhc0R5bmFtaWNLZXlzLFxuICAgIGNvbnRlbnRIYXNoS2V5XG4gICkge1xuICAgIHJlcyA9IHJlcyB8fCB7ICRzdGFibGU6ICFoYXNEeW5hbWljS2V5cyB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2xvdCA9IGZuc1tpXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNsb3QpKSB7XG4gICAgICAgIHJlc29sdmVTY29wZWRTbG90cyhzbG90LCByZXMsIGhhc0R5bmFtaWNLZXlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc2xvdCkge1xuICAgICAgICAvLyBtYXJrZXIgZm9yIHJldmVyc2UgcHJveHlpbmcgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICAgICAgaWYgKHNsb3QucHJveHkpIHtcbiAgICAgICAgICBzbG90LmZuLnByb3h5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXNbc2xvdC5rZXldID0gc2xvdC5mbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRlbnRIYXNoS2V5KSB7XG4gICAgICAocmVzKS4ka2V5ID0gY29udGVudEhhc2hLZXk7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmREeW5hbWljS2V5cyAoYmFzZU9iaiwgdmFsdWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHZhciBrZXkgPSB2YWx1ZXNbaV07XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5KSB7XG4gICAgICAgIGJhc2VPYmpbdmFsdWVzW2ldXSA9IHZhbHVlc1tpICsgMV07XG4gICAgICB9IGVsc2UgaWYgKGtleSAhPT0gJycgJiYga2V5ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIG51bGwgaXMgYSBzcGVpY2FsIHZhbHVlIGZvciBleHBsaWNpdGx5IHJlbW92aW5nIGEgYmluZGluZ1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIChcIkludmFsaWQgdmFsdWUgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IChleHBlY3RlZCBzdHJpbmcgb3IgbnVsbCk6IFwiICsga2V5KSxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlT2JqXG4gIH1cblxuICAvLyBoZWxwZXIgdG8gZHluYW1pY2FsbHkgYXBwZW5kIG1vZGlmaWVyIHJ1bnRpbWUgbWFya2VycyB0byBldmVudCBuYW1lcy5cbiAgLy8gZW5zdXJlIG9ubHkgYXBwZW5kIHdoZW4gdmFsdWUgaXMgYWxyZWFkeSBzdHJpbmcsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGNhc3RcbiAgLy8gdG8gc3RyaW5nIGFuZCBjYXVzZSB0aGUgdHlwZSBjaGVjayB0byBtaXNzLlxuICBmdW5jdGlvbiBwcmVwZW5kTW9kaWZpZXIgKHZhbHVlLCBzeW1ib2wpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHN5bWJvbCArIHZhbHVlIDogdmFsdWVcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluc3RhbGxSZW5kZXJIZWxwZXJzICh0YXJnZXQpIHtcbiAgICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgICB0YXJnZXQuX24gPSB0b051bWJlcjtcbiAgICB0YXJnZXQuX3MgPSB0b1N0cmluZztcbiAgICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICAgIHRhcmdldC5fdCA9IHJlbmRlclNsb3Q7XG4gICAgdGFyZ2V0Ll9xID0gbG9vc2VFcXVhbDtcbiAgICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gICAgdGFyZ2V0Ll9tID0gcmVuZGVyU3RhdGljO1xuICAgIHRhcmdldC5fZiA9IHJlc29sdmVGaWx0ZXI7XG4gICAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgICB0YXJnZXQuX2IgPSBiaW5kT2JqZWN0UHJvcHM7XG4gICAgdGFyZ2V0Ll92ID0gY3JlYXRlVGV4dFZOb2RlO1xuICAgIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgdGFyZ2V0Ll91ID0gcmVzb2x2ZVNjb3BlZFNsb3RzO1xuICAgIHRhcmdldC5fZyA9IGJpbmRPYmplY3RMaXN0ZW5lcnM7XG4gICAgdGFyZ2V0Ll9kID0gYmluZER5bmFtaWNLZXlzO1xuICAgIHRhcmdldC5fcCA9IHByZXBlbmRNb2RpZmllcjtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgICBkYXRhLFxuICAgIHByb3BzLFxuICAgIGNoaWxkcmVuLFxuICAgIHBhcmVudCxcbiAgICBDdG9yXG4gICkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gICAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAgIC8vIGdldHMgYSB1bmlxdWUgY29udGV4dCAtIHRoaXMgaXMgbmVjZXNzYXJ5IGZvciBjb3JyZWN0IG5hbWVkIHNsb3QgY2hlY2tcbiAgICB2YXIgY29udGV4dFZtO1xuICAgIGlmIChoYXNPd24ocGFyZW50LCAnX3VpZCcpKSB7XG4gICAgICBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIGNvbnRleHRWbS5fb3JpZ2luYWwgPSBwYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRoZSBjb250ZXh0IHZtIHBhc3NlZCBpbiBpcyBhIGZ1bmN0aW9uYWwgY29udGV4dCBhcyB3ZWxsLlxuICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFyZSBhYmxlIHRvIGdldCBhIGhvbGQgdG8gdGhlXG4gICAgICAvLyByZWFsIGNvbnRleHQgaW5zdGFuY2UuXG4gICAgICBjb250ZXh0Vm0gPSBwYXJlbnQ7XG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHBhcmVudCA9IHBhcmVudC5fb3JpZ2luYWw7XG4gICAgfVxuICAgIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgICB2YXIgbmVlZE5vcm1hbGl6YXRpb24gPSAhaXNDb21waWxlZDtcblxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gICAgdGhpcy5pbmplY3Rpb25zID0gcmVzb2x2ZUluamVjdChvcHRpb25zLmluamVjdCwgcGFyZW50KTtcbiAgICB0aGlzLnNsb3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzJDEuJHNsb3RzKSB7XG4gICAgICAgIG5vcm1hbGl6ZVNjb3BlZFNsb3RzKFxuICAgICAgICAgIGRhdGEuc2NvcGVkU2xvdHMsXG4gICAgICAgICAgdGhpcyQxLiRzbG90cyA9IHJlc29sdmVTbG90cyhjaGlsZHJlbiwgcGFyZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMkMS4kc2xvdHNcbiAgICB9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY29wZWRTbG90cycsICh7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplU2NvcGVkU2xvdHMoZGF0YS5zY29wZWRTbG90cywgdGhpcy5zbG90cygpKVxuICAgICAgfVxuICAgIH0pKTtcblxuICAgIC8vIHN1cHBvcnQgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgICBpZiAoaXNDb21waWxlZCkge1xuICAgICAgLy8gZXhwb3NpbmcgJG9wdGlvbnMgZm9yIHJlbmRlclN0YXRpYygpXG4gICAgICB0aGlzLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICAgIHRoaXMuJHNsb3RzID0gdGhpcy5zbG90cygpO1xuICAgICAgdGhpcy4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhkYXRhLnNjb3BlZFNsb3RzLCB0aGlzLiRzbG90cyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuX3Njb3BlSWQpIHtcbiAgICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgICB2YXIgdm5vZGUgPSBjcmVhdGVFbGVtZW50KGNvbnRleHRWbSwgYSwgYiwgYywgZCwgbmVlZE5vcm1hbGl6YXRpb24pO1xuICAgICAgICBpZiAodm5vZGUgJiYgIUFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgICAgdm5vZGUuZm5TY29wZUlkID0gb3B0aW9ucy5fc2NvcGVJZDtcbiAgICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZub2RlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29udGV4dFZtLCBhLCBiLCBjLCBkLCBuZWVkTm9ybWFsaXphdGlvbik7IH07XG4gICAgfVxuICB9XG5cbiAgaW5zdGFsbFJlbmRlckhlbHBlcnMoRnVuY3Rpb25hbFJlbmRlckNvbnRleHQucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgICBDdG9yLFxuICAgIHByb3BzRGF0YSxcbiAgICBkYXRhLFxuICAgIGNvbnRleHRWbSxcbiAgICBjaGlsZHJlblxuICApIHtcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICAgIGlmIChpc0RlZihwcm9wT3B0aW9ucykpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEucHJvcHMpKSB7IG1lcmdlUHJvcHMocHJvcHMsIGRhdGEucHJvcHMpOyB9XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgICBkYXRhLFxuICAgICAgcHJvcHMsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGNvbnRleHRWbSxcbiAgICAgIEN0b3JcbiAgICApO1xuXG4gICAgdmFyIHZub2RlID0gb3B0aW9ucy5yZW5kZXIuY2FsbChudWxsLCByZW5kZXJDb250ZXh0Ll9jLCByZW5kZXJDb250ZXh0KTtcblxuICAgIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgICByZXR1cm4gY2xvbmVBbmRNYXJrRnVuY3Rpb25hbFJlc3VsdCh2bm9kZSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgdmFyIHZub2RlcyA9IG5vcm1hbGl6ZUNoaWxkcmVuKHZub2RlKSB8fCBbXTtcbiAgICAgIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXNbaV0gPSBjbG9uZUFuZE1hcmtGdW5jdGlvbmFsUmVzdWx0KHZub2Rlc1tpXSwgZGF0YSwgcmVuZGVyQ29udGV4dC5wYXJlbnQsIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsb25lQW5kTWFya0Z1bmN0aW9uYWxSZXN1bHQgKHZub2RlLCBkYXRhLCBjb250ZXh0Vm0sIG9wdGlvbnMsIHJlbmRlckNvbnRleHQpIHtcbiAgICAvLyAjNzgxNyBjbG9uZSBub2RlIGJlZm9yZSBzZXR0aW5nIGZuQ29udGV4dCwgb3RoZXJ3aXNlIGlmIHRoZSBub2RlIGlzIHJldXNlZFxuICAgIC8vIChlLmcuIGl0IHdhcyBmcm9tIGEgY2FjaGVkIG5vcm1hbCBzbG90KSB0aGUgZm5Db250ZXh0IGNhdXNlcyBuYW1lZCBzbG90c1xuICAgIC8vIHRoYXQgc2hvdWxkIG5vdCBiZSBtYXRjaGVkIHRvIG1hdGNoLlxuICAgIHZhciBjbG9uZSA9IGNsb25lVk5vZGUodm5vZGUpO1xuICAgIGNsb25lLmZuQ29udGV4dCA9IGNvbnRleHRWbTtcbiAgICBjbG9uZS5mbk9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHtcbiAgICAgIChjbG9uZS5kZXZ0b29sc01ldGEgPSBjbG9uZS5kZXZ0b29sc01ldGEgfHwge30pLnJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0O1xuICAgIH1cbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAoY2xvbmUuZGF0YSB8fCAoY2xvbmUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lXG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVByb3BzICh0bywgZnJvbSkge1xuICAgIGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG4gICAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICAvLyBpbmxpbmUgaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxuICB2YXIgY29tcG9uZW50Vk5vZGVIb29rcyA9IHtcbiAgICBpbml0OiBmdW5jdGlvbiBpbml0ICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlICYmXG4gICAgICAgICF2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQgJiZcbiAgICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmVcbiAgICAgICkge1xuICAgICAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgICAgY29tcG9uZW50Vk5vZGVIb29rcy5wcmVwYXRjaChtb3VudGVkTm9kZSwgbW91bnRlZE5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlKFxuICAgICAgICAgIHZub2RlLFxuICAgICAgICAgIGFjdGl2ZUluc3RhbmNlXG4gICAgICAgICk7XG4gICAgICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHByZXBhdGNoOiBmdW5jdGlvbiBwcmVwYXRjaCAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IG9sZFZub2RlLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgdXBkYXRlQ2hpbGRDb21wb25lbnQoXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBvcHRpb25zLnByb3BzRGF0YSwgLy8gdXBkYXRlZCBwcm9wc1xuICAgICAgICBvcHRpb25zLmxpc3RlbmVycywgLy8gdXBkYXRlZCBsaXN0ZW5lcnNcbiAgICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgICAgb3B0aW9ucy5jaGlsZHJlbiAvLyBuZXcgY2hpbGRyZW5cbiAgICAgICk7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0ICh2bm9kZSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB2bm9kZS5jb250ZXh0O1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICBpZiAoIWNvbXBvbmVudEluc3RhbmNlLl9pc01vdW50ZWQpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHZub2RlLmRhdGEua2VlcEFsaXZlKSB7XG4gICAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgICAvLyB2dWUtcm91dGVyIzEyMTJcbiAgICAgICAgICAvLyBEdXJpbmcgdXBkYXRlcywgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCdzIGNoaWxkIGNvbXBvbmVudHMgbWF5XG4gICAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgICAgLy8gb24gaW5jb3JyZWN0IGNoaWxkcmVuLiBJbnN0ZWFkIHdlIHB1c2ggdGhlbSBpbnRvIGEgcXVldWUgd2hpY2ggd2lsbFxuICAgICAgICAgIC8vIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgd2hvbGUgcGF0Y2ggcHJvY2VzcyBlbmRlZC5cbiAgICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgIGlmICghY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgICBjb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBob29rc1RvTWVyZ2UgPSBPYmplY3Qua2V5cyhjb21wb25lbnRWTm9kZUhvb2tzKTtcblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICAgIEN0b3IsXG4gICAgZGF0YSxcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIHRhZ1xuICApIHtcbiAgICBpZiAoaXNVbmRlZihDdG9yKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcblxuICAgIC8vIHBsYWluIG9wdGlvbnMgb2JqZWN0OiB0dXJuIGl0IGludG8gYSBjb25zdHJ1Y3RvclxuICAgIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgICB9XG5cbiAgICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gICAgLy8gcmVqZWN0LlxuICAgIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGFzeW5jIGNvbXBvbmVudFxuICAgIHZhciBhc3luY0ZhY3Rvcnk7XG4gICAgaWYgKGlzVW5kZWYoQ3Rvci5jaWQpKSB7XG4gICAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChhc3luY0ZhY3RvcnksIGJhc2VDdG9yKTtcbiAgICAgIGlmIChDdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgICAvLyBhcyBhIGNvbW1lbnQgbm9kZSBidXQgcHJlc2VydmVzIGFsbCB0aGUgcmF3IGluZm9ybWF0aW9uIGZvciB0aGUgbm9kZS5cbiAgICAgICAgLy8gdGhlIGluZm9ybWF0aW9uIHdpbGwgYmUgdXNlZCBmb3IgYXN5bmMgc2VydmVyLXJlbmRlcmluZyBhbmQgaHlkcmF0aW9uLlxuICAgICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgICBhc3luY0ZhY3RvcnksXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgIHRhZ1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgICAvLyByZXNvbHZlIGNvbnN0cnVjdG9yIG9wdGlvbnMgaW4gY2FzZSBnbG9iYWwgbWl4aW5zIGFyZSBhcHBsaWVkIGFmdGVyXG4gICAgLy8gY29tcG9uZW50IGNvbnN0cnVjdG9yIGNyZWF0aW9uXG4gICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAgIC8vIHRyYW5zZm9ybSBjb21wb25lbnQgdi1tb2RlbCBkYXRhIGludG8gcHJvcHMgJiBldmVudHNcbiAgICBpZiAoaXNEZWYoZGF0YS5tb2RlbCkpIHtcbiAgICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gZXh0cmFjdCBwcm9wc1xuICAgIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgICAvLyBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgIGlmIChpc1RydWUoQ3Rvci5vcHRpb25zLmZ1bmN0aW9uYWwpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICAgIH1cblxuICAgIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gICAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgICB2YXIgbGlzdGVuZXJzID0gZGF0YS5vbjtcbiAgICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICAgIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICAgIGRhdGEub24gPSBkYXRhLm5hdGl2ZU9uO1xuXG4gICAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuYWJzdHJhY3QpKSB7XG4gICAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgICAvLyBvdGhlciB0aGFuIHByb3BzICYgbGlzdGVuZXJzICYgc2xvdFxuXG4gICAgICAvLyB3b3JrIGFyb3VuZCBmbG93XG4gICAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICAgIGRhdGEgPSB7fTtcbiAgICAgIGlmIChzbG90KSB7XG4gICAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW5zdGFsbCBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gICAgaW5zdGFsbENvbXBvbmVudEhvb2tzKGRhdGEpO1xuXG4gICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgICB2YXIgbmFtZSA9IEN0b3Iub3B0aW9ucy5uYW1lIHx8IHRhZztcbiAgICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgICAgZGF0YSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgICBhc3luY0ZhY3RvcnlcbiAgICApO1xuXG4gICAgcmV0dXJuIHZub2RlXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgICB2bm9kZSwgLy8gd2Uga25vdyBpdCdzIE1vdW50ZWRDb21wb25lbnRWTm9kZSBidXQgZmxvdyBkb2Vzbid0XG4gICAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICApIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIF9pc0NvbXBvbmVudDogdHJ1ZSxcbiAgICAgIF9wYXJlbnRWbm9kZTogdm5vZGUsXG4gICAgICBwYXJlbnQ6IHBhcmVudFxuICAgIH07XG4gICAgLy8gY2hlY2sgaW5saW5lLXRlbXBsYXRlIHJlbmRlciBmdW5jdGlvbnNcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSB2bm9kZS5kYXRhLmlubGluZVRlbXBsYXRlO1xuICAgIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBpbmxpbmVUZW1wbGF0ZS5zdGF0aWNSZW5kZXJGbnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsQ29tcG9uZW50SG9va3MgKGRhdGEpIHtcbiAgICB2YXIgaG9va3MgPSBkYXRhLmhvb2sgfHwgKGRhdGEuaG9vayA9IHt9KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGhvb2tzVG9NZXJnZVtpXTtcbiAgICAgIHZhciBleGlzdGluZyA9IGhvb2tzW2tleV07XG4gICAgICB2YXIgdG9NZXJnZSA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICAgIGlmIChleGlzdGluZyAhPT0gdG9NZXJnZSAmJiAhKGV4aXN0aW5nICYmIGV4aXN0aW5nLl9tZXJnZWQpKSB7XG4gICAgICAgIGhvb2tzW2tleV0gPSBleGlzdGluZyA/IG1lcmdlSG9vayQxKHRvTWVyZ2UsIGV4aXN0aW5nKSA6IHRvTWVyZ2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VIb29rJDEgKGYxLCBmMikge1xuICAgIHZhciBtZXJnZWQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgLy8gZmxvdyBjb21wbGFpbnMgYWJvdXQgZXh0cmEgYXJncyB3aGljaCBpcyB3aHkgd2UgdXNlIGFueVxuICAgICAgZjEoYSwgYik7XG4gICAgICBmMihhLCBiKTtcbiAgICB9O1xuICAgIG1lcmdlZC5fbWVyZ2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gbWVyZ2VkXG4gIH1cblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgaW5mbyAodmFsdWUgYW5kIGNhbGxiYWNrKSBpbnRvXG4gIC8vIHByb3AgYW5kIGV2ZW50IGhhbmRsZXIgcmVzcGVjdGl2ZWx5LlxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICAgIHZhciBwcm9wID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5wcm9wKSB8fCAndmFsdWUnO1xuICAgIHZhciBldmVudCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwuZXZlbnQpIHx8ICdpbnB1dCdcbiAgICA7KGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSkpW3Byb3BdID0gZGF0YS5tb2RlbC52YWx1ZTtcbiAgICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICAgIHZhciBleGlzdGluZyA9IG9uW2V2ZW50XTtcbiAgICB2YXIgY2FsbGJhY2sgPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICAgIGlmIChpc0RlZihleGlzdGluZykpIHtcbiAgICAgIGlmIChcbiAgICAgICAgQXJyYXkuaXNBcnJheShleGlzdGluZylcbiAgICAgICAgICA/IGV4aXN0aW5nLmluZGV4T2YoY2FsbGJhY2spID09PSAtMVxuICAgICAgICAgIDogZXhpc3RpbmcgIT09IGNhbGxiYWNrXG4gICAgICApIHtcbiAgICAgICAgb25bZXZlbnRdID0gW2NhbGxiYWNrXS5jb25jYXQoZXhpc3RpbmcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbltldmVudF0gPSBjYWxsYmFjaztcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG4gIHZhciBBTFdBWVNfTk9STUFMSVpFID0gMjtcblxuICAvLyB3cmFwcGVyIGZ1bmN0aW9uIGZvciBwcm92aWRpbmcgYSBtb3JlIGZsZXhpYmxlIGludGVyZmFjZVxuICAvLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gICAgY29udGV4dCxcbiAgICB0YWcsXG4gICAgZGF0YSxcbiAgICBjaGlsZHJlbixcbiAgICBub3JtYWxpemF0aW9uVHlwZSxcbiAgICBhbHdheXNOb3JtYWxpemVcbiAgKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gY2hpbGRyZW47XG4gICAgICBjaGlsZHJlbiA9IGRhdGE7XG4gICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaXNUcnVlKGFsd2F5c05vcm1hbGl6ZSkpIHtcbiAgICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVFbGVtZW50KGNvbnRleHQsIHRhZywgZGF0YSwgY2hpbGRyZW4sIG5vcm1hbGl6YXRpb25UeXBlKVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICAgIGNvbnRleHQsXG4gICAgdGFnLFxuICAgIGRhdGEsXG4gICAgY2hpbGRyZW4sXG4gICAgbm9ybWFsaXphdGlvblR5cGVcbiAgKSB7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKChkYXRhKS5fX29iX18pKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgICAnQWx3YXlzIGNyZWF0ZSBmcmVzaCB2bm9kZSBkYXRhIG9iamVjdHMgaW4gZWFjaCByZW5kZXIhJyxcbiAgICAgICAgY29udGV4dFxuICAgICAgKTtcbiAgICAgIHJldHVybiBjcmVhdGVFbXB0eVZOb2RlKClcbiAgICB9XG4gICAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5pcykpIHtcbiAgICAgIHRhZyA9IGRhdGEuaXM7XG4gICAgfVxuICAgIGlmICghdGFnKSB7XG4gICAgICAvLyBpbiBjYXNlIG9mIGNvbXBvbmVudCA6aXMgc2V0IHRvIGZhbHN5IHZhbHVlXG4gICAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gICAgfVxuICAgIC8vIHdhcm4gYWdhaW5zdCBub24tcHJpbWl0aXZlIGtleVxuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc0RlZihkYXRhLmtleSkgJiYgIWlzUHJpbWl0aXZlKGRhdGEua2V5KVxuICAgICkge1xuICAgICAge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAgICAgJ3VzZSBzdHJpbmcvbnVtYmVyIHZhbHVlIGluc3RlYWQuJyxcbiAgICAgICAgICBjb250ZXh0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHN1cHBvcnQgc2luZ2xlIGZ1bmN0aW9uIGNoaWxkcmVuIGFzIGRlZmF1bHQgc2NvcGVkIHNsb3RcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICAgIHR5cGVvZiBjaGlsZHJlblswXSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICBkYXRhLnNjb3BlZFNsb3RzID0geyBkZWZhdWx0OiBjaGlsZHJlblswXSB9O1xuICAgICAgY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBBTFdBWVNfTk9STUFMSVpFKSB7XG4gICAgICBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgICBjaGlsZHJlbiA9IHNpbXBsZU5vcm1hbGl6ZUNoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICB9XG4gICAgdmFyIHZub2RlLCBucztcbiAgICBpZiAodHlwZW9mIHRhZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBDdG9yO1xuICAgICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAgIC8vIHBsYXRmb3JtIGJ1aWx0LWluIGVsZW1lbnRzXG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIGNvbmZpZy5wYXJzZVBsYXRmb3JtVGFnTmFtZSh0YWcpLCBkYXRhLCBjaGlsZHJlbixcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICgoIWRhdGEgfHwgIWRhdGEucHJlKSAmJiBpc0RlZihDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdW5rbm93biBvciB1bmxpc3RlZCBuYW1lc3BhY2VkIGVsZW1lbnRzXG4gICAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAgIC8vIHBhcmVudCBub3JtYWxpemVzIGNoaWxkcmVuXG4gICAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGNvbnRleHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2bm9kZSkpIHtcbiAgICAgIHJldHVybiB2bm9kZVxuICAgIH0gZWxzZSBpZiAoaXNEZWYodm5vZGUpKSB7XG4gICAgICBpZiAoaXNEZWYobnMpKSB7IGFwcGx5TlModm5vZGUsIG5zKTsgfVxuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7IHJlZ2lzdGVyRGVlcEJpbmRpbmdzKGRhdGEpOyB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgICB2bm9kZS5ucyA9IG5zO1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgICBucyA9IHVuZGVmaW5lZDtcbiAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKHZub2RlLmNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChpc0RlZihjaGlsZC50YWcpICYmIChcbiAgICAgICAgICBpc1VuZGVmKGNoaWxkLm5zKSB8fCAoaXNUcnVlKGZvcmNlKSAmJiBjaGlsZC50YWcgIT09ICdzdmcnKSkpIHtcbiAgICAgICAgICBhcHBseU5TKGNoaWxkLCBucywgZm9yY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVmICM1MzE4XG4gIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgcGFyZW50IHJlLXJlbmRlciB3aGVuIGRlZXAgYmluZGluZ3MgbGlrZSA6c3R5bGUgYW5kXG4gIC8vIDpjbGFzcyBhcmUgdXNlZCBvbiBzbG90IG5vZGVzXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRGVlcEJpbmRpbmdzIChkYXRhKSB7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuc3R5bGUpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLnN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEuY2xhc3MpKSB7XG4gICAgICB0cmF2ZXJzZShkYXRhLmNsYXNzKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0UmVuZGVyICh2bSkge1xuICAgIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gICAgdm0uX3N0YXRpY1RyZWVzID0gbnVsbDsgLy8gdi1vbmNlIGNhY2hlZCB0cmVlc1xuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG4gICAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gICAgdmFyIHJlbmRlckNvbnRleHQgPSBwYXJlbnRWbm9kZSAmJiBwYXJlbnRWbm9kZS5jb250ZXh0O1xuICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiwgcmVuZGVyQ29udGV4dCk7XG4gICAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gICAgLy8gYmluZCB0aGUgY3JlYXRlRWxlbWVudCBmbiB0byB0aGlzIGluc3RhbmNlXG4gICAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gICAgLy8gaW50ZXJuYWwgdmVyc2lvbiBpcyB1c2VkIGJ5IHJlbmRlciBmdW5jdGlvbnMgY29tcGlsZWQgZnJvbSB0ZW1wbGF0ZXNcbiAgICB2bS5fYyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCBmYWxzZSk7IH07XG4gICAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gICAgLy8gdXNlci13cml0dGVuIHJlbmRlciBmdW5jdGlvbnMuXG4gICAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudCh2bSwgYSwgYiwgYywgZCwgdHJ1ZSk7IH07XG5cbiAgICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAgIC8vIHRoZXkgbmVlZCB0byBiZSByZWFjdGl2ZSBzbyB0aGF0IEhPQ3MgdXNpbmcgdGhlbSBhcmUgYWx3YXlzIHVwZGF0ZWRcbiAgICB2YXIgcGFyZW50RGF0YSA9IHBhcmVudFZub2RlICYmIHBhcmVudFZub2RlLmRhdGE7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIHtcbiAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRhdHRycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCAmJiB3YXJuKFwiJGxpc3RlbmVycyBpcyByZWFkb25seS5cIiwgdm0pO1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcmVuZGVyTWl4aW4gKFZ1ZSkge1xuICAgIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gICAgaW5zdGFsbFJlbmRlckhlbHBlcnMoVnVlLnByb3RvdHlwZSk7XG5cbiAgICBWdWUucHJvdG90eXBlLiRuZXh0VGljayA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLl9yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIHJlbmRlciA9IHJlZi5yZW5kZXI7XG4gICAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgICAgaWYgKF9wYXJlbnRWbm9kZSkge1xuICAgICAgICB2bS4kc2NvcGVkU2xvdHMgPSBub3JtYWxpemVTY29wZWRTbG90cyhcbiAgICAgICAgICBfcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyxcbiAgICAgICAgICB2bS4kc2xvdHMsXG4gICAgICAgICAgdm0uJHNjb3BlZFNsb3RzXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAgIC8vIHRvIHRoZSBkYXRhIG9uIHRoZSBwbGFjZWhvbGRlciBub2RlLlxuICAgICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgICAgLy8gcmVuZGVyIHNlbGZcbiAgICAgIHZhciB2bm9kZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBtYWludGFpbiBhIHN0YWNrIGJlY2F1ZXMgYWxsIHJlbmRlciBmbnMgYXJlIGNhbGxlZFxuICAgICAgICAvLyBzZXBhcmF0ZWx5IGZyb20gb25lIGFub3RoZXIuIE5lc3RlZCBjb21wb25lbnQncyByZW5kZXIgZm5zIGFyZSBjYWxsZWRcbiAgICAgICAgLy8gd2hlbiBwYXJlbnQgY29tcG9uZW50IGlzIHBhdGNoZWQuXG4gICAgICAgIGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZSA9IHZtO1xuICAgICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgXCJyZW5kZXJcIik7XG4gICAgICAgIC8vIHJldHVybiBlcnJvciByZW5kZXIgcmVzdWx0LFxuICAgICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodm0uJG9wdGlvbnMucmVuZGVyRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdm5vZGUgPSB2bS4kb3B0aW9ucy5yZW5kZXJFcnJvci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQsIGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcInJlbmRlckVycm9yXCIpO1xuICAgICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBjdXJyZW50UmVuZGVyaW5nSW5zdGFuY2UgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gaWYgdGhlIHJldHVybmVkIGFycmF5IGNvbnRhaW5zIG9ubHkgYSBzaW5nbGUgbm9kZSwgYWxsb3cgaXRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSAmJiB2bm9kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZVswXTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBlbXB0eSB2bm9kZSBpbiBjYXNlIHRoZSByZW5kZXIgZnVuY3Rpb24gZXJyb3JlZCBvdXRcbiAgICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnTXVsdGlwbGUgcm9vdCBub2RlcyByZXR1cm5lZCBmcm9tIHJlbmRlciBmdW5jdGlvbi4gUmVuZGVyIGZ1bmN0aW9uICcgK1xuICAgICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgICB9XG4gICAgICAvLyBzZXQgcGFyZW50XG4gICAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZW5zdXJlQ3RvciAoY29tcCwgYmFzZSkge1xuICAgIGlmIChcbiAgICAgIGNvbXAuX19lc01vZHVsZSB8fFxuICAgICAgKGhhc1N5bWJvbCAmJiBjb21wW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdNb2R1bGUnKVxuICAgICkge1xuICAgICAgY29tcCA9IGNvbXAuZGVmYXVsdDtcbiAgICB9XG4gICAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgICA/IGJhc2UuZXh0ZW5kKGNvbXApXG4gICAgICA6IGNvbXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFzeW5jUGxhY2Vob2xkZXIgKFxuICAgIGZhY3RvcnksXG4gICAgZGF0YSxcbiAgICBjb250ZXh0LFxuICAgIGNoaWxkcmVuLFxuICAgIHRhZ1xuICApIHtcbiAgICB2YXIgbm9kZSA9IGNyZWF0ZUVtcHR5Vk5vZGUoKTtcbiAgICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgbm9kZS5hc3luY01ldGEgPSB7IGRhdGE6IGRhdGEsIGNvbnRleHQ6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiwgdGFnOiB0YWcgfTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUFzeW5jQ29tcG9uZW50IChcbiAgICBmYWN0b3J5LFxuICAgIGJhc2VDdG9yXG4gICkge1xuICAgIGlmIChpc1RydWUoZmFjdG9yeS5lcnJvcikgJiYgaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgICB9XG5cbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gICAgfVxuXG4gICAgaWYgKGlzVHJ1ZShmYWN0b3J5LmxvYWRpbmcpICYmIGlzRGVmKGZhY3RvcnkubG9hZGluZ0NvbXApKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICAgIH1cblxuICAgIHZhciBvd25lciA9IGN1cnJlbnRSZW5kZXJpbmdJbnN0YW5jZTtcbiAgICBpZiAoaXNEZWYoZmFjdG9yeS5vd25lcnMpKSB7XG4gICAgICAvLyBhbHJlYWR5IHBlbmRpbmdcbiAgICAgIGZhY3Rvcnkub3duZXJzLnB1c2gob3duZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3duZXJzID0gZmFjdG9yeS5vd25lcnMgPSBbb3duZXJdO1xuICAgICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgICB2YXIgZm9yY2VSZW5kZXIgPSBmdW5jdGlvbiAocmVuZGVyQ29tcGxldGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIChvd25lcnNbaV0pLiRmb3JjZVVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlckNvbXBsZXRlZCkge1xuICAgICAgICAgIG93bmVycy5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgcmVzb2x2ZSA9IG9uY2UoZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgICBmYWN0b3J5LnJlc29sdmVkID0gZW5zdXJlQ3RvcihyZXMsIGJhc2VDdG9yKTtcbiAgICAgICAgLy8gaW52b2tlIGNhbGxiYWNrcyBvbmx5IGlmIHRoaXMgaXMgbm90IGEgc3luY2hyb25vdXMgcmVzb2x2ZVxuICAgICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgICAgaWYgKCFzeW5jKSB7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3duZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVqZWN0ID0gb25jZShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgdG8gcmVzb2x2ZSBhc3luYyBjb21wb25lbnQ6IFwiICsgKFN0cmluZyhmYWN0b3J5KSkgK1xuICAgICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgICApO1xuICAgICAgICBpZiAoaXNEZWYoZmFjdG9yeS5lcnJvckNvbXApKSB7XG4gICAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgICAgZm9yY2VSZW5kZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICBpZiAoaXNPYmplY3QocmVzKSkge1xuICAgICAgICBpZiAoaXNQcm9taXNlKHJlcykpIHtcbiAgICAgICAgICAvLyAoKSA9PiBQcm9taXNlXG4gICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkpIHtcbiAgICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShyZXMuY29tcG9uZW50KSkge1xuICAgICAgICAgIHJlcy5jb21wb25lbnQudGhlbihyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgICAgICAgaWYgKGlzRGVmKHJlcy5lcnJvcikpIHtcbiAgICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNEZWYocmVzLmxvYWRpbmcpKSB7XG4gICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgICAgaWYgKHJlcy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgICBmYWN0b3J5LmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWYoZmFjdG9yeS5yZXNvbHZlZCkgJiYgaXNVbmRlZihmYWN0b3J5LmVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIHJlcy5kZWxheSB8fCAyMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0RlZihyZXMudGltZW91dCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgICAgICAgIFwidGltZW91dCAoXCIgKyAocmVzLnRpbWVvdXQpICsgXCJtcylcIlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlcy50aW1lb3V0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgLy8gcmV0dXJuIGluIGNhc2UgcmVzb2x2ZWQgc3luY2hyb25vdXNseVxuICAgICAgcmV0dXJuIGZhY3RvcnkubG9hZGluZ1xuICAgICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgICAgOiBmYWN0b3J5LnJlc29sdmVkXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaXNBc3luY1BsYWNlaG9sZGVyIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoaXNEZWYoYykgJiYgKGlzRGVmKGMuY29tcG9uZW50T3B0aW9ucykgfHwgaXNBc3luY1BsYWNlaG9sZGVyKGMpKSkge1xuICAgICAgICAgIHJldHVybiBjXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZtLl9oYXNIb29rRXZlbnQgPSBmYWxzZTtcbiAgICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldDtcblxuICBmdW5jdGlvbiBhZGQgKGV2ZW50LCBmbikge1xuICAgIHRhcmdldC4kb24oZXZlbnQsIGZuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZSQxIChldmVudCwgZm4pIHtcbiAgICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT25jZUhhbmRsZXIgKGV2ZW50LCBmbikge1xuICAgIHZhciBfdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHJldHVybiBmdW5jdGlvbiBvbmNlSGFuZGxlciAoKSB7XG4gICAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgX3RhcmdldC4kb2ZmKGV2ZW50LCBvbmNlSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzIChcbiAgICB2bSxcbiAgICBsaXN0ZW5lcnMsXG4gICAgb2xkTGlzdGVuZXJzXG4gICkge1xuICAgIHRhcmdldCA9IHZtO1xuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgYWRkLCByZW1vdmUkMSwgY3JlYXRlT25jZUhhbmRsZXIsIHZtKTtcbiAgICB0YXJnZXQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBldmVudHNNaXhpbiAoVnVlKSB7XG4gICAgdmFyIGhvb2tSRSA9IC9eaG9vazovO1xuICAgIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgICAgdmFyIHZtID0gdGhpcztcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZtLiRvbihldmVudFtpXSwgZm4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICAgICAgLy8gb3B0aW1pemUgaG9vazpldmVudCBjb3N0IGJ5IHVzaW5nIGEgYm9vbGVhbiBmbGFnIG1hcmtlZCBhdCByZWdpc3RyYXRpb25cbiAgICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICAgIGlmIChob29rUkUudGVzdChldmVudCkpIHtcbiAgICAgICAgICB2bS5faGFzSG9va0V2ZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJG9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgICB2bS4kb2ZmKGV2ZW50LCBvbik7XG4gICAgICAgIGZuLmFwcGx5KHZtLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgb24uZm4gPSBmbjtcbiAgICAgIHZtLiRvbihldmVudCwgb24pO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJG9mZiA9IGZ1bmN0aW9uIChldmVudCwgZm4pIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICAvLyBhbGxcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcmV0dXJuIHZtXG4gICAgICB9XG4gICAgICAvLyBhcnJheSBvZiBldmVudHNcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpJDEgPCBsOyBpJDErKykge1xuICAgICAgICAgIHZtLiRvZmYoZXZlbnRbaSQxXSwgZm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bVxuICAgICAgfVxuICAgICAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICAgIGlmICghY2JzKSB7XG4gICAgICAgIHJldHVybiB2bVxuICAgICAgfVxuICAgICAgaWYgKCFmbikge1xuICAgICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICAgIHJldHVybiB2bVxuICAgICAgfVxuICAgICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgICAgdmFyIGNiO1xuICAgICAgdmFyIGkgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjYiA9IGNic1tpXTtcbiAgICAgICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAge1xuICAgICAgICB2YXIgbG93ZXJDYXNlRXZlbnQgPSBldmVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJFdmVudCBcXFwiXCIgKyBsb3dlckNhc2VFdmVudCArIFwiXFxcIiBpcyBlbWl0dGVkIGluIGNvbXBvbmVudCBcIiArXG4gICAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgICBcIk5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIFwiICtcbiAgICAgICAgICAgIFwidi1vbiB0byBsaXN0ZW4gdG8gY2FtZWxDYXNlIGV2ZW50cyB3aGVuIHVzaW5nIGluLURPTSB0ZW1wbGF0ZXMuIFwiICtcbiAgICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgICBpZiAoY2JzKSB7XG4gICAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIGluZm8gPSBcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGludm9rZVdpdGhFcnJvckhhbmRsaW5nKGNic1tpXSwgdm0sIGFyZ3MsIHZtLCBpbmZvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZtXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIHZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZXRBY3RpdmVJbnN0YW5jZSh2bSkge1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICAgIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgICAvLyBsb2NhdGUgZmlyc3Qgbm9uLWFic3RyYWN0IHBhcmVudFxuICAgIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICB3aGlsZSAocGFyZW50LiRvcHRpb25zLmFic3RyYWN0ICYmIHBhcmVudC4kcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgICAgfVxuICAgICAgcGFyZW50LiRjaGlsZHJlbi5wdXNoKHZtKTtcbiAgICB9XG5cbiAgICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICAgIHZtLiRyb290ID0gcGFyZW50ID8gcGFyZW50LiRyb290IDogdm07XG5cbiAgICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgICB2bS4kcmVmcyA9IHt9O1xuXG4gICAgdm0uX3dhdGNoZXIgPSBudWxsO1xuICAgIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gICAgdm0uX2RpcmVjdEluYWN0aXZlID0gZmFsc2U7XG4gICAgdm0uX2lzTW91bnRlZCA9IGZhbHNlO1xuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgICAgdmFyIHByZXZWbm9kZSA9IHZtLl92bm9kZTtcbiAgICAgIHZhciByZXN0b3JlQWN0aXZlSW5zdGFuY2UgPSBzZXRBY3RpdmVJbnN0YW5jZSh2bSk7XG4gICAgICB2bS5fdm5vZGUgPSB2bm9kZTtcbiAgICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgICBpZiAoIXByZXZWbm9kZSkge1xuICAgICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nLCBmYWxzZSAvKiByZW1vdmVPbmx5ICovKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVwZGF0ZXNcbiAgICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgcmVzdG9yZUFjdGl2ZUluc3RhbmNlKCk7XG4gICAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICAgIGlmIChwcmV2RWwpIHtcbiAgICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHZtLiRlbCkge1xuICAgICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgICAgfVxuICAgICAgLy8gaWYgcGFyZW50IGlzIGFuIEhPQywgdXBkYXRlIGl0cyAkZWwgYXMgd2VsbFxuICAgICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgICAvLyB1cGRhdGVkIGluIGEgcGFyZW50J3MgdXBkYXRlZCBob29rLlxuICAgIH07XG5cbiAgICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAodm0uX3dhdGNoZXIpIHtcbiAgICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgaWYgKHZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVEZXN0cm95Jyk7XG4gICAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IHZtLiRwYXJlbnQ7XG4gICAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICAgIHJlbW92ZShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgICB9XG4gICAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICAgIHZtLl93YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgICAgfVxuICAgICAgLy8gcmVtb3ZlIHJlZmVyZW5jZSBmcm9tIGRhdGEgb2JcbiAgICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgICB2bS5fZGF0YS5fX29iX18udm1Db3VudC0tO1xuICAgICAgfVxuICAgICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgICB2bS5faXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgICB2bS5fX3BhdGNoX18odm0uX3Zub2RlLCBudWxsKTtcbiAgICAgIC8vIGZpcmUgZGVzdHJveWVkIGhvb2tcbiAgICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgICAvLyB0dXJuIG9mZiBhbGwgaW5zdGFuY2UgbGlzdGVuZXJzLlxuICAgICAgdm0uJG9mZigpO1xuICAgICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgICBpZiAodm0uJGVsKSB7XG4gICAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIHJlbGVhc2UgY2lyY3VsYXIgcmVmZXJlbmNlICgjNjc1OSlcbiAgICAgIGlmICh2bS4kdm5vZGUpIHtcbiAgICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50IChcbiAgICB2bSxcbiAgICBlbCxcbiAgICBoeWRyYXRpbmdcbiAgKSB7XG4gICAgdm0uJGVsID0gZWw7XG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gICAgICB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICAgIHZtLiRvcHRpb25zLmVsIHx8IGVsKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAgICdjb21waWxlciBpcyBub3QgYXZhaWxhYmxlLiBFaXRoZXIgcHJlLWNvbXBpbGUgdGhlIHRlbXBsYXRlcyBpbnRvICcgK1xuICAgICAgICAgICAgJ3JlbmRlciBmdW5jdGlvbnMsIG9yIHVzZSB0aGUgY29tcGlsZXItaW5jbHVkZWQgYnVpbGQuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ0ZhaWxlZCB0byBtb3VudCBjb21wb25lbnQ6IHRlbXBsYXRlIG9yIHJlbmRlciBmdW5jdGlvbiBub3QgZGVmaW5lZC4nLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlTW91bnQnKTtcblxuICAgIHZhciB1cGRhdGVDb21wb25lbnQ7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuYW1lID0gdm0uX25hbWU7XG4gICAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICAgIHZhciBzdGFydFRhZyA9IFwidnVlLXBlcmYtc3RhcnQ6XCIgKyBpZDtcbiAgICAgICAgdmFyIGVuZFRhZyA9IFwidnVlLXBlcmYtZW5kOlwiICsgaWQ7XG5cbiAgICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICAgIHZhciB2bm9kZSA9IHZtLl9yZW5kZXIoKTtcbiAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgICB2bS5fdXBkYXRlKHZub2RlLCBoeWRyYXRpbmcpO1xuICAgICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgbmFtZSArIFwiIHBhdGNoXCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIHdlIHNldCB0aGlzIHRvIHZtLl93YXRjaGVyIGluc2lkZSB0aGUgd2F0Y2hlcidzIGNvbnN0cnVjdG9yXG4gICAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudGVkIGhvb2spLCB3aGljaCByZWxpZXMgb24gdm0uX3dhdGNoZXIgYmVpbmcgYWxyZWFkeSBkZWZpbmVkXG4gICAgbmV3IFdhdGNoZXIodm0sIHVwZGF0ZUNvbXBvbmVudCwgbm9vcCwge1xuICAgICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUgKCkge1xuICAgICAgICBpZiAodm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRydWUgLyogaXNSZW5kZXJXYXRjaGVyICovKTtcbiAgICBoeWRyYXRpbmcgPSBmYWxzZTtcblxuICAgIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gICAgLy8gbW91bnRlZCBpcyBjYWxsZWQgZm9yIHJlbmRlci1jcmVhdGVkIGNoaWxkIGNvbXBvbmVudHMgaW4gaXRzIGluc2VydGVkIGhvb2tcbiAgICBpZiAodm0uJHZub2RlID09IG51bGwpIHtcbiAgICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgY2FsbEhvb2sodm0sICdtb3VudGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB2bVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRDb21wb25lbnQgKFxuICAgIHZtLFxuICAgIHByb3BzRGF0YSxcbiAgICBsaXN0ZW5lcnMsXG4gICAgcGFyZW50Vm5vZGUsXG4gICAgcmVuZGVyQ2hpbGRyZW5cbiAgKSB7XG4gICAge1xuICAgICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBjb21wb25lbnQgaGFzIHNsb3QgY2hpbGRyZW5cbiAgICAvLyB3ZSBuZWVkIHRvIGRvIHRoaXMgYmVmb3JlIG92ZXJ3cml0aW5nICRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbi5cblxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBkeW5hbWljIHNjb3BlZFNsb3RzIChoYW5kLXdyaXR0ZW4gb3IgY29tcGlsZWQgYnV0IHdpdGhcbiAgICAvLyBkeW5hbWljIHNsb3QgbmFtZXMpLiBTdGF0aWMgc2NvcGVkIHNsb3RzIGNvbXBpbGVkIGZyb20gdGVtcGxhdGUgaGFzIHRoZVxuICAgIC8vIFwiJHN0YWJsZVwiIG1hcmtlci5cbiAgICB2YXIgbmV3U2NvcGVkU2xvdHMgPSBwYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzO1xuICAgIHZhciBvbGRTY29wZWRTbG90cyA9IHZtLiRzY29wZWRTbG90cztcbiAgICB2YXIgaGFzRHluYW1pY1Njb3BlZFNsb3QgPSAhIShcbiAgICAgIChuZXdTY29wZWRTbG90cyAmJiAhbmV3U2NvcGVkU2xvdHMuJHN0YWJsZSkgfHxcbiAgICAgIChvbGRTY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgJiYgIW9sZFNjb3BlZFNsb3RzLiRzdGFibGUpIHx8XG4gICAgICAobmV3U2NvcGVkU2xvdHMgJiYgdm0uJHNjb3BlZFNsb3RzLiRrZXkgIT09IG5ld1Njb3BlZFNsb3RzLiRrZXkpXG4gICAgKTtcblxuICAgIC8vIEFueSBzdGF0aWMgc2xvdCBjaGlsZHJlbiBmcm9tIHRoZSBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgcGFyZW50J3NcbiAgICAvLyB1cGRhdGUuIER5bmFtaWMgc2NvcGVkIHNsb3RzIG1heSBhbHNvIGhhdmUgY2hhbmdlZC4gSW4gc3VjaCBjYXNlcywgYSBmb3JjZWRcbiAgICAvLyB1cGRhdGUgaXMgbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcy5cbiAgICB2YXIgbmVlZHNGb3JjZVVwZGF0ZSA9ICEhKFxuICAgICAgcmVuZGVyQ2hpbGRyZW4gfHwgICAgICAgICAgICAgICAvLyBoYXMgbmV3IHN0YXRpYyBzbG90c1xuICAgICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8ICAvLyBoYXMgb2xkIHN0YXRpYyBzbG90c1xuICAgICAgaGFzRHluYW1pY1Njb3BlZFNsb3RcbiAgICApO1xuXG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlID0gcGFyZW50Vm5vZGU7XG4gICAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICAgIGlmICh2bS5fdm5vZGUpIHsgLy8gdXBkYXRlIGNoaWxkIHRyZWUncyBwYXJlbnRcbiAgICAgIHZtLl92bm9kZS5wYXJlbnQgPSBwYXJlbnRWbm9kZTtcbiAgICB9XG4gICAgdm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuID0gcmVuZGVyQ2hpbGRyZW47XG5cbiAgICAvLyB1cGRhdGUgJGF0dHJzIGFuZCAkbGlzdGVuZXJzIGhhc2hcbiAgICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgICAvLyB1c2VkIHRoZW0gZHVyaW5nIHJlbmRlclxuICAgIHZtLiRhdHRycyA9IHBhcmVudFZub2RlLmRhdGEuYXR0cnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgdm0uJGxpc3RlbmVycyA9IGxpc3RlbmVycyB8fCBlbXB0eU9iamVjdDtcblxuICAgIC8vIHVwZGF0ZSBwcm9wc1xuICAgIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICAgIHRvZ2dsZU9ic2VydmluZyhmYWxzZSk7XG4gICAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgICB2YXIgcHJvcEtleXMgPSB2bS4kb3B0aW9ucy5fcHJvcEtleXMgfHwgW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgICAgdmFyIHByb3BPcHRpb25zID0gdm0uJG9wdGlvbnMucHJvcHM7IC8vIHd0ZiBmbG93P1xuICAgICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSwgdm0pO1xuICAgICAgfVxuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKHRydWUpO1xuICAgICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG4gICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycywgb2xkTGlzdGVuZXJzKTtcblxuICAgIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gICAgaWYgKG5lZWRzRm9yY2VVcGRhdGUpIHtcbiAgICAgIHZtLiRzbG90cyA9IHJlc29sdmVTbG90cyhyZW5kZXJDaGlsZHJlbiwgcGFyZW50Vm5vZGUuY29udGV4dCk7XG4gICAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc0luSW5hY3RpdmVUcmVlICh2bSkge1xuICAgIHdoaWxlICh2bSAmJiAodm0gPSB2bS4kcGFyZW50KSkge1xuICAgICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGVDaGlsZENvbXBvbmVudCAodm0sIGRpcmVjdCkge1xuICAgIGlmIChkaXJlY3QpIHtcbiAgICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm0uX2RpcmVjdEluYWN0aXZlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSB8fCB2bS5faW5hY3RpdmUgPT09IG51bGwpIHtcbiAgICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgICBpZiAoZGlyZWN0KSB7XG4gICAgICB2bS5fZGlyZWN0SW5hY3RpdmUgPSB0cnVlO1xuICAgICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXZtLl9pbmFjdGl2ZSkge1xuICAgICAgdm0uX2luYWN0aXZlID0gdHJ1ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudCh2bS4kY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICAgIC8vICM3NTczIGRpc2FibGUgZGVwIGNvbGxlY3Rpb24gd2hlbiBpbnZva2luZyBsaWZlY3ljbGUgaG9va3NcbiAgICBwdXNoVGFyZ2V0KCk7XG4gICAgdmFyIGhhbmRsZXJzID0gdm0uJG9wdGlvbnNbaG9va107XG4gICAgdmFyIGluZm8gPSBob29rICsgXCIgaG9va1wiO1xuICAgIGlmIChoYW5kbGVycykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaW52b2tlV2l0aEVycm9ySGFuZGxpbmcoaGFuZGxlcnNbaV0sIHZtLCBudWxsLCB2bSwgaW5mbyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2bS5faGFzSG9va0V2ZW50KSB7XG4gICAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gICAgfVxuICAgIHBvcFRhcmdldCgpO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbiAgdmFyIHF1ZXVlID0gW107XG4gIHZhciBhY3RpdmF0ZWRDaGlsZHJlbiA9IFtdO1xuICB2YXIgaGFzID0ge307XG4gIHZhciBjaXJjdWxhciA9IHt9O1xuICB2YXIgd2FpdGluZyA9IGZhbHNlO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICAvKipcbiAgICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVzZXRTY2hlZHVsZXJTdGF0ZSAoKSB7XG4gICAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIGhhcyA9IHt9O1xuICAgIHtcbiAgICAgIGNpcmN1bGFyID0ge307XG4gICAgfVxuICAgIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gQXN5bmMgZWRnZSBjYXNlICM2NTY2IHJlcXVpcmVzIHNhdmluZyB0aGUgdGltZXN0YW1wIHdoZW4gZXZlbnQgbGlzdGVuZXJzIGFyZVxuICAvLyBhdHRhY2hlZC4gSG93ZXZlciwgY2FsbGluZyBwZXJmb3JtYW5jZS5ub3coKSBoYXMgYSBwZXJmIG92ZXJoZWFkIGVzcGVjaWFsbHlcbiAgLy8gaWYgdGhlIHBhZ2UgaGFzIHRob3VzYW5kcyBvZiBldmVudCBsaXN0ZW5lcnMuIEluc3RlYWQsIHdlIHRha2UgYSB0aW1lc3RhbXBcbiAgLy8gZXZlcnkgdGltZSB0aGUgc2NoZWR1bGVyIGZsdXNoZXMgYW5kIHVzZSB0aGF0IGZvciBhbGwgZXZlbnQgbGlzdGVuZXJzXG4gIC8vIGF0dGFjaGVkIGR1cmluZyB0aGF0IGZsdXNoLlxuICB2YXIgY3VycmVudEZsdXNoVGltZXN0YW1wID0gMDtcblxuICAvLyBBc3luYyBlZGdlIGNhc2UgZml4IHJlcXVpcmVzIHN0b3JpbmcgYW4gZXZlbnQgbGlzdGVuZXIncyBhdHRhY2ggdGltZXN0YW1wLlxuICB2YXIgZ2V0Tm93ID0gRGF0ZS5ub3c7XG5cbiAgLy8gRGV0ZXJtaW5lIHdoYXQgZXZlbnQgdGltZXN0YW1wIHRoZSBicm93c2VyIGlzIHVzaW5nLiBBbm5veWluZ2x5LCB0aGVcbiAgLy8gdGltZXN0YW1wIGNhbiBlaXRoZXIgYmUgaGktcmVzIChyZWxhdGl2ZSB0byBwYWdlIGxvYWQpIG9yIGxvdy1yZXNcbiAgLy8gKHJlbGF0aXZlIHRvIFVOSVggZXBvY2gpLCBzbyBpbiBvcmRlciB0byBjb21wYXJlIHRpbWUgd2UgaGF2ZSB0byB1c2UgdGhlXG4gIC8vIHNhbWUgdGltZXN0YW1wIHR5cGUgd2hlbiBzYXZpbmcgdGhlIGZsdXNoIHRpbWVzdGFtcC5cbiAgaWYgKGluQnJvd3NlciAmJiBnZXROb3coKSA+IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpLnRpbWVTdGFtcCkge1xuICAgIC8vIGlmIHRoZSBsb3ctcmVzIHRpbWVzdGFtcCB3aGljaCBpcyBiaWdnZXIgdGhhbiB0aGUgZXZlbnQgdGltZXN0YW1wXG4gICAgLy8gKHdoaWNoIGlzIGV2YWx1YXRlZCBBRlRFUikgaXQgbWVhbnMgdGhlIGV2ZW50IGlzIHVzaW5nIGEgaGktcmVzIHRpbWVzdGFtcCxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byB1c2UgdGhlIGhpLXJlcyB2ZXJzaW9uIGZvciBldmVudCBsaXN0ZW5lcnMgYXMgd2VsbC5cbiAgICBnZXROb3cgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCBib3RoIHF1ZXVlcyBhbmQgcnVuIHRoZSB3YXRjaGVycy5cbiAgICovXG4gIGZ1bmN0aW9uIGZsdXNoU2NoZWR1bGVyUXVldWUgKCkge1xuICAgIGN1cnJlbnRGbHVzaFRpbWVzdGFtcCA9IGdldE5vdygpO1xuICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgICAvLyBTb3J0IHF1ZXVlIGJlZm9yZSBmbHVzaC5cbiAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gICAgLy8gICAgY3JlYXRlZCBiZWZvcmUgdGhlIGNoaWxkKVxuICAgIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gICAgLy8gMy4gSWYgYSBjb21wb25lbnQgaXMgZGVzdHJveWVkIGR1cmluZyBhIHBhcmVudCBjb21wb25lbnQncyB3YXRjaGVyIHJ1bixcbiAgICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gICAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gICAgLy8gZG8gbm90IGNhY2hlIGxlbmd0aCBiZWNhdXNlIG1vcmUgd2F0Y2hlcnMgbWlnaHQgYmUgcHVzaGVkXG4gICAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgICAgaWYgKHdhdGNoZXIuYmVmb3JlKSB7XG4gICAgICAgIHdhdGNoZXIuYmVmb3JlKCk7XG4gICAgICB9XG4gICAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgICBoYXNbaWRdID0gbnVsbDtcbiAgICAgIHdhdGNoZXIucnVuKCk7XG4gICAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgICBpZiAoaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICAgIGNpcmN1bGFyW2lkXSA9IChjaXJjdWxhcltpZF0gfHwgMCkgKyAxO1xuICAgICAgICBpZiAoY2lyY3VsYXJbaWRdID4gTUFYX1VQREFURV9DT1VOVCkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wICcgKyAoXG4gICAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgICA6IFwiaW4gYSBjb21wb25lbnQgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgICB2YXIgYWN0aXZhdGVkUXVldWUgPSBhY3RpdmF0ZWRDaGlsZHJlbi5zbGljZSgpO1xuICAgIHZhciB1cGRhdGVkUXVldWUgPSBxdWV1ZS5zbGljZSgpO1xuXG4gICAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gICAgLy8gY2FsbCBjb21wb25lbnQgdXBkYXRlZCBhbmQgYWN0aXZhdGVkIGhvb2tzXG4gICAgY2FsbEFjdGl2YXRlZEhvb2tzKGFjdGl2YXRlZFF1ZXVlKTtcbiAgICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgICAvLyBkZXZ0b29sIGhvb2tcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxVcGRhdGVkSG9va3MgKHF1ZXVlKSB7XG4gICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFyIHdhdGNoZXIgPSBxdWV1ZVtpXTtcbiAgICAgIHZhciB2bSA9IHdhdGNoZXIudm07XG4gICAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCAmJiAhdm0uX2lzRGVzdHJveWVkKSB7XG4gICAgICAgIGNhbGxIb29rKHZtLCAndXBkYXRlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWV1ZSBhIGtlcHQtYWxpdmUgY29tcG9uZW50IHRoYXQgd2FzIGFjdGl2YXRlZCBkdXJpbmcgcGF0Y2guXG4gICAqIFRoZSBxdWV1ZSB3aWxsIGJlIHByb2Nlc3NlZCBhZnRlciB0aGUgZW50aXJlIHRyZWUgaGFzIGJlZW4gcGF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIHF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50ICh2bSkge1xuICAgIC8vIHNldHRpbmcgX2luYWN0aXZlIHRvIGZhbHNlIGhlcmUgc28gdGhhdCBhIHJlbmRlciBmdW5jdGlvbiBjYW5cbiAgICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICAgIHZtLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGFjdGl2YXRlZENoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEFjdGl2YXRlZEhvb2tzIChxdWV1ZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KHF1ZXVlW2ldLCB0cnVlIC8qIHRydWUgKi8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoIGEgd2F0Y2hlciBpbnRvIHRoZSB3YXRjaGVyIHF1ZXVlLlxuICAgKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAgICogcHVzaGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGJlaW5nIGZsdXNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgICB2YXIgaWQgPSB3YXRjaGVyLmlkO1xuICAgIGlmIChoYXNbaWRdID09IG51bGwpIHtcbiAgICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgYWxyZWFkeSBmbHVzaGluZywgc3BsaWNlIHRoZSB3YXRjaGVyIGJhc2VkIG9uIGl0cyBpZFxuICAgICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICAgIHdoaWxlIChpID4gaW5kZXggJiYgcXVldWVbaV0uaWQgPiB3YXRjaGVyLmlkKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlLnNwbGljZShpICsgMSwgMCwgd2F0Y2hlcik7XG4gICAgICB9XG4gICAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICAgIGlmICghd2FpdGluZykge1xuICAgICAgICB3YWl0aW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAoIWNvbmZpZy5hc3luYykge1xuICAgICAgICAgIGZsdXNoU2NoZWR1bGVyUXVldWUoKTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBuZXh0VGljayhmbHVzaFNjaGVkdWxlclF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuXG5cbiAgdmFyIHVpZCQyID0gMDtcblxuICAvKipcbiAgICogQSB3YXRjaGVyIHBhcnNlcyBhbiBleHByZXNzaW9uLCBjb2xsZWN0cyBkZXBlbmRlbmNpZXMsXG4gICAqIGFuZCBmaXJlcyBjYWxsYmFjayB3aGVuIHRoZSBleHByZXNzaW9uIHZhbHVlIGNoYW5nZXMuXG4gICAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICAgKi9cbiAgdmFyIFdhdGNoZXIgPSBmdW5jdGlvbiBXYXRjaGVyIChcbiAgICB2bSxcbiAgICBleHBPckZuLFxuICAgIGNiLFxuICAgIG9wdGlvbnMsXG4gICAgaXNSZW5kZXJXYXRjaGVyXG4gICkge1xuICAgIHRoaXMudm0gPSB2bTtcbiAgICBpZiAoaXNSZW5kZXJXYXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlciA9IHRoaXM7XG4gICAgfVxuICAgIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAgIC8vIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgdGhpcy5kZWVwID0gISFvcHRpb25zLmRlZXA7XG4gICAgICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgICAgdGhpcy5zeW5jID0gISFvcHRpb25zLnN5bmM7XG4gICAgICB0aGlzLmJlZm9yZSA9IG9wdGlvbnMuYmVmb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlZXAgPSB0aGlzLnVzZXIgPSB0aGlzLmxhenkgPSB0aGlzLnN5bmMgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jYiA9IGNiO1xuICAgIHRoaXMuaWQgPSArK3VpZCQyOyAvLyB1aWQgZm9yIGJhdGNoaW5nXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuZGlydHkgPSB0aGlzLmxhenk7IC8vIGZvciBsYXp5IHdhdGNoZXJzXG4gICAgdGhpcy5kZXBzID0gW107XG4gICAgdGhpcy5uZXdEZXBzID0gW107XG4gICAgdGhpcy5kZXBJZHMgPSBuZXcgX1NldCgpO1xuICAgIHRoaXMubmV3RGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gICAgLy8gcGFyc2UgZXhwcmVzc2lvbiBmb3IgZ2V0dGVyXG4gICAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmdldHRlciA9IGV4cE9yRm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgICAgaWYgKCF0aGlzLmdldHRlcikge1xuICAgICAgICB0aGlzLmdldHRlciA9IG5vb3A7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJGYWlsZWQgd2F0Y2hpbmcgcGF0aDogXFxcIlwiICsgZXhwT3JGbiArIFwiXFxcIiBcIiArXG4gICAgICAgICAgJ1dhdGNoZXIgb25seSBhY2NlcHRzIHNpbXBsZSBkb3QtZGVsaW1pdGVkIHBhdGhzLiAnICtcbiAgICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB0aGlzLmxhenlcbiAgICAgID8gdW5kZWZpbmVkXG4gICAgICA6IHRoaXMuZ2V0KCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoZSBnZXR0ZXIsIGFuZCByZS1jb2xsZWN0IGRlcGVuZGVuY2llcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcHVzaFRhcmdldCh0aGlzKTtcbiAgICB2YXIgdmFsdWU7XG4gICAgdmFyIHZtID0gdGhpcy52bTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldHRlci5jYWxsKHZtLCB2bSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKFwiZ2V0dGVyIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gXCJ0b3VjaFwiIGV2ZXJ5IHByb3BlcnR5IHNvIHRoZXkgYXJlIGFsbCB0cmFja2VkIGFzXG4gICAgICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgICAgdHJhdmVyc2UodmFsdWUpO1xuICAgICAgfVxuICAgICAgcG9wVGFyZ2V0KCk7XG4gICAgICB0aGlzLmNsZWFudXBEZXBzKCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgICB2YXIgaWQgPSBkZXAuaWQ7XG4gICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoaWQpKSB7XG4gICAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICAgIGlmICghdGhpcy5kZXBJZHMuaGFzKGlkKSkge1xuICAgICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xlYW4gdXAgZm9yIGRlcGVuZGVuY3kgY29sbGVjdGlvbi5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB2YXIgZGVwID0gdGhpcy5kZXBzW2ldO1xuICAgICAgaWYgKCF0aGlzLm5ld0RlcElkcy5oYXMoZGVwLmlkKSkge1xuICAgICAgICBkZXAucmVtb3ZlU3ViKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdG1wID0gdGhpcy5kZXBJZHM7XG4gICAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgICB0aGlzLm5ld0RlcElkcy5jbGVhcigpO1xuICAgIHRtcCA9IHRoaXMuZGVwcztcbiAgICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gICAgdGhpcy5uZXdEZXBzID0gdG1wO1xuICAgIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAgICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAgICovXG4gIFdhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodGhpcy5sYXp5KSB7XG4gICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogU2NoZWR1bGVyIGpvYiBpbnRlcmZhY2UuXG4gICAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiBydW4gKCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsdWUgIT09IHRoaXMudmFsdWUgfHxcbiAgICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgICAgLy8gaGF2ZSBtdXRhdGVkLlxuICAgICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgICAgdGhpcy5kZWVwXG4gICAgICApIHtcbiAgICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdGhpcy52bSwgKFwiY2FsbGJhY2sgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogRXZhbHVhdGUgdGhlIHZhbHVlIG9mIHRoZSB3YXRjaGVyLlxuICAgKiBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgZm9yIGxhenkgd2F0Y2hlcnMuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS5ldmFsdWF0ZSA9IGZ1bmN0aW9uIGV2YWx1YXRlICgpIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICAgKi9cbiAgV2F0Y2hlci5wcm90b3R5cGUuZGVwZW5kID0gZnVuY3Rpb24gZGVwZW5kICgpIHtcbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5kZXBzW2ldLmRlcGVuZCgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUmVtb3ZlIHNlbGYgZnJvbSBhbGwgZGVwZW5kZW5jaWVzJyBzdWJzY3JpYmVyIGxpc3QuXG4gICAqL1xuICBXYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIC8vIHJlbW92ZSBzZWxmIGZyb20gdm0ncyB3YXRjaGVyIGxpc3RcbiAgICAgIC8vIHRoaXMgaXMgYSBzb21ld2hhdCBleHBlbnNpdmUgb3BlcmF0aW9uIHNvIHdlIHNraXAgaXRcbiAgICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICBpZiAoIXRoaXMudm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgICAgcmVtb3ZlKHRoaXMudm0uX3dhdGNoZXJzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5kZXBzW2ldLnJlbW92ZVN1Yih0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24gPSB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBub29wLFxuICAgIHNldDogbm9vcFxuICB9O1xuXG4gIGZ1bmN0aW9uIHByb3h5ICh0YXJnZXQsIHNvdXJjZUtleSwga2V5KSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IGZ1bmN0aW9uIHByb3h5R2V0dGVyICgpIHtcbiAgICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICAgIH07XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IGZ1bmN0aW9uIHByb3h5U2V0dGVyICh2YWwpIHtcbiAgICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICAgIHZtLl93YXRjaGVycyA9IFtdO1xuICAgIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gICAgaWYgKG9wdHMucHJvcHMpIHsgaW5pdFByb3BzKHZtLCBvcHRzLnByb3BzKTsgfVxuICAgIGlmIChvcHRzLm1ldGhvZHMpIHsgaW5pdE1ldGhvZHModm0sIG9wdHMubWV0aG9kcyk7IH1cbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICBpbml0RGF0YSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY29tcHV0ZWQpIHsgaW5pdENvbXB1dGVkKHZtLCBvcHRzLmNvbXB1dGVkKTsgfVxuICAgIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgICBpbml0V2F0Y2godm0sIG9wdHMud2F0Y2gpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyAodm0sIHByb3BzT3B0aW9ucykge1xuICAgIHZhciBwcm9wc0RhdGEgPSB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgfHwge307XG4gICAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gICAgLy8gY2FjaGUgcHJvcCBrZXlzIHNvIHRoYXQgZnV0dXJlIHByb3BzIHVwZGF0ZXMgY2FuIGl0ZXJhdGUgdXNpbmcgQXJyYXlcbiAgICAvLyBpbnN0ZWFkIG9mIGR5bmFtaWMgb2JqZWN0IGtleSBlbnVtZXJhdGlvbi5cbiAgICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICAgIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICBpZiAoIWlzUm9vdCkge1xuICAgICAgdG9nZ2xlT2JzZXJ2aW5nKGZhbHNlKTtcbiAgICB9XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICB7XG4gICAgICAgIHZhciBoeXBoZW5hdGVkS2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICAgIGlmIChpc1Jlc2VydmVkQXR0cmlidXRlKGh5cGhlbmF0ZWRLZXkpIHx8XG4gICAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgKFwiXFxcIlwiICsgaHlwaGVuYXRlZEtleSArIFwiXFxcIiBpcyBhIHJlc2VydmVkIGF0dHJpYnV0ZSBhbmQgY2Fubm90IGJlIHVzZWQgYXMgY29tcG9uZW50IHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWN0aXZlJCQxKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFpc1Jvb3QgJiYgIWlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIHByb3BzIGFyZSBhbHJlYWR5IHByb3hpZWQgb24gdGhlIGNvbXBvbmVudCdzIHByb3RvdHlwZVxuICAgICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAgIC8vIGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICAgIHRvZ2dsZU9ic2VydmluZyh0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXREYXRhICh2bSkge1xuICAgIHZhciBkYXRhID0gdm0uJG9wdGlvbnMuZGF0YTtcbiAgICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgPyBnZXREYXRhKGRhdGEsIHZtKVxuICAgICAgOiBkYXRhIHx8IHt9O1xuICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgZGF0YSA9IHt9O1xuICAgICAgd2FybihcbiAgICAgICAgJ2RhdGEgZnVuY3Rpb25zIHNob3VsZCByZXR1cm4gYW4gb2JqZWN0OlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIHZhciBtZXRob2RzID0gdm0uJG9wdGlvbnMubWV0aG9kcztcbiAgICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAge1xuICAgICAgICBpZiAobWV0aG9kcyAmJiBoYXNPd24obWV0aG9kcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHByb3h5KHZtLCBcIl9kYXRhXCIsIGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIG9ic2VydmUgZGF0YVxuICAgIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERhdGEgKGRhdGEsIHZtKSB7XG4gICAgLy8gIzc1NzMgZGlzYWJsZSBkZXAgY29sbGVjdGlvbiB3aGVuIGludm9raW5nIGRhdGEgZ2V0dGVyc1xuICAgIHB1c2hUYXJnZXQoKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGRhdGEuY2FsbCh2bSwgdm0pXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwiZGF0YSgpXCIpO1xuICAgICAgcmV0dXJuIHt9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHBvcFRhcmdldCgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21wdXRlZFdhdGNoZXJPcHRpb25zID0geyBsYXp5OiB0cnVlIH07XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSwgY29tcHV0ZWQpIHtcbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gY29tcHV0ZWQgcHJvcGVydGllcyBhcmUganVzdCBnZXR0ZXJzIGR1cmluZyBTU1JcbiAgICB2YXIgaXNTU1IgPSBpc1NlcnZlclJlbmRlcmluZygpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICB2YXIgZ2V0dGVyID0gdHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicgPyB1c2VyRGVmIDogdXNlckRlZi5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJHZXR0ZXIgaXMgbWlzc2luZyBmb3IgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiKSxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU1NSKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICAgIHdhdGNoZXJzW2tleV0gPSBuZXcgV2F0Y2hlcihcbiAgICAgICAgICB2bSxcbiAgICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgICBub29wLFxuICAgICAgICAgIGNvbXB1dGVkV2F0Y2hlck9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcG9uZW50LWRlZmluZWQgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZVxuICAgICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAgIC8vIGF0IGluc3RhbnRpYXRpb24gaGVyZS5cbiAgICAgIGlmICghKGtleSBpbiB2bSkpIHtcbiAgICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgICAgd2FybigoXCJUaGUgY29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIGFscmVhZHkgZGVmaW5lZCBpbiBkYXRhLlwiKSwgdm0pO1xuICAgICAgICB9IGVsc2UgaWYgKHZtLiRvcHRpb25zLnByb3BzICYmIGtleSBpbiB2bS4kb3B0aW9ucy5wcm9wcykge1xuICAgICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVmaW5lQ29tcHV0ZWQgKFxuICAgIHRhcmdldCxcbiAgICBrZXksXG4gICAgdXNlckRlZlxuICApIHtcbiAgICB2YXIgc2hvdWxkQ2FjaGUgPSAhaXNTZXJ2ZXJSZW5kZXJpbmcoKTtcbiAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgICA/IGNyZWF0ZUNvbXB1dGVkR2V0dGVyKGtleSlcbiAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYpO1xuICAgICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSB1c2VyRGVmLmdldFxuICAgICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICAgICAgOiBjcmVhdGVHZXR0ZXJJbnZva2VyKHVzZXJEZWYuZ2V0KVxuICAgICAgICA6IG5vb3A7XG4gICAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gdXNlckRlZi5zZXQgfHwgbm9vcDtcbiAgICB9XG4gICAgaWYgKHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgICAgdGhpc1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIgKGtleSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgICAgaWYgKHdhdGNoZXIpIHtcbiAgICAgICAgaWYgKHdhdGNoZXIuZGlydHkpIHtcbiAgICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERlcC50YXJnZXQpIHtcbiAgICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3YXRjaGVyLnZhbHVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlR2V0dGVySW52b2tlcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBjb21wdXRlZEdldHRlciAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCB0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRNZXRob2RzICh2bSwgbWV0aG9kcykge1xuICAgIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiTWV0aG9kIFxcXCJcIiArIGtleSArIFwiXFxcIiBoYXMgdHlwZSBcXFwiXCIgKyAodHlwZW9mIG1ldGhvZHNba2V5XSkgKyBcIlxcXCIgaW4gdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLiBcIiArXG4gICAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzICYmIGhhc093bihwcm9wcywga2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoa2V5IGluIHZtKSAmJiBpc1Jlc2VydmVkKGtleSkpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICAgIFwiQXZvaWQgZGVmaW5pbmcgY29tcG9uZW50IG1ldGhvZHMgdGhhdCBzdGFydCB3aXRoIF8gb3IgJC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZtW2tleV0gPSB0eXBlb2YgbWV0aG9kc1trZXldICE9PSAnZnVuY3Rpb24nID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gd2F0Y2gpIHtcbiAgICAgIHZhciBoYW5kbGVyID0gd2F0Y2hba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcltpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZVdhdGNoZXIodm0sIGtleSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gICAgdm0sXG4gICAgZXhwT3JGbixcbiAgICBoYW5kbGVyLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuaGFuZGxlcjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgICAgaGFuZGxlciA9IHZtW2hhbmRsZXJdO1xuICAgIH1cbiAgICByZXR1cm4gdm0uJHdhdGNoKGV4cE9yRm4sIGhhbmRsZXIsIG9wdGlvbnMpXG4gIH1cblxuICBmdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgICAvLyBmbG93IHNvbWVob3cgaGFzIHByb2JsZW1zIHdpdGggZGlyZWN0bHkgZGVjbGFyZWQgZGVmaW5pdGlvbiBvYmplY3RcbiAgICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gICAgdmFyIGRhdGFEZWYgPSB7fTtcbiAgICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RhdGEgfTtcbiAgICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgICBwcm9wc0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9wcm9wcyB9O1xuICAgIHtcbiAgICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICAgJ1VzZSBuZXN0ZWQgZGF0YSBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKFwiJHByb3BzIGlzIHJlYWRvbmx5LlwiLCB0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGRhdGEnLCBkYXRhRGVmKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRwcm9wcycsIHByb3BzRGVmKTtcblxuICAgIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgICBWdWUucHJvdG90eXBlLiR3YXRjaCA9IGZ1bmN0aW9uIChcbiAgICAgIGV4cE9yRm4sXG4gICAgICBjYixcbiAgICAgIG9wdGlvbnNcbiAgICApIHtcbiAgICAgIHZhciB2bSA9IHRoaXM7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdChjYikpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgICAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZXhwT3JGbiwgY2IsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY2IuY2FsbCh2bSwgd2F0Y2hlci52YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZXJyb3IsIHZtLCAoXCJjYWxsYmFjayBmb3IgaW1tZWRpYXRlIHdhdGNoZXIgXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgICAgd2F0Y2hlci50ZWFyZG93bigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgdWlkJDMgPSAwO1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiAoVnVlKSB7XG4gICAgVnVlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICB2YXIgdm0gPSB0aGlzO1xuICAgICAgLy8gYSB1aWRcbiAgICAgIHZtLl91aWQgPSB1aWQkMysrO1xuXG4gICAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgICAgIHN0YXJ0VGFnID0gXCJ2dWUtcGVyZi1zdGFydDpcIiArICh2bS5fdWlkKTtcbiAgICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICAgIG1hcmsoc3RhcnRUYWcpO1xuICAgICAgfVxuXG4gICAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAgIC8vIG1lcmdlIG9wdGlvbnNcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAgIC8vIHNpbmNlIGR5bmFtaWMgb3B0aW9ucyBtZXJnaW5nIGlzIHByZXR0eSBzbG93LCBhbmQgbm9uZSBvZiB0aGVcbiAgICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgICBvcHRpb25zIHx8IHt9LFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAge1xuICAgICAgICBpbml0UHJveHkodm0pO1xuICAgICAgfVxuICAgICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgICAgdm0uX3NlbGYgPSB2bTtcbiAgICAgIGluaXRMaWZlY3ljbGUodm0pO1xuICAgICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgICBpbml0UmVuZGVyKHZtKTtcbiAgICAgIGNhbGxIb29rKHZtLCAnYmVmb3JlQ3JlYXRlJyk7XG4gICAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgICAgaW5pdFN0YXRlKHZtKTtcbiAgICAgIGluaXRQcm92aWRlKHZtKTsgLy8gcmVzb2x2ZSBwcm92aWRlIGFmdGVyIGRhdGEvcHJvcHNcbiAgICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICB2bS5fbmFtZSA9IGZvcm1hdENvbXBvbmVudE5hbWUodm0sIGZhbHNlKTtcbiAgICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh2bS5fbmFtZSkgKyBcIiBpbml0XCIpLCBzdGFydFRhZywgZW5kVGFnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICAgIHZtLiRtb3VudCh2bS4kb3B0aW9ucy5lbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgICAvLyBkb2luZyB0aGlzIGJlY2F1c2UgaXQncyBmYXN0ZXIgdGhhbiBkeW5hbWljIGVudW1lcmF0aW9uLlxuICAgIHZhciBwYXJlbnRWbm9kZSA9IG9wdGlvbnMuX3BhcmVudFZub2RlO1xuICAgIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gICAgb3B0cy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcblxuICAgIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSBwYXJlbnRWbm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIG9wdHMucHJvcHNEYXRhID0gdm5vZGVDb21wb25lbnRPcHRpb25zLnByb3BzRGF0YTtcbiAgICBvcHRzLl9wYXJlbnRMaXN0ZW5lcnMgPSB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzO1xuICAgIG9wdHMuX3JlbmRlckNoaWxkcmVuID0gdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuO1xuICAgIG9wdHMuX2NvbXBvbmVudFRhZyA9IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWc7XG5cbiAgICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIG9wdHMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICBvcHRzLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMgKEN0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgICBpZiAoQ3Rvci5zdXBlcikge1xuICAgICAgdmFyIHN1cGVyT3B0aW9ucyA9IHJlc29sdmVDb25zdHJ1Y3Rvck9wdGlvbnMoQ3Rvci5zdXBlcik7XG4gICAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgICAgLy8gc3VwZXIgb3B0aW9uIGNoYW5nZWQsXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgICAgQ3Rvci5zdXBlck9wdGlvbnMgPSBzdXBlck9wdGlvbnM7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgbGF0ZS1tb2RpZmllZC9hdHRhY2hlZCBvcHRpb25zICgjNDk3NilcbiAgICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAgIC8vIHVwZGF0ZSBiYXNlIGV4dGVuZCBvcHRpb25zXG4gICAgICAgIGlmIChtb2RpZmllZE9wdGlvbnMpIHtcbiAgICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoc3VwZXJPcHRpb25zLCBDdG9yLmV4dGVuZE9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgICAgb3B0aW9ucy5jb21wb25lbnRzW29wdGlvbnMubmFtZV0gPSBDdG9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlTW9kaWZpZWRPcHRpb25zIChDdG9yKSB7XG4gICAgdmFyIG1vZGlmaWVkO1xuICAgIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gICAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgICBmb3IgKHZhciBrZXkgaW4gbGF0ZXN0KSB7XG4gICAgICBpZiAobGF0ZXN0W2tleV0gIT09IHNlYWxlZFtrZXldKSB7XG4gICAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgICBtb2RpZmllZFtrZXldID0gbGF0ZXN0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtb2RpZmllZFxuICB9XG5cbiAgZnVuY3Rpb24gVnVlIChvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZ1ZSlcbiAgICApIHtcbiAgICAgIHdhcm4oJ1Z1ZSBpcyBhIGNvbnN0cnVjdG9yIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQnKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdChvcHRpb25zKTtcbiAgfVxuXG4gIGluaXRNaXhpbihWdWUpO1xuICBzdGF0ZU1peGluKFZ1ZSk7XG4gIGV2ZW50c01peGluKFZ1ZSk7XG4gIGxpZmVjeWNsZU1peGluKFZ1ZSk7XG4gIHJlbmRlck1peGluKFZ1ZSk7XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gICAgVnVlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgICAgaWYgKGluc3RhbGxlZFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cblxuICAgICAgLy8gYWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luLmluc3RhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwbHVnaW4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9XG4gICAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRNaXhpbiQxIChWdWUpIHtcbiAgICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyh0aGlzLm9wdGlvbnMsIG1peGluKTtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfTtcbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICAgKiBjb25zdHJ1Y3RvcnNcIiBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZSBhbmQgY2FjaGUgdGhlbS5cbiAgICAgKi9cbiAgICBWdWUuY2lkID0gMDtcbiAgICB2YXIgY2lkID0gMTtcblxuICAgIC8qKlxuICAgICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAgICovXG4gICAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBTdXBlciA9IHRoaXM7XG4gICAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgICBpZiAoY2FjaGVkQ3RvcnNbU3VwZXJJZF0pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShuYW1lKTtcbiAgICAgIH1cblxuICAgICAgdmFyIFN1YiA9IGZ1bmN0aW9uIFZ1ZUNvbXBvbmVudCAob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9pbml0KG9wdGlvbnMpO1xuICAgICAgfTtcbiAgICAgIFN1Yi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN1cGVyLnByb3RvdHlwZSk7XG4gICAgICBTdWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3ViO1xuICAgICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgICAgU3ViLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnMoXG4gICAgICAgIFN1cGVyLm9wdGlvbnMsXG4gICAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICAgICk7XG4gICAgICBTdWJbJ3N1cGVyJ10gPSBTdXBlcjtcblxuICAgICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAgIC8vIHRoZSBWdWUgaW5zdGFuY2VzIGF0IGV4dGVuc2lvbiB0aW1lLCBvbiB0aGUgZXh0ZW5kZWQgcHJvdG90eXBlLiBUaGlzXG4gICAgICAvLyBhdm9pZHMgT2JqZWN0LmRlZmluZVByb3BlcnR5IGNhbGxzIGZvciBlYWNoIGluc3RhbmNlIGNyZWF0ZWQuXG4gICAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgICAgaW5pdFByb3BzJDEoU3ViKTtcbiAgICAgIH1cbiAgICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgICBpbml0Q29tcHV0ZWQkMShTdWIpO1xuICAgICAgfVxuXG4gICAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgICBTdWIubWl4aW4gPSBTdXBlci5taXhpbjtcbiAgICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAgIC8vIGNyZWF0ZSBhc3NldCByZWdpc3RlcnMsIHNvIGV4dGVuZGVkIGNsYXNzZXNcbiAgICAgIC8vIGNhbiBoYXZlIHRoZWlyIHByaXZhdGUgYXNzZXRzIHRvby5cbiAgICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgU3ViW3R5cGVdID0gU3VwZXJbdHlwZV07XG4gICAgICB9KTtcbiAgICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgICB9XG5cbiAgICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgICAvLyBsYXRlciBhdCBpbnN0YW50aWF0aW9uIHdlIGNhbiBjaGVjayBpZiBTdXBlcidzIG9wdGlvbnMgaGF2ZVxuICAgICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgICBTdWIuZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnM7XG4gICAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgICAvLyBjYWNoZSBjb25zdHJ1Y3RvclxuICAgICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgICByZXR1cm4gU3ViXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gICAgdmFyIHByb3BzID0gQ29tcC5vcHRpb25zLnByb3BzO1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgICB2YXIgY29tcHV0ZWQgPSBDb21wLm9wdGlvbnMuY29tcHV0ZWQ7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBpbml0QXNzZXRSZWdpc3RlcnMgKFZ1ZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICAgKi9cbiAgICBBU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICAgIGlkLFxuICAgICAgICBkZWZpbml0aW9uXG4gICAgICApIHtcbiAgICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlQ29tcG9uZW50TmFtZShpZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBpc1BsYWluT2JqZWN0KGRlZmluaXRpb24pKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qICAqL1xuXG5cblxuICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lIChvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG4gIH1cblxuICBmdW5jdGlvbiBtYXRjaGVzIChwYXR0ZXJuLCBuYW1lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICAgIH0gZWxzZSBpZiAoaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QobmFtZSlcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHBydW5lQ2FjaGUgKGtlZXBBbGl2ZUluc3RhbmNlLCBmaWx0ZXIpIHtcbiAgICB2YXIgY2FjaGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5jYWNoZTtcbiAgICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gICAgdmFyIF92bm9kZSA9IGtlZXBBbGl2ZUluc3RhbmNlLl92bm9kZTtcbiAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICAgIGlmIChjYWNoZWROb2RlKSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjYWNoZWROb2RlLmNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KGNhY2hlLCBrZXksIGtleXMsIF92bm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICAgIGNhY2hlLFxuICAgIGtleSxcbiAgICBrZXlzLFxuICAgIGN1cnJlbnRcbiAgKSB7XG4gICAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gICAgaWYgKGNhY2hlZCQkMSAmJiAoIWN1cnJlbnQgfHwgY2FjaGVkJCQxLnRhZyAhPT0gY3VycmVudC50YWcpKSB7XG4gICAgICBjYWNoZWQkJDEuY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICB9XG4gICAgY2FjaGVba2V5XSA9IG51bGw7XG4gICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gIH1cblxuICB2YXIgcGF0dGVyblR5cGVzID0gW1N0cmluZywgUmVnRXhwLCBBcnJheV07XG5cbiAgdmFyIEtlZXBBbGl2ZSA9IHtcbiAgICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICBwcm9wczoge1xuICAgICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgZXhjbHVkZTogcGF0dGVyblR5cGVzLFxuICAgICAgbWF4OiBbU3RyaW5nLCBOdW1iZXJdXG4gICAgfSxcblxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICB9LFxuXG4gICAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgcHJ1bmVDYWNoZUVudHJ5KHRoaXMuY2FjaGUsIGtleSwgdGhpcy5rZXlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy4kd2F0Y2goJ2luY2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gbWF0Y2hlcyh2YWwsIG5hbWUpOyB9KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy4kd2F0Y2goJ2V4Y2x1ZGUnLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHBydW5lQ2FjaGUodGhpcyQxLCBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gIW1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKCkge1xuICAgICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZChzbG90KTtcbiAgICAgIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAgIC8vIGNoZWNrIHBhdHRlcm5cbiAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNvbXBvbmVudE9wdGlvbnMpO1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGluY2x1ZGUgPSByZWYuaW5jbHVkZTtcbiAgICAgICAgdmFyIGV4Y2x1ZGUgPSByZWYuZXhjbHVkZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIG5vdCBpbmNsdWRlZFxuICAgICAgICAgIChpbmNsdWRlICYmICghbmFtZSB8fCAhbWF0Y2hlcyhpbmNsdWRlLCBuYW1lKSkpIHx8XG4gICAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgICAoZXhjbHVkZSAmJiBuYW1lICYmIG1hdGNoZXMoZXhjbHVkZSwgbmFtZSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlZiQxID0gdGhpcztcbiAgICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICAgIHZhciBrZXlzID0gcmVmJDEua2V5cztcbiAgICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgICAvLyBzbyBjaWQgYWxvbmUgaXMgbm90IGVub3VnaCAoIzMyNjkpXG4gICAgICAgICAgPyBjb21wb25lbnRPcHRpb25zLkN0b3IuY2lkICsgKGNvbXBvbmVudE9wdGlvbnMudGFnID8gKFwiOjpcIiArIChjb21wb25lbnRPcHRpb25zLnRhZykpIDogJycpXG4gICAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBjYWNoZVtrZXldLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgICByZW1vdmUoa2V5cywga2V5KTtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWNoZVtrZXldID0gdm5vZGU7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgICAgaWYgKHRoaXMubWF4ICYmIGtleXMubGVuZ3RoID4gcGFyc2VJbnQodGhpcy5tYXgpKSB7XG4gICAgICAgICAgICBwcnVuZUNhY2hlRW50cnkoY2FjaGUsIGtleXNbMF0sIGtleXMsIHRoaXMuX3Zub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2bm9kZS5kYXRhLmtlZXBBbGl2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGUgfHwgKHNsb3QgJiYgc2xvdFswXSlcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJ1aWx0SW5Db21wb25lbnRzID0ge1xuICAgIEtlZXBBbGl2ZTogS2VlcEFsaXZlXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gaW5pdEdsb2JhbEFQSSAoVnVlKSB7XG4gICAgLy8gY29uZmlnXG4gICAgdmFyIGNvbmZpZ0RlZiA9IHt9O1xuICAgIGNvbmZpZ0RlZi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH07XG4gICAge1xuICAgICAgY29uZmlnRGVmLnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnRG8gbm90IHJlcGxhY2UgdGhlIFZ1ZS5jb25maWcgb2JqZWN0LCBzZXQgaW5kaXZpZHVhbCBmaWVsZHMgaW5zdGVhZC4nXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLCAnY29uZmlnJywgY29uZmlnRGVmKTtcblxuICAgIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAgIC8vIE5PVEU6IHRoZXNlIGFyZSBub3QgY29uc2lkZXJlZCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJIC0gYXZvaWQgcmVseWluZyBvblxuICAgIC8vIHRoZW0gdW5sZXNzIHlvdSBhcmUgYXdhcmUgb2YgdGhlIHJpc2suXG4gICAgVnVlLnV0aWwgPSB7XG4gICAgICB3YXJuOiB3YXJuLFxuICAgICAgZXh0ZW5kOiBleHRlbmQsXG4gICAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICAgIGRlZmluZVJlYWN0aXZlOiBkZWZpbmVSZWFjdGl2ZSQkMVxuICAgIH07XG5cbiAgICBWdWUuc2V0ID0gc2V0O1xuICAgIFZ1ZS5kZWxldGUgPSBkZWw7XG4gICAgVnVlLm5leHRUaWNrID0gbmV4dFRpY2s7XG5cbiAgICAvLyAyLjYgZXhwbGljaXQgb2JzZXJ2YWJsZSBBUElcbiAgICBWdWUub2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIG9ic2VydmUob2JqKTtcbiAgICAgIHJldHVybiBvYmpcbiAgICB9O1xuXG4gICAgVnVlLm9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFZ1ZS5vcHRpb25zW3R5cGUgKyAncyddID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9KTtcblxuICAgIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgICAvLyBjb21wb25lbnRzIHdpdGggaW4gV2VleCdzIG11bHRpLWluc3RhbmNlIHNjZW5hcmlvcy5cbiAgICBWdWUub3B0aW9ucy5fYmFzZSA9IFZ1ZTtcblxuICAgIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgICBpbml0VXNlKFZ1ZSk7XG4gICAgaW5pdE1peGluJDEoVnVlKTtcbiAgICBpbml0RXh0ZW5kKFZ1ZSk7XG4gICAgaW5pdEFzc2V0UmVnaXN0ZXJzKFZ1ZSk7XG4gIH1cblxuICBpbml0R2xvYmFsQVBJKFZ1ZSk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZS5wcm90b3R5cGUsICckaXNTZXJ2ZXInLCB7XG4gICAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRzc3JDb250ZXh0Jywge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0ICgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gdGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dFxuICAgIH1cbiAgfSk7XG5cbiAgLy8gZXhwb3NlIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IGZvciBzc3IgcnVudGltZSBoZWxwZXIgaW5zdGFsbGF0aW9uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdGdW5jdGlvbmFsUmVuZGVyQ29udGV4dCcsIHtcbiAgICB2YWx1ZTogRnVuY3Rpb25hbFJlbmRlckNvbnRleHRcbiAgfSk7XG5cbiAgVnVlLnZlcnNpb24gPSAnMi42LjcnO1xuXG4gIC8qICAqL1xuXG4gIC8vIHRoZXNlIGFyZSByZXNlcnZlZCBmb3Igd2ViIGJlY2F1c2UgdGhleSBhcmUgZGlyZWN0bHkgY29tcGlsZWQgYXdheVxuICAvLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbiAgdmFyIGlzUmVzZXJ2ZWRBdHRyID0gbWFrZU1hcCgnc3R5bGUsY2xhc3MnKTtcblxuICAvLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG4gIHZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbiAgdmFyIG11c3RVc2VQcm9wID0gZnVuY3Rpb24gKHRhZywgdHlwZSwgYXR0cikge1xuICAgIHJldHVybiAoXG4gICAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAgIChhdHRyID09PSAnY2hlY2tlZCcgJiYgdGFnID09PSAnaW5wdXQnKSB8fFxuICAgICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICAgIClcbiAgfTtcblxuICB2YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG4gIHZhciBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUgPSBtYWtlTWFwKCdldmVudHMsY2FyZXQsdHlwaW5nLHBsYWludGV4dC1vbmx5Jyk7XG5cbiAgdmFyIGNvbnZlcnRFbnVtZXJhdGVkVmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJ2ZhbHNlJ1xuICAgICAgPyAnZmFsc2UnXG4gICAgICAvLyBhbGxvdyBhcmJpdHJhcnkgc3RyaW5nIHZhbHVlIGZvciBjb250ZW50ZWRpdGFibGVcbiAgICAgIDoga2V5ID09PSAnY29udGVudGVkaXRhYmxlJyAmJiBpc1ZhbGlkQ29udGVudEVkaXRhYmxlVmFsdWUodmFsdWUpXG4gICAgICAgID8gdmFsdWVcbiAgICAgICAgOiAndHJ1ZSdcbiAgfTtcblxuICB2YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICAgJ2RlZmF1bHQsZGVmYXVsdGNoZWNrZWQsZGVmYXVsdG11dGVkLGRlZmF1bHRzZWxlY3RlZCxkZWZlcixkaXNhYmxlZCwnICtcbiAgICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgICAncmVxdWlyZWQscmV2ZXJzZWQsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNvcnRhYmxlLHRyYW5zbGF0ZSwnICtcbiAgICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbiAgKTtcblxuICB2YXIgeGxpbmtOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJztcblxuICB2YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xuICB9O1xuXG4gIHZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xuICB9O1xuXG4gIHZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlzRGVmKGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShjaGlsZE5vZGUuZGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChpc0RlZihwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJDbGFzcyhkYXRhLnN0YXRpY0NsYXNzLCBkYXRhLmNsYXNzKVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgICAgPyBbY2hpbGQuY2xhc3MsIHBhcmVudC5jbGFzc11cbiAgICAgICAgOiBwYXJlbnQuY2xhc3NcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJDbGFzcyAoXG4gICAgc3RhdGljQ2xhc3MsXG4gICAgZHluYW1pY0NsYXNzXG4gICkge1xuICAgIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgICAgcmV0dXJuIGNvbmNhdChzdGF0aWNDbGFzcywgc3RyaW5naWZ5Q2xhc3MoZHluYW1pY0NsYXNzKSlcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICAgIHJldHVybiBhID8gYiA/IChhICsgJyAnICsgYikgOiBhIDogKGIgfHwgJycpXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlBcnJheSh2YWx1ZSlcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeU9iamVjdCh2YWx1ZSlcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5QXJyYXkgKHZhbHVlKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGlzRGVmKHN0cmluZ2lmaWVkID0gc3RyaW5naWZ5Q2xhc3ModmFsdWVbaV0pKSAmJiBzdHJpbmdpZmllZCAhPT0gJycpIHtcbiAgICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICAgIHJlcyArPSBzdHJpbmdpZmllZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICAgIHZhciByZXMgPSAnJztcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICAgIGlmIChyZXMpIHsgcmVzICs9ICcgJzsgfVxuICAgICAgICByZXMgKz0ga2V5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgbmFtZXNwYWNlTWFwID0ge1xuICAgIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICBtYXRoOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbiAgfTtcblxuICB2YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgICAnaHRtbCxib2R5LGJhc2UsaGVhZCxsaW5rLG1ldGEsc3R5bGUsdGl0bGUsJyArXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxmb290ZXIsaGVhZGVyLGgxLGgyLGgzLGg0LGg1LGg2LGhncm91cCxuYXYsc2VjdGlvbiwnICtcbiAgICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICAgJ2EsYixhYmJyLGJkaSxiZG8sYnIsY2l0ZSxjb2RlLGRhdGEsZGZuLGVtLGksa2JkLG1hcmsscSxycCxydCxydGMscnVieSwnICtcbiAgICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAgICdjYXB0aW9uLGNvbCxjb2xncm91cCx0YWJsZSx0aGVhZCx0Ym9keSx0ZCx0aCx0ciwnICtcbiAgICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csbWVudSxtZW51aXRlbSxzdW1tYXJ5LCcgK1xuICAgICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlLGJsb2NrcXVvdGUsaWZyYW1lLHRmb290J1xuICApO1xuXG4gIC8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuICAvLyBjb250YWluIGNoaWxkIGVsZW1lbnRzLlxuICB2YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAgICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LWZhY2UsJyArXG4gICAgJ2ZvcmVpZ25PYmplY3QsZyxnbHlwaCxpbWFnZSxsaW5lLG1hcmtlcixtYXNrLG1pc3NpbmctZ2x5cGgscGF0aCxwYXR0ZXJuLCcgK1xuICAgICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgICB0cnVlXG4gICk7XG5cbiAgdmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxuICB2YXIgaXNSZXNlcnZlZFRhZyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICByZXR1cm4gaXNIVE1MVGFnKHRhZykgfHwgaXNTVkcodGFnKVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFRhZ05hbWVzcGFjZSAodGFnKSB7XG4gICAgaWYgKGlzU1ZHKHRhZykpIHtcbiAgICAgIHJldHVybiAnc3ZnJ1xuICAgIH1cbiAgICAvLyBiYXNpYyBzdXBwb3J0IGZvciBNYXRoTUxcbiAgICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gICAgaWYgKHRhZyA9PT0gJ21hdGgnKSB7XG4gICAgICByZXR1cm4gJ21hdGgnXG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25FbGVtZW50Q2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3Nlcikge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgaWYgKGlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVua25vd25FbGVtZW50Q2FjaGVbdGFnXVxuICAgIH1cbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRhZy5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgICAgcmV0dXJuICh1bmtub3duRWxlbWVudENhY2hlW3RhZ10gPSAoXG4gICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTFVua25vd25FbGVtZW50IHx8XG4gICAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICAgICkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgICB9XG4gIH1cblxuICB2YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuICAvKiAgKi9cblxuICAvKipcbiAgICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gICAqL1xuICBmdW5jdGlvbiBxdWVyeSAoZWwpIHtcbiAgICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RlZFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gICAgdmFyIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG4gICAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgICByZXR1cm4gZWxtXG4gICAgfVxuICAgIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gICAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiB2bm9kZS5kYXRhLmF0dHJzLm11bHRpcGxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsbS5zZXRBdHRyaWJ1dGUoJ211bHRpcGxlJywgJ211bHRpcGxlJyk7XG4gICAgfVxuICAgIHJldHVybiBlbG1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG4gIH1cblxuICBmdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG4gIH1cblxuICBmdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudGFnTmFtZVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFN0eWxlU2NvcGUgKG5vZGUsIHNjb3BlSWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShzY29wZUlkLCAnJyk7XG4gIH1cblxuICB2YXIgbm9kZU9wcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG4gICAgY3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG4gICAgY3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlLFxuICAgIGNyZWF0ZUNvbW1lbnQ6IGNyZWF0ZUNvbW1lbnQsXG4gICAgaW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG4gICAgcmVtb3ZlQ2hpbGQ6IHJlbW92ZUNoaWxkLFxuICAgIGFwcGVuZENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgIG5leHRTaWJsaW5nOiBuZXh0U2libGluZyxcbiAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgIHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcbiAgICBzZXRTdHlsZVNjb3BlOiBzZXRTdHlsZVNjb3BlXG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciByZWYgPSB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgICByZWdpc3RlclJlZih2bm9kZSk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgICBpZiAob2xkVm5vZGUuZGF0YS5yZWYgIT09IHZub2RlLmRhdGEucmVmKSB7XG4gICAgICAgIHJlZ2lzdGVyUmVmKG9sZFZub2RlLCB0cnVlKTtcbiAgICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICAgIHJlZ2lzdGVyUmVmKHZub2RlLCB0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJSZWYgKHZub2RlLCBpc1JlbW92YWwpIHtcbiAgICB2YXIga2V5ID0gdm5vZGUuZGF0YS5yZWY7XG4gICAgaWYgKCFpc0RlZihrZXkpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICAgIHZhciByZWYgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSB8fCB2bm9kZS5lbG07XG4gICAgdmFyIHJlZnMgPSB2bS4kcmVmcztcbiAgICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWZzW2tleV0pKSB7XG4gICAgICAgIHJlbW92ZShyZWZzW2tleV0sIHJlZik7XG4gICAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlZnNba2V5XSkpIHtcbiAgICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWZzW2tleV0uaW5kZXhPZihyZWYpIDwgMCkge1xuICAgICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gICAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICAgKlxuICAgKiBtb2RpZmllZCBieSBFdmFuIFlvdSAoQHl5eDk5MDgwMylcbiAgICpcbiAgICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICAgKiBvZiBtYWtpbmcgZmxvdyB1bmRlcnN0YW5kIGl0IGlzIG5vdCB3b3J0aCBpdC5cbiAgICovXG5cbiAgdmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxuICB2YXIgaG9va3MgPSBbJ2NyZWF0ZScsICdhY3RpdmF0ZScsICd1cGRhdGUnLCAncmVtb3ZlJywgJ2Rlc3Ryb3knXTtcblxuICBmdW5jdGlvbiBzYW1lVm5vZGUgKGEsIGIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgYS5rZXkgPT09IGIua2V5ICYmIChcbiAgICAgICAgKFxuICAgICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICAgIGEuaXNDb21tZW50ID09PSBiLmlzQ29tbWVudCAmJlxuICAgICAgICAgIGlzRGVmKGEuZGF0YSkgPT09IGlzRGVmKGIuZGF0YSkgJiZcbiAgICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICAgICkgfHwgKFxuICAgICAgICAgIGlzVHJ1ZShhLmlzQXN5bmNQbGFjZWhvbGRlcikgJiZcbiAgICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgICBpc1VuZGVmKGIuYXN5bmNGYWN0b3J5LmVycm9yKVxuICAgICAgICApXG4gICAgICApXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICAgIGlmIChhLnRhZyAhPT0gJ2lucHV0JykgeyByZXR1cm4gdHJ1ZSB9XG4gICAgdmFyIGk7XG4gICAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgICB2YXIgdHlwZUIgPSBpc0RlZihpID0gYi5kYXRhKSAmJiBpc0RlZihpID0gaS5hdHRycykgJiYgaS50eXBlO1xuICAgIHJldHVybiB0eXBlQSA9PT0gdHlwZUIgfHwgaXNUZXh0SW5wdXRUeXBlKHR5cGVBKSAmJiBpc1RleHRJbnB1dFR5cGUodHlwZUIpXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVLZXlUb09sZElkeCAoY2hpbGRyZW4sIGJlZ2luSWR4LCBlbmRJZHgpIHtcbiAgICB2YXIgaSwga2V5O1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICBmb3IgKGkgPSBiZWdpbklkeDsgaSA8PSBlbmRJZHg7ICsraSkge1xuICAgICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGNoRnVuY3Rpb24gKGJhY2tlbmQpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgY2JzID0ge307XG5cbiAgICB2YXIgbW9kdWxlcyA9IGJhY2tlbmQubW9kdWxlcztcbiAgICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgICAgY2JzW2hvb2tzW2ldXSA9IFtdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG1vZHVsZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICAgIGNic1tob29rc1tpXV0ucHVzaChtb2R1bGVzW2pdW2hvb2tzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbXB0eU5vZGVBdCAoZWxtKSB7XG4gICAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUm1DYiAoY2hpbGRFbG0sIGxpc3RlbmVycykge1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlJCQxICgpIHtcbiAgICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICAgIHJlbW92ZU5vZGUoY2hpbGRFbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZW1vdmUkJDEubGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgcmV0dXJuIHJlbW92ZSQkMVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUgKGVsKSB7XG4gICAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbCAvIHYtdGV4dFxuICAgICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAhaW5WUHJlICYmXG4gICAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgICAhKFxuICAgICAgICAgIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMubGVuZ3RoICYmXG4gICAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1JlZ0V4cChpZ25vcmUpXG4gICAgICAgICAgICAgID8gaWdub3JlLnRlc3Qodm5vZGUudGFnKVxuICAgICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgICAgfSlcbiAgICAgICAgKSAmJlxuICAgICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgICApXG4gICAgfVxuXG4gICAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVsbSAoXG4gICAgICB2bm9kZSxcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgIHBhcmVudEVsbSxcbiAgICAgIHJlZkVsbSxcbiAgICAgIG5lc3RlZCxcbiAgICAgIG93bmVyQXJyYXksXG4gICAgICBpbmRleFxuICAgICkge1xuICAgICAgaWYgKGlzRGVmKHZub2RlLmVsbSkgJiYgaXNEZWYob3duZXJBcnJheSkpIHtcbiAgICAgICAgLy8gVGhpcyB2bm9kZSB3YXMgdXNlZCBpbiBhIHByZXZpb3VzIHJlbmRlciFcbiAgICAgICAgLy8gbm93IGl0J3MgdXNlZCBhcyBhIG5ldyBub2RlLCBvdmVyd3JpdGluZyBpdHMgZWxtIHdvdWxkIGNhdXNlXG4gICAgICAgIC8vIHBvdGVudGlhbCBwYXRjaCBlcnJvcnMgZG93biB0aGUgcm9hZCB3aGVuIGl0J3MgdXNlZCBhcyBhbiBpbnNlcnRpb25cbiAgICAgICAgLy8gcmVmZXJlbmNlIG5vZGUuIEluc3RlYWQsIHdlIGNsb25lIHRoZSBub2RlIG9uLWRlbWFuZCBiZWZvcmUgY3JlYXRpbmdcbiAgICAgICAgLy8gYXNzb2NpYXRlZCBET00gZWxlbWVudCBmb3IgaXQuXG4gICAgICAgIHZub2RlID0gb3duZXJBcnJheVtpbmRleF0gPSBjbG9uZVZOb2RlKHZub2RlKTtcbiAgICAgIH1cblxuICAgICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICAgIGlmIChjcmVhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1Vua25vd25FbGVtZW50JCQxKHZub2RlLCBjcmVhdGluZ0VsbUluVlByZSkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgICAnbWFrZSBzdXJlIHRvIHByb3ZpZGUgdGhlIFwibmFtZVwiIG9wdGlvbi4nLFxuICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZub2RlLmVsbSA9IHZub2RlLm5zXG4gICAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgICBzZXRTY29wZSh2bm9kZSk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS5wcmUpIHtcbiAgICAgICAgICBjcmVhdGluZ0VsbUluVlByZS0tO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzVHJ1ZSh2bm9kZS5pc0NvbW1lbnQpKSB7XG4gICAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlQ29tbWVudCh2bm9kZS50ZXh0KTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KTtcbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICAgIHZhciBpID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBpLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7XG4gICAgICAgICAgaSh2bm9kZSwgZmFsc2UgLyogaHlkcmF0aW5nICovKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZnRlciBjYWxsaW5nIHRoZSBpbml0IGhvb2ssIGlmIHRoZSB2bm9kZSBpcyBhIGNoaWxkIGNvbXBvbmVudFxuICAgICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAgIC8vIGluIHRoYXQgY2FzZSB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIGVsZW1lbnQgYW5kIGJlIGRvbmUuXG4gICAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICAgICAgICBpZiAoaXNUcnVlKGlzUmVhY3RpdmF0ZWQpKSB7XG4gICAgICAgICAgICByZWFjdGl2YXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluaXRDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoLmFwcGx5KGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0KTtcbiAgICAgICAgdm5vZGUuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZub2RlLmVsbSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLiRlbDtcbiAgICAgIGlmIChpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHNldFNjb3BlKHZub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgICAvLyBza2lwIGFsbCBlbGVtZW50LXJlbGF0ZWQgbW9kdWxlcyBleGNlcHQgZm9yIHJlZiAoIzM0NTUpXG4gICAgICAgIHJlZ2lzdGVyUmVmKHZub2RlKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWN0aXZhdGVDb21wb25lbnQgKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAgIC8vIGRvZXMgbm90IHRyaWdnZXIgYmVjYXVzZSB0aGUgaW5uZXIgbm9kZSdzIGNyZWF0ZWQgaG9va3MgYXJlIG5vdCBjYWxsZWRcbiAgICAgIC8vIGFnYWluLiBJdCdzIG5vdCBpZGVhbCB0byBpbnZvbHZlIG1vZHVsZS1zcGVjaWZpYyBsb2dpYyBpbiBoZXJlIGJ1dFxuICAgICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICAgIHZhciBpbm5lck5vZGUgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChpbm5lck5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBpbm5lck5vZGUuZGF0YSkgJiYgaXNEZWYoaSA9IGkudHJhbnNpdGlvbikpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmFjdGl2YXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaChpbm5lck5vZGUpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgICAgLy8gYSByZWFjdGl2YXRlZCBrZWVwLWFsaXZlIGNvbXBvbmVudCBkb2Vzbid0IGluc2VydCBpdHNlbGZcbiAgICAgIGluc2VydChwYXJlbnRFbG0sIHZub2RlLmVsbSwgcmVmRWxtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnNlcnQgKHBhcmVudCwgZWxtLCByZWYkJDEpIHtcbiAgICAgIGlmIChpc0RlZihwYXJlbnQpKSB7XG4gICAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgICAgaWYgKG5vZGVPcHMucGFyZW50Tm9kZShyZWYkJDEpID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudCwgZWxtLCByZWYkJDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHBhcmVudCwgZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjaGVja0R1cGxpY2F0ZUtleXMoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlLCBjaGlsZHJlbiwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNQcmltaXRpdmUodm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5hcHBlbmRDaGlsZCh2bm9kZS5lbG0sIG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUoU3RyaW5nKHZub2RlLnRleHQpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgICB3aGlsZSAodm5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgdm5vZGUgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNEZWYodm5vZGUudGFnKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgY2JzLmNyZWF0ZVtpJDFdKGVtcHR5Tm9kZSwgdm5vZGUpO1xuICAgICAgfVxuICAgICAgaSA9IHZub2RlLmRhdGEuaG9vazsgLy8gUmV1c2UgdmFyaWFibGVcbiAgICAgIGlmIChpc0RlZihpKSkge1xuICAgICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICAgIGlmIChpc0RlZihpLmluc2VydCkpIHsgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2godm5vZGUpOyB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0IHNjb3BlIGlkIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIENTUy5cbiAgICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAgIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgICBmdW5jdGlvbiBzZXRTY29wZSAodm5vZGUpIHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICAgIHdoaWxlIChhbmNlc3Rvcikge1xuICAgICAgICAgIGlmIChpc0RlZihpID0gYW5jZXN0b3IuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICAgICAgICBub2RlT3BzLnNldFN0eWxlU2NvcGUodm5vZGUuZWxtLCBpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGZvciBzbG90IGNvbnRlbnQgdGhleSBzaG91bGQgYWxzbyBnZXQgdGhlIHNjb3BlSWQgZnJvbSB0aGUgaG9zdCBpbnN0YW5jZS5cbiAgICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICAgIGkgIT09IHZub2RlLmNvbnRleHQgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuZm5Db250ZXh0ICYmXG4gICAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICAgKSB7XG4gICAgICAgIG5vZGVPcHMuc2V0U3R5bGVTY29wZSh2bm9kZS5lbG0sIGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCByZWZFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICAgIGNyZWF0ZUVsbSh2bm9kZXNbc3RhcnRJZHhdLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtLCBmYWxzZSwgdm5vZGVzLCBzdGFydElkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgICB2YXIgaSwgajtcbiAgICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5kZXN0cm95Lmxlbmd0aDsgKytpKSB7IGNicy5kZXN0cm95W2ldKHZub2RlKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKGlzRGVmKGNoLnRhZykpIHtcbiAgICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIFRleHQgbm9kZVxuICAgICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAgIC8vIGluY3JlYXNlIHRoZSBsaXN0ZW5lcnMgY291bnRcbiAgICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRpcmVjdGx5IHJlbW92aW5nXG4gICAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgICByZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rKGksIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNicy5yZW1vdmVbaV0odm5vZGUsIHJtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICAgIGkodm5vZGUsIHJtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBybSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICAgIHZhciBvbGRTdGFydElkeCA9IDA7XG4gICAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgb2xkU3RhcnRWbm9kZSA9IG9sZENoWzBdO1xuICAgICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgICAgdmFyIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFswXTtcbiAgICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAgIC8vIHRvIGVuc3VyZSByZW1vdmVkIGVsZW1lbnRzIHN0YXkgaW4gY29ycmVjdCByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgICB7XG4gICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhuZXdDaCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdOyAvLyBWbm9kZSBoYXMgYmVlbiBtb3ZlZCBsZWZ0XG4gICAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCByaWdodFxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld0VuZElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG5ld0NoLCBuZXdTdGFydElkeCk7XG4gICAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG9sZEVuZFZub2RlID0gb2xkQ2hbLS1vbGRFbmRJZHhdO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNVbmRlZihvbGRLZXlUb0lkeCkpIHsgb2xkS2V5VG9JZHggPSBjcmVhdGVLZXlUb09sZElkeChvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7IH1cbiAgICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgICAgPyBvbGRLZXlUb0lkeFtuZXdTdGFydFZub2RlLmtleV1cbiAgICAgICAgICAgIDogZmluZElkeEluT2xkKG5ld1N0YXJ0Vm5vZGUsIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAgIGlmIChzYW1lVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgbmV3Q2gsIG5ld1N0YXJ0SWR4KTtcbiAgICAgICAgICAgICAgb2xkQ2hbaWR4SW5PbGRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBzYW1lIGtleSBidXQgZGlmZmVyZW50IGVsZW1lbnQuIHRyZWF0IGFzIG5ldyBlbGVtZW50XG4gICAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0sIGZhbHNlLCBuZXdDaCwgbmV3U3RhcnRJZHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgICByZWZFbG0gPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICAgIGFkZFZub2RlcyhwYXJlbnRFbG0sIHJlZkVsbSwgbmV3Q2gsIG5ld1N0YXJ0SWR4LCBuZXdFbmRJZHgsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0R1cGxpY2F0ZUtleXMgKGNoaWxkcmVuKSB7XG4gICAgICB2YXIgc2VlbktleXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBrZXkgPSB2bm9kZS5rZXk7XG4gICAgICAgIGlmIChpc0RlZihrZXkpKSB7XG4gICAgICAgICAgaWYgKHNlZW5LZXlzW2tleV0pIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgIChcIkR1cGxpY2F0ZSBrZXlzIGRldGVjdGVkOiAnXCIgKyBrZXkgKyBcIicuIFRoaXMgbWF5IGNhdXNlIGFuIHVwZGF0ZSBlcnJvci5cIiksXG4gICAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW5LZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmRJZHhJbk9sZCAobm9kZSwgb2xkQ2gsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gb2xkQ2hbaV07XG4gICAgICAgIGlmIChpc0RlZihjKSAmJiBzYW1lVm5vZGUobm9kZSwgYykpIHsgcmV0dXJuIGkgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhdGNoVm5vZGUgKFxuICAgICAgb2xkVm5vZGUsXG4gICAgICB2bm9kZSxcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZSxcbiAgICAgIG93bmVyQXJyYXksXG4gICAgICBpbmRleCxcbiAgICAgIHJlbW92ZU9ubHlcbiAgICApIHtcbiAgICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5lbG0pICYmIGlzRGVmKG93bmVyQXJyYXkpKSB7XG4gICAgICAgIC8vIGNsb25lIHJldXNlZCB2bm9kZVxuICAgICAgICB2bm9kZSA9IG93bmVyQXJyYXlbaW5kZXhdID0gY2xvbmVWTm9kZSh2bm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbG0gPSB2bm9kZS5lbG0gPSBvbGRWbm9kZS5lbG07XG5cbiAgICAgIGlmIChpc1RydWUob2xkVm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyKSkge1xuICAgICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIGh5ZHJhdGUob2xkVm5vZGUuZWxtLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgICAvLyBub3RlIHdlIG9ubHkgZG8gdGhpcyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIC1cbiAgICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICAgIGlmIChpc1RydWUodm5vZGUuaXNTdGF0aWMpICYmXG4gICAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKGlzVHJ1ZSh2bm9kZS5pc0Nsb25lZCkgfHwgaXNUcnVlKHZub2RlLmlzT25jZSkpXG4gICAgICApIHtcbiAgICAgICAgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgICBpKG9sZFZub2RlLCB2bm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgICAgdmFyIGNoID0gdm5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNQYXRjaGFibGUodm5vZGUpKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkudXBkYXRlKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICAgIGlmIChpc0RlZihvbGRDaCkgJiYgaXNEZWYoY2gpKSB7XG4gICAgICAgICAgaWYgKG9sZENoICE9PSBjaCkgeyB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoLCBjaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTsgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlS2V5cyhjaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0RlZihvbGRWbm9kZS50ZXh0KSkgeyBub2RlT3BzLnNldFRleHRDb250ZW50KGVsbSwgJycpOyB9XG4gICAgICAgICAgYWRkVm5vZGVzKGVsbSwgbnVsbCwgY2gsIDAsIGNoLmxlbmd0aCAtIDEsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKGVsbSwgb2xkQ2gsIDAsIG9sZENoLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGVmKG9sZFZub2RlLnRleHQpKSB7XG4gICAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvbGRWbm9kZS50ZXh0ICE9PSB2bm9kZS50ZXh0KSB7XG4gICAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgICAgLy8gZWxlbWVudCBpcyByZWFsbHkgaW5zZXJ0ZWRcbiAgICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaHlkcmF0aW9uQmFpbGVkID0gZmFsc2U7XG4gICAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgICAvLyBhcmUgYWxyZWFkeSByZW5kZXJlZCBvbiB0aGUgY2xpZW50IG9yIGhhcyBubyBuZWVkIGZvciBpbml0aWFsaXphdGlvblxuICAgIC8vIE5vdGU6IHN0eWxlIGlzIGV4Y2x1ZGVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIGluaXRpYWwgY2xvbmUgZm9yIGZ1dHVyZVxuICAgIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICAgIHZhciBpc1JlbmRlcmVkTW9kdWxlID0gbWFrZU1hcCgnYXR0cnMsY2xhc3Msc3RhdGljQ2xhc3Msc3RhdGljU3R5bGUsa2V5Jyk7XG5cbiAgICAvLyBOb3RlOiB0aGlzIGlzIGEgYnJvd3Nlci1vbmx5IGZ1bmN0aW9uIHNvIHdlIGNhbiBhc3N1bWUgZWxtcyBhcmUgRE9NIG5vZGVzLlxuICAgIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICAgIGluVlByZSA9IGluVlByZSB8fCAoZGF0YSAmJiBkYXRhLnByZSk7XG4gICAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICAgIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSAmJiBpc0RlZih2bm9kZS5hc3luY0ZhY3RvcnkpKSB7XG4gICAgICAgIHZub2RlLmlzQXN5bmNQbGFjZWhvbGRlciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICAvLyBhc3NlcnQgbm9kZSBtYXRjaFxuICAgICAge1xuICAgICAgICBpZiAoIWFzc2VydE5vZGVNYXRjaChlbG0sIHZub2RlLCBpblZQcmUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuaW5pdCkpIHsgaSh2bm9kZSwgdHJ1ZSAvKiBoeWRyYXRpbmcgKi8pOyB9XG4gICAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UpKSB7XG4gICAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgLy8gZW1wdHkgZWxlbWVudCwgYWxsb3cgY2xpZW50IHRvIHBpY2sgdXAgYW5kIHBvcHVsYXRlIGNoaWxkcmVuXG4gICAgICAgICAgaWYgKCFlbG0uaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHYtaHRtbCBhbmQgZG9tUHJvcHM6IGlubmVySFRNTFxuICAgICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgICBpZiAoaSAhPT0gZWxtLmlubmVySFRNTCkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIGh5ZHJhdGlvbkJhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NsaWVudCBpbm5lckhUTUw6ICcsIGVsbS5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgIHZhciBjaGlsZE5vZGUgPSBlbG0uZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGROb2RlIHx8ICFoeWRyYXRlKGNoaWxkTm9kZSwgY2hpbGRyZW5baSQxXSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpblZQcmUpKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbk1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gaWYgY2hpbGROb2RlIGlzIG5vdCBudWxsLCBpdCBtZWFucyB0aGUgYWN0dWFsIGNoaWxkTm9kZXMgbGlzdCBpc1xuICAgICAgICAgICAgICAvLyBsb25nZXIgdGhhbiB0aGUgdmlydHVhbCBjaGlsZHJlbiBsaXN0LlxuICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdNaXNtYXRjaGluZyBjaGlsZE5vZGVzIHZzLiBWTm9kZXM6ICcsIGVsbS5jaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICAgIHZhciBmdWxsSW52b2tlID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICAgIGZ1bGxJbnZva2UgPSB0cnVlO1xuICAgICAgICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjb2xsZWN0aW5nIGRlcHMgZm9yIGRlZXAgY2xhc3MgYmluZGluZ3MgZm9yIGZ1dHVyZSB1cGRhdGVzXG4gICAgICAgICAgICB0cmF2ZXJzZShkYXRhWydjbGFzcyddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWxtLmRhdGEgIT09IHZub2RlLnRleHQpIHtcbiAgICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnROb2RlTWF0Y2ggKG5vZGUsIHZub2RlLCBpblZQcmUpIHtcbiAgICAgIGlmIChpc0RlZih2bm9kZS50YWcpKSB7XG4gICAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgICAhaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgaW5WUHJlKSAmJlxuICAgICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSAobm9kZS50YWdOYW1lICYmIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PT0gKHZub2RlLmlzQ29tbWVudCA/IDggOiAzKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBwYXRjaCAob2xkVm5vZGUsIHZub2RlLCBoeWRyYXRpbmcsIHJlbW92ZU9ubHkpIHtcbiAgICAgIGlmIChpc1VuZGVmKHZub2RlKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUpKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIGlzSW5pdGlhbFBhdGNoID0gZmFsc2U7XG4gICAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICAgIGlmIChpc1VuZGVmKG9sZFZub2RlKSkge1xuICAgICAgICAvLyBlbXB0eSBtb3VudCAobGlrZWx5IGFzIGNvbXBvbmVudCksIGNyZWF0ZSBuZXcgcm9vdCBlbGVtZW50XG4gICAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzUmVhbEVsZW1lbnQgPSBpc0RlZihvbGRWbm9kZS5ub2RlVHlwZSk7XG4gICAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICAgIHBhdGNoVm5vZGUob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIG51bGwsIG51bGwsIHJlbW92ZU9ubHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBtb3VudGluZyB0byBhIHJlYWwgZWxlbWVudFxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCBhbmQgaWYgd2UgY2FuIHBlcmZvcm1cbiAgICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgICBpZiAob2xkVm5vZGUubm9kZVR5cGUgPT09IDEgJiYgb2xkVm5vZGUuaGFzQXR0cmlidXRlKFNTUl9BVFRSKSkge1xuICAgICAgICAgICAgICBvbGRWbm9kZS5yZW1vdmVBdHRyaWJ1dGUoU1NSX0FUVFIpO1xuICAgICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVHJ1ZShoeWRyYXRpbmcpKSB7XG4gICAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICAgIGludm9rZUluc2VydEhvb2sodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgICAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFRoaXMgaXMgbGlrZWx5IGNhdXNlZCBieSBpbmNvcnJlY3QgJyArXG4gICAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAgICdmdWxsIGNsaWVudC1zaWRlIHJlbmRlci4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgICAgb2xkVm5vZGUgPSBlbXB0eU5vZGVBdChvbGRWbm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgICB2YXIgb2xkRWxtID0gb2xkVm5vZGUuZWxtO1xuICAgICAgICAgIHZhciBwYXJlbnRFbG0gPSBub2RlT3BzLnBhcmVudE5vZGUob2xkRWxtKTtcblxuICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgbm9kZVxuICAgICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICAgIHZub2RlLFxuICAgICAgICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLFxuICAgICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAgIC8vIGxlYXZpbmcgdHJhbnNpdGlvbi4gT25seSBoYXBwZW5zIHdoZW4gY29tYmluaW5nIHRyYW5zaXRpb24gK1xuICAgICAgICAgICAgLy8ga2VlcC1hbGl2ZSArIEhPQ3MuICgjNDU5MClcbiAgICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0sXG4gICAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gdXBkYXRlIHBhcmVudCBwbGFjZWhvbGRlciBub2RlIGVsZW1lbnQsIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICAgIHZhciBhbmNlc3RvciA9IHZub2RlLnBhcmVudDtcbiAgICAgICAgICAgIHZhciBwYXRjaGFibGUgPSBpc1BhdGNoYWJsZSh2bm9kZSk7XG4gICAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNicy5kZXN0cm95W2ldKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbmNlc3Rvci5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgICAgIGlmIChwYXRjaGFibGUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICAgIGNicy5jcmVhdGVbaSQxXShlbXB0eU5vZGUsIGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgICAvLyBpbnZva2UgaW5zZXJ0IGhvb2tzIHRoYXQgbWF5IGhhdmUgYmVlbiBtZXJnZWQgYnkgY3JlYXRlIGhvb2tzLlxuICAgICAgICAgICAgICAgIC8vIGUuZy4gZm9yIGRpcmVjdGl2ZXMgdGhhdCB1c2VzIHRoZSBcImluc2VydGVkXCIgaG9vay5cbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0Lm1lcmdlZCkge1xuICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgYXQgaW5kZXggMSB0byBhdm9pZCByZS1pbnZva2luZyBjb21wb25lbnQgbW91bnRlZCBob29rXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0LmZuc1tpJDJdKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyUmVmKGFuY2VzdG9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBkZXN0cm95IG9sZCBub2RlXG4gICAgICAgICAgaWYgKGlzRGVmKHBhcmVudEVsbSkpIHtcbiAgICAgICAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIFtvbGRWbm9kZV0sIDAsIDApO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGFnKSkge1xuICAgICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIGlzSW5pdGlhbFBhdGNoKTtcbiAgICAgIHJldHVybiB2bm9kZS5lbG1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgZGlyZWN0aXZlcyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gICAgdXBkYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgICB1cGRhdGVEaXJlY3RpdmVzKHZub2RlLCBlbXB0eU5vZGUpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGVEaXJlY3RpdmVzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICBpZiAob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzIHx8IHZub2RlLmRhdGEuZGlyZWN0aXZlcykge1xuICAgICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBpc0NyZWF0ZSA9IG9sZFZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIGlzRGVzdHJveSA9IHZub2RlID09PSBlbXB0eU5vZGU7XG4gICAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gICAgdmFyIGRpcnNXaXRoSW5zZXJ0ID0gW107XG4gICAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgICBmb3IgKGtleSBpbiBuZXdEaXJzKSB7XG4gICAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgICBpZiAoIW9sZERpcikge1xuICAgICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuaW5zZXJ0ZWQpIHtcbiAgICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgICAgZGlyLm9sZEFyZyA9IG9sZERpci5hcmc7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5jb21wb25lbnRVcGRhdGVkKSB7XG4gICAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgICAgdmFyIGNhbGxJbnNlcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoSW5zZXJ0W2ldLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgaWYgKGlzQ3JlYXRlKSB7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAnaW5zZXJ0JywgY2FsbEluc2VydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsSW5zZXJ0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpcnNXaXRoUG9zdHBhdGNoLmxlbmd0aCkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdwb3N0cGF0Y2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjYWxsSG9vayQxKGRpcnNXaXRoUG9zdHBhdGNoW2ldLCAnY29tcG9uZW50VXBkYXRlZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaXNDcmVhdGUpIHtcbiAgICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgICAgaWYgKCFuZXdEaXJzW2tleV0pIHtcbiAgICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gICAgZGlycyxcbiAgICB2bVxuICApIHtcbiAgICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoIWRpcnMpIHtcbiAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgICB2YXIgaSwgZGlyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBkaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaXIgPSBkaXJzW2ldO1xuICAgICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICAgIC8vICRmbG93LWRpc2FibGUtbGluZVxuICAgICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgICB9XG4gICAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICAgIH1cbiAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICBmdW5jdGlvbiBnZXRSYXdEaXJOYW1lIChkaXIpIHtcbiAgICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbEhvb2skMSAoZGlyLCBob29rLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSkge1xuICAgIHZhciBmbiA9IGRpci5kZWYgJiYgZGlyLmRlZltob29rXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGhhbmRsZUVycm9yKGUsIHZub2RlLmNvbnRleHQsIChcImRpcmVjdGl2ZSBcIiArIChkaXIubmFtZSkgKyBcIiBcIiArIGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZU1vZHVsZXMgPSBbXG4gICAgcmVmLFxuICAgIGRpcmVjdGl2ZXNcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB1cGRhdGVBdHRycyAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBrZXksIGN1ciwgb2xkO1xuICAgIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gICAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAgIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICAgIGlmIChpc0RlZihhdHRycy5fX29iX18pKSB7XG4gICAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICAgIG9sZCA9IG9sZEF0dHJzW2tleV07XG4gICAgICBpZiAob2xkICE9PSBjdXIpIHtcbiAgICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgICAvLyAjNjY2NjogSUUvRWRnZSBmb3JjZXMgcHJvZ3Jlc3MgdmFsdWUgZG93biB0byAxIGJlZm9yZSBzZXR0aW5nIGEgbWF4XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgICBzZXRBdHRyKGVsbSwgJ3ZhbHVlJywgYXR0cnMudmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgICAgaWYgKGlzVW5kZWYoYXR0cnNba2V5XSkpIHtcbiAgICAgICAgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGVsLnRhZ05hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGJhc2VTZXRBdHRyKGVsLCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQm9vbGVhbkF0dHIoa2V5KSkge1xuICAgICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAgIC8vIGUuZy4gPG9wdGlvbiBkaXNhYmxlZD5TZWxlY3Qgb25lPC9vcHRpb24+XG4gICAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0ZWNobmljYWxseSBhbGxvd2Z1bGxzY3JlZW4gaXMgYSBib29sZWFuIGF0dHJpYnV0ZSBmb3IgPGlmcmFtZT4sXG4gICAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICAgIHZhbHVlID0ga2V5ID09PSAnYWxsb3dmdWxsc2NyZWVuJyAmJiBlbC50YWdOYW1lID09PSAnRU1CRUQnXG4gICAgICAgICAgPyAndHJ1ZSdcbiAgICAgICAgICA6IGtleTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBjb252ZXJ0RW51bWVyYXRlZFZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICB9IGVsc2UgaWYgKGlzWGxpbmsoa2V5KSkge1xuICAgICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlU2V0QXR0cihlbCwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmFzZVNldEF0dHIgKGVsLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gIzcxMzg6IElFMTAgJiAxMSBmaXJlcyBpbnB1dCBldmVudCB3aGVuIHNldHRpbmcgcGxhY2Vob2xkZXIgb25cbiAgICAgIC8vIDx0ZXh0YXJlYT4uLi4gYmxvY2sgdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFuZCByZW1vdmUgdGhlIGJsb2NrZXJcbiAgICAgIC8vIGltbWVkaWF0ZWx5LlxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoXG4gICAgICAgIGlzSUUgJiYgIWlzSUU5ICYmXG4gICAgICAgIGVsLnRhZ05hbWUgPT09ICdURVhUQVJFQScgJiZcbiAgICAgICAga2V5ID09PSAncGxhY2Vob2xkZXInICYmIHZhbHVlICE9PSAnJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXR0cnMgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG4gIH07XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICAgIGlmIChcbiAgICAgIGlzVW5kZWYoZGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgICBpc1VuZGVmKG9sZERhdGEpIHx8IChcbiAgICAgICAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljQ2xhc3MpICYmXG4gICAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgICApXG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gICAgdmFyIHRyYW5zaXRpb25DbGFzcyA9IGVsLl90cmFuc2l0aW9uQ2xhc3NlcztcbiAgICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgICAgY2xzID0gY29uY2F0KGNscywgc3RyaW5naWZ5Q2xhc3ModHJhbnNpdGlvbkNsYXNzKSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHRoZSBjbGFzc1xuICAgIGlmIChjbHMgIT09IGVsLl9wcmV2Q2xhc3MpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgICB9XG4gIH1cblxuICB2YXIga2xhc3MgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVDbGFzcyxcbiAgICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHZhbGlkRGl2aXNpb25DaGFyUkUgPSAvW1xcdykuK1xcLV8kXFxdXS87XG5cbiAgZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgICB2YXIgaW5TaW5nbGUgPSBmYWxzZTtcbiAgICB2YXIgaW5Eb3VibGUgPSBmYWxzZTtcbiAgICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICAgIHZhciBpblJlZ2V4ID0gZmFsc2U7XG4gICAgdmFyIGN1cmx5ID0gMDtcbiAgICB2YXIgc3F1YXJlID0gMDtcbiAgICB2YXIgcGFyZW4gPSAwO1xuICAgIHZhciBsYXN0RmlsdGVySW5kZXggPSAwO1xuICAgIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgcHJldiA9IGM7XG4gICAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgICBpZiAoaW5TaW5nbGUpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MjcgJiYgcHJldiAhPT0gMHg1QykgeyBpblNpbmdsZSA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICAgIGlmIChjID09PSAweDIyICYmIHByZXYgIT09IDB4NUMpIHsgaW5Eb3VibGUgPSBmYWxzZTsgfVxuICAgICAgfSBlbHNlIGlmIChpblRlbXBsYXRlU3RyaW5nKSB7XG4gICAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgICB9IGVsc2UgaWYgKGluUmVnZXgpIHtcbiAgICAgICAgaWYgKGMgPT09IDB4MmYgJiYgcHJldiAhPT0gMHg1QykgeyBpblJlZ2V4ID0gZmFsc2U7IH1cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGMgPT09IDB4N0MgJiYgLy8gcGlwZVxuICAgICAgICBleHAuY2hhckNvZGVBdChpICsgMSkgIT09IDB4N0MgJiZcbiAgICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAgICFjdXJseSAmJiAhc3F1YXJlICYmICFwYXJlblxuICAgICAgKSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBmaXJzdCBmaWx0ZXIsIGVuZCBvZiBleHByZXNzaW9uXG4gICAgICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaEZpbHRlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICAgIGNhc2UgMHgyNzogaW5TaW5nbGUgPSB0cnVlOyBicmVhayAgICAgICAgIC8vICdcbiAgICAgICAgICBjYXNlIDB4NjA6IGluVGVtcGxhdGVTdHJpbmcgPSB0cnVlOyBicmVhayAvLyBgXG4gICAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICAgIGNhc2UgMHgyOTogcGFyZW4tLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIClcbiAgICAgICAgICBjYXNlIDB4NUI6IHNxdWFyZSsrOyBicmVhayAgICAgICAgICAgICAgICAvLyBbXG4gICAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICAgIGNhc2UgMHg3QjogY3VybHkrKzsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICBjYXNlIDB4N0Q6IGN1cmx5LS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IDB4MmYpIHsgLy8gL1xuICAgICAgICAgIHZhciBqID0gaSAtIDE7XG4gICAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgICAvLyBmaW5kIGZpcnN0IG5vbi13aGl0ZXNwYWNlIHByZXYgY2hhclxuICAgICAgICAgIGZvciAoOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgICBpZiAocCAhPT0gJyAnKSB7IGJyZWFrIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICAgIGluUmVnZXggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGV4cHJlc3Npb24gPSBleHAuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAobGFzdEZpbHRlckluZGV4ICE9PSAwKSB7XG4gICAgICBwdXNoRmlsdGVyKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaEZpbHRlciAoKSB7XG4gICAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgICAgbGFzdEZpbHRlckluZGV4ID0gaSArIDE7XG4gICAgfVxuXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4cHJlc3Npb24gPSB3cmFwRmlsdGVyKGV4cHJlc3Npb24sIGZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBleHByZXNzaW9uXG4gIH1cblxuICBmdW5jdGlvbiB3cmFwRmlsdGVyIChleHAsIGZpbHRlcikge1xuICAgIHZhciBpID0gZmlsdGVyLmluZGV4T2YoJygnKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIC8vIF9mOiByZXNvbHZlRmlsdGVyXG4gICAgICByZXR1cm4gKFwiX2YoXFxcIlwiICsgZmlsdGVyICsgXCJcXFwiKShcIiArIGV4cCArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmFtZSA9IGZpbHRlci5zbGljZSgwLCBpKTtcbiAgICAgIHZhciBhcmdzID0gZmlsdGVyLnNsaWNlKGkgKyAxKTtcbiAgICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIChhcmdzICE9PSAnKScgPyAnLCcgKyBhcmdzIDogYXJncykpXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4gIGZ1bmN0aW9uIGJhc2VXYXJuIChtc2csIHJhbmdlKSB7XG4gICAgY29uc29sZS5lcnJvcigoXCJbVnVlIGNvbXBpbGVyXTogXCIgKyBtc2cpKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbiAgZnVuY3Rpb24gcGx1Y2tNb2R1bGVGdW5jdGlvbiAoXG4gICAgbW9kdWxlcyxcbiAgICBrZXlcbiAgKSB7XG4gICAgcmV0dXJuIG1vZHVsZXNcbiAgICAgID8gbW9kdWxlcy5tYXAoZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG1ba2V5XTsgfSkuZmlsdGVyKGZ1bmN0aW9uIChfKSB7IHJldHVybiBfOyB9KVxuICAgICAgOiBbXVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkUHJvcCAoZWwsIG5hbWUsIHZhbHVlLCByYW5nZSwgZHluYW1pYykge1xuICAgIChlbC5wcm9wcyB8fCAoZWwucHJvcHMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKSk7XG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEF0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UsIGR5bmFtaWMpIHtcbiAgICB2YXIgYXR0cnMgPSBkeW5hbWljXG4gICAgICA/IChlbC5keW5hbWljQXR0cnMgfHwgKGVsLmR5bmFtaWNBdHRycyA9IFtdKSlcbiAgICAgIDogKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSk7XG4gICAgYXR0cnMucHVzaChyYW5nZVNldEl0ZW0oeyBuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWUsIGR5bmFtaWM6IGR5bmFtaWMgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgLy8gYWRkIGEgcmF3IGF0dHIgKHVzZSB0aGlzIGluIHByZVRyYW5zZm9ybXMpXG4gIGZ1bmN0aW9uIGFkZFJhd0F0dHIgKGVsLCBuYW1lLCB2YWx1ZSwgcmFuZ2UpIHtcbiAgICBlbC5hdHRyc01hcFtuYW1lXSA9IHZhbHVlO1xuICAgIGVsLmF0dHJzTGlzdC5wdXNoKHJhbmdlU2V0SXRlbSh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9LCByYW5nZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgICBlbCxcbiAgICBuYW1lLFxuICAgIHJhd05hbWUsXG4gICAgdmFsdWUsXG4gICAgYXJnLFxuICAgIGlzRHluYW1pY0FyZyxcbiAgICBtb2RpZmllcnMsXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgKGVsLmRpcmVjdGl2ZXMgfHwgKGVsLmRpcmVjdGl2ZXMgPSBbXSkpLnB1c2gocmFuZ2VTZXRJdGVtKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByYXdOYW1lOiByYXdOYW1lLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgYXJnOiBhcmcsXG4gICAgICBpc0R5bmFtaWNBcmc6IGlzRHluYW1pY0FyZyxcbiAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzXG4gICAgfSwgcmFuZ2UpKTtcbiAgICBlbC5wbGFpbiA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGVuZE1vZGlmaWVyTWFya2VyIChzeW1ib2wsIG5hbWUsIGR5bmFtaWMpIHtcbiAgICByZXR1cm4gZHluYW1pY1xuICAgICAgPyAoXCJfcChcIiArIG5hbWUgKyBcIixcXFwiXCIgKyBzeW1ib2wgKyBcIlxcXCIpXCIpXG4gICAgICA6IHN5bWJvbCArIG5hbWUgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICAgIGVsLFxuICAgIG5hbWUsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzLFxuICAgIGltcG9ydGFudCxcbiAgICB3YXJuLFxuICAgIHJhbmdlLFxuICAgIGR5bmFtaWNcbiAgKSB7XG4gICAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAgIC8vIHdhcm4gcHJldmVudCBhbmQgcGFzc2l2ZSBtb2RpZmllclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChcbiAgICAgIHdhcm4gJiZcbiAgICAgIG1vZGlmaWVycy5wcmV2ZW50ICYmIG1vZGlmaWVycy5wYXNzaXZlXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAncGFzc2l2ZSBhbmQgcHJldmVudCBjYW5cXCd0IGJlIHVzZWQgdG9nZXRoZXIuICcgK1xuICAgICAgICAnUGFzc2l2ZSBoYW5kbGVyIGNhblxcJ3QgcHJldmVudCBkZWZhdWx0IGV2ZW50LicsXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG5vcm1hbGl6ZSBjbGljay5yaWdodCBhbmQgY2xpY2subWlkZGxlIHNpbmNlIHRoZXkgZG9uJ3QgYWN0dWFsbHkgZmlyZVxuICAgIC8vIHRoaXMgaXMgdGVjaG5pY2FsbHkgYnJvd3Nlci1zcGVjaWZpYywgYnV0IGF0IGxlYXN0IGZvciBub3cgYnJvd3NlcnMgYXJlXG4gICAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgbmFtZSA9IFwiKFwiICsgbmFtZSArIFwiKT09PSdjbGljayc/J2NvbnRleHRtZW51JzooXCIgKyBuYW1lICsgXCIpXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICAgIGRlbGV0ZSBtb2RpZmllcnMucmlnaHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtb2RpZmllcnMubWlkZGxlKSB7XG4gICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICBuYW1lID0gXCIoXCIgKyBuYW1lICsgXCIpPT09J2NsaWNrJz8nbW91c2V1cCc6KFwiICsgbmFtZSArIFwiKVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgIG5hbWUgPSAnbW91c2V1cCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgY2FwdHVyZSBtb2RpZmllclxuICAgIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5jYXB0dXJlO1xuICAgICAgbmFtZSA9IHByZXBlbmRNb2RpZmllck1hcmtlcignIScsIG5hbWUsIGR5bmFtaWMpO1xuICAgIH1cbiAgICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICAgIGRlbGV0ZSBtb2RpZmllcnMub25jZTtcbiAgICAgIG5hbWUgPSBwcmVwZW5kTW9kaWZpZXJNYXJrZXIoJ34nLCBuYW1lLCBkeW5hbWljKTtcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnBhc3NpdmU7XG4gICAgICBuYW1lID0gcHJlcGVuZE1vZGlmaWVyTWFya2VyKCcmJywgbmFtZSwgZHluYW1pYyk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgICAgZGVsZXRlIG1vZGlmaWVycy5uYXRpdmU7XG4gICAgICBldmVudHMgPSBlbC5uYXRpdmVFdmVudHMgfHwgKGVsLm5hdGl2ZUV2ZW50cyA9IHt9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZlbnRzID0gZWwuZXZlbnRzIHx8IChlbC5ldmVudHMgPSB7fSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0hhbmRsZXIgPSByYW5nZVNldEl0ZW0oeyB2YWx1ZTogdmFsdWUudHJpbSgpLCBkeW5hbWljOiBkeW5hbWljIH0sIHJhbmdlKTtcbiAgICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgICAgbmV3SGFuZGxlci5tb2RpZmllcnMgPSBtb2RpZmllcnM7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXJzKSkge1xuICAgICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gICAgfSBlbHNlIGlmIChoYW5kbGVycykge1xuICAgICAgZXZlbnRzW25hbWVdID0gaW1wb3J0YW50ID8gW25ld0hhbmRsZXIsIGhhbmRsZXJzXSA6IFtoYW5kbGVycywgbmV3SGFuZGxlcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50c1tuYW1lXSA9IG5ld0hhbmRsZXI7XG4gICAgfVxuXG4gICAgZWwucGxhaW4gPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJhd0JpbmRpbmdBdHRyIChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHJldHVybiBlbC5yYXdBdHRyc01hcFsnOicgKyBuYW1lXSB8fFxuICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtYmluZDonICsgbmFtZV0gfHxcbiAgICAgIGVsLnJhd0F0dHJzTWFwW25hbWVdXG4gIH1cblxuICBmdW5jdGlvbiBnZXRCaW5kaW5nQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICBnZXRTdGF0aWNcbiAgKSB7XG4gICAgdmFyIGR5bmFtaWNWYWx1ZSA9XG4gICAgICBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnOicgKyBuYW1lKSB8fFxuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gICAgaWYgKGR5bmFtaWNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyc2VGaWx0ZXJzKGR5bmFtaWNWYWx1ZSlcbiAgICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBzdGF0aWNWYWx1ZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsIG5hbWUpO1xuICAgICAgaWYgKHN0YXRpY1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdGU6IHRoaXMgb25seSByZW1vdmVzIHRoZSBhdHRyIGZyb20gdGhlIEFycmF5IChhdHRyc0xpc3QpIHNvIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBnZXQgcHJvY2Vzc2VkIGJ5IHByb2Nlc3NBdHRycy5cbiAgLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4gIC8vIG5lZWRlZCBkdXJpbmcgY29kZWdlbi5cbiAgZnVuY3Rpb24gZ2V0QW5kUmVtb3ZlQXR0ciAoXG4gICAgZWwsXG4gICAgbmFtZSxcbiAgICByZW1vdmVGcm9tTWFwXG4gICkge1xuICAgIHZhciB2YWw7XG4gICAgaWYgKCh2YWwgPSBlbC5hdHRyc01hcFtuYW1lXSkgIT0gbnVsbCkge1xuICAgICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChsaXN0W2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyZW1vdmVGcm9tTWFwKSB7XG4gICAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gICAgfVxuICAgIHJldHVybiB2YWxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4IChcbiAgICBlbCxcbiAgICBuYW1lXG4gICkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhdHRyID0gbGlzdFtpXTtcbiAgICAgIGlmIChuYW1lLnRlc3QoYXR0ci5uYW1lKSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuIGF0dHJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByYW5nZVNldEl0ZW0gKFxuICAgIGl0ZW0sXG4gICAgcmFuZ2VcbiAgKSB7XG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBpdGVtLnN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgaXRlbS5lbmQgPSByYW5nZS5lbmQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtXG4gIH1cblxuICAvKiAgKi9cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZSBnZW5lcmF0aW9uIGZvciBjb21wb25lbnQgdi1tb2RlbFxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuQ29tcG9uZW50TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBudW1iZXIgPSByZWYubnVtYmVyO1xuICAgIHZhciB0cmltID0gcmVmLnRyaW07XG5cbiAgICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSBiYXNlVmFsdWVFeHByZXNzaW9uO1xuICAgIGlmICh0cmltKSB7XG4gICAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgICBcIih0eXBlb2YgXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIgPT09ICdzdHJpbmcnXCIgK1xuICAgICAgICBcIj8gXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIudHJpbSgpXCIgK1xuICAgICAgICBcIjogXCIgKyBiYXNlVmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChudW1iZXIpIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiX24oXCIgKyB2YWx1ZUV4cHJlc3Npb24gKyBcIilcIjtcbiAgICB9XG4gICAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICAgIGVsLm1vZGVsID0ge1xuICAgICAgdmFsdWU6IChcIihcIiArIHZhbHVlICsgXCIpXCIpLFxuICAgICAgZXhwcmVzc2lvbjogSlNPTi5zdHJpbmdpZnkodmFsdWUpLFxuICAgICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3Jvc3MtcGxhdGZvcm0gY29kZWdlbiBoZWxwZXIgZm9yIGdlbmVyYXRpbmcgdi1tb2RlbCB2YWx1ZSBhc3NpZ25tZW50IGNvZGUuXG4gICAqL1xuICBmdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gICAgdmFsdWUsXG4gICAgYXNzaWdubWVudFxuICApIHtcbiAgICB2YXIgcmVzID0gcGFyc2VNb2RlbCh2YWx1ZSk7XG4gICAgaWYgKHJlcy5rZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoXCIkc2V0KFwiICsgKHJlcy5leHApICsgXCIsIFwiICsgKHJlcy5rZXkpICsgXCIsIFwiICsgYXNzaWdubWVudCArIFwiKVwiKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICAgKiBIYW5kbGVzIGJvdGggZG90LXBhdGggYW5kIHBvc3NpYmxlIHNxdWFyZSBicmFja2V0cy5cbiAgICpcbiAgICogUG9zc2libGUgY2FzZXM6XG4gICAqXG4gICAqIC0gdGVzdFxuICAgKiAtIHRlc3Rba2V5XVxuICAgKiAtIHRlc3RbdGVzdDFba2V5XV1cbiAgICogLSB0ZXN0W1wiYVwiXVtrZXldXG4gICAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICAgKiAtIHRlc3QueHh4LmFbXCJhc2FcIl1bdGVzdDFba2V5XV1cbiAgICpcbiAgICovXG5cbiAgdmFyIGxlbiwgc3RyLCBjaHIsIGluZGV4JDEsIGV4cHJlc3Npb25Qb3MsIGV4cHJlc3Npb25FbmRQb3M7XG5cblxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICAgIC8vIEZpeCBodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlL3B1bGwvNzczMFxuICAgIC8vIGFsbG93IHYtbW9kZWw9XCJvYmoudmFsIFwiICh0cmFpbGluZyB3aGl0ZXNwYWNlKVxuICAgIHZhbCA9IHZhbC50cmltKCk7XG4gICAgbGVuID0gdmFsLmxlbmd0aDtcblxuICAgIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICAgIGluZGV4JDEgPSB2YWwubGFzdEluZGV4T2YoJy4nKTtcbiAgICAgIGlmIChpbmRleCQxID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBleHA6IHZhbC5zbGljZSgwLCBpbmRleCQxKSxcbiAgICAgICAgICBrZXk6ICdcIicgKyB2YWwuc2xpY2UoaW5kZXgkMSArIDEpICsgJ1wiJ1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGV4cDogdmFsLFxuICAgICAgICAgIGtleTogbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RyID0gdmFsO1xuICAgIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgICB3aGlsZSAoIWVvZigpKSB7XG4gICAgICBjaHIgPSBuZXh0KCk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc1N0cmluZ1N0YXJ0KGNocikpIHtcbiAgICAgICAgcGFyc2VTdHJpbmcoY2hyKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICAgIHBhcnNlQnJhY2tldChjaHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBleHA6IHZhbC5zbGljZSgwLCBleHByZXNzaW9uUG9zKSxcbiAgICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIHJldHVybiBzdHIuY2hhckNvZGVBdCgrK2luZGV4JDEpXG4gIH1cblxuICBmdW5jdGlvbiBlb2YgKCkge1xuICAgIHJldHVybiBpbmRleCQxID49IGxlblxuICB9XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gICAgcmV0dXJuIGNociA9PT0gMHgyMiB8fCBjaHIgPT09IDB4MjdcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gICAgdmFyIGluQnJhY2tldCA9IDE7XG4gICAgZXhwcmVzc2lvblBvcyA9IGluZGV4JDE7XG4gICAgd2hpbGUgKCFlb2YoKSkge1xuICAgICAgY2hyID0gbmV4dCgpO1xuICAgICAgaWYgKGlzU3RyaW5nU3RhcnQoY2hyKSkge1xuICAgICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgICAgaWYgKGNociA9PT0gMHg1RCkgeyBpbkJyYWNrZXQtLTsgfVxuICAgICAgaWYgKGluQnJhY2tldCA9PT0gMCkge1xuICAgICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0cmluZyAoY2hyKSB7XG4gICAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICAgIHdoaWxlICghZW9mKCkpIHtcbiAgICAgIGNociA9IG5leHQoKTtcbiAgICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIHdhcm4kMTtcblxuICAvLyBpbiBzb21lIGNhc2VzLCB0aGUgZXZlbnQgdXNlZCBoYXMgdG8gYmUgZGV0ZXJtaW5lZCBhdCBydW50aW1lXG4gIC8vIHNvIHdlIHVzZWQgc29tZSByZXNlcnZlZCB0b2tlbnMgZHVyaW5nIGNvbXBpbGUuXG4gIHZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xuICB2YXIgQ0hFQ0tCT1hfUkFESU9fVE9LRU4gPSAnX19jJztcblxuICBmdW5jdGlvbiBtb2RlbCAoXG4gICAgZWwsXG4gICAgZGlyLFxuICAgIF93YXJuXG4gICkge1xuICAgIHdhcm4kMSA9IF93YXJuO1xuICAgIHZhciB2YWx1ZSA9IGRpci52YWx1ZTtcbiAgICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgICB2YXIgdGFnID0gZWwudGFnO1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIHtcbiAgICAgIC8vIGlucHV0cyB3aXRoIHR5cGU9XCJmaWxlXCIgYXJlIHJlYWQgb25seSBhbmQgc2V0dGluZyB0aGUgaW5wdXQnc1xuICAgICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmICh0YWcgPT09ICdpbnB1dCcgJiYgdHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIHdhcm4kMShcbiAgICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICAgIFwiRmlsZSBpbnB1dHMgYXJlIHJlYWQgb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1tb2RlbCddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgZ2VuU2VsZWN0KGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICBnZW5DaGVja2JveE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAncmFkaW8nKSB7XG4gICAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgIGdlbkRlZmF1bHRNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gICAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgZ2VuQ29tcG9uZW50TW9kZWwoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICAgICAgLy8gY29tcG9uZW50IHYtbW9kZWwgZG9lc24ndCBuZWVkIGV4dHJhIHJ1bnRpbWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIFwiPFwiICsgKGVsLnRhZykgKyBcIiB2LW1vZGVsPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiPjogXCIgK1xuICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiB0aGlzIGVsZW1lbnQgdHlwZS4gXCIgK1xuICAgICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICAgIGVsLnJhd0F0dHJzTWFwWyd2LW1vZGVsJ11cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHJ1bnRpbWUgZGlyZWN0aXZlIG1ldGFkYXRhXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNoZWNrYm94TW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuICApIHtcbiAgICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gICAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gICAgdmFyIHRydWVWYWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3RydWUtdmFsdWUnKSB8fCAndHJ1ZSc7XG4gICAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gICAgYWRkUHJvcChlbCwgJ2NoZWNrZWQnLFxuICAgICAgXCJBcnJheS5pc0FycmF5KFwiICsgdmFsdWUgKyBcIilcIiArXG4gICAgICBcIj9faShcIiArIHZhbHVlICsgXCIsXCIgKyB2YWx1ZUJpbmRpbmcgKyBcIik+LTFcIiArIChcbiAgICAgICAgdHJ1ZVZhbHVlQmluZGluZyA9PT0gJ3RydWUnXG4gICAgICAgICAgPyAoXCI6KFwiICsgdmFsdWUgKyBcIilcIilcbiAgICAgICAgICA6IChcIjpfcShcIiArIHZhbHVlICsgXCIsXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpXCIpXG4gICAgICApXG4gICAgKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJyxcbiAgICAgIFwidmFyICQkYT1cIiArIHZhbHVlICsgXCIsXCIgK1xuICAgICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgICAgXCIkJGM9JCRlbC5jaGVja2VkPyhcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIik6KFwiICsgZmFsc2VWYWx1ZUJpbmRpbmcgKyBcIik7XCIgK1xuICAgICAgJ2lmKEFycmF5LmlzQXJyYXkoJCRhKSl7JyArXG4gICAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgICAnJCRpPV9pKCQkYSwkJHYpOycgK1xuICAgICAgICBcImlmKCQkZWwuY2hlY2tlZCl7JCRpPDAmJihcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYS5jb25jYXQoWyQkdl0pJykpICsgXCIpfVwiICtcbiAgICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgKGdlbkFzc2lnbm1lbnRDb2RlKHZhbHVlLCAnJCRhLnNsaWNlKDAsJCRpKS5jb25jYXQoJCRhLnNsaWNlKCQkaSsxKSknKSkgKyBcIil9XCIgK1xuICAgICAgXCJ9ZWxzZXtcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgJyQkYycpKSArIFwifVwiLFxuICAgICAgbnVsbCwgdHJ1ZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5SYWRpb01vZGVsIChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICAgIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICAgIGFkZFByb3AoZWwsICdjaGVja2VkJywgKFwiX3EoXCIgKyB2YWx1ZSArIFwiLFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCAnY2hhbmdlJywgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlQmluZGluZyksIG51bGwsIHRydWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2VsZWN0IChcbiAgICBlbCxcbiAgICB2YWx1ZSxcbiAgICBtb2RpZmllcnNcbiAgKSB7XG4gICAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICAgIHZhciBzZWxlY3RlZFZhbCA9IFwiQXJyYXkucHJvdG90eXBlLmZpbHRlclwiICtcbiAgICAgIFwiLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSlcIiArXG4gICAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgICAgXCJyZXR1cm4gXCIgKyAobnVtYmVyID8gJ19uKHZhbCknIDogJ3ZhbCcpICsgXCJ9KVwiO1xuXG4gICAgdmFyIGFzc2lnbm1lbnQgPSAnJGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdJztcbiAgICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gICAgY29kZSA9IGNvZGUgKyBcIiBcIiArIChnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgYXNzaWdubWVudCkpO1xuICAgIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBjb2RlLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkRlZmF1bHRNb2RlbCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4gICkge1xuICAgIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAgIC8vIHdhcm4gaWYgdi1iaW5kOnZhbHVlIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWxcbiAgICAvLyBleGNlcHQgZm9yIGlucHV0cyB3aXRoIHYtYmluZDp0eXBlXG4gICAge1xuICAgICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZWwuYXR0cnNNYXBbJ3YtYmluZDp0eXBlJ10gfHwgZWwuYXR0cnNNYXBbJzp0eXBlJ107XG4gICAgICBpZiAodmFsdWUkMSAmJiAhdHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGJpbmRpbmcgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gPyAndi1iaW5kOnZhbHVlJyA6ICc6dmFsdWUnO1xuICAgICAgICB3YXJuJDEoXG4gICAgICAgICAgYmluZGluZyArIFwiPVxcXCJcIiArIHZhbHVlJDEgKyBcIlxcXCIgY29uZmxpY3RzIHdpdGggdi1tb2RlbCBvbiB0aGUgc2FtZSBlbGVtZW50IFwiICtcbiAgICAgICAgICAnYmVjYXVzZSB0aGUgbGF0dGVyIGFscmVhZHkgZXhwYW5kcyB0byBhIHZhbHVlIGJpbmRpbmcgaW50ZXJuYWxseScsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbYmluZGluZ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICAgIHZhciBsYXp5ID0gcmVmLmxhenk7XG4gICAgdmFyIG51bWJlciA9IHJlZi5udW1iZXI7XG4gICAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgICB2YXIgbmVlZENvbXBvc2l0aW9uR3VhcmQgPSAhbGF6eSAmJiB0eXBlICE9PSAncmFuZ2UnO1xuICAgIHZhciBldmVudCA9IGxhenlcbiAgICAgID8gJ2NoYW5nZSdcbiAgICAgIDogdHlwZSA9PT0gJ3JhbmdlJ1xuICAgICAgICA/IFJBTkdFX1RPS0VOXG4gICAgICAgIDogJ2lucHV0JztcblxuICAgIHZhciB2YWx1ZUV4cHJlc3Npb24gPSAnJGV2ZW50LnRhcmdldC52YWx1ZSc7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgICB9XG4gICAgaWYgKG51bWJlcikge1xuICAgICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICAgIH1cblxuICAgIHZhciBjb2RlID0gZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIHZhbHVlRXhwcmVzc2lvbik7XG4gICAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgICBjb2RlID0gXCJpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZylyZXR1cm47XCIgKyBjb2RlO1xuICAgIH1cblxuICAgIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgICBhZGRIYW5kbGVyKGVsLCBldmVudCwgY29kZSwgbnVsbCwgdHJ1ZSk7XG4gICAgaWYgKHRyaW0gfHwgbnVtYmVyKSB7XG4gICAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIC8vIG5vcm1hbGl6ZSB2LW1vZGVsIGV2ZW50IHRva2VucyB0aGF0IGNhbiBvbmx5IGJlIGRldGVybWluZWQgYXQgcnVudGltZS5cbiAgLy8gaXQncyBpbXBvcnRhbnQgdG8gcGxhY2UgdGhlIGV2ZW50IGFzIHRoZSBmaXJzdCBpbiB0aGUgYXJyYXkgYmVjYXVzZVxuICAvLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gIC8vIHVzZXItYXR0YWNoZWQgaGFuZGxlcnMuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50cyAob24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bUkFOR0VfVE9LRU5dKSkge1xuICAgICAgLy8gSUUgaW5wdXRbdHlwZT1yYW5nZV0gb25seSBzdXBwb3J0cyBgY2hhbmdlYCBldmVudFxuICAgICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICAgIG9uW2V2ZW50XSA9IFtdLmNvbmNhdChvbltSQU5HRV9UT0tFTl0sIG9uW2V2ZW50XSB8fCBbXSk7XG4gICAgICBkZWxldGUgb25bUkFOR0VfVE9LRU5dO1xuICAgIH1cbiAgICAvLyBUaGlzIHdhcyBvcmlnaW5hbGx5IGludGVuZGVkIHRvIGZpeCAjNDUyMSBidXQgbm8gbG9uZ2VyIG5lY2Vzc2FyeVxuICAgIC8vIGFmdGVyIDIuNS4gS2VlcGluZyBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdCB3aXRoIGdlbmVyYXRlZCBjb2RlIGZyb20gPCAyLjRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNEZWYob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dKSkge1xuICAgICAgb24uY2hhbmdlID0gW10uY29uY2F0KG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSwgb24uY2hhbmdlIHx8IFtdKTtcbiAgICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhcmdldCQxO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9uY2VIYW5kbGVyJDEgKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgICByZXR1cm4gZnVuY3Rpb24gb25jZUhhbmRsZXIgKCkge1xuICAgICAgdmFyIHJlcyA9IGhhbmRsZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlJDIoZXZlbnQsIG9uY2VIYW5kbGVyLCBjYXB0dXJlLCBfdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAjOTQ0NjogRmlyZWZveCA8PSA1MyAoaW4gcGFydGljdWxhciwgRVNSIDUyKSBoYXMgaW5jb3JyZWN0IEV2ZW50LnRpbWVTdGFtcFxuICAvLyBpbXBsZW1lbnRhdGlvbiBhbmQgZG9lcyBub3QgZmlyZSBtaWNyb3Rhc2tzIGluIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24sIHNvXG4gIC8vIHNhZmUgdG8gZXhjbHVkZS5cbiAgdmFyIHVzZU1pY3JvdGFza0ZpeCA9IGlzVXNpbmdNaWNyb1Rhc2sgJiYgIShpc0ZGICYmIE51bWJlcihpc0ZGWzFdKSA8PSA1Myk7XG5cbiAgZnVuY3Rpb24gYWRkJDEgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIHBhc3NpdmVcbiAgKSB7XG4gICAgLy8gYXN5bmMgZWRnZSBjYXNlICM2NTY2OiBpbm5lciBjbGljayBldmVudCB0cmlnZ2VycyBwYXRjaCwgZXZlbnQgaGFuZGxlclxuICAgIC8vIGF0dGFjaGVkIHRvIG91dGVyIGVsZW1lbnQgZHVyaW5nIHBhdGNoLCBhbmQgdHJpZ2dlcmVkIGFnYWluLiBUaGlzXG4gICAgLy8gaGFwcGVucyBiZWNhdXNlIGJyb3dzZXJzIGZpcmUgbWljcm90YXNrIHRpY2tzIGJldHdlZW4gZXZlbnQgcHJvcGFnYXRpb24uXG4gICAgLy8gdGhlIHNvbHV0aW9uIGlzIHNpbXBsZTogd2Ugc2F2ZSB0aGUgdGltZXN0YW1wIHdoZW4gYSBoYW5kbGVyIGlzIGF0dGFjaGVkLFxuICAgIC8vIGFuZCB0aGUgaGFuZGxlciB3b3VsZCBvbmx5IGZpcmUgaWYgdGhlIGV2ZW50IHBhc3NlZCB0byBpdCB3YXMgZmlyZWRcbiAgICAvLyBBRlRFUiBpdCB3YXMgYXR0YWNoZWQuXG4gICAgaWYgKHVzZU1pY3JvdGFza0ZpeCkge1xuICAgICAgdmFyIGF0dGFjaGVkVGltZXN0YW1wID0gY3VycmVudEZsdXNoVGltZXN0YW1wO1xuICAgICAgdmFyIG9yaWdpbmFsID0gaGFuZGxlcjtcbiAgICAgIGhhbmRsZXIgPSBvcmlnaW5hbC5fd3JhcHBlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBubyBidWJibGluZywgc2hvdWxkIGFsd2F5cyBmaXJlLlxuICAgICAgICAgIC8vIHRoaXMgaXMganVzdCBhIHNhZmV0eSBuZXQgaW4gY2FzZSBldmVudC50aW1lU3RhbXAgaXMgdW5yZWxpYWJsZSBpblxuICAgICAgICAgIC8vIGNlcnRhaW4gd2VpcmQgZW52aXJvbm1lbnRzLi4uXG4gICAgICAgICAgZS50YXJnZXQgPT09IGUuY3VycmVudFRhcmdldCB8fFxuICAgICAgICAgIC8vIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGhhbmRsZXIgYXR0YWNobWVudFxuICAgICAgICAgIGUudGltZVN0YW1wID49IGF0dGFjaGVkVGltZXN0YW1wIHx8XG4gICAgICAgICAgLy8gIzk0NjIgYmFpbCBmb3IgaU9TIDkgYnVnOiBldmVudC50aW1lU3RhbXAgaXMgMCBhZnRlciBoaXN0b3J5LnB1c2hTdGF0ZVxuICAgICAgICAgIGUudGltZVN0YW1wID09PSAwIHx8XG4gICAgICAgICAgLy8gIzk0NDggYmFpbCBpZiBldmVudCBpcyBmaXJlZCBpbiBhbm90aGVyIGRvY3VtZW50IGluIGEgbXVsdGktcGFnZVxuICAgICAgICAgIC8vIGVsZWN0cm9uL253LmpzIGFwcCwgc2luY2UgZXZlbnQudGltZVN0YW1wIHdpbGwgYmUgdXNpbmcgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyBzdGFydGluZyByZWZlcmVuY2VcbiAgICAgICAgICBlLnRhcmdldC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudFxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgbmFtZSxcbiAgICAgIGhhbmRsZXIsXG4gICAgICBzdXBwb3J0c1Bhc3NpdmVcbiAgICAgICAgPyB7IGNhcHR1cmU6IGNhcHR1cmUsIHBhc3NpdmU6IHBhc3NpdmUgfVxuICAgICAgICA6IGNhcHR1cmVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICAgIG5hbWUsXG4gICAgaGFuZGxlcixcbiAgICBjYXB0dXJlLFxuICAgIF90YXJnZXRcbiAgKSB7XG4gICAgKF90YXJnZXQgfHwgdGFyZ2V0JDEpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBuYW1lLFxuICAgICAgaGFuZGxlci5fd3JhcHBlciB8fCBoYW5kbGVyLFxuICAgICAgY2FwdHVyZVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEub24pICYmIGlzVW5kZWYodm5vZGUuZGF0YS5vbikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICAgIHZhciBvbGRPbiA9IG9sZFZub2RlLmRhdGEub24gfHwge307XG4gICAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gICAgbm9ybWFsaXplRXZlbnRzKG9uKTtcbiAgICB1cGRhdGVMaXN0ZW5lcnMob24sIG9sZE9uLCBhZGQkMSwgcmVtb3ZlJDIsIGNyZWF0ZU9uY2VIYW5kbGVyJDEsIHZub2RlLmNvbnRleHQpO1xuICAgIHRhcmdldCQxID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIGV2ZW50cyA9IHtcbiAgICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgICB1cGRhdGU6IHVwZGF0ZURPTUxpc3RlbmVyc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBzdmdDb250YWluZXI7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRE9NUHJvcHMgKG9sZFZub2RlLCB2bm9kZSkge1xuICAgIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIga2V5LCBjdXI7XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkUHJvcHMgPSBvbGRWbm9kZS5kYXRhLmRvbVByb3BzIHx8IHt9O1xuICAgIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gICAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gICAgaWYgKGlzRGVmKHByb3BzLl9fb2JfXykpIHtcbiAgICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICAgIH1cblxuICAgIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgICBlbG1ba2V5XSA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGtleSBpbiBwcm9wcykge1xuICAgICAgY3VyID0gcHJvcHNba2V5XTtcbiAgICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgICAgLy8gYXMgdGhlc2Ugd2lsbCB0aHJvdyBhd2F5IGV4aXN0aW5nIERPTSBub2RlcyBhbmQgY2F1c2UgcmVtb3ZhbCBlcnJvcnNcbiAgICAgIC8vIG9uIHN1YnNlcXVlbnQgcGF0Y2hlcyAoIzMzNjApXG4gICAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7IHZub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7IH1cbiAgICAgICAgaWYgKGN1ciA9PT0gb2xkUHJvcHNba2V5XSkgeyBjb250aW51ZSB9XG4gICAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgICAgLy8gcmVwbGFjZWQgYnkgaW5uZXJIVE1ML3RleHRDb250ZW50IHJldGFpbnMgaXRzIHBhcmVudE5vZGUgcHJvcGVydHlcbiAgICAgICAgaWYgKGVsbS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PT0gJ3ZhbHVlJyAmJiBlbG0udGFnTmFtZSAhPT0gJ1BST0dSRVNTJykge1xuICAgICAgICAvLyBzdG9yZSB2YWx1ZSBhcyBfdmFsdWUgYXMgd2VsbCBzaW5jZVxuICAgICAgICAvLyBub24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkXG4gICAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAgIC8vIGF2b2lkIHJlc2V0dGluZyBjdXJzb3IgcG9zaXRpb24gd2hlbiB2YWx1ZSBpcyB0aGUgc2FtZVxuICAgICAgICB2YXIgc3RyQ3VyID0gaXNVbmRlZihjdXIpID8gJycgOiBTdHJpbmcoY3VyKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICAgIGVsbS52YWx1ZSA9IHN0ckN1cjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdpbm5lckhUTUwnICYmIGlzU1ZHKGVsbS50YWdOYW1lKSAmJiBpc1VuZGVmKGVsbS5pbm5lckhUTUwpKSB7XG4gICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBpbm5lckhUTUwgZm9yIFNWRyBlbGVtZW50c1xuICAgICAgICBzdmdDb250YWluZXIgPSBzdmdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIjxzdmc+XCIgKyBjdXIgKyBcIjwvc3ZnPlwiO1xuICAgICAgICB2YXIgc3ZnID0gc3ZnQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChlbG0uZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN2Zy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgZWxtLmFwcGVuZENoaWxkKHN2Zy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gc2tpcCB0aGUgdXBkYXRlIGlmIG9sZCBhbmQgbmV3IFZET00gc3RhdGUgaXMgdGhlIHNhbWUuXG4gICAgICAgIC8vIGB2YWx1ZWAgaXMgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgdGhlIERPTSB2YWx1ZSBtYXkgYmUgdGVtcG9yYXJpbHlcbiAgICAgICAgLy8gb3V0IG9mIHN5bmMgd2l0aCBWRE9NIHN0YXRlIGR1ZSB0byBmb2N1cywgY29tcG9zaXRpb24gYW5kIG1vZGlmaWVycy5cbiAgICAgICAgLy8gVGhpcyAgIzQ1MjEgYnkgc2tpcHBpbmcgdGhlIHVubmVjZXNhcnJ5IGBjaGVja2VkYCB1cGRhdGUuXG4gICAgICAgIGN1ciAhPT0gb2xkUHJvcHNba2V5XVxuICAgICAgKSB7XG4gICAgICAgIC8vIHNvbWUgcHJvcGVydHkgdXBkYXRlcyBjYW4gdGhyb3dcbiAgICAgICAgLy8gZS5nLiBgdmFsdWVgIG9uIDxwcm9ncmVzcz4gdy8gbm9uLWZpbml0ZSB2YWx1ZVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHBsYXRmb3Jtcy93ZWIvdXRpbC9hdHRycy5qcyBhY2NlcHRWYWx1ZVxuXG5cbiAgZnVuY3Rpb24gc2hvdWxkVXBkYXRlVmFsdWUgKGVsbSwgY2hlY2tWYWwpIHtcbiAgICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICAgIGVsbS50YWdOYW1lID09PSAnT1BUSU9OJyB8fFxuICAgICAgaXNOb3RJbkZvY3VzQW5kRGlydHkoZWxtLCBjaGVja1ZhbCkgfHxcbiAgICAgIGlzRGlydHlXaXRoTW9kaWZpZXJzKGVsbSwgY2hlY2tWYWwpXG4gICAgKSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm90SW5Gb2N1c0FuZERpcnR5IChlbG0sIGNoZWNrVmFsKSB7XG4gICAgLy8gcmV0dXJuIHRydWUgd2hlbiB0ZXh0Ym94ICgubnVtYmVyIGFuZCAudHJpbSkgbG9zZXMgZm9jdXMgYW5kIGl0cyB2YWx1ZSBpc1xuICAgIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICAgIHZhciBub3RJbkZvY3VzID0gdHJ1ZTtcbiAgICAvLyAjNjE1N1xuICAgIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICAgIHRyeSB7IG5vdEluRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbG07IH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIG5vdEluRm9jdXMgJiYgZWxtLnZhbHVlICE9PSBjaGVja1ZhbFxuICB9XG5cbiAgZnVuY3Rpb24gaXNEaXJ0eVdpdGhNb2RpZmllcnMgKGVsbSwgbmV3VmFsKSB7XG4gICAgdmFyIHZhbHVlID0gZWxtLnZhbHVlO1xuICAgIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICAgIGlmIChpc0RlZihtb2RpZmllcnMpKSB7XG4gICAgICBpZiAobW9kaWZpZXJzLm51bWJlcikge1xuICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpICE9PSB0b051bWJlcihuZXdWYWwpXG4gICAgICB9XG4gICAgICBpZiAobW9kaWZpZXJzLnRyaW0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgIT09IG5ld1ZhbFxuICB9XG5cbiAgdmFyIGRvbVByb3BzID0ge1xuICAgIGNyZWF0ZTogdXBkYXRlRE9NUHJvcHMsXG4gICAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgbGlzdERlbGltaXRlciA9IC87KD8hW14oXSpcXCkpL2c7XG4gICAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXNcbiAgfSk7XG5cbiAgLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbiAgZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gICAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKGRhdGEuc3R5bGUpO1xuICAgIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAgIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gICAgcmV0dXJuIGRhdGEuc3RhdGljU3R5bGVcbiAgICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgICAgOiBzdHlsZVxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuICBmdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJpbmRpbmdTdHlsZSkpIHtcbiAgICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgYmluZGluZ1N0eWxlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgICB9XG4gICAgcmV0dXJuIGJpbmRpbmdTdHlsZVxuICB9XG5cbiAgLyoqXG4gICAqIHBhcmVudCBjb21wb25lbnQgc3R5bGUgc2hvdWxkIGJlIGFmdGVyIGNoaWxkJ3NcbiAgICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAgICovXG4gIGZ1bmN0aW9uIGdldFN0eWxlICh2bm9kZSwgY2hlY2tDaGlsZCkge1xuICAgIHZhciByZXMgPSB7fTtcbiAgICB2YXIgc3R5bGVEYXRhO1xuXG4gICAgaWYgKGNoZWNrQ2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICAgIHdoaWxlIChjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UpIHtcbiAgICAgICAgY2hpbGROb2RlID0gY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNoaWxkTm9kZSAmJiBjaGlsZE5vZGUuZGF0YSAmJlxuICAgICAgICAgIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKVxuICAgICAgICApIHtcbiAgICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGNzc1ZhclJFID0gL14tLS87XG4gIHZhciBpbXBvcnRhbnRSRSA9IC9cXHMqIWltcG9ydGFudCQvO1xuICB2YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGNzc1ZhclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpbXBvcnRhbnRSRS50ZXN0KHZhbCkpIHtcbiAgICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KGh5cGhlbmF0ZShuYW1lKSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9ybWFsaXplZE5hbWUgPSBub3JtYWxpemUobmFtZSk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgdmFsdWVzIGFycmF5IGNyZWF0ZWQgYnkgYXV0b3ByZWZpeGVyLCBlLmcuXG4gICAgICAgIC8vIHtkaXNwbGF5OiBbXCItd2Via2l0LWJveFwiLCBcIi1tcy1mbGV4Ym94XCIsIFwiZmxleFwiXX1cbiAgICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgZWwuc3R5bGVbbm9ybWFsaXplZE5hbWVdID0gdmFsW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG4gIHZhciBlbXB0eVN0eWxlO1xuICB2YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gICAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICAgIGlmIChwcm9wICE9PSAnZmlsdGVyJyAmJiAocHJvcCBpbiBlbXB0eVN0eWxlKSkge1xuICAgICAgcmV0dXJuIHByb3BcbiAgICB9XG4gICAgdmFyIGNhcE5hbWUgPSBwcm9wLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcC5zbGljZSgxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IHZlbmRvck5hbWVzW2ldICsgY2FwTmFtZTtcbiAgICAgIGlmIChuYW1lIGluIGVtcHR5U3R5bGUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gICAgaWYgKGlzVW5kZWYoZGF0YS5zdGF0aWNTdHlsZSkgJiYgaXNVbmRlZihkYXRhLnN0eWxlKSAmJlxuICAgICAgaXNVbmRlZihvbGREYXRhLnN0YXRpY1N0eWxlKSAmJiBpc1VuZGVmKG9sZERhdGEuc3R5bGUpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgY3VyLCBuYW1lO1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcbiAgICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGREYXRhLnN0YXRpY1N0eWxlO1xuICAgIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gICAgLy8gaWYgc3RhdGljIHN0eWxlIGV4aXN0cywgc3R5bGViaW5kaW5nIGFscmVhZHkgbWVyZ2VkIGludG8gaXQgd2hlbiBkb2luZyBub3JtYWxpemVTdHlsZURhdGFcbiAgICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgICAvLyBzdG9yZSBub3JtYWxpemVkIHN0eWxlIHVuZGVyIGEgZGlmZmVyZW50IGtleSBmb3IgbmV4dCBkaWZmXG4gICAgLy8gbWFrZSBzdXJlIHRvIGNsb25lIGl0IGlmIGl0J3MgcmVhY3RpdmUsIHNpbmNlIHRoZSB1c2VyIGxpa2VseSB3YW50c1xuICAgIC8vIHRvIG11dGF0ZSBpdC5cbiAgICB2bm9kZS5kYXRhLm5vcm1hbGl6ZWRTdHlsZSA9IGlzRGVmKHN0eWxlLl9fb2JfXylcbiAgICAgID8gZXh0ZW5kKHt9LCBzdHlsZSlcbiAgICAgIDogc3R5bGU7XG5cbiAgICB2YXIgbmV3U3R5bGUgPSBnZXRTdHlsZSh2bm9kZSwgdHJ1ZSk7XG5cbiAgICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCAnJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBuZXdTdHlsZSkge1xuICAgICAgY3VyID0gbmV3U3R5bGVbbmFtZV07XG4gICAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgICAvLyBpZTkgc2V0dGluZyB0byBudWxsIGhhcyBubyBlZmZlY3QsIG11c3QgdXNlIGVtcHR5IHN0cmluZ1xuICAgICAgICBzZXRQcm9wKGVsLCBuYW1lLCBjdXIgPT0gbnVsbCA/ICcnIDogY3VyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3R5bGUgPSB7XG4gICAgY3JlYXRlOiB1cGRhdGVTdHlsZSxcbiAgICB1cGRhdGU6IHVwZGF0ZVN0eWxlXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHdoaXRlc3BhY2VSRSA9IC9cXHMrLztcblxuICAvKipcbiAgICogQWRkIGNsYXNzIHdpdGggY29tcGF0aWJpbGl0eSBmb3IgU1ZHIHNpbmNlIGNsYXNzTGlzdCBpcyBub3Qgc3VwcG9ydGVkIG9uXG4gICAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICAgKi9cbiAgZnVuY3Rpb24gYWRkQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgICAgY2xzLnNwbGl0KHdoaXRlc3BhY2VSRSkuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIChjdXIgKyBjbHMpLnRyaW0oKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICAgKiBTVkcgZWxlbWVudHMgaW4gSUVcbiAgICovXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjbHMgfHwgIShjbHMgPSBjbHMudHJpbSgpKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICAgIGNscy5zcGxpdCh3aGl0ZXNwYWNlUkUpLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5yZW1vdmUoYyk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgICAgfVxuICAgICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICAgIGN1ciA9IGN1ci5yZXBsYWNlKHRhciwgJyAnKTtcbiAgICAgIH1cbiAgICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgICBpZiAoY3VyKSB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdjbGFzcycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYkJDEpIHtcbiAgICBpZiAoIWRlZiQkMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBpZiAoZGVmJCQxLmNzcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgICB9XG4gICAgICBleHRlbmQocmVzLCBkZWYkJDEpO1xuICAgICAgcmV0dXJuIHJlc1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlZiQkMSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhdXRvQ3NzVHJhbnNpdGlvbihkZWYkJDEpXG4gICAgfVxuICB9XG5cbiAgdmFyIGF1dG9Dc3NUcmFuc2l0aW9uID0gY2FjaGVkKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgICBlbnRlclRvQ2xhc3M6IChuYW1lICsgXCItZW50ZXItdG9cIiksXG4gICAgICBlbnRlckFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWVudGVyLWFjdGl2ZVwiKSxcbiAgICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgICBsZWF2ZVRvQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtdG9cIiksXG4gICAgICBsZWF2ZUFjdGl2ZUNsYXNzOiAobmFtZSArIFwiLWxlYXZlLWFjdGl2ZVwiKVxuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGhhc1RyYW5zaXRpb24gPSBpbkJyb3dzZXIgJiYgIWlzSUU5O1xuICB2YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbiAgdmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4gIC8vIFRyYW5zaXRpb24gcHJvcGVydHkvZXZlbnQgc25pZmZpbmdcbiAgdmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xuICB2YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xuICB2YXIgYW5pbWF0aW9uUHJvcCA9ICdhbmltYXRpb24nO1xuICB2YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbiAgaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgICAgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xuICAgIH1cbiAgICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHdpbmRvdy5vbndlYmtpdGFuaW1hdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgICBhbmltYXRpb25FbmRFdmVudCA9ICd3ZWJraXRBbmltYXRpb25FbmQnO1xuICAgIH1cbiAgfVxuXG4gIC8vIGJpbmRpbmcgdG8gd2luZG93IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGhvdCByZWxvYWQgd29yayBpbiBJRSBpbiBzdHJpY3QgbW9kZVxuICB2YXIgcmFmID0gaW5Ccm93c2VyXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG4gICAgICA6IHNldFRpbWVvdXRcbiAgICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuICBmdW5jdGlvbiBuZXh0RnJhbWUgKGZuKSB7XG4gICAgcmFmKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJhZihmbik7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgICB2YXIgdHJhbnNpdGlvbkNsYXNzZXMgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXMgfHwgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyA9IFtdKTtcbiAgICBpZiAodHJhbnNpdGlvbkNsYXNzZXMuaW5kZXhPZihjbHMpIDwgMCkge1xuICAgICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgICAgYWRkQ2xhc3MoZWwsIGNscyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVHJhbnNpdGlvbkNsYXNzIChlbCwgY2xzKSB7XG4gICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3MoZWwsIGNscyk7XG4gIH1cblxuICBmdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkVuZHMgKFxuICAgIGVsLFxuICAgIGV4cGVjdGVkVHlwZSxcbiAgICBjYlxuICApIHtcbiAgICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gICAgdmFyIHR5cGUgPSByZWYudHlwZTtcbiAgICB2YXIgdGltZW91dCA9IHJlZi50aW1lb3V0O1xuICAgIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICAgIGlmICghdHlwZSkgeyByZXR1cm4gY2IoKSB9XG4gICAgdmFyIGV2ZW50ID0gdHlwZSA9PT0gVFJBTlNJVElPTiA/IHRyYW5zaXRpb25FbmRFdmVudCA6IGFuaW1hdGlvbkVuZEV2ZW50O1xuICAgIHZhciBlbmRlZCA9IDA7XG4gICAgdmFyIGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgICAgIGNiKCk7XG4gICAgfTtcbiAgICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgICBpZiAoKytlbmRlZCA+PSBwcm9wQ291bnQpIHtcbiAgICAgICAgICBlbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kZWQgPCBwcm9wQ291bnQpIHtcbiAgICAgICAgZW5kKCk7XG4gICAgICB9XG4gICAgfSwgdGltZW91dCArIDEpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIG9uRW5kKTtcbiAgfVxuXG4gIHZhciB0cmFuc2Zvcm1SRSA9IC9cXGIodHJhbnNmb3JtfGFsbCkoLHwkKS87XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNpdGlvbkluZm8gKGVsLCBleHBlY3RlZFR5cGUpIHtcbiAgICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIC8vIEpTRE9NIG1heSByZXR1cm4gdW5kZWZpbmVkIGZvciB0cmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXSB8fCAnJykuc3BsaXQoJywgJyk7XG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSAoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciB0cmFuc2l0aW9uVGltZW91dCA9IGdldFRpbWVvdXQodHJhbnNpdGlvbkRlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gICAgdmFyIGFuaW1hdGlvbkRlbGF5cyA9IChzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gKHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgdGltZW91dCA9IDA7XG4gICAgdmFyIHByb3BDb3VudCA9IDA7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGV4cGVjdGVkVHlwZSA9PT0gVFJBTlNJVElPTikge1xuICAgICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgICAgdGltZW91dCA9IHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gQU5JTUFUSU9OKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgICAgdGltZW91dCA9IGFuaW1hdGlvblRpbWVvdXQ7XG4gICAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgICAgPyB0cmFuc2l0aW9uVGltZW91dCA+IGFuaW1hdGlvblRpbWVvdXRcbiAgICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgICA6IG51bGw7XG4gICAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICAgID8gdHJhbnNpdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgICAgOiAwO1xuICAgIH1cbiAgICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICAgIHRyYW5zZm9ybVJFLnRlc3Qoc3R5bGVzW3RyYW5zaXRpb25Qcm9wICsgJ1Byb3BlcnR5J10pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgdGltZW91dDogdGltZW91dCxcbiAgICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gICAgfSkpXG4gIH1cblxuICAvLyBPbGQgdmVyc2lvbnMgb2YgQ2hyb21pdW0gKGJlbG93IDYxLjAuMzE2My4xMDApIGZvcm1hdHMgZmxvYXRpbmcgcG9pbnRlciBudW1iZXJzXG4gIC8vIGluIGEgbG9jYWxlLWRlcGVuZGVudCB3YXksIHVzaW5nIGEgY29tbWEgaW5zdGVhZCBvZiBhIGRvdC5cbiAgLy8gSWYgY29tbWEgaXMgbm90IHJlcGxhY2VkIHdpdGggYSBkb3QsIHRoZSBpbnB1dCB3aWxsIGJlIHJvdW5kZWQgZG93biAoaS5lLiBhY3RpbmdcbiAgLy8gYXMgYSBmbG9vciBmdW5jdGlvbikgY2F1c2luZyB1bmV4cGVjdGVkIGJlaGF2aW9yc1xuICBmdW5jdGlvbiB0b01zIChzKSB7XG4gICAgcmV0dXJuIE51bWJlcihzLnNsaWNlKDAsIC0xKS5yZXBsYWNlKCcsJywgJy4nKSkgKiAxMDAwXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBlbnRlciAodm5vZGUsIHRvZ2dsZURpc3BsYXkpIHtcbiAgICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICBlbC5fbGVhdmVDYigpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgICBpZiAoaXNVbmRlZihkYXRhKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgIHZhciBlbnRlckNsYXNzID0gZGF0YS5lbnRlckNsYXNzO1xuICAgIHZhciBlbnRlclRvQ2xhc3MgPSBkYXRhLmVudGVyVG9DbGFzcztcbiAgICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICAgIHZhciBhcHBlYXJUb0NsYXNzID0gZGF0YS5hcHBlYXJUb0NsYXNzO1xuICAgIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUVudGVyID0gZGF0YS5iZWZvcmVFbnRlcjtcbiAgICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICAgIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZCA9IGRhdGEuZW50ZXJDYW5jZWxsZWQ7XG4gICAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICAgIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgICB2YXIgYWZ0ZXJBcHBlYXIgPSBkYXRhLmFmdGVyQXBwZWFyO1xuICAgIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcbiAgICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gICAgLy8gYWN0aXZlSW5zdGFuY2Ugd2lsbCBhbHdheXMgYmUgdGhlIDx0cmFuc2l0aW9uPiBjb21wb25lbnQgbWFuYWdpbmcgdGhpc1xuICAgIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAgIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gICAgLy8gPHRyYW5zaXRpb24+J3MgcGFyZW50IGZvciBhcHBlYXIgY2hlY2suXG4gICAgdmFyIGNvbnRleHQgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gICAgd2hpbGUgKHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudCkge1xuICAgICAgdHJhbnNpdGlvbk5vZGUgPSB0cmFuc2l0aW9uTm9kZS5wYXJlbnQ7XG4gICAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcHBlYXIgPSAhY29udGV4dC5faXNNb3VudGVkIHx8ICF2bm9kZS5pc1Jvb3RJbnNlcnQ7XG5cbiAgICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgICA/IGFwcGVhckNsYXNzXG4gICAgICA6IGVudGVyQ2xhc3M7XG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgID8gYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICAgIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICAgID8gYXBwZWFyVG9DbGFzc1xuICAgICAgOiBlbnRlclRvQ2xhc3M7XG5cbiAgICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICAgID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcilcbiAgICAgIDogYmVmb3JlRW50ZXI7XG4gICAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/ICh0eXBlb2YgYXBwZWFyID09PSAnZnVuY3Rpb24nID8gYXBwZWFyIDogZW50ZXIpXG4gICAgICA6IGVudGVyO1xuICAgIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgICA/IChhZnRlckFwcGVhciB8fCBhZnRlckVudGVyKVxuICAgICAgOiBhZnRlckVudGVyO1xuICAgIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgICAgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKVxuICAgICAgOiBlbnRlckNhbmNlbGxlZDtcblxuICAgIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmVudGVyXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICBjaGVja0R1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbiwgJ2VudGVyJywgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGVudGVySG9vayk7XG5cbiAgICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICAgIH1cbiAgICAgIGVsLl9lbnRlckNiID0gbnVsbDtcbiAgICB9KTtcblxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAvLyByZW1vdmUgcGVuZGluZyBsZWF2ZSBlbGVtZW50IG9uIGVudGVyIGJ5IGluamVjdGluZyBhbiBpbnNlcnQgaG9va1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgcGVuZGluZ05vZGUgPSBwYXJlbnQgJiYgcGFyZW50Ll9wZW5kaW5nICYmIHBhcmVudC5fcGVuZGluZ1t2bm9kZS5rZXldO1xuICAgICAgICBpZiAocGVuZGluZ05vZGUgJiZcbiAgICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYlxuICAgICAgICApIHtcbiAgICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgICAgfVxuICAgICAgICBlbnRlckhvb2sgJiYgZW50ZXJIb29rKGVsLCBjYik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzdGFydCBlbnRlciB0cmFuc2l0aW9uXG4gICAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICB0b2dnbGVEaXNwbGF5ICYmIHRvZ2dsZURpc3BsYXkoKTtcbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9XG5cbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbGVhdmUgKHZub2RlLCBybSkge1xuICAgIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAgIC8vIGNhbGwgZW50ZXIgY2FsbGJhY2sgbm93XG4gICAgaWYgKGlzRGVmKGVsLl9lbnRlckNiKSkge1xuICAgICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgIGVsLl9lbnRlckNiKCk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICAgIGlmIChpc1VuZGVmKGRhdGEpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm4gcm0oKVxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihlbC5fbGVhdmVDYikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjc3MgPSBkYXRhLmNzcztcbiAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgICB2YXIgbGVhdmVUb0NsYXNzID0gZGF0YS5sZWF2ZVRvQ2xhc3M7XG4gICAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gICAgdmFyIGJlZm9yZUxlYXZlID0gZGF0YS5iZWZvcmVMZWF2ZTtcbiAgICB2YXIgbGVhdmUgPSBkYXRhLmxlYXZlO1xuICAgIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICAgIHZhciBsZWF2ZUNhbmNlbGxlZCA9IGRhdGEubGVhdmVDYW5jZWxsZWQ7XG4gICAgdmFyIGRlbGF5TGVhdmUgPSBkYXRhLmRlbGF5TGVhdmU7XG4gICAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICAgIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gICAgdmFyIHVzZXJXYW50c0NvbnRyb2wgPSBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKGxlYXZlKTtcblxuICAgIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICAgIGlzT2JqZWN0KGR1cmF0aW9uKVxuICAgICAgICA/IGR1cmF0aW9uLmxlYXZlXG4gICAgICAgIDogZHVyYXRpb25cbiAgICApO1xuXG4gICAgaWYgKGlzRGVmKGV4cGxpY2l0TGVhdmVEdXJhdGlvbikpIHtcbiAgICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uLCAnbGVhdmUnLCB2bm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlbC5wYXJlbnROb2RlICYmIGVsLnBhcmVudE5vZGUuX3BlbmRpbmcpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICB9XG4gICAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJtKCk7XG4gICAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgICB9XG4gICAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoZGVsYXlMZWF2ZSkge1xuICAgICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJmb3JtTGVhdmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgICAgLy8gdGhlIGRlbGF5ZWQgbGVhdmUgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNhbmNlbGxlZFxuICAgICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICAgIGlmICghdm5vZGUuZGF0YS5zaG93ICYmIGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgYmVmb3JlTGVhdmUgJiYgYmVmb3JlTGVhdmUoZWwpO1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICAgIGlmICghY2IuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlVG9DbGFzcyk7XG4gICAgICAgICAgICBpZiAoIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICAgICAgaWYgKGlzVmFsaWREdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsZWF2ZSAmJiBsZWF2ZShlbCwgY2IpO1xuICAgICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gb25seSB1c2VkIGluIGRldiBtb2RlXG4gIGZ1bmN0aW9uIGNoZWNrRHVyYXRpb24gKHZhbCwgbmFtZSwgdm5vZGUpIHtcbiAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIG5vdCBhIHZhbGlkIG51bWJlciAtIFwiICtcbiAgICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiPHRyYW5zaXRpb24+IGV4cGxpY2l0IFwiICsgbmFtZSArIFwiIGR1cmF0aW9uIGlzIE5hTiAtIFwiICtcbiAgICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVmFsaWREdXJhdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gICAqIC0gYSBtZXJnZWQgaG9vayAoaW52b2tlcikgd2l0aCB0aGUgb3JpZ2luYWwgaW4gLmZuc1xuICAgKiAtIGEgd3JhcHBlZCBjb21wb25lbnQgbWV0aG9kIChjaGVjayAuX2xlbmd0aClcbiAgICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCAoZm4pIHtcbiAgICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgICBpZiAoaXNEZWYoaW52b2tlckZucykpIHtcbiAgICAgIC8vIGludm9rZXJcbiAgICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgICBBcnJheS5pc0FycmF5KGludm9rZXJGbnMpXG4gICAgICAgICAgPyBpbnZva2VyRm5zWzBdXG4gICAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUuZGF0YS5zaG93ICE9PSB0cnVlKSB7XG4gICAgICBlbnRlcih2bm9kZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRyYW5zaXRpb24gPSBpbkJyb3dzZXIgPyB7XG4gICAgY3JlYXRlOiBfZW50ZXIsXG4gICAgYWN0aXZhdGU6IF9lbnRlcixcbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSQkMSAodm5vZGUsIHJtKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gOiB7fTtcblxuICB2YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICAgIGF0dHJzLFxuICAgIGtsYXNzLFxuICAgIGV2ZW50cyxcbiAgICBkb21Qcm9wcyxcbiAgICBzdHlsZSxcbiAgICB0cmFuc2l0aW9uXG4gIF07XG5cbiAgLyogICovXG5cbiAgLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4gIC8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4gIHZhciBtb2R1bGVzID0gcGxhdGZvcm1Nb2R1bGVzLmNvbmNhdChiYXNlTW9kdWxlcyk7XG5cbiAgdmFyIHBhdGNoID0gY3JlYXRlUGF0Y2hGdW5jdGlvbih7IG5vZGVPcHM6IG5vZGVPcHMsIG1vZHVsZXM6IG1vZHVsZXMgfSk7XG5cbiAgLyoqXG4gICAqIE5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBsaWtlIGF0dGFjaGluZ1xuICAgKiBwcm9wZXJ0aWVzIHRvIEVsZW1lbnRzLlxuICAgKi9cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzSUU5KSB7XG4gICAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2lucHV0Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgZGlyZWN0aXZlID0ge1xuICAgIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgLy8gIzY5MDNcbiAgICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLCAncG9zdHBhdGNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGlyZWN0aXZlLmNvbXBvbmVudFVwZGF0ZWQoZWwsIGJpbmRpbmcsIHZub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh2bm9kZS50YWcgPT09ICd0ZXh0YXJlYScgfHwgaXNUZXh0SW5wdXRUeXBlKGVsLnR5cGUpKSB7XG4gICAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICAgIGlmICghYmluZGluZy5tb2RpZmllcnMubGF6eSkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAgIC8vIHN3aXRjaGluZyBmb2N1cyBiZWZvcmUgY29uZmlybWluZyBjb21wb3NpdGlvbiBjaG9pY2VcbiAgICAgICAgICAvLyB0aGlzIGFsc28gZml4ZXMgdGhlIGlzc3VlIHdoZXJlIHNvbWUgYnJvd3NlcnMgZS5nLiBpT1MgQ2hyb21lXG4gICAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgICAgICBlbC52bW9kZWwgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAgIC8vIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgdmFsdWUgaXMgb3V0LW9mLXN5bmMgd2l0aCB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAgICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgICB2YXIgcHJldk9wdGlvbnMgPSBlbC5fdk9wdGlvbnM7XG4gICAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgICBpZiAoY3VyT3B0aW9ucy5zb21lKGZ1bmN0aW9uIChvLCBpKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCBwcmV2T3B0aW9uc1tpXSk7IH0pKSB7XG4gICAgICAgICAgLy8gdHJpZ2dlciBjaGFuZ2UgZXZlbnQgaWZcbiAgICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICAgIHZhciBuZWVkUmVzZXQgPSBlbC5tdWx0aXBsZVxuICAgICAgICAgICAgPyBiaW5kaW5nLnZhbHVlLnNvbWUoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIGhhc05vTWF0Y2hpbmdPcHRpb24odiwgY3VyT3B0aW9ucyk7IH0pXG4gICAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgICBpZiAobmVlZFJlc2V0KSB7XG4gICAgICAgICAgICB0cmlnZ2VyKGVsLCAnY2hhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWN0dWFsbHlTZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm0pO1xuICAgICAgfSwgMCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0dWFsbHlTZXRTZWxlY3RlZCAoZWwsIGJpbmRpbmcsIHZtKSB7XG4gICAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICAgIGlmIChpc011bHRpcGxlICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9wdGlvbiA9IGVsLm9wdGlvbnNbaV07XG4gICAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgICAgaWYgKG9wdGlvbi5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzTXVsdGlwbGUpIHtcbiAgICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmV2ZXJ5KGZ1bmN0aW9uIChvKSB7IHJldHVybiAhbG9vc2VFcXVhbChvLCB2YWx1ZSk7IH0pXG4gIH1cblxuICBmdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gICAgcmV0dXJuICdfdmFsdWUnIGluIG9wdGlvblxuICAgICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgICA6IG9wdGlvbi52YWx1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICAgIGlmICghZS50YXJnZXQuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgICBlLmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKTtcbiAgICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xuICB9XG5cbiAgLyogICovXG5cbiAgLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuICBmdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSAmJiAoIXZub2RlLmRhdGEgfHwgIXZub2RlLmRhdGEudHJhbnNpdGlvbilcbiAgICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUpXG4gICAgICA6IHZub2RlXG4gIH1cblxuICB2YXIgc2hvdyA9IHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuXG4gICAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXkgPVxuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgICB2bm9kZS5kYXRhLnNob3cgPSB0cnVlO1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcbiAgICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIXZhbHVlID09PSAhb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgICB2YXIgdHJhbnNpdGlvbiQkMSA9IHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS50cmFuc2l0aW9uO1xuICAgICAgaWYgKHRyYW5zaXRpb24kJDEpIHtcbiAgICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgZW50ZXIodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZSA/IGVsLl9fdk9yaWdpbmFsRGlzcGxheSA6ICdub25lJztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiB1bmJpbmQgKFxuICAgICAgZWwsXG4gICAgICBiaW5kaW5nLFxuICAgICAgdm5vZGUsXG4gICAgICBvbGRWbm9kZSxcbiAgICAgIGlzRGVzdHJveVxuICAgICkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IGVsLl9fdk9yaWdpbmFsRGlzcGxheTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgICBtb2RlbDogZGlyZWN0aXZlLFxuICAgIHNob3c6IHNob3dcbiAgfTtcblxuICAvKiAgKi9cblxuICB2YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICAgIG5hbWU6IFN0cmluZyxcbiAgICBhcHBlYXI6IEJvb2xlYW4sXG4gICAgY3NzOiBCb29sZWFuLFxuICAgIG1vZGU6IFN0cmluZyxcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgZW50ZXJDbGFzczogU3RyaW5nLFxuICAgIGxlYXZlQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgICBlbnRlckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBhcHBlYXJUb0NsYXNzOiBTdHJpbmcsXG4gICAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxuICB9O1xuXG4gIC8vIGluIGNhc2UgdGhlIGNoaWxkIGlzIGFsc28gYW4gYWJzdHJhY3QgY29tcG9uZW50LCBlLmcuIDxrZWVwLWFsaXZlPlxuICAvLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuICBmdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBPcHRpb25zID0gdm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciBvcHRpb25zID0gY29tcC4kb3B0aW9ucztcbiAgICAvLyBwcm9wc1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgICAgZGF0YVtrZXldID0gY29tcFtrZXldO1xuICAgIH1cbiAgICAvLyBldmVudHMuXG4gICAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMgYW5kIHBhc3MgdGhlbSBkaXJlY3RseSB0byB0aGUgdHJhbnNpdGlvbiBtZXRob2RzXG4gICAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIGRhdGFbY2FtZWxpemUoa2V5JDEpXSA9IGxpc3RlbmVyc1trZXkkMV07XG4gICAgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgICBpZiAoL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpKSB7XG4gICAgICByZXR1cm4gaCgna2VlcC1hbGl2ZScsIHtcbiAgICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc1BhcmVudFRyYW5zaXRpb24gKHZub2RlKSB7XG4gICAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1NhbWVDaGlsZCAoY2hpbGQsIG9sZENoaWxkKSB7XG4gICAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG4gIH1cblxuICB2YXIgaXNOb3RUZXh0Tm9kZSA9IGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRhZyB8fCBpc0FzeW5jUGxhY2Vob2xkZXIoYyk7IH07XG5cbiAgdmFyIGlzVlNob3dEaXJlY3RpdmUgPSBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnc2hvdyc7IH07XG5cbiAgdmFyIFRyYW5zaXRpb24gPSB7XG4gICAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICAgIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gICAgYWJzdHJhY3Q6IHRydWUsXG5cbiAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBmaWx0ZXIgb3V0IHRleHQgbm9kZXMgKHBvc3NpYmxlIHdoaXRlc3BhY2VzKVxuICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoaXNOb3RUZXh0Tm9kZSk7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICc8dHJhbnNpdGlvbj4gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHNpbmdsZSBlbGVtZW50LiBVc2UgJyArXG4gICAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAgIC8vIHdhcm4gaW52YWxpZCBtb2RlXG4gICAgICBpZiAobW9kZSAmJiBtb2RlICE9PSAnaW4tb3V0JyAmJiBtb2RlICE9PSAnb3V0LWluJ1xuICAgICAgKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ2ludmFsaWQgPHRyYW5zaXRpb24+IG1vZGU6ICcgKyBtb2RlLFxuICAgICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyBhIGNvbXBvbmVudCByb290IG5vZGUgYW5kIHRoZSBjb21wb25lbnQnc1xuICAgICAgLy8gcGFyZW50IGNvbnRhaW5lciBub2RlIGFsc28gaGFzIHRyYW5zaXRpb24sIHNraXAuXG4gICAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHJhd0NoaWxkXG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgICAgLy8gdXNlIGdldFJlYWxDaGlsZCgpIHRvIGlnbm9yZSBhYnN0cmFjdCBjb21wb25lbnRzIGUuZy4ga2VlcC1hbGl2ZVxuICAgICAgdmFyIGNoaWxkID0gZ2V0UmVhbENoaWxkKHJhd0NoaWxkKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlYXZpbmcpIHtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIHZub2RlIHR5cGUgYW5kIHRvIHRoaXMgdHJhbnNpdGlvblxuICAgICAgLy8gY29tcG9uZW50IGluc3RhbmNlLiBUaGlzIGtleSB3aWxsIGJlIHVzZWQgdG8gcmVtb3ZlIHBlbmRpbmcgbGVhdmluZyBub2Rlc1xuICAgICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgICAgdmFyIGlkID0gXCJfX3RyYW5zaXRpb24tXCIgKyAodGhpcy5fdWlkKSArIFwiLVwiO1xuICAgICAgY2hpbGQua2V5ID0gY2hpbGQua2V5ID09IG51bGxcbiAgICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgICA/IGlkICsgJ2NvbW1lbnQnXG4gICAgICAgICAgOiBpZCArIGNoaWxkLnRhZ1xuICAgICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgICA/IChTdHJpbmcoY2hpbGQua2V5KS5pbmRleE9mKGlkKSA9PT0gMCA/IGNoaWxkLmtleSA6IGlkICsgY2hpbGQua2V5KVxuICAgICAgICAgIDogY2hpbGQua2V5O1xuXG4gICAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgICAgdmFyIG9sZFJhd0NoaWxkID0gdGhpcy5fdm5vZGU7XG4gICAgICB2YXIgb2xkQ2hpbGQgPSBnZXRSZWFsQ2hpbGQob2xkUmF3Q2hpbGQpO1xuXG4gICAgICAvLyBtYXJrIHYtc2hvd1xuICAgICAgLy8gc28gdGhhdCB0aGUgdHJhbnNpdGlvbiBtb2R1bGUgY2FuIGhhbmQgb3ZlciB0aGUgY29udHJvbCB0byB0aGUgZGlyZWN0aXZlXG4gICAgICBpZiAoY2hpbGQuZGF0YS5kaXJlY3RpdmVzICYmIGNoaWxkLmRhdGEuZGlyZWN0aXZlcy5zb21lKGlzVlNob3dEaXJlY3RpdmUpKSB7XG4gICAgICAgIGNoaWxkLmRhdGEuc2hvdyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgb2xkQ2hpbGQgJiZcbiAgICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgICAhaXNTYW1lQ2hpbGQoY2hpbGQsIG9sZENoaWxkKSAmJlxuICAgICAgICAhaXNBc3luY1BsYWNlaG9sZGVyKG9sZENoaWxkKSAmJlxuICAgICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgICAhKG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlICYmIG9sZENoaWxkLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZS5pc0NvbW1lbnQpXG4gICAgICApIHtcbiAgICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAgIC8vIGltcG9ydGFudCBmb3IgZHluYW1pYyB0cmFuc2l0aW9ucyFcbiAgICAgICAgdmFyIG9sZERhdGEgPSBvbGRDaGlsZC5kYXRhLnRyYW5zaXRpb24gPSBleHRlbmQoe30sIGRhdGEpO1xuICAgICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAgIC8vIHJldHVybiBwbGFjZWhvbGRlciBub2RlIGFuZCBxdWV1ZSB1cGRhdGUgd2hlbiBsZWF2ZSBmaW5pc2hlc1xuICAgICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcyQxLl9sZWF2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgICAgaWYgKGlzQXN5bmNQbGFjZWhvbGRlcihjaGlsZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBvbGRSYXdDaGlsZFxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICAgIHZhciBwZXJmb3JtTGVhdmUgPSBmdW5jdGlvbiAoKSB7IGRlbGF5ZWRMZWF2ZSgpOyB9O1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgICBtZXJnZVZOb2RlSG9vayhkYXRhLCAnZW50ZXJDYW5jZWxsZWQnLCBwZXJmb3JtTGVhdmUpO1xuICAgICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdkZWxheUxlYXZlJywgZnVuY3Rpb24gKGxlYXZlKSB7IGRlbGF5ZWRMZWF2ZSA9IGxlYXZlOyB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmF3Q2hpbGRcbiAgICB9XG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgICB0YWc6IFN0cmluZyxcbiAgICBtb3ZlQ2xhc3M6IFN0cmluZ1xuICB9LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG4gIGRlbGV0ZSBwcm9wcy5tb2RlO1xuXG4gIHZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50ICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgICB2YXIgdXBkYXRlID0gdGhpcy5fdXBkYXRlO1xuICAgICAgdGhpcy5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICAgICAgdmFyIHJlc3RvcmVBY3RpdmVJbnN0YW5jZSA9IHNldEFjdGl2ZUluc3RhbmNlKHRoaXMkMSk7XG4gICAgICAgIC8vIGZvcmNlIHJlbW92aW5nIHBhc3NcbiAgICAgICAgdGhpcyQxLl9fcGF0Y2hfXyhcbiAgICAgICAgICB0aGlzJDEuX3Zub2RlLFxuICAgICAgICAgIHRoaXMkMS5rZXB0LFxuICAgICAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgICAgICB0cnVlIC8vIHJlbW92ZU9ubHkgKCFpbXBvcnRhbnQsIGF2b2lkcyB1bm5lY2Vzc2FyeSBtb3ZlcylcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcyQxLl92bm9kZSA9IHRoaXMkMS5rZXB0O1xuICAgICAgICByZXN0b3JlQWN0aXZlSW5zdGFuY2UoKTtcbiAgICAgICAgdXBkYXRlLmNhbGwodGhpcyQxLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICAgIH07XG4gICAgfSxcblxuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgICB2YXIgdGFnID0gdGhpcy50YWcgfHwgdGhpcy4kdm5vZGUuZGF0YS50YWcgfHwgJ3NwYW4nO1xuICAgICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgdmFyIHJhd0NoaWxkcmVuID0gdGhpcy4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgICBpZiAoYy5rZXkgIT0gbnVsbCAmJiBTdHJpbmcoYy5rZXkpLmluZGV4T2YoJ19fdmxpc3QnKSAhPT0gMCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgICA7KGMuZGF0YSB8fCAoYy5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcHRzID0gYy5jb21wb25lbnRPcHRpb25zO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBvcHRzID8gKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcgfHwgJycpIDogYy50YWc7XG4gICAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZDaGlsZHJlbikge1xuICAgICAgICB2YXIga2VwdCA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwcmV2Q2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBjJDEgPSBwcmV2Q2hpbGRyZW5baSQxXTtcbiAgICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgICAgYyQxLmRhdGEucG9zID0gYyQxLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBpZiAobWFwW2MkMS5rZXldKSB7XG4gICAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKGMkMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VwdCA9IGgodGFnLCBudWxsLCBrZXB0KTtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGgodGFnLCBudWxsLCBjaGlsZHJlbilcbiAgICB9LFxuXG4gICAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByZXZDaGlsZHJlbjtcbiAgICAgIHZhciBtb3ZlQ2xhc3MgPSB0aGlzLm1vdmVDbGFzcyB8fCAoKHRoaXMubmFtZSB8fCAndicpICsgJy1tb3ZlJyk7XG4gICAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgICAvLyBpbiBlYWNoIGl0ZXJhdGlvbiAtIHdoaWNoIGhlbHBzIHByZXZlbnQgbGF5b3V0IHRocmFzaGluZy5cbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2FsbFBlbmRpbmdDYnMpO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGFwcGx5VHJhbnNsYXRpb24pO1xuXG4gICAgICAvLyBmb3JjZSByZWZsb3cgdG8gcHV0IGV2ZXJ5dGhpbmcgaW4gcG9zaXRpb25cbiAgICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgIHRoaXMuX3JlZmxvdyA9IGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgICB2YXIgZWwgPSBjLmVsbTtcbiAgICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnJztcbiAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAmJiBlLnRhcmdldCAhPT0gZWwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBjYik7XG4gICAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtZXRob2RzOiB7XG4gICAgICBoYXNNb3ZlOiBmdW5jdGlvbiBoYXNNb3ZlIChlbCwgbW92ZUNsYXNzKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMuX2hhc01vdmUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgICB9XG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIGFuIGVsZW1lbnQgd2l0aCB0aGUgbW92ZSBjbGFzcyBhcHBsaWVkIGhhc1xuICAgICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgICAgLy8gdHJhbnNpdGlvbiBhdCB0aGlzIHZlcnkgbW9tZW50LCB3ZSBtYWtlIGEgY2xvbmUgb2YgaXQgYW5kIHJlbW92ZVxuICAgICAgICAvLyBhbGwgb3RoZXIgdHJhbnNpdGlvbiBjbGFzc2VzIGFwcGxpZWQgdG8gZW5zdXJlIG9ubHkgdGhlIG1vdmUgY2xhc3NcbiAgICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgICAgdmFyIGNsb25lID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICAgIGlmIChlbC5fdHJhbnNpdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBhZGRDbGFzcyhjbG9uZSwgbW92ZUNsYXNzKTtcbiAgICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGNsb25lKTtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc01vdmUgPSBpbmZvLmhhc1RyYW5zZm9ybSlcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX21vdmVDYikge1xuICAgICAgYy5lbG0uX21vdmVDYigpO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgICBjLmRhdGEubmV3UG9zID0gYy5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gICAgdmFyIG9sZFBvcyA9IGMuZGF0YS5wb3M7XG4gICAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gICAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgICB2YXIgZHkgPSBvbGRQb3MudG9wIC0gbmV3UG9zLnRvcDtcbiAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgICB2YXIgcyA9IGMuZWxtLnN0eWxlO1xuICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gICAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxuICB9O1xuXG4gIC8qICAqL1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcbiAgVnVlLmNvbmZpZy5tdXN0VXNlUHJvcCA9IG11c3RVc2VQcm9wO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRUYWcgPSBpc1Jlc2VydmVkVGFnO1xuICBWdWUuY29uZmlnLmlzUmVzZXJ2ZWRBdHRyID0gaXNSZXNlcnZlZEF0dHI7XG4gIFZ1ZS5jb25maWcuZ2V0VGFnTmFtZXNwYWNlID0gZ2V0VGFnTmFtZXNwYWNlO1xuICBWdWUuY29uZmlnLmlzVW5rbm93bkVsZW1lbnQgPSBpc1Vua25vd25FbGVtZW50O1xuXG4gIC8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuICBleHRlbmQoVnVlLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbiAgZXh0ZW5kKFZ1ZS5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbiAgLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuICBWdWUucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGluQnJvd3NlciA/IHBhdGNoIDogbm9vcDtcblxuICAvLyBwdWJsaWMgbW91bnQgbWV0aG9kXG4gIFZ1ZS5wcm90b3R5cGUuJG1vdW50ID0gZnVuY3Rpb24gKFxuICAgIGVsLFxuICAgIGh5ZHJhdGluZ1xuICApIHtcbiAgICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbW91bnRDb21wb25lbnQodGhpcywgZWwsIGh5ZHJhdGluZylcbiAgfTtcblxuICAvLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoaW5Ccm93c2VyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoY29uZmlnLmRldnRvb2xzKSB7XG4gICAgICAgIGlmIChkZXZ0b29scykge1xuICAgICAgICAgIGRldnRvb2xzLmVtaXQoJ2luaXQnLCBWdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAgICAgJ0Rvd25sb2FkIHRoZSBWdWUgRGV2dG9vbHMgZXh0ZW5zaW9uIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy92dWUtZGV2dG9vbHMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5wcm9kdWN0aW9uVGlwICE9PSBmYWxzZSAmJlxuICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICkge1xuICAgICAgICBjb25zb2xlW2NvbnNvbGUuaW5mbyA/ICdpbmZvJyA6ICdsb2cnXShcbiAgICAgICAgICBcIllvdSBhcmUgcnVubmluZyBWdWUgaW4gZGV2ZWxvcG1lbnQgbW9kZS5cXG5cIiArXG4gICAgICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgICAgIFwiU2VlIG1vcmUgdGlwcyBhdCBodHRwczovL3Z1ZWpzLm9yZy9ndWlkZS9kZXBsb3ltZW50Lmh0bWxcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sIDApO1xuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGRlZmF1bHRUYWdSRSA9IC9cXHtcXHsoKD86LnxcXHI/XFxuKSs/KVxcfVxcfS9nO1xuICB2YXIgcmVnZXhFc2NhcGVSRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2c7XG5cbiAgdmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgICB2YXIgb3BlbiA9IGRlbGltaXRlcnNbMF0ucmVwbGFjZShyZWdleEVzY2FwZVJFLCAnXFxcXCQmJyk7XG4gICAgdmFyIGNsb3NlID0gZGVsaW1pdGVyc1sxXS5yZXBsYWNlKHJlZ2V4RXNjYXBlUkUsICdcXFxcJCYnKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxuICB9KTtcblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VUZXh0IChcbiAgICB0ZXh0LFxuICAgIGRlbGltaXRlcnNcbiAgKSB7XG4gICAgdmFyIHRhZ1JFID0gZGVsaW1pdGVycyA/IGJ1aWxkUmVnZXgoZGVsaW1pdGVycykgOiBkZWZhdWx0VGFnUkU7XG4gICAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIHRva2VucyA9IFtdO1xuICAgIHZhciByYXdUb2tlbnMgPSBbXTtcbiAgICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgICB2YXIgbWF0Y2gsIGluZGV4LCB0b2tlblZhbHVlO1xuICAgIHdoaWxlICgobWF0Y2ggPSB0YWdSRS5leGVjKHRleHQpKSkge1xuICAgICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgIC8vIHB1c2ggdGV4dCB0b2tlblxuICAgICAgaWYgKGluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpKTtcbiAgICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgICAgfVxuICAgICAgLy8gdGFnIHRva2VuXG4gICAgICB2YXIgZXhwID0gcGFyc2VGaWx0ZXJzKG1hdGNoWzFdLnRyaW0oKSk7XG4gICAgICB0b2tlbnMucHVzaCgoXCJfcyhcIiArIGV4cCArIFwiKVwiKSk7XG4gICAgICByYXdUb2tlbnMucHVzaCh7ICdAYmluZGluZyc6IGV4cCB9KTtcbiAgICAgIGxhc3RJbmRleCA9IGluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIHJhd1Rva2Vucy5wdXNoKHRva2VuVmFsdWUgPSB0ZXh0LnNsaWNlKGxhc3RJbmRleCkpO1xuICAgICAgdG9rZW5zLnB1c2goSlNPTi5zdHJpbmdpZnkodG9rZW5WYWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZXhwcmVzc2lvbjogdG9rZW5zLmpvaW4oJysnKSxcbiAgICAgIHRva2VuczogcmF3VG9rZW5zXG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljQ2xhc3MgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnY2xhc3MnKTtcbiAgICBpZiAoc3RhdGljQ2xhc3MpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZVRleHQoc3RhdGljQ2xhc3MsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAocmVzKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJjbGFzcz1cXFwiXCIgKyBzdGF0aWNDbGFzcyArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgY2xhc3M9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDpjbGFzcz1cInZhbFwiPi4nLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydjbGFzcyddXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0aWNDbGFzcykge1xuICAgICAgZWwuc3RhdGljQ2xhc3MgPSBKU09OLnN0cmluZ2lmeShzdGF0aWNDbGFzcyk7XG4gICAgfVxuICAgIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoY2xhc3NCaW5kaW5nKSB7XG4gICAgICBlbC5jbGFzc0JpbmRpbmcgPSBjbGFzc0JpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSAoZWwpIHtcbiAgICB2YXIgZGF0YSA9ICcnO1xuICAgIGlmIChlbC5zdGF0aWNDbGFzcykge1xuICAgICAgZGF0YSArPSBcInN0YXRpY0NsYXNzOlwiICsgKGVsLnN0YXRpY0NsYXNzKSArIFwiLFwiO1xuICAgIH1cbiAgICBpZiAoZWwuY2xhc3NCaW5kaW5nKSB7XG4gICAgICBkYXRhICs9IFwiY2xhc3M6XCIgKyAoZWwuY2xhc3NCaW5kaW5nKSArIFwiLFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgdmFyIGtsYXNzJDEgPSB7XG4gICAgc3RhdGljS2V5czogWydzdGF0aWNDbGFzcyddLFxuICAgIHRyYW5zZm9ybU5vZGU6IHRyYW5zZm9ybU5vZGUsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgd2FybiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcbiAgICB2YXIgc3RhdGljU3R5bGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc3R5bGUnKTtcbiAgICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAge1xuICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHN0YXRpY1N0eWxlLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJyxcbiAgICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzdHlsZSddXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwuc3RhdGljU3R5bGUgPSBKU09OLnN0cmluZ2lmeShwYXJzZVN0eWxlVGV4dChzdGF0aWNTdHlsZSkpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3N0eWxlJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgICBpZiAoc3R5bGVCaW5kaW5nKSB7XG4gICAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICAgIHZhciBkYXRhID0gJyc7XG4gICAgaWYgKGVsLnN0YXRpY1N0eWxlKSB7XG4gICAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5zdHlsZUJpbmRpbmcpIHtcbiAgICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIHZhciBzdHlsZSQxID0ge1xuICAgIHN0YXRpY0tleXM6IFsnc3RhdGljU3R5bGUnXSxcbiAgICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gICAgZ2VuRGF0YTogZ2VuRGF0YSQxXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGRlY29kZXI7XG5cbiAgdmFyIGhlID0ge1xuICAgIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgICBkZWNvZGVyID0gZGVjb2RlciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRlY29kZXIuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gICAgfVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1VuYXJ5VGFnID0gbWFrZU1hcChcbiAgICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuICApO1xuXG4gIC8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuICAvLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnID0gbWFrZU1hcChcbiAgICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZSdcbiAgKTtcblxuICAvLyBIVE1MNSB0YWdzIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZGljZXMuaHRtbCNlbGVtZW50cy0zXG4gIC8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxuICB2YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICAgJ2FkZHJlc3MsYXJ0aWNsZSxhc2lkZSxiYXNlLGJsb2NrcXVvdGUsYm9keSxjYXB0aW9uLGNvbCxjb2xncm91cCxkZCwnICtcbiAgICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAgICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgICAnb3B0Z3JvdXAsb3B0aW9uLHBhcmFtLHJwLHJ0LHNvdXJjZSxzdHlsZSxzdW1tYXJ5LHRib2R5LHRkLHRmb290LHRoLHRoZWFkLCcgK1xuICAgICd0aXRsZSx0cix0cmFjaydcbiAgKTtcblxuICAvKipcbiAgICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgaXQncyBtb3N0bHkgdmVuZG9yIGNvZGUuXG4gICAqL1xuXG4gIC8vIFJlZ3VsYXIgRXhwcmVzc2lvbnMgZm9yIHBhcnNpbmcgdGFncyBhbmQgYXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlID0gL15cXHMqKFteXFxzXCInPD5cXC89XSspKD86XFxzKig9KVxccyooPzpcIihbXlwiXSopXCIrfCcoW14nXSopJyt8KFteXFxzXCInPTw+YF0rKSkpPy87XG4gIHZhciBkeW5hbWljQXJnQXR0cmlidXRlID0gL15cXHMqKCg/OnYtW1xcdy1dKzp8QHw6fCMpXFxbW149XStcXF1bXlxcc1wiJzw+XFwvPV0qKSg/OlxccyooPSlcXHMqKD86XCIoW15cIl0qKVwiK3wnKFteJ10qKScrfChbXlxcc1wiJz08PmBdKykpKT8vO1xuICB2YXIgbmNuYW1lID0gXCJbYS16QS1aX11bXFxcXC1cXFxcLjAtOV9hLXpBLVpcIiArIHVuaWNvZGVMZXR0ZXJzICsgXCJdKlwiO1xuICB2YXIgcW5hbWVDYXB0dXJlID0gXCIoKD86XCIgKyBuY25hbWUgKyBcIlxcXFw6KT9cIiArIG5jbmFtZSArIFwiKVwiO1xuICB2YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG4gIHZhciBzdGFydFRhZ0Nsb3NlID0gL15cXHMqKFxcLz8pPi87XG4gIHZhciBlbmRUYWcgPSBuZXcgUmVnRXhwKChcIl48XFxcXC9cIiArIHFuYW1lQ2FwdHVyZSArIFwiW14+XSo+XCIpKTtcbiAgdmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbiAgLy8gIzcyOTg6IGVzY2FwZSAtIHRvIGF2b2lkIGJlaW5nIHBhc2VkIGFzIEhUTUwgY29tbWVudCB3aGVuIGlubGluZWQgaW4gcGFnZVxuICB2YXIgY29tbWVudCA9IC9ePCFcXC0tLztcbiAgdmFyIGNvbmRpdGlvbmFsQ29tbWVudCA9IC9ePCFcXFsvO1xuXG4gIC8vIFNwZWNpYWwgRWxlbWVudHMgKGNhbiBjb250YWluIGFueXRoaW5nKVxuICB2YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciByZUNhY2hlID0ge307XG5cbiAgdmFyIGRlY29kaW5nTWFwID0ge1xuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYW1wOyc6ICcmJyxcbiAgICAnJiMxMDsnOiAnXFxuJyxcbiAgICAnJiM5Oyc6ICdcXHQnLFxuICAgICcmIzM5Oyc6IFwiJ1wiXG4gIH07XG4gIHZhciBlbmNvZGVkQXR0ciA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzM5KTsvZztcbiAgdmFyIGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzID0gLyYoPzpsdHxndHxxdW90fGFtcHwjMzl8IzEwfCM5KTsvZztcblxuICAvLyAjNTk5MlxuICB2YXIgaXNJZ25vcmVOZXdsaW5lVGFnID0gbWFrZU1hcCgncHJlLHRleHRhcmVhJywgdHJ1ZSk7XG4gIHZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlQXR0ciAodmFsdWUsIHNob3VsZERlY29kZU5ld2xpbmVzKSB7XG4gICAgdmFyIHJlID0gc2hvdWxkRGVjb2RlTmV3bGluZXMgPyBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA6IGVuY29kZWRBdHRyO1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSFRNTCAoaHRtbCwgb3B0aW9ucykge1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBleHBlY3RIVE1MID0gb3B0aW9ucy5leHBlY3RIVE1MO1xuICAgIHZhciBpc1VuYXJ5VGFnJCQxID0gb3B0aW9ucy5pc1VuYXJ5VGFnIHx8IG5vO1xuICAgIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxhc3QsIGxhc3RUYWc7XG4gICAgd2hpbGUgKGh0bWwpIHtcbiAgICAgIGxhc3QgPSBodG1sO1xuICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIG5vdCBpbiBhIHBsYWludGV4dCBjb250ZW50IGVsZW1lbnQgbGlrZSBzY3JpcHQvc3R5bGVcbiAgICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICAgIHZhciB0ZXh0RW5kID0gaHRtbC5pbmRleE9mKCc8Jyk7XG4gICAgICAgIGlmICh0ZXh0RW5kID09PSAwKSB7XG4gICAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgICBpZiAoY29tbWVudC50ZXN0KGh0bWwpKSB7XG4gICAgICAgICAgICB2YXIgY29tbWVudEVuZCA9IGh0bWwuaW5kZXhPZignLS0+Jyk7XG5cbiAgICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc2hvdWxkS2VlcENvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbW1lbnQoaHRtbC5zdWJzdHJpbmcoNCwgY29tbWVudEVuZCksIGluZGV4LCBpbmRleCArIGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbmRpdGlvbmFsX2NvbW1lbnQjRG93bmxldmVsLXJldmVhbGVkX2NvbmRpdGlvbmFsX2NvbW1lbnRcbiAgICAgICAgICBpZiAoY29uZGl0aW9uYWxDb21tZW50LnRlc3QoaHRtbCkpIHtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbmFsRW5kID49IDApIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShjb25kaXRpb25hbEVuZCArIDIpO1xuICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgICAgdmFyIGRvY3R5cGVNYXRjaCA9IGh0bWwubWF0Y2goZG9jdHlwZSk7XG4gICAgICAgICAgaWYgKGRvY3R5cGVNYXRjaCkge1xuICAgICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgICB2YXIgZW5kVGFnTWF0Y2ggPSBodG1sLm1hdGNoKGVuZFRhZyk7XG4gICAgICAgICAgaWYgKGVuZFRhZ01hdGNoKSB7XG4gICAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGFkdmFuY2UoZW5kVGFnTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgIHBhcnNlRW5kVGFnKGVuZFRhZ01hdGNoWzFdLCBjdXJJbmRleCwgaW5kZXgpO1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdGFydCB0YWc6XG4gICAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgICAgaWYgKHN0YXJ0VGFnTWF0Y2gpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0YXJ0VGFnKHN0YXJ0VGFnTWF0Y2gpO1xuICAgICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFydFRhZ01hdGNoLnRhZ05hbWUsIGh0bWwpKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0ID0gKHZvaWQgMCksIHJlc3QgPSAodm9pZCAwKSwgbmV4dCA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodGV4dEVuZCA+PSAwKSB7XG4gICAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgIWVuZFRhZy50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb21tZW50LnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAgICFjb25kaXRpb25hbENvbW1lbnQudGVzdChyZXN0KVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gPCBpbiBwbGFpbiB0ZXh0LCBiZSBmb3JnaXZpbmcgYW5kIHRyZWF0IGl0IGFzIHRleHRcbiAgICAgICAgICAgIG5leHQgPSByZXN0LmluZGV4T2YoJzwnLCAxKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgICB0ZXh0RW5kICs9IG5leHQ7XG4gICAgICAgICAgICByZXN0ID0gaHRtbC5zbGljZSh0ZXh0RW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGV4dCA9IGh0bWwuc3Vic3RyaW5nKDAsIHRleHRFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgICAgdGV4dCA9IGh0bWw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIGFkdmFuY2UodGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnMgJiYgdGV4dCkge1xuICAgICAgICAgIG9wdGlvbnMuY2hhcnModGV4dCwgaW5kZXggLSB0ZXh0Lmxlbmd0aCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZW5kVGFnTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHN0YWNrZWRUYWcgPSBsYXN0VGFnLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgICAgdmFyIHJlc3QkMSA9IGh0bWwucmVwbGFjZShyZVN0YWNrZWRUYWcsIGZ1bmN0aW9uIChhbGwsIHRleHQsIGVuZFRhZykge1xuICAgICAgICAgIGVuZFRhZ0xlbmd0aCA9IGVuZFRhZy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHRcbiAgICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFwtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKSAvLyAjNzI5OFxuICAgICAgICAgICAgICAucmVwbGFjZSgvPCFcXFtDREFUQVxcWyhbXFxzXFxTXSo/KV1dPi9nLCAnJDEnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNoYXJzKHRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ICs9IGh0bWwubGVuZ3RoIC0gcmVzdCQxLmxlbmd0aDtcbiAgICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgICAgcGFyc2VFbmRUYWcoc3RhY2tlZFRhZywgaW5kZXggLSBlbmRUYWdMZW5ndGgsIGluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyAmJiBvcHRpb25zLmNoYXJzKGh0bWwpO1xuICAgICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBvcHRpb25zLndhcm4pIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oKFwiTWFsLWZvcm1hdHRlZCB0YWcgYXQgZW5kIG9mIHRlbXBsYXRlOiBcXFwiXCIgKyBodG1sICsgXCJcXFwiXCIpLCB7IHN0YXJ0OiBpbmRleCArIGh0bWwubGVuZ3RoIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4gdXAgYW55IHJlbWFpbmluZyB0YWdzXG4gICAgcGFyc2VFbmRUYWcoKTtcblxuICAgIGZ1bmN0aW9uIGFkdmFuY2UgKG4pIHtcbiAgICAgIGluZGV4ICs9IG47XG4gICAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGFydFRhZyAoKSB7XG4gICAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICAgIGF0dHJzOiBbXSxcbiAgICAgICAgICBzdGFydDogaW5kZXhcbiAgICAgICAgfTtcbiAgICAgICAgYWR2YW5jZShzdGFydFswXS5sZW5ndGgpO1xuICAgICAgICB2YXIgZW5kLCBhdHRyO1xuICAgICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goZHluYW1pY0FyZ0F0dHJpYnV0ZSkgfHwgaHRtbC5tYXRjaChhdHRyaWJ1dGUpKSkge1xuICAgICAgICAgIGF0dHIuc3RhcnQgPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGF0dHJbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBhdHRyLmVuZCA9IGluZGV4O1xuICAgICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCkge1xuICAgICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgICAgYWR2YW5jZShlbmRbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBtYXRjaC5lbmQgPSBpbmRleDtcbiAgICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0YXJ0VGFnIChtYXRjaCkge1xuICAgICAgdmFyIHRhZ05hbWUgPSBtYXRjaC50YWdOYW1lO1xuICAgICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgICBpZiAoZXhwZWN0SFRNTCkge1xuICAgICAgICBpZiAobGFzdFRhZyA9PT0gJ3AnICYmIGlzTm9uUGhyYXNpbmdUYWcodGFnTmFtZSkpIHtcbiAgICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuQmVMZWZ0T3BlblRhZyQkMSh0YWdOYW1lKSAmJiBsYXN0VGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICAgIHZhciBsID0gbWF0Y2guYXR0cnMubGVuZ3RoO1xuICAgICAgdmFyIGF0dHJzID0gbmV3IEFycmF5KGwpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBtYXRjaC5hdHRyc1tpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICAgIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IHRhZ05hbWUgPT09ICdhJyAmJiBhcmdzWzFdID09PSAnaHJlZidcbiAgICAgICAgICA/IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmXG4gICAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgICBhdHRyc1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiBhcmdzWzFdLFxuICAgICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBhdHRyc1tpXS5zdGFydCA9IGFyZ3Muc3RhcnQgKyBhcmdzWzBdLm1hdGNoKC9eXFxzKi8pLmxlbmd0aDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBhcmdzLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgIHN0YWNrLnB1c2goeyB0YWc6IHRhZ05hbWUsIGxvd2VyQ2FzZWRUYWc6IHRhZ05hbWUudG9Mb3dlckNhc2UoKSwgYXR0cnM6IGF0dHJzLCBzdGFydDogbWF0Y2guc3RhcnQsIGVuZDogbWF0Y2guZW5kIH0pO1xuICAgICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgcG9zLCBsb3dlckNhc2VkVGFnTmFtZTtcbiAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHN0YXJ0ID0gaW5kZXg7IH1cbiAgICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IG9wZW5lZCB0YWcgb2YgdGhlIHNhbWUgdHlwZVxuICAgICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgbG93ZXJDYXNlZFRhZ05hbWUgPSB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgICAgaWYgKHN0YWNrW3Bvc10ubG93ZXJDYXNlZFRhZyA9PT0gbG93ZXJDYXNlZFRhZ05hbWUpIHtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgICBwb3MgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIHRoZSBvcGVuIGVsZW1lbnRzLCB1cCB0aGUgc3RhY2tcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gcG9zOyBpLS0pIHtcbiAgICAgICAgICBpZiAoaSA+IHBvcyB8fCAhdGFnTmFtZSAmJlxuICAgICAgICAgICAgb3B0aW9ucy53YXJuXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAgIChcInRhZyA8XCIgKyAoc3RhY2tbaV0udGFnKSArIFwiPiBoYXMgbm8gbWF0Y2hpbmcgZW5kIHRhZy5cIiksXG4gICAgICAgICAgICAgIHsgc3RhcnQ6IHN0YWNrW2ldLnN0YXJ0IH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgICAgb3B0aW9ucy5lbmQoc3RhY2tbaV0udGFnLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgdGhlIG9wZW4gZWxlbWVudHMgZnJvbSB0aGUgc3RhY2tcbiAgICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgICBsYXN0VGFnID0gcG9zICYmIHN0YWNrW3BvcyAtIDFdLnRhZztcbiAgICAgIH0gZWxzZSBpZiAobG93ZXJDYXNlZFRhZ05hbWUgPT09ICdicicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCB0cnVlLCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgZmFsc2UsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmVuZCkge1xuICAgICAgICAgIG9wdGlvbnMuZW5kKHRhZ05hbWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIG9uUkUgPSAvXkB8XnYtb246LztcbiAgdmFyIGRpclJFID0gL152LXxeQHxeOi87XG4gIHZhciBmb3JBbGlhc1JFID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvO1xuICB2YXIgZm9ySXRlcmF0b3JSRSA9IC8sKFteLFxcfVxcXV0qKSg/OiwoW14sXFx9XFxdXSopKT8kLztcbiAgdmFyIHN0cmlwUGFyZW5zUkUgPSAvXlxcKHxcXCkkL2c7XG4gIHZhciBkeW5hbWljQXJnUkUgPSAvXlxcWy4qXFxdJC87XG5cbiAgdmFyIGFyZ1JFID0gLzooLiopJC87XG4gIHZhciBiaW5kUkUgPSAvXjp8XlxcLnxedi1iaW5kOi87XG4gIHZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbiAgdmFyIHNsb3RSRSA9IC9edi1zbG90KDp8JCl8XiMvO1xuXG4gIHZhciBsaW5lQnJlYWtSRSA9IC9bXFxyXFxuXS87XG4gIHZhciB3aGl0ZXNwYWNlUkUkMSA9IC9cXHMrL2c7XG5cbiAgdmFyIGludmFsaWRBdHRyaWJ1dGVSRSA9IC9bXFxzXCInPD5cXC89XS87XG5cbiAgdmFyIGRlY29kZUhUTUxDYWNoZWQgPSBjYWNoZWQoaGUuZGVjb2RlKTtcblxuICB2YXIgZW1wdHlTbG90U2NvcGVUb2tlbiA9IFwiX2VtcHR5X1wiO1xuXG4gIC8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxuICB2YXIgd2FybiQyO1xuICB2YXIgZGVsaW1pdGVycztcbiAgdmFyIHRyYW5zZm9ybXM7XG4gIHZhciBwcmVUcmFuc2Zvcm1zO1xuICB2YXIgcG9zdFRyYW5zZm9ybXM7XG4gIHZhciBwbGF0Zm9ybUlzUHJlVGFnO1xuICB2YXIgcGxhdGZvcm1NdXN0VXNlUHJvcDtcbiAgdmFyIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlO1xuICB2YXIgbWF5YmVDb21wb25lbnQ7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQVNURWxlbWVudCAoXG4gICAgdGFnLFxuICAgIGF0dHJzLFxuICAgIHBhcmVudFxuICApIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogMSxcbiAgICAgIHRhZzogdGFnLFxuICAgICAgYXR0cnNMaXN0OiBhdHRycyxcbiAgICAgIGF0dHJzTWFwOiBtYWtlQXR0cnNNYXAoYXR0cnMpLFxuICAgICAgcmF3QXR0cnNNYXA6IHt9LFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBIVE1MIHN0cmluZyB0byBBU1QuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZSAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB3YXJuJDIgPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG5cbiAgICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgICBwbGF0Zm9ybU11c3RVc2VQcm9wID0gb3B0aW9ucy5tdXN0VXNlUHJvcCB8fCBubztcbiAgICBwbGF0Zm9ybUdldFRhZ05hbWVzcGFjZSA9IG9wdGlvbnMuZ2V0VGFnTmFtZXNwYWNlIHx8IG5vO1xuICAgIHZhciBpc1Jlc2VydmVkVGFnID0gb3B0aW9ucy5pc1Jlc2VydmVkVGFnIHx8IG5vO1xuICAgIG1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuXG4gICAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICAgIHByZVRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3ByZVRyYW5zZm9ybU5vZGUnKTtcbiAgICBwb3N0VHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAncG9zdFRyYW5zZm9ybU5vZGUnKTtcblxuICAgIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgcHJlc2VydmVXaGl0ZXNwYWNlID0gb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09IGZhbHNlO1xuICAgIHZhciB3aGl0ZXNwYWNlT3B0aW9uID0gb3B0aW9ucy53aGl0ZXNwYWNlO1xuICAgIHZhciByb290O1xuICAgIHZhciBjdXJyZW50UGFyZW50O1xuICAgIHZhciBpblZQcmUgPSBmYWxzZTtcbiAgICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgICB2YXIgd2FybmVkID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB3YXJuT25jZSAobXNnLCByYW5nZSkge1xuICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgICAgd2FybiQyKG1zZywgcmFuZ2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb3NlRWxlbWVudCAoZWxlbWVudCkge1xuICAgICAgdHJpbUVuZGluZ1doaXRlc3BhY2UoZWxlbWVudCk7XG4gICAgICBpZiAoIWluVlByZSAmJiAhZWxlbWVudC5wcm9jZXNzZWQpIHtcbiAgICAgICAgZWxlbWVudCA9IHByb2Nlc3NFbGVtZW50KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgLy8gdHJlZSBtYW5hZ2VtZW50XG4gICAgICBpZiAoIXN0YWNrLmxlbmd0aCAmJiBlbGVtZW50ICE9PSByb290KSB7XG4gICAgICAgIC8vIGFsbG93IHJvb3QgZWxlbWVudHMgd2l0aCB2LWlmLCB2LWVsc2UtaWYgYW5kIHYtZWxzZVxuICAgICAgICBpZiAocm9vdC5pZiAmJiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoZWNrUm9vdENvbnN0cmFpbnRzKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRJZkNvbmRpdGlvbihyb290LCB7XG4gICAgICAgICAgICBleHA6IGVsZW1lbnQuZWxzZWlmLFxuICAgICAgICAgICAgYmxvY2s6IGVsZW1lbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgIFwiQ29tcG9uZW50IHRlbXBsYXRlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHJvb3QgZWxlbWVudC4gXCIgK1xuICAgICAgICAgICAgXCJJZiB5b3UgYXJlIHVzaW5nIHYtaWYgb24gbXVsdGlwbGUgZWxlbWVudHMsIFwiICtcbiAgICAgICAgICAgIFwidXNlIHYtZWxzZS1pZiB0byBjaGFpbiB0aGVtIGluc3RlYWQuXCIsXG4gICAgICAgICAgICB7IHN0YXJ0OiBlbGVtZW50LnN0YXJ0IH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFBhcmVudCAmJiAhZWxlbWVudC5mb3JiaWRkZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuZWxzZWlmIHx8IGVsZW1lbnQuZWxzZSkge1xuICAgICAgICAgIHByb2Nlc3NJZkNvbmRpdGlvbnMoZWxlbWVudCwgY3VycmVudFBhcmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQuc2xvdFNjb3BlKSB7XG4gICAgICAgICAgICAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgICAgLy8ga2VlcCBpdCBpbiB0aGUgY2hpbGRyZW4gbGlzdCBzbyB0aGF0IHYtZWxzZSgtaWYpIGNvbmRpdGlvbnMgY2FuXG4gICAgICAgICAgICAvLyBmaW5kIGl0IGFzIHRoZSBwcmV2IG5vZGUuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInXG4gICAgICAgICAgICA7KGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgfHwgKGN1cnJlbnRQYXJlbnQuc2NvcGVkU2xvdHMgPSB7fSkpW25hbWVdID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaW5hbCBjaGlsZHJlbiBjbGVhbnVwXG4gICAgICAvLyBmaWx0ZXIgb3V0IHNjb3BlZCBzbG90c1xuICAgICAgZWxlbWVudC5jaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhKGMpLnNsb3RTY29wZTsgfSk7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZSBub2RlIGFnYWluXG4gICAgICB0cmltRW5kaW5nV2hpdGVzcGFjZShlbGVtZW50KTtcblxuICAgICAgLy8gY2hlY2sgcHJlIHN0YXRlXG4gICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3N0VHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0cmltRW5kaW5nV2hpdGVzcGFjZSAoZWwpIHtcbiAgICAgIC8vIHJlbW92ZSB0cmFpbGluZyB3aGl0ZXNwYWNlIG5vZGVcbiAgICAgIGlmICghaW5QcmUpIHtcbiAgICAgICAgdmFyIGxhc3ROb2RlO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgKGxhc3ROb2RlID0gZWwuY2hpbGRyZW5bZWwuY2hpbGRyZW4ubGVuZ3RoIC0gMV0pICYmXG4gICAgICAgICAgbGFzdE5vZGUudHlwZSA9PT0gMyAmJlxuICAgICAgICAgIGxhc3ROb2RlLnRleHQgPT09ICcgJ1xuICAgICAgICApIHtcbiAgICAgICAgICBlbC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrUm9vdENvbnN0cmFpbnRzIChlbCkge1xuICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICBcIkNhbm5vdCB1c2UgPFwiICsgKGVsLnRhZykgKyBcIj4gYXMgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlIGl0IG1heSBcIiArXG4gICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJyxcbiAgICAgICAgICB7IHN0YXJ0OiBlbC5zdGFydCB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZWwuYXR0cnNNYXAuaGFzT3duUHJvcGVydHkoJ3YtZm9yJykpIHtcbiAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICdpdCByZW5kZXJzIG11bHRpcGxlIGVsZW1lbnRzLicsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICAgIHdhcm46IHdhcm4kMixcbiAgICAgIGV4cGVjdEhUTUw6IG9wdGlvbnMuZXhwZWN0SFRNTCxcbiAgICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICAgIGNhbkJlTGVmdE9wZW5UYWc6IG9wdGlvbnMuY2FuQmVMZWZ0T3BlblRhZyxcbiAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgIHNob3VsZEtlZXBDb21tZW50OiBvcHRpb25zLmNvbW1lbnRzLFxuICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UsXG4gICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5LCBzdGFydCQxKSB7XG4gICAgICAgIC8vIGNoZWNrIG5hbWVzcGFjZS5cbiAgICAgICAgLy8gaW5oZXJpdCBwYXJlbnQgbnMgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgICAgLy8gaGFuZGxlIElFIHN2ZyBidWdcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICAgIGF0dHJzID0gZ3VhcmRJRVNWR0J1ZyhhdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICAgIGlmIChucykge1xuICAgICAgICAgIGVsZW1lbnQubnMgPSBucztcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgZWxlbWVudC5zdGFydCA9IHN0YXJ0JDE7XG4gICAgICAgICAgICBlbGVtZW50LnJhd0F0dHJzTWFwID0gZWxlbWVudC5hdHRyc0xpc3QucmVkdWNlKGZ1bmN0aW9uIChjdW11bGF0ZWQsIGF0dHIpIHtcbiAgICAgICAgICAgICAgY3VtdWxhdGVkW2F0dHIubmFtZV0gPSBhdHRyO1xuICAgICAgICAgICAgICByZXR1cm4gY3VtdWxhdGVkXG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgIGlmIChpbnZhbGlkQXR0cmlidXRlUkUudGVzdChhdHRyLm5hbWUpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIkludmFsaWQgZHluYW1pYyBhcmd1bWVudCBleHByZXNzaW9uOiBhdHRyaWJ1dGUgbmFtZXMgY2Fubm90IGNvbnRhaW4gXCIgK1xuICAgICAgICAgICAgICAgIFwic3BhY2VzLCBxdW90ZXMsIDwsID4sIC8gb3IgPS5cIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdGFydDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5pbmRleE9mKFwiW1wiKSxcbiAgICAgICAgICAgICAgICAgIGVuZDogYXR0ci5zdGFydCArIGF0dHIubmFtZS5sZW5ndGhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgICBlbGVtZW50LmZvcmJpZGRlbiA9IHRydWU7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgJ1RlbXBsYXRlcyBzaG91bGQgb25seSBiZSByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgc3RhdGUgdG8gdGhlICcgK1xuICAgICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgICBcIjxcIiArIHRhZyArIFwiPlwiICsgJywgYXMgdGhleSB3aWxsIG5vdCBiZSBwYXJzZWQuJyxcbiAgICAgICAgICAgIHsgc3RhcnQ6IGVsZW1lbnQuc3RhcnQgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBwcmUtdHJhbnNmb3Jtc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZVRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpblZQcmUpIHtcbiAgICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgICAgICAgaW5WUHJlID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYXRmb3JtSXNQcmVUYWcoZWxlbWVudC50YWcpKSB7XG4gICAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpblZQcmUpIHtcbiAgICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWVsZW1lbnQucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgLy8gc3RydWN0dXJhbCBkaXJlY3RpdmVzXG4gICAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgICBwcm9jZXNzSWYoZWxlbWVudCk7XG4gICAgICAgICAgcHJvY2Vzc09uY2UoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGVja1Jvb3RDb25zdHJhaW50cyhyb290KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVuYXJ5KSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIGVuZDogZnVuY3Rpb24gZW5kICh0YWcsIHN0YXJ0LCBlbmQkMSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBwb3Agc3RhY2tcbiAgICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICBlbGVtZW50LmVuZCA9IGVuZCQxO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIH0sXG5cbiAgICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCwgc3RhcnQsIGVuZCkge1xuICAgICAgICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGV4dCA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LicsXG4gICAgICAgICAgICAgICAgeyBzdGFydDogc3RhcnQgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgICAoXCJ0ZXh0IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgb3V0c2lkZSByb290IGVsZW1lbnQgd2lsbCBiZSBpZ25vcmVkLlwiKSxcbiAgICAgICAgICAgICAgICB7IHN0YXJ0OiBzdGFydCB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGlzSUUgJiZcbiAgICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuYXR0cnNNYXAucGxhY2Vob2xkZXIgPT09IHRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY3VycmVudFBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgaWYgKGluUHJlIHx8IHRleHQudHJpbSgpKSB7XG4gICAgICAgICAgdGV4dCA9IGlzVGV4dFRhZyhjdXJyZW50UGFyZW50KSA/IHRleHQgOiBkZWNvZGVIVE1MQ2FjaGVkKHRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIHdoaXRlc3BhY2Utb25seSBub2RlIHJpZ2h0IGFmdGVyIGFuIG9wZW5pbmcgdGFnXG4gICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2VPcHRpb24pIHtcbiAgICAgICAgICBpZiAod2hpdGVzcGFjZU9wdGlvbiA9PT0gJ2NvbmRlbnNlJykge1xuICAgICAgICAgICAgLy8gaW4gY29uZGVuc2UgbW9kZSwgcmVtb3ZlIHRoZSB3aGl0ZXNwYWNlIG5vZGUgaWYgaXQgY29udGFpbnNcbiAgICAgICAgICAgIC8vIGxpbmUgYnJlYWssIG90aGVyd2lzZSBjb25kZW5zZSB0byBhIHNpbmdsZSBzcGFjZVxuICAgICAgICAgICAgdGV4dCA9IGxpbmVCcmVha1JFLnRlc3QodGV4dCkgPyAnJyA6ICcgJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9ICcgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IHByZXNlcnZlV2hpdGVzcGFjZSA/ICcgJyA6ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgaWYgKHdoaXRlc3BhY2VPcHRpb24gPT09ICdjb25kZW5zZScpIHtcbiAgICAgICAgICAgIC8vIGNvbmRlbnNlIGNvbnNlY3V0aXZlIHdoaXRlc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKHdoaXRlc3BhY2VSRSQxLCAnICcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzO1xuICAgICAgICAgIHZhciBjaGlsZDtcbiAgICAgICAgICBpZiAoIWluVlByZSAmJiB0ZXh0ICE9PSAnICcgJiYgKHJlcyA9IHBhcnNlVGV4dCh0ZXh0LCBkZWxpbWl0ZXJzKSkpIHtcbiAgICAgICAgICAgIGNoaWxkID0ge1xuICAgICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiByZXMuZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgdG9rZW5zOiByZXMudG9rZW5zLFxuICAgICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHtcbiAgICAgICAgICAgICAgdHlwZTogMyxcbiAgICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgICBjaGlsZC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIC8vIGFkZGluZyBhbnl0aW5nIGFzIGEgc2libGluZyB0byB0aGUgcm9vdCBub2RlIGlzIGZvcmJpZGRlblxuICAgICAgICAvLyBjb21tZW50cyBzaG91bGQgc3RpbGwgYmUgYWxsb3dlZCwgYnV0IGlnbm9yZWRcbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGlzQ29tbWVudDogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKG9wdGlvbnMub3V0cHV0U291cmNlUmFuZ2UpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjaGlsZC5lbmQgPSBlbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcm9vdFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc1ByZSAoZWwpIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtcHJlJykgIT0gbnVsbCkge1xuICAgICAgZWwucHJlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICAgIGlmIChsZW4pIHtcbiAgICAgIHZhciBhdHRycyA9IGVsLmF0dHJzID0gbmV3IEFycmF5KGxlbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGF0dHJzW2ldID0ge1xuICAgICAgICAgIG5hbWU6IGxpc3RbaV0ubmFtZSxcbiAgICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkobGlzdFtpXS52YWx1ZSlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxpc3RbaV0uc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgIGF0dHJzW2ldLnN0YXJ0ID0gbGlzdFtpXS5zdGFydDtcbiAgICAgICAgICBhdHRyc1tpXS5lbmQgPSBsaXN0W2ldLmVuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgICAgLy8gbm9uIHJvb3Qgbm9kZSBpbiBwcmUgYmxvY2tzIHdpdGggbm8gYXR0cmlidXRlc1xuICAgICAgZWwucGxhaW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NFbGVtZW50IChcbiAgICBlbGVtZW50LFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoaXMgaXMgYSBwbGFpbiBlbGVtZW50IGFmdGVyXG4gICAgLy8gcmVtb3Zpbmcgc3RydWN0dXJhbCBhdHRyaWJ1dGVzXG4gICAgZWxlbWVudC5wbGFpbiA9IChcbiAgICAgICFlbGVtZW50LmtleSAmJlxuICAgICAgIWVsZW1lbnQuc2NvcGVkU2xvdHMgJiZcbiAgICAgICFlbGVtZW50LmF0dHJzTGlzdC5sZW5ndGhcbiAgICApO1xuXG4gICAgcHJvY2Vzc1JlZihlbGVtZW50KTtcbiAgICBwcm9jZXNzU2xvdENvbnRlbnQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc1Nsb3RPdXRsZXQoZWxlbWVudCk7XG4gICAgcHJvY2Vzc0NvbXBvbmVudChlbGVtZW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnQgPSB0cmFuc2Zvcm1zW2ldKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQ7XG4gICAgfVxuICAgIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgICB2YXIgZXhwID0gZ2V0QmluZGluZ0F0dHIoZWwsICdrZXknKTtcbiAgICBpZiAoZXhwKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICBcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIixcbiAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbC5mb3IpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBlbC5pdGVyYXRvcjIgfHwgZWwuaXRlcmF0b3IxO1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnQ7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yICYmIGl0ZXJhdG9yID09PSBleHAgJiYgcGFyZW50ICYmIHBhcmVudC50YWcgPT09ICd0cmFuc2l0aW9uLWdyb3VwJykge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICBcIkRvIG5vdCB1c2Ugdi1mb3IgaW5kZXggYXMga2V5IG9uIDx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiwgXCIgK1xuICAgICAgICAgICAgICBcInRoaXMgaXMgdGhlIHNhbWUgYXMgbm90IHVzaW5nIGtleXMuXCIsXG4gICAgICAgICAgICAgIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAna2V5JyksXG4gICAgICAgICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWwua2V5ID0gZXhwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NSZWYgKGVsKSB7XG4gICAgdmFyIHJlZiA9IGdldEJpbmRpbmdBdHRyKGVsLCAncmVmJyk7XG4gICAgaWYgKHJlZikge1xuICAgICAgZWwucmVmID0gcmVmO1xuICAgICAgZWwucmVmSW5Gb3IgPSBjaGVja0luRm9yKGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzRm9yIChlbCkge1xuICAgIHZhciBleHA7XG4gICAgaWYgKChleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1mb3InKSkpIHtcbiAgICAgIHZhciByZXMgPSBwYXJzZUZvcihleHApO1xuICAgICAgaWYgKHJlcykge1xuICAgICAgICBleHRlbmQoZWwsIHJlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cCksXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ11cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5cbiAgZnVuY3Rpb24gcGFyc2VGb3IgKGV4cCkge1xuICAgIHZhciBpbk1hdGNoID0gZXhwLm1hdGNoKGZvckFsaWFzUkUpO1xuICAgIGlmICghaW5NYXRjaCkgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSB7fTtcbiAgICByZXMuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCkucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgcmVzLmFsaWFzID0gYWxpYXMucmVwbGFjZShmb3JJdGVyYXRvclJFLCAnJykudHJpbSgpO1xuICAgICAgcmVzLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMV0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbMl0pIHtcbiAgICAgICAgcmVzLml0ZXJhdG9yMiA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMuYWxpYXMgPSBhbGlhcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0lmIChlbCkge1xuICAgIHZhciBleHAgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicpO1xuICAgIGlmIChleHApIHtcbiAgICAgIGVsLmlmID0gZXhwO1xuICAgICAgYWRkSWZDb25kaXRpb24oZWwsIHtcbiAgICAgICAgZXhwOiBleHAsXG4gICAgICAgIGJsb2NrOiBlbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJykgIT0gbnVsbCkge1xuICAgICAgICBlbC5lbHNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBlbHNlaWYgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJyk7XG4gICAgICBpZiAoZWxzZWlmKSB7XG4gICAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzSWZDb25kaXRpb25zIChlbCwgcGFyZW50KSB7XG4gICAgdmFyIHByZXYgPSBmaW5kUHJldkVsZW1lbnQocGFyZW50LmNoaWxkcmVuKTtcbiAgICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgICBhZGRJZkNvbmRpdGlvbihwcmV2LCB7XG4gICAgICAgIGV4cDogZWwuZWxzZWlmLFxuICAgICAgICBibG9jazogZWxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwidi1cIiArIChlbC5lbHNlaWYgPyAoJ2Vsc2UtaWY9XCInICsgZWwuZWxzZWlmICsgJ1wiJykgOiAnZWxzZScpICsgXCIgXCIgK1xuICAgICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbZWwuZWxzZWlmID8gJ3YtZWxzZS1pZicgOiAndi1lbHNlJ11cbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICAgIHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLnRleHQgIT09ICcgJykge1xuICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgIFwidGV4dCBcXFwiXCIgKyAoY2hpbGRyZW5baV0udGV4dC50cmltKCkpICsgXCJcXFwiIGJldHdlZW4gdi1pZiBhbmQgdi1lbHNlKC1pZikgXCIgK1xuICAgICAgICAgICAgXCJ3aWxsIGJlIGlnbm9yZWQuXCIsXG4gICAgICAgICAgICBjaGlsZHJlbltpXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkSWZDb25kaXRpb24gKGVsLCBjb25kaXRpb24pIHtcbiAgICBpZiAoIWVsLmlmQ29uZGl0aW9ucykge1xuICAgICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gICAgfVxuICAgIGVsLmlmQ29uZGl0aW9ucy5wdXNoKGNvbmRpdGlvbik7XG4gIH1cblxuICBmdW5jdGlvbiBwcm9jZXNzT25jZSAoZWwpIHtcbiAgICB2YXIgb25jZSQkMSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LW9uY2UnKTtcbiAgICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgICBlbC5vbmNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBoYW5kbGUgY29udGVudCBiZWluZyBwYXNzZWQgdG8gYSBjb21wb25lbnQgYXMgc2xvdCxcbiAgLy8gZS5nLiA8dGVtcGxhdGUgc2xvdD1cInh4eFwiPiwgPGRpdiBzbG90LXNjb3BlPVwieHh4XCI+XG4gIGZ1bmN0aW9uIHByb2Nlc3NTbG90Q29udGVudCAoZWwpIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoc2xvdFNjb3BlKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRoZSBcXFwic2NvcGVcXFwiIGF0dHJpYnV0ZSBmb3Igc2NvcGVkIHNsb3RzIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBcIiArXG4gICAgICAgICAgXCJyZXBsYWNlZCBieSBcXFwic2xvdC1zY29wZVxcXCIgc2luY2UgMi41LiBUaGUgbmV3IFxcXCJzbG90LXNjb3BlXFxcIiBhdHRyaWJ1dGUgXCIgK1xuICAgICAgICAgIFwiY2FuIGFsc28gYmUgdXNlZCBvbiBwbGFpbiBlbGVtZW50cyBpbiBhZGRpdGlvbiB0byA8dGVtcGxhdGU+IHRvIFwiICtcbiAgICAgICAgICBcImRlbm90ZSBzY29wZWQgc2xvdHMuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3Njb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlIHx8IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzbG90LXNjb3BlJyk7XG4gICAgfSBlbHNlIGlmICgoc2xvdFNjb3BlID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKSkpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGVsLmF0dHJzTWFwWyd2LWZvciddKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcIkFtYmlndW91cyBjb21iaW5lZCB1c2FnZSBvZiBzbG90LXNjb3BlIGFuZCB2LWZvciBvbiA8XCIgKyAoZWwudGFnKSArIFwiPiBcIiArXG4gICAgICAgICAgXCIodi1mb3IgdGFrZXMgaGlnaGVyIHByaW9yaXR5KS4gVXNlIGEgd3JhcHBlciA8dGVtcGxhdGU+IGZvciB0aGUgXCIgK1xuICAgICAgICAgIFwic2NvcGVkIHNsb3QgdG8gbWFrZSBpdCBjbGVhcmVyLlwiLFxuICAgICAgICAgIGVsLnJhd0F0dHJzTWFwWydzbG90LXNjb3BlJ10sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgZWwuc2xvdFNjb3BlID0gc2xvdFNjb3BlO1xuICAgIH1cblxuICAgIC8vIHNsb3Q9XCJ4eHhcIlxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICAgIGVsLnNsb3RUYXJnZXREeW5hbWljID0gISEoZWwuYXR0cnNNYXBbJzpzbG90J10gfHwgZWwuYXR0cnNNYXBbJ3YtYmluZDpzbG90J10pO1xuICAgICAgLy8gcHJlc2VydmUgc2xvdCBhcyBhbiBhdHRyaWJ1dGUgZm9yIG5hdGl2ZSBzaGFkb3cgRE9NIGNvbXBhdFxuICAgICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90cy5cbiAgICAgIGlmIChlbC50YWcgIT09ICd0ZW1wbGF0ZScgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgICAgICBhZGRBdHRyKGVsLCAnc2xvdCcsIHNsb3RUYXJnZXQsIGdldFJhd0JpbmRpbmdBdHRyKGVsLCAnc2xvdCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyLjYgdi1zbG90IHN5bnRheFxuICAgIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgLy8gdi1zbG90IG9uIDx0ZW1wbGF0ZT5cbiAgICAgICAgdmFyIHNsb3RCaW5kaW5nID0gZ2V0QW5kUmVtb3ZlQXR0ckJ5UmVnZXgoZWwsIHNsb3RSRSk7XG4gICAgICAgIGlmIChzbG90QmluZGluZykge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChlbC5zbG90VGFyZ2V0IHx8IGVsLnNsb3RTY29wZSkge1xuICAgICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIG1peGVkIHVzYWdlIG9mIGRpZmZlcmVudCBzbG90IHN5bnRheGVzLlwiLFxuICAgICAgICAgICAgICAgIGVsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwucGFyZW50ICYmICFtYXliZUNvbXBvbmVudChlbC5wYXJlbnQpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIjx0ZW1wbGF0ZSB2LXNsb3Q+IGNhbiBvbmx5IGFwcGVhciBhdCB0aGUgcm9vdCBsZXZlbCBpbnNpZGUgXCIgK1xuICAgICAgICAgICAgICAgIFwidGhlIHJlY2VpdmluZyB0aGUgY29tcG9uZW50XCIsXG4gICAgICAgICAgICAgICAgZWxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlZiA9IGdldFNsb3ROYW1lKHNsb3RCaW5kaW5nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICAgIHZhciBkeW5hbWljID0gcmVmLmR5bmFtaWM7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldCA9IG5hbWU7XG4gICAgICAgICAgZWwuc2xvdFRhcmdldER5bmFtaWMgPSBkeW5hbWljO1xuICAgICAgICAgIGVsLnNsb3RTY29wZSA9IHNsb3RCaW5kaW5nLnZhbHVlIHx8IGVtcHR5U2xvdFNjb3BlVG9rZW47IC8vIGZvcmNlIGl0IGludG8gYSBzY29wZWQgc2xvdCBmb3IgcGVyZlxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2LXNsb3Qgb24gY29tcG9uZW50LCBkZW5vdGVzIGRlZmF1bHQgc2xvdFxuICAgICAgICB2YXIgc2xvdEJpbmRpbmckMSA9IGdldEFuZFJlbW92ZUF0dHJCeVJlZ2V4KGVsLCBzbG90UkUpO1xuICAgICAgICBpZiAoc2xvdEJpbmRpbmckMSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghbWF5YmVDb21wb25lbnQoZWwpKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcInYtc2xvdCBjYW4gb25seSBiZSB1c2VkIG9uIGNvbXBvbmVudHMgb3IgPHRlbXBsYXRlPi5cIixcbiAgICAgICAgICAgICAgICBzbG90QmluZGluZyQxXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWwuc2xvdFNjb3BlIHx8IGVsLnNsb3RUYXJnZXQpIHtcbiAgICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAgIFwiVW5leHBlY3RlZCBtaXhlZCB1c2FnZSBvZiBkaWZmZXJlbnQgc2xvdCBzeW50YXhlcy5cIixcbiAgICAgICAgICAgICAgICBlbFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVsLnNjb3BlZFNsb3RzKSB7XG4gICAgICAgICAgICAgIHdhcm4kMihcbiAgICAgICAgICAgICAgICBcIlRvIGF2b2lkIHNjb3BlIGFtYmlndWl0eSwgdGhlIGRlZmF1bHQgc2xvdCBzaG91bGQgYWxzbyB1c2UgXCIgK1xuICAgICAgICAgICAgICAgIFwiPHRlbXBsYXRlPiBzeW50YXggd2hlbiB0aGVyZSBhcmUgb3RoZXIgbmFtZWQgc2xvdHMuXCIsXG4gICAgICAgICAgICAgICAgc2xvdEJpbmRpbmckMVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBhZGQgdGhlIGNvbXBvbmVudCdzIGNoaWxkcmVuIHRvIGl0cyBkZWZhdWx0IHNsb3RcbiAgICAgICAgICB2YXIgc2xvdHMgPSBlbC5zY29wZWRTbG90cyB8fCAoZWwuc2NvcGVkU2xvdHMgPSB7fSk7XG4gICAgICAgICAgdmFyIHJlZiQxID0gZ2V0U2xvdE5hbWUoc2xvdEJpbmRpbmckMSk7XG4gICAgICAgICAgdmFyIG5hbWUkMSA9IHJlZiQxLm5hbWU7XG4gICAgICAgICAgdmFyIGR5bmFtaWMkMSA9IHJlZiQxLmR5bmFtaWM7XG4gICAgICAgICAgdmFyIHNsb3RDb250YWluZXIgPSBzbG90c1tuYW1lJDFdID0gY3JlYXRlQVNURWxlbWVudCgndGVtcGxhdGUnLCBbXSwgZWwpO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFRhcmdldCA9IG5hbWUkMTtcbiAgICAgICAgICBzbG90Q29udGFpbmVyLnNsb3RUYXJnZXREeW5hbWljID0gZHluYW1pYyQxO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuY2hpbGRyZW4gPSBlbC5jaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgIGlmICghYy5zbG90U2NvcGUpIHtcbiAgICAgICAgICAgICAgYy5wYXJlbnQgPSBzbG90Q29udGFpbmVyO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNsb3RDb250YWluZXIuc2xvdFNjb3BlID0gc2xvdEJpbmRpbmckMS52YWx1ZSB8fCBlbXB0eVNsb3RTY29wZVRva2VuO1xuICAgICAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBhcyB0aGV5IGFyZSByZXR1cm5lZCBmcm9tIHNjb3BlZFNsb3RzIG5vd1xuICAgICAgICAgIGVsLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgLy8gbWFyayBlbCBub24tcGxhaW4gc28gZGF0YSBnZXRzIGdlbmVyYXRlZFxuICAgICAgICAgIGVsLnBsYWluID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTbG90TmFtZSAoYmluZGluZykge1xuICAgIHZhciBuYW1lID0gYmluZGluZy5uYW1lLnJlcGxhY2Uoc2xvdFJFLCAnJyk7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBpZiAoYmluZGluZy5uYW1lWzBdICE9PSAnIycpIHtcbiAgICAgICAgbmFtZSA9ICdkZWZhdWx0JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInYtc2xvdCBzaG9ydGhhbmQgc3ludGF4IHJlcXVpcmVzIGEgc2xvdCBuYW1lLlwiLFxuICAgICAgICAgIGJpbmRpbmdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpXG4gICAgICAvLyBkeW5hbWljIFtuYW1lXVxuICAgICAgPyB7IG5hbWU6IG5hbWUuc2xpY2UoMSwgLTEpLCBkeW5hbWljOiB0cnVlIH1cbiAgICAgIC8vIHN0YXRpYyBuYW1lXG4gICAgICA6IHsgbmFtZTogKFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIlwiKSwgZHluYW1pYzogZmFsc2UgfVxuICB9XG5cbiAgLy8gaGFuZGxlIDxzbG90Lz4gb3V0bGV0c1xuICBmdW5jdGlvbiBwcm9jZXNzU2xvdE91dGxldCAoZWwpIHtcbiAgICBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgICBpZiAoZWwua2V5KSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcImBrZXlgIGRvZXMgbm90IHdvcmsgb24gPHNsb3Q+IGJlY2F1c2Ugc2xvdHMgYXJlIGFic3RyYWN0IG91dGxldHMgXCIgK1xuICAgICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICAgIFwiVXNlIHRoZSBrZXkgb24gYSB3cmFwcGluZyBlbGVtZW50IGluc3RlYWQuXCIsXG4gICAgICAgICAgZ2V0UmF3QmluZGluZ0F0dHIoZWwsICdrZXknKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDb21wb25lbnQgKGVsKSB7XG4gICAgdmFyIGJpbmRpbmc7XG4gICAgaWYgKChiaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdpcycpKSkge1xuICAgICAgZWwuY29tcG9uZW50ID0gYmluZGluZztcbiAgICB9XG4gICAgaWYgKGdldEFuZFJlbW92ZUF0dHIoZWwsICdpbmxpbmUtdGVtcGxhdGUnKSAhPSBudWxsKSB7XG4gICAgICBlbC5pbmxpbmVUZW1wbGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHJvY2Vzc0F0dHJzIChlbCkge1xuICAgIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICAgIHZhciBpLCBsLCBuYW1lLCByYXdOYW1lLCB2YWx1ZSwgbW9kaWZpZXJzLCBzeW5jR2VuLCBpc0R5bmFtaWM7XG4gICAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICAgIHZhbHVlID0gbGlzdFtpXS52YWx1ZTtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICAgIGVsLmhhc0JpbmRpbmdzID0gdHJ1ZTtcbiAgICAgICAgLy8gbW9kaWZpZXJzXG4gICAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUucmVwbGFjZShkaXJSRSwgJycpKTtcbiAgICAgICAgLy8gc3VwcG9ydCAuZm9vIHNob3J0aGFuZCBzeW50YXggZm9yIHRoZSAucHJvcCBtb2RpZmllclxuICAgICAgICBpZiAobW9kaWZpZXJzKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShtb2RpZmllclJFLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJpbmRSRS50ZXN0KG5hbWUpKSB7IC8vIHYtYmluZFxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoYmluZFJFLCAnJyk7XG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgICAoXCJUaGUgdmFsdWUgZm9yIGEgdi1iaW5kIGV4cHJlc3Npb24gY2Fubm90IGJlIGVtcHR5LiBGb3VuZCBpbiBcXFwidi1iaW5kOlwiICsgbmFtZSArIFwiXFxcIlwiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcm9wICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2lubmVySHRtbCcpIHsgbmFtZSA9ICdpbm5lckhUTUwnOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZXJzLmNhbWVsICYmICFpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5zeW5jKSB7XG4gICAgICAgICAgICAgIHN5bmNHZW4gPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgXCIkZXZlbnRcIik7XG4gICAgICAgICAgICAgIGlmICghaXNEeW5hbWljKSB7XG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwidXBkYXRlOlwiICsgKGNhbWVsaXplKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKGh5cGhlbmF0ZShuYW1lKSAhPT0gY2FtZWxpemUobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoaHlwaGVuYXRlKG5hbWUpKSksXG4gICAgICAgICAgICAgICAgICAgIHN5bmNHZW4sXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB3YXJuJDIsXG4gICAgICAgICAgICAgICAgICAgIGxpc3RbaV1cbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhhbmRsZXIgdy8gZHluYW1pYyBldmVudCBuYW1lXG4gICAgICAgICAgICAgICAgYWRkSGFuZGxlcihcbiAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgKFwiXFxcInVwZGF0ZTpcXFwiKyhcIiArIG5hbWUgKyBcIilcIiksXG4gICAgICAgICAgICAgICAgICBzeW5jR2VuLFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAgICAgd2FybiQyLFxuICAgICAgICAgICAgICAgICAgbGlzdFtpXSxcbiAgICAgICAgICAgICAgICAgIHRydWUgLy8gZHluYW1pY1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLnByb3ApIHx8IChcbiAgICAgICAgICAgICFlbC5jb21wb25lbnQgJiYgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpXG4gICAgICAgICAgKSkge1xuICAgICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUsIGxpc3RbaV0sIGlzRHluYW1pYyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlLCBsaXN0W2ldLCBpc0R5bmFtaWMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2Uob25SRSwgJycpO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGR5bmFtaWNBcmdSRS50ZXN0KG5hbWUpO1xuICAgICAgICAgIGlmIChpc0R5bmFtaWMpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMiwgbGlzdFtpXSwgaXNEeW5hbWljKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gbm9ybWFsIGRpcmVjdGl2ZXNcbiAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgICAgLy8gcGFyc2UgYXJnXG4gICAgICAgICAgdmFyIGFyZ01hdGNoID0gbmFtZS5tYXRjaChhcmdSRSk7XG4gICAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICAgIGlzRHluYW1pYyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChhcmcpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIC0oYXJnLmxlbmd0aCArIDEpKTtcbiAgICAgICAgICAgIGlmIChkeW5hbWljQXJnUkUudGVzdChhcmcpKSB7XG4gICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICAgIGlzRHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgaXNEeW5hbWljLCBtb2RpZmllcnMsIGxpc3RbaV0pO1xuICAgICAgICAgIGlmIChuYW1lID09PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICBjaGVja0ZvckFsaWFzTW9kZWwoZWwsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcmVzID0gcGFyc2VUZXh0KHZhbHVlLCBkZWxpbWl0ZXJzKTtcbiAgICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgICAgIG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIjogXCIgK1xuICAgICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICAgJ1VzZSB2LWJpbmQgb3IgdGhlIGNvbG9uIHNob3J0aGFuZCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgJyArXG4gICAgICAgICAgICAgICdpbnN0ZWFkIG9mIDxkaXYgaWQ9XCJ7eyB2YWwgfX1cIj4sIHVzZSA8ZGl2IDppZD1cInZhbFwiPi4nLFxuICAgICAgICAgICAgICBsaXN0W2ldXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSksIGxpc3RbaV0pO1xuICAgICAgICAvLyAjNjg4NyBmaXJlZm94IGRvZXNuJ3QgdXBkYXRlIG11dGVkIHN0YXRlIGlmIHNldCB2aWEgYXR0cmlidXRlXG4gICAgICAgIC8vIGV2ZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgZWxlbWVudCBjcmVhdGlvblxuICAgICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgICAgbmFtZSA9PT0gJ211dGVkJyAmJlxuICAgICAgICAgICAgcGxhdGZvcm1NdXN0VXNlUHJvcChlbC50YWcsIGVsLmF0dHJzTWFwLnR5cGUsIG5hbWUpKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnLCBsaXN0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrSW5Gb3IgKGVsKSB7XG4gICAgdmFyIHBhcmVudCA9IGVsO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgICB2YXIgbWF0Y2ggPSBuYW1lLm1hdGNoKG1vZGlmaWVyUkUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgdmFyIHJldCA9IHt9O1xuICAgICAgbWF0Y2guZm9yRWFjaChmdW5jdGlvbiAobSkgeyByZXRbbS5zbGljZSgxKV0gPSB0cnVlOyB9KTtcbiAgICAgIHJldHVybiByZXRcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQXR0cnNNYXAgKGF0dHJzKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgICApIHtcbiAgICAgICAgd2FybiQyKCdkdXBsaWNhdGUgYXR0cmlidXRlOiAnICsgYXR0cnNbaV0ubmFtZSwgYXR0cnNbaV0pO1xuICAgICAgfVxuICAgICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8vIGZvciBzY3JpcHQgKGUuZy4gdHlwZT1cIngvdGVtcGxhdGVcIikgb3Igc3R5bGUsIGRvIG5vdCBkZWNvZGUgY29udGVudFxuICBmdW5jdGlvbiBpc1RleHRUYWcgKGVsKSB7XG4gICAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG4gIH1cblxuICBmdW5jdGlvbiBpc0ZvcmJpZGRlblRhZyAoZWwpIHtcbiAgICByZXR1cm4gKFxuICAgICAgZWwudGFnID09PSAnc3R5bGUnIHx8XG4gICAgICAoZWwudGFnID09PSAnc2NyaXB0JyAmJiAoXG4gICAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICAgIGVsLmF0dHJzTWFwLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnXG4gICAgICApKVxuICAgIClcbiAgfVxuXG4gIHZhciBpZU5TQnVnID0gL154bWxuczpOU1xcZCsvO1xuICB2YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZnVuY3Rpb24gZ3VhcmRJRVNWR0J1ZyAoYXR0cnMpIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXTtcbiAgICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgICAgYXR0ci5uYW1lID0gYXR0ci5uYW1lLnJlcGxhY2UoaWVOU1ByZWZpeCwgJycpO1xuICAgICAgICByZXMucHVzaChhdHRyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tGb3JBbGlhc01vZGVsIChlbCwgdmFsdWUpIHtcbiAgICB2YXIgX2VsID0gZWw7XG4gICAgd2hpbGUgKF9lbCkge1xuICAgICAgaWYgKF9lbC5mb3IgJiYgX2VsLmFsaWFzID09PSB2YWx1ZSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgICAgXCJZb3UgYXJlIGJpbmRpbmcgdi1tb2RlbCBkaXJlY3RseSB0byBhIHYtZm9yIGl0ZXJhdGlvbiBhbGlhcy4gXCIgK1xuICAgICAgICAgIFwiVGhpcyB3aWxsIG5vdCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgdi1mb3Igc291cmNlIGFycmF5IGJlY2F1c2UgXCIgK1xuICAgICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICAgIFwiQ29uc2lkZXIgdXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhbmQgdXNlIHYtbW9kZWwgb24gYW4gb2JqZWN0IHByb3BlcnR5IGluc3RlYWQuXCIsXG4gICAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtbW9kZWwnXVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgX2VsID0gX2VsLnBhcmVudDtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBwcmVUcmFuc2Zvcm1Ob2RlIChlbCwgb3B0aW9ucykge1xuICAgIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICAgIHZhciBtYXAgPSBlbC5hdHRyc01hcDtcbiAgICAgIGlmICghbWFwWyd2LW1vZGVsJ10pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlQmluZGluZztcbiAgICAgIGlmIChtYXBbJzp0eXBlJ10gfHwgbWFwWyd2LWJpbmQ6dHlwZSddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcC50eXBlICYmICF0eXBlQmluZGluZyAmJiBtYXBbJ3YtYmluZCddKSB7XG4gICAgICAgIHR5cGVCaW5kaW5nID0gXCIoXCIgKyAobWFwWyd2LWJpbmQnXSkgKyBcIikudHlwZVwiO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZUJpbmRpbmcpIHtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtaWYnLCB0cnVlKTtcbiAgICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgICB2YXIgaGFzRWxzZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWVsc2UnLCB0cnVlKSAhPSBudWxsO1xuICAgICAgICB2YXIgZWxzZUlmQ29uZGl0aW9uID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicsIHRydWUpO1xuICAgICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgICB2YXIgYnJhbmNoMCA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIC8vIHByb2Nlc3MgZm9yIG9uIHRoZSBtYWluIG5vZGVcbiAgICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgICAgYWRkUmF3QXR0cihicmFuY2gwLCAndHlwZScsICdjaGVja2JveCcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gwLCBvcHRpb25zKTtcbiAgICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgICBicmFuY2gwLmlmID0gXCIoXCIgKyB0eXBlQmluZGluZyArIFwiKT09PSdjaGVja2JveCdcIiArIGlmQ29uZGl0aW9uRXh0cmE7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDBcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgICB2YXIgYnJhbmNoMSA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMSwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMSwgb3B0aW9ucyk7XG4gICAgICAgIGFkZElmQ29uZGl0aW9uKGJyYW5jaDAsIHtcbiAgICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICAgIGJsb2NrOiBicmFuY2gxXG4gICAgICAgIH0pO1xuICAgICAgICAvLyAzLiBvdGhlclxuICAgICAgICB2YXIgYnJhbmNoMiA9IGNsb25lQVNURWxlbWVudChlbCk7XG4gICAgICAgIGdldEFuZFJlbW92ZUF0dHIoYnJhbmNoMiwgJ3YtZm9yJywgdHJ1ZSk7XG4gICAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgICBwcm9jZXNzRWxlbWVudChicmFuY2gyLCBvcHRpb25zKTtcbiAgICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgICAgYmxvY2s6IGJyYW5jaDJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgICBicmFuY2gwLmVsc2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGVsc2VJZkNvbmRpdGlvbikge1xuICAgICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJyYW5jaDBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFTVEVsZW1lbnQoZWwudGFnLCBlbC5hdHRyc0xpc3Quc2xpY2UoKSwgZWwucGFyZW50KVxuICB9XG5cbiAgdmFyIG1vZGVsJDEgPSB7XG4gICAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxuICB9O1xuXG4gIHZhciBtb2R1bGVzJDEgPSBbXG4gICAga2xhc3MkMSxcbiAgICBzdHlsZSQxLFxuICAgIG1vZGVsJDFcbiAgXTtcblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiB0ZXh0IChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ3RleHRDb250ZW50JywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSwgZGlyKTtcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gICAgaWYgKGRpci52YWx1ZSkge1xuICAgICAgYWRkUHJvcChlbCwgJ2lubmVySFRNTCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIiksIGRpcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgICBtb2RlbDogbW9kZWwsXG4gICAgdGV4dDogdGV4dCxcbiAgICBodG1sOiBodG1sXG4gIH07XG5cbiAgLyogICovXG5cbiAgdmFyIGJhc2VPcHRpb25zID0ge1xuICAgIGV4cGVjdEhUTUw6IHRydWUsXG4gICAgbW9kdWxlczogbW9kdWxlcyQxLFxuICAgIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgICBpc1ByZVRhZzogaXNQcmVUYWcsXG4gICAgaXNVbmFyeVRhZzogaXNVbmFyeVRhZyxcbiAgICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gICAgY2FuQmVMZWZ0T3BlblRhZzogY2FuQmVMZWZ0T3BlblRhZyxcbiAgICBpc1Jlc2VydmVkVGFnOiBpc1Jlc2VydmVkVGFnLFxuICAgIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICAgIHN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMobW9kdWxlcyQxKVxuICB9O1xuXG4gIC8qICAqL1xuXG4gIHZhciBpc1N0YXRpY0tleTtcbiAgdmFyIGlzUGxhdGZvcm1SZXNlcnZlZFRhZztcblxuICB2YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4gIC8qKlxuICAgKiBHb2FsIG9mIHRoZSBvcHRpbWl6ZXI6IHdhbGsgdGhlIGdlbmVyYXRlZCB0ZW1wbGF0ZSBBU1QgdHJlZVxuICAgKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gICAqIHRoZSBET00gdGhhdCBuZXZlciBuZWVkcyB0byBjaGFuZ2UuXG4gICAqXG4gICAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICAgKlxuICAgKiAxLiBIb2lzdCB0aGVtIGludG8gY29uc3RhbnRzLCBzbyB0aGF0IHdlIG5vIGxvbmdlciBuZWVkIHRvXG4gICAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAgICogMi4gQ29tcGxldGVseSBza2lwIHRoZW0gaW4gdGhlIHBhdGNoaW5nIHByb2Nlc3MuXG4gICAqL1xuICBmdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkgeyByZXR1cm4gfVxuICAgIGlzU3RhdGljS2V5ID0gZ2VuU3RhdGljS2V5c0NhY2hlZChvcHRpb25zLnN0YXRpY0tleXMgfHwgJycpO1xuICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICAvLyBmaXJzdCBwYXNzOiBtYXJrIGFsbCBub24tc3RhdGljIG5vZGVzLlxuICAgIG1hcmtTdGF0aWMkMShyb290KTtcbiAgICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gICAgbWFya1N0YXRpY1Jvb3RzKHJvb3QsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICAgIHJldHVybiBtYWtlTWFwKFxuICAgICAgJ3R5cGUsdGFnLGF0dHJzTGlzdCxhdHRyc01hcCxwbGFpbixwYXJlbnQsY2hpbGRyZW4sYXR0cnMsc3RhcnQsZW5kLHJhd0F0dHJzTWFwJyArXG4gICAgICAoa2V5cyA/ICcsJyArIGtleXMgOiAnJylcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljJDEgKG5vZGUpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIC8vIGRvIG5vdCBtYWtlIGNvbXBvbmVudCBzbG90IGNvbnRlbnQgc3RhdGljLiB0aGlzIGF2b2lkc1xuICAgICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgICAgLy8gMi4gc3RhdGljIHNsb3QgY29udGVudCBmYWlscyBmb3IgaG90LXJlbG9hZGluZ1xuICAgICAgaWYgKFxuICAgICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgICBub2RlLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgICAgIG5vZGUuYXR0cnNNYXBbJ2lubGluZS10ZW1wbGF0ZSddID09IG51bGxcbiAgICAgICkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgbWFya1N0YXRpYyQxKGNoaWxkKTtcbiAgICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5pZkNvbmRpdGlvbnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgICBtYXJrU3RhdGljJDEoYmxvY2spO1xuICAgICAgICAgIGlmICghYmxvY2suc3RhdGljKSB7XG4gICAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIGlmIChub2RlLnN0YXRpYyB8fCBub2RlLm9uY2UpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgICB9XG4gICAgICAvLyBGb3IgYSBub2RlIHRvIHF1YWxpZnkgYXMgYSBzdGF0aWMgcm9vdCwgaXQgc2hvdWxkIGhhdmUgY2hpbGRyZW4gdGhhdFxuICAgICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAgIC8vIG91dHdlaWdoIHRoZSBiZW5lZml0cyBhbmQgaXQncyBiZXR0ZXIgb2ZmIHRvIGp1c3QgYWx3YXlzIHJlbmRlciBpdCBmcmVzaC5cbiAgICAgIGlmIChub2RlLnN0YXRpYyAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCAmJiAhKFxuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBub2RlLmNoaWxkcmVuWzBdLnR5cGUgPT09IDNcbiAgICAgICkpIHtcbiAgICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBtYXJrU3RhdGljUm9vdHMobm9kZS5jaGlsZHJlbltpXSwgaXNJbkZvciB8fCAhIW5vZGUuZm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDEsIGwkMSA9IG5vZGUuaWZDb25kaXRpb25zLmxlbmd0aDsgaSQxIDwgbCQxOyBpJDErKykge1xuICAgICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3RhdGljIChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICAgIW5vZGUuaGFzQmluZGluZ3MgJiYgLy8gbm8gZHluYW1pYyBiaW5kaW5nc1xuICAgICAgIW5vZGUuaWYgJiYgIW5vZGUuZm9yICYmIC8vIG5vdCB2LWlmIG9yIHYtZm9yIG9yIHYtZWxzZVxuICAgICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICAgIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgY29tcG9uZW50XG4gICAgICAhaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3Iobm9kZSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICAgICkpXG4gIH1cblxuICBmdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyogICovXG5cbiAgdmFyIGZuRXhwUkUgPSAvXihbXFx3JF9dK3xcXChbXildKj9cXCkpXFxzKj0+fF5mdW5jdGlvblxccypcXCgvO1xuICB2YXIgZm5JbnZva2VSRSA9IC9cXChbXildKj9cXCk7KiQvO1xuICB2YXIgc2ltcGxlUGF0aFJFID0gL15bQS1aYS16XyRdW1xcdyRdKig/OlxcLltBLVphLXpfJF1bXFx3JF0qfFxcWydbXiddKj8nXXxcXFtcIlteXCJdKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSokLztcblxuICAvLyBLZXlib2FyZEV2ZW50LmtleUNvZGUgYWxpYXNlc1xuICB2YXIga2V5Q29kZXMgPSB7XG4gICAgZXNjOiAyNyxcbiAgICB0YWI6IDksXG4gICAgZW50ZXI6IDEzLFxuICAgIHNwYWNlOiAzMixcbiAgICB1cDogMzgsXG4gICAgbGVmdDogMzcsXG4gICAgcmlnaHQ6IDM5LFxuICAgIGRvd246IDQwLFxuICAgICdkZWxldGUnOiBbOCwgNDZdXG4gIH07XG5cbiAgLy8gS2V5Ym9hcmRFdmVudC5rZXkgYWxpYXNlc1xuICB2YXIga2V5TmFtZXMgPSB7XG4gICAgLy8gIzc4ODA6IElFMTEgYW5kIEVkZ2UgdXNlIGBFc2NgIGZvciBFc2NhcGUga2V5IG5hbWUuXG4gICAgZXNjOiBbJ0VzYycsICdFc2NhcGUnXSxcbiAgICB0YWI6ICdUYWInLFxuICAgIGVudGVyOiAnRW50ZXInLFxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYFNwYWNlYmFyYCBmb3IgU3BhY2Uga2V5IG5hbWUuXG4gICAgc3BhY2U6IFsnICcsICdTcGFjZWJhciddLFxuICAgIC8vICM3ODA2OiBJRTExIHVzZXMga2V5IG5hbWVzIHdpdGhvdXQgYEFycm93YCBwcmVmaXggZm9yIGFycm93IGtleXMuXG4gICAgdXA6IFsnVXAnLCAnQXJyb3dVcCddLFxuICAgIGxlZnQ6IFsnTGVmdCcsICdBcnJvd0xlZnQnXSxcbiAgICByaWdodDogWydSaWdodCcsICdBcnJvd1JpZ2h0J10sXG4gICAgZG93bjogWydEb3duJywgJ0Fycm93RG93biddLFxuICAgIC8vICM5MTEyOiBJRTExIHVzZXMgYERlbGAgZm9yIERlbGV0ZSBrZXkgbmFtZS5cbiAgICAnZGVsZXRlJzogWydCYWNrc3BhY2UnLCAnRGVsZXRlJywgJ0RlbCddXG4gIH07XG5cbiAgLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbiAgLy8gbmVlZCB0byBleHBsaWNpdGx5IHJldHVybiBudWxsIHNvIHRoYXQgd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIHRvIHJlbW92ZVxuICAvLyB0aGUgbGlzdGVuZXIgZm9yIC5vbmNlXG4gIHZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG4gIHZhciBtb2RpZmllckNvZGUgPSB7XG4gICAgc3RvcDogJyRldmVudC5zdG9wUHJvcGFnYXRpb24oKTsnLFxuICAgIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICAgIHNlbGY6IGdlbkd1YXJkKFwiJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXRcIiksXG4gICAgY3RybDogZ2VuR3VhcmQoXCIhJGV2ZW50LmN0cmxLZXlcIiksXG4gICAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgICBhbHQ6IGdlbkd1YXJkKFwiISRldmVudC5hbHRLZXlcIiksXG4gICAgbWV0YTogZ2VuR3VhcmQoXCIhJGV2ZW50Lm1ldGFLZXlcIiksXG4gICAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgICBtaWRkbGU6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDFcIiksXG4gICAgcmlnaHQ6IGdlbkd1YXJkKFwiJ2J1dHRvbicgaW4gJGV2ZW50ICYmICRldmVudC5idXR0b24gIT09IDJcIilcbiAgfTtcblxuICBmdW5jdGlvbiBnZW5IYW5kbGVycyAoXG4gICAgZXZlbnRzLFxuICAgIGlzTmF0aXZlXG4gICkge1xuICAgIHZhciBwcmVmaXggPSBpc05hdGl2ZSA/ICduYXRpdmVPbjonIDogJ29uOic7XG4gICAgdmFyIHN0YXRpY0hhbmRsZXJzID0gXCJcIjtcbiAgICB2YXIgZHluYW1pY0hhbmRsZXJzID0gXCJcIjtcbiAgICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgICAgdmFyIGhhbmRsZXJDb2RlID0gZ2VuSGFuZGxlcihldmVudHNbbmFtZV0pO1xuICAgICAgaWYgKGV2ZW50c1tuYW1lXSAmJiBldmVudHNbbmFtZV0uZHluYW1pYykge1xuICAgICAgICBkeW5hbWljSGFuZGxlcnMgKz0gbmFtZSArIFwiLFwiICsgaGFuZGxlckNvZGUgKyBcIixcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRpY0hhbmRsZXJzICs9IFwiXFxcIlwiICsgbmFtZSArIFwiXFxcIjpcIiArIGhhbmRsZXJDb2RlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRpY0hhbmRsZXJzID0gXCJ7XCIgKyAoc3RhdGljSGFuZGxlcnMuc2xpY2UoMCwgLTEpKSArIFwifVwiO1xuICAgIGlmIChkeW5hbWljSGFuZGxlcnMpIHtcbiAgICAgIHJldHVybiBwcmVmaXggKyBcIl9kKFwiICsgc3RhdGljSGFuZGxlcnMgKyBcIixbXCIgKyAoZHluYW1pY0hhbmRsZXJzLnNsaWNlKDAsIC0xKSkgKyBcIl0pXCJcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHByZWZpeCArIHN0YXRpY0hhbmRsZXJzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuSGFuZGxlciAoaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIoaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgICB9XG5cbiAgICB2YXIgaXNNZXRob2RQYXRoID0gc2ltcGxlUGF0aFJFLnRlc3QoaGFuZGxlci52YWx1ZSk7XG4gICAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuICAgIHZhciBpc0Z1bmN0aW9uSW52b2NhdGlvbiA9IHNpbXBsZVBhdGhSRS50ZXN0KGhhbmRsZXIudmFsdWUucmVwbGFjZShmbkludm9rZVJFLCAnJykpO1xuXG4gICAgaWYgKCFoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgaWYgKGlzTWV0aG9kUGF0aCB8fCBpc0Z1bmN0aW9uRXhwcmVzc2lvbikge1xuICAgICAgICByZXR1cm4gaGFuZGxlci52YWx1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIChcImZ1bmN0aW9uKCRldmVudCl7XCIgKyAoaXNGdW5jdGlvbkludm9jYXRpb24gPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpIDogaGFuZGxlci52YWx1ZSkgKyBcIn1cIikgLy8gaW5saW5lIHN0YXRlbWVudFxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29kZSA9ICcnO1xuICAgICAgdmFyIGdlbk1vZGlmaWVyQ29kZSA9ICcnO1xuICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBoYW5kbGVyLm1vZGlmaWVycykge1xuICAgICAgICBpZiAobW9kaWZpZXJDb2RlW2tleV0pIHtcbiAgICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgICAgLy8gbGVmdC9yaWdodFxuICAgICAgICAgIGlmIChrZXlDb2Rlc1trZXldKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZXhhY3QnKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgICAgZ2VuTW9kaWZpZXJDb2RlICs9IGdlbkd1YXJkKFxuICAgICAgICAgICAgWydjdHJsJywgJ3NoaWZ0JywgJ2FsdCcsICdtZXRhJ11cbiAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXlNb2RpZmllcikgeyByZXR1cm4gKFwiJGV2ZW50LlwiICsga2V5TW9kaWZpZXIgKyBcIktleVwiKTsgfSlcbiAgICAgICAgICAgICAgLmpvaW4oJ3x8JylcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgICB9XG4gICAgICAvLyBNYWtlIHN1cmUgbW9kaWZpZXJzIGxpa2UgcHJldmVudCBhbmQgc3RvcCBnZXQgZXhlY3V0ZWQgYWZ0ZXIga2V5IGZpbHRlcmluZ1xuICAgICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgICBjb2RlICs9IGdlbk1vZGlmaWVyQ29kZTtcbiAgICAgIH1cbiAgICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgICA/IChcInJldHVybiBcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKCRldmVudClcIilcbiAgICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICAgID8gKFwicmV0dXJuIChcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgICAgOiBpc0Z1bmN0aW9uSW52b2NhdGlvblxuICAgICAgICAgICAgPyAoXCJyZXR1cm4gXCIgKyAoaGFuZGxlci52YWx1ZSkpXG4gICAgICAgICAgICA6IGhhbmRsZXIudmFsdWU7XG4gICAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICAgIHJldHVybiAoXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGtleSBmaWx0ZXJzIG9ubHkgYXBwbHkgdG8gS2V5Ym9hcmRFdmVudHNcbiAgICAgIC8vICM5NDQxOiBjYW4ndCB1c2UgJ2tleUNvZGUnIGluICRldmVudCBiZWNhdXNlIENocm9tZSBhdXRvZmlsbCBmaXJlcyBmYWtlXG4gICAgICAvLyBrZXkgZXZlbnRzIHRoYXQgZG8gbm90IGhhdmUga2V5Q29kZSBwcm9wZXJ0eS4uLlxuICAgICAgXCJpZighJGV2ZW50LnR5cGUuaW5kZXhPZigna2V5JykmJlwiICtcbiAgICAgIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRmlsdGVyQ29kZSAoa2V5KSB7XG4gICAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICAgIGlmIChrZXlWYWwpIHtcbiAgICAgIHJldHVybiAoXCIkZXZlbnQua2V5Q29kZSE9PVwiICsga2V5VmFsKVxuICAgIH1cbiAgICB2YXIga2V5Q29kZSA9IGtleUNvZGVzW2tleV07XG4gICAgdmFyIGtleU5hbWUgPSBrZXlOYW1lc1trZXldO1xuICAgIHJldHVybiAoXG4gICAgICBcIl9rKCRldmVudC5rZXlDb2RlLFwiICtcbiAgICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAgIChKU09OLnN0cmluZ2lmeShrZXlDb2RlKSkgKyBcIixcIiArXG4gICAgICBcIiRldmVudC5rZXksXCIgK1xuICAgICAgXCJcIiArIChKU09OLnN0cmluZ2lmeShrZXlOYW1lKSkgK1xuICAgICAgXCIpXCJcbiAgICApXG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICAgIGlmIChkaXIubW9kaWZpZXJzKSB7XG4gICAgICB3YXJuKFwidi1vbiB3aXRob3V0IGFyZ3VtZW50IGRvZXMgbm90IHN1cHBvcnQgbW9kaWZpZXJzLlwiKTtcbiAgICB9XG4gICAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xuICB9XG5cbiAgLyogICovXG5cbiAgZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gICAgZWwud3JhcERhdGEgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgcmV0dXJuIChcIl9iKFwiICsgY29kZSArIFwiLCdcIiArIChlbC50YWcpICsgXCInLFwiICsgKGRpci52YWx1ZSkgKyBcIixcIiArIChkaXIubW9kaWZpZXJzICYmIGRpci5tb2RpZmllcnMucHJvcCA/ICd0cnVlJyA6ICdmYWxzZScpICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5zeW5jID8gJyx0cnVlJyA6ICcnKSArIFwiKVwiKVxuICAgIH07XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gICAgb246IG9uLFxuICAgIGJpbmQ6IGJpbmQkMSxcbiAgICBjbG9hazogbm9vcFxuICB9O1xuXG4gIC8qICAqL1xuXG5cblxuXG5cbiAgdmFyIENvZGVnZW5TdGF0ZSA9IGZ1bmN0aW9uIENvZGVnZW5TdGF0ZSAob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtQ29kZScpO1xuICAgIHRoaXMuZGF0YUdlbkZucyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAnZ2VuRGF0YScpO1xuICAgIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgICB2YXIgaXNSZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgICB0aGlzLm1heWJlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGVsKSB7IHJldHVybiAhIWVsLmNvbXBvbmVudCB8fCAhaXNSZXNlcnZlZFRhZyhlbC50YWcpOyB9O1xuICAgIHRoaXMub25jZUlkID0gMDtcbiAgICB0aGlzLnN0YXRpY1JlbmRlckZucyA9IFtdO1xuICAgIHRoaXMucHJlID0gZmFsc2U7XG4gIH07XG5cblxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlIChcbiAgICBhc3QsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgc3RhdGUgPSBuZXcgQ29kZWdlblN0YXRlKG9wdGlvbnMpO1xuICAgIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcjogKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyBjb2RlICsgXCJ9XCIpLFxuICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgICBpZiAoZWwucGFyZW50KSB7XG4gICAgICBlbC5wcmUgPSBlbC5wcmUgfHwgZWwucGFyZW50LnByZTtcbiAgICB9XG5cbiAgICBpZiAoZWwuc3RhdGljUm9vdCAmJiAhZWwuc3RhdGljUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICAgIHJldHVybiBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLmZvciAmJiAhZWwuZm9yUHJvY2Vzc2VkKSB7XG4gICAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCAmJiAhc3RhdGUucHJlKSB7XG4gICAgICByZXR1cm4gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndm9pZCAwJ1xuICAgIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICAgIHJldHVybiBnZW5TbG90KGVsLCBzdGF0ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICAgIHZhciBjb2RlO1xuICAgICAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoIWVsLnBsYWluIHx8IChlbC5wcmUgJiYgc3RhdGUubWF5YmVDb21wb25lbnQoZWwpKSkge1xuICAgICAgICAgIGRhdGEgPSBnZW5EYXRhJDIoZWwsIHN0YXRlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gICAgICAgIGNvZGUgPSBcIl9jKCdcIiArIChlbC50YWcpICsgXCInXCIgKyAoZGF0YSA/IChcIixcIiArIGRhdGEpIDogJycpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCI7XG4gICAgICB9XG4gICAgICAvLyBtb2R1bGUgdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS50cmFuc2Zvcm1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb2RlXG4gICAgfVxuICB9XG5cbiAgLy8gaG9pc3Qgc3RhdGljIHN1Yi10cmVlcyBvdXRcbiAgZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUpIHtcbiAgICBlbC5zdGF0aWNQcm9jZXNzZWQgPSB0cnVlO1xuICAgIC8vIFNvbWUgZWxlbWVudHMgKHRlbXBsYXRlcykgbmVlZCB0byBiZWhhdmUgZGlmZmVyZW50bHkgaW5zaWRlIG9mIGEgdi1wcmVcbiAgICAvLyBub2RlLiAgQWxsIHByZSBub2RlcyBhcmUgc3RhdGljIHJvb3RzLCBzbyB3ZSBjYW4gdXNlIHRoaXMgYXMgYSBsb2NhdGlvbiB0b1xuICAgIC8vIHdyYXAgYSBzdGF0ZSBjaGFuZ2UgYW5kIHJlc2V0IGl0IHVwb24gZXhpdGluZyB0aGUgcHJlIG5vZGUuXG4gICAgdmFyIG9yaWdpbmFsUHJlU3RhdGUgPSBzdGF0ZS5wcmU7XG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgc3RhdGUucHJlID0gZWwucHJlO1xuICAgIH1cbiAgICBzdGF0ZS5zdGF0aWNSZW5kZXJGbnMucHVzaCgoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIChnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCIpKTtcbiAgICBzdGF0ZS5wcmUgPSBvcmlnaW5hbFByZVN0YXRlO1xuICAgIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyAoZWwuc3RhdGljSW5Gb3IgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH1cblxuICAvLyB2LW9uY2VcbiAgZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gICAgZWwub25jZVByb2Nlc3NlZCA9IHRydWU7XG4gICAgaWYgKGVsLmlmICYmICFlbC5pZlByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgICB9IGVsc2UgaWYgKGVsLnN0YXRpY0luRm9yKSB7XG4gICAgICB2YXIga2V5ID0gJyc7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LmZvcikge1xuICAgICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgfVxuICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgc3RhdGUud2FybihcbiAgICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIixcbiAgICAgICAgICBlbC5yYXdBdHRyc01hcFsndi1vbmNlJ11cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgICAgfVxuICAgICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2VuU3RhdGljKGVsLCBzdGF0ZSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5JZiAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEVtcHR5XG4gICkge1xuICAgIGVsLmlmUHJvY2Vzc2VkID0gdHJ1ZTsgLy8gYXZvaWQgcmVjdXJzaW9uXG4gICAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5JZkNvbmRpdGlvbnMgKFxuICAgIGNvbmRpdGlvbnMsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEVtcHR5XG4gICkge1xuICAgIGlmICghY29uZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgICB9XG5cbiAgICB2YXIgY29uZGl0aW9uID0gY29uZGl0aW9ucy5zaGlmdCgpO1xuICAgIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgICByZXR1cm4gKFwiKFwiICsgKGNvbmRpdGlvbi5leHApICsgXCIpP1wiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkgKyBcIjpcIiArIChnZW5JZkNvbmRpdGlvbnMoY29uZGl0aW9ucywgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gICAgfVxuXG4gICAgLy8gdi1pZiB3aXRoIHYtb25jZSBzaG91bGQgZ2VuZXJhdGUgY29kZSBsaWtlIChhKT9fbSgwKTpfbSgxKVxuICAgIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgICByZXR1cm4gYWx0R2VuXG4gICAgICAgID8gYWx0R2VuKGVsLCBzdGF0ZSlcbiAgICAgICAgOiBlbC5vbmNlXG4gICAgICAgICAgPyBnZW5PbmNlKGVsLCBzdGF0ZSlcbiAgICAgICAgICA6IGdlbkVsZW1lbnQoZWwsIHN0YXRlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkZvciAoXG4gICAgZWwsXG4gICAgc3RhdGUsXG4gICAgYWx0R2VuLFxuICAgIGFsdEhlbHBlclxuICApIHtcbiAgICB2YXIgZXhwID0gZWwuZm9yO1xuICAgIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICAgIHZhciBpdGVyYXRvcjEgPSBlbC5pdGVyYXRvcjEgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IxKSkgOiAnJztcbiAgICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG5cbiAgICBpZiAoc3RhdGUubWF5YmVDb21wb25lbnQoZWwpICYmXG4gICAgICBlbC50YWcgIT09ICdzbG90JyAmJlxuICAgICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgICAhZWwua2V5XG4gICAgKSB7XG4gICAgICBzdGF0ZS53YXJuKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1mb3I9XFxcIlwiICsgYWxpYXMgKyBcIiBpbiBcIiArIGV4cCArIFwiXFxcIj46IGNvbXBvbmVudCBsaXN0cyByZW5kZXJlZCB3aXRoIFwiICtcbiAgICAgICAgXCJ2LWZvciBzaG91bGQgaGF2ZSBleHBsaWNpdCBrZXlzLiBcIiArXG4gICAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgICAgZWwucmF3QXR0cnNNYXBbJ3YtZm9yJ10sXG4gICAgICAgIHRydWUgLyogdGlwICovXG4gICAgICApO1xuICAgIH1cblxuICAgIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICAgIHJldHVybiAoYWx0SGVscGVyIHx8ICdfbCcpICsgXCIoKFwiICsgZXhwICsgXCIpLFwiICtcbiAgICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICAgJ30pJ1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgICB2YXIgZGF0YSA9ICd7JztcblxuICAgIC8vIGRpcmVjdGl2ZXMgZmlyc3QuXG4gICAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgICB2YXIgZGlycyA9IGdlbkRpcmVjdGl2ZXMoZWwsIHN0YXRlKTtcbiAgICBpZiAoZGlycykgeyBkYXRhICs9IGRpcnMgKyAnLCc7IH1cblxuICAgIC8vIGtleVxuICAgIGlmIChlbC5rZXkpIHtcbiAgICAgIGRhdGEgKz0gXCJrZXk6XCIgKyAoZWwua2V5KSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyByZWZcbiAgICBpZiAoZWwucmVmKSB7XG4gICAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgICB9XG4gICAgaWYgKGVsLnJlZkluRm9yKSB7XG4gICAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgICB9XG4gICAgLy8gcHJlXG4gICAgaWYgKGVsLnByZSkge1xuICAgICAgZGF0YSArPSBcInByZTp0cnVlLFwiO1xuICAgIH1cbiAgICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICAgIGlmIChlbC5jb21wb25lbnQpIHtcbiAgICAgIGRhdGEgKz0gXCJ0YWc6XFxcIlwiICsgKGVsLnRhZykgKyBcIlxcXCIsXCI7XG4gICAgfVxuICAgIC8vIG1vZHVsZSBkYXRhIGdlbmVyYXRpb24gZnVuY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGF0ZS5kYXRhR2VuRm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICAgIH1cbiAgICAvLyBhdHRyaWJ1dGVzXG4gICAgaWYgKGVsLmF0dHJzKSB7XG4gICAgICBkYXRhICs9IFwiYXR0cnM6XCIgKyAoZ2VuUHJvcHMoZWwuYXR0cnMpKSArIFwiLFwiO1xuICAgIH1cbiAgICAvLyBET00gcHJvcHNcbiAgICBpZiAoZWwucHJvcHMpIHtcbiAgICAgIGRhdGEgKz0gXCJkb21Qcm9wczpcIiArIChnZW5Qcm9wcyhlbC5wcm9wcykpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKGVsLmV2ZW50cykge1xuICAgICAgZGF0YSArPSAoZ2VuSGFuZGxlcnMoZWwuZXZlbnRzLCBmYWxzZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLm5hdGl2ZUV2ZW50cywgdHJ1ZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIHNsb3QgdGFyZ2V0XG4gICAgLy8gb25seSBmb3Igbm9uLXNjb3BlZCBzbG90c1xuICAgIGlmIChlbC5zbG90VGFyZ2V0ICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIHNjb3BlZCBzbG90c1xuICAgIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgICAgZGF0YSArPSAoZ2VuU2NvcGVkU2xvdHMoZWwsIGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gICAgfVxuICAgIC8vIGNvbXBvbmVudCB2LW1vZGVsXG4gICAgaWYgKGVsLm1vZGVsKSB7XG4gICAgICBkYXRhICs9IFwibW9kZWw6e3ZhbHVlOlwiICsgKGVsLm1vZGVsLnZhbHVlKSArIFwiLGNhbGxiYWNrOlwiICsgKGVsLm1vZGVsLmNhbGxiYWNrKSArIFwiLGV4cHJlc3Npb246XCIgKyAoZWwubW9kZWwuZXhwcmVzc2lvbikgKyBcIn0sXCI7XG4gICAgfVxuICAgIC8vIGlubGluZS10ZW1wbGF0ZVxuICAgIGlmIChlbC5pbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgdmFyIGlubGluZVRlbXBsYXRlID0gZ2VuSW5saW5lVGVtcGxhdGUoZWwsIHN0YXRlKTtcbiAgICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgICBkYXRhICs9IGlubGluZVRlbXBsYXRlICsgXCIsXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoLywkLywgJycpICsgJ30nO1xuICAgIC8vIHYtYmluZCBkeW5hbWljIGFyZ3VtZW50IHdyYXBcbiAgICAvLyB2LWJpbmQgd2l0aCBkeW5hbWljIGFyZ3VtZW50cyBtdXN0IGJlIGFwcGxpZWQgdXNpbmcgdGhlIHNhbWUgdi1iaW5kIG9iamVjdFxuICAgIC8vIG1lcmdlIGhlbHBlciBzbyB0aGF0IGNsYXNzL3N0eWxlL211c3RVc2VQcm9wIGF0dHJzIGFyZSBoYW5kbGVkIGNvcnJlY3RseS5cbiAgICBpZiAoZWwuZHluYW1pY0F0dHJzKSB7XG4gICAgICBkYXRhID0gXCJfYihcIiArIGRhdGEgKyBcIixcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIiArIChnZW5Qcm9wcyhlbC5keW5hbWljQXR0cnMpKSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyB2LWJpbmQgZGF0YSB3cmFwXG4gICAgaWYgKGVsLndyYXBEYXRhKSB7XG4gICAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gICAgfVxuICAgIC8vIHYtb24gZGF0YSB3cmFwXG4gICAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICAgIGRhdGEgPSBlbC53cmFwTGlzdGVuZXJzKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuRGlyZWN0aXZlcyAoZWwsIHN0YXRlKSB7XG4gICAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICAgIGlmICghZGlycykgeyByZXR1cm4gfVxuICAgIHZhciByZXMgPSAnZGlyZWN0aXZlczpbJztcbiAgICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICAgIHZhciBpLCBsLCBkaXIsIG5lZWRSdW50aW1lO1xuICAgIGZvciAoaSA9IDAsIGwgPSBkaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZGlyID0gZGlyc1tpXTtcbiAgICAgIG5lZWRSdW50aW1lID0gdHJ1ZTtcbiAgICAgIHZhciBnZW4gPSBzdGF0ZS5kaXJlY3RpdmVzW2Rpci5uYW1lXTtcbiAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgLy8gY29tcGlsZS10aW1lIGRpcmVjdGl2ZSB0aGF0IG1hbmlwdWxhdGVzIEFTVC5cbiAgICAgICAgLy8gcmV0dXJucyB0cnVlIGlmIGl0IGFsc28gbmVlZHMgYSBydW50aW1lIGNvdW50ZXJwYXJ0LlxuICAgICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRSdW50aW1lKSB7XG4gICAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgICByZXMgKz0gXCJ7bmFtZTpcXFwiXCIgKyAoZGlyLm5hbWUpICsgXCJcXFwiLHJhd05hbWU6XFxcIlwiICsgKGRpci5yYXdOYW1lKSArIFwiXFxcIlwiICsgKGRpci52YWx1ZSA/IChcIix2YWx1ZTooXCIgKyAoZGlyLnZhbHVlKSArIFwiKSxleHByZXNzaW9uOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci52YWx1ZSkpKSA6ICcnKSArIChkaXIuYXJnID8gKFwiLGFyZzpcIiArIChkaXIuaXNEeW5hbWljQXJnID8gZGlyLmFyZyA6IChcIlxcXCJcIiArIChkaXIuYXJnKSArIFwiXFxcIlwiKSkpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChoYXNSdW50aW1lKSB7XG4gICAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKSArICddJ1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbklubGluZVRlbXBsYXRlIChlbCwgc3RhdGUpIHtcbiAgICB2YXIgYXN0ID0gZWwuY2hpbGRyZW5bMF07XG4gICAgaWYgKGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMSkge1xuICAgICAgc3RhdGUud2FybihcbiAgICAgICAgJ0lubGluZS10ZW1wbGF0ZSBjb21wb25lbnRzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBjaGlsZCBlbGVtZW50LicsXG4gICAgICAgIHsgc3RhcnQ6IGVsLnN0YXJ0IH1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhc3QgJiYgYXN0LnR5cGUgPT09IDEpIHtcbiAgICAgIHZhciBpbmxpbmVSZW5kZXJGbnMgPSBnZW5lcmF0ZShhc3QsIHN0YXRlLm9wdGlvbnMpO1xuICAgICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gICAgZWwsXG4gICAgc2xvdHMsXG4gICAgc3RhdGVcbiAgKSB7XG4gICAgLy8gYnkgZGVmYXVsdCBzY29wZWQgc2xvdHMgYXJlIGNvbnNpZGVyZWQgXCJzdGFibGVcIiwgdGhpcyBhbGxvd3MgY2hpbGRcbiAgICAvLyBjb21wb25lbnRzIHdpdGggb25seSBzY29wZWQgc2xvdHMgdG8gc2tpcCBmb3JjZWQgdXBkYXRlcyBmcm9tIHBhcmVudC5cbiAgICAvLyBidXQgaW4gc29tZSBjYXNlcyB3ZSBoYXZlIHRvIGJhaWwtb3V0IG9mIHRoaXMgb3B0aW1pemF0aW9uXG4gICAgLy8gZm9yIGV4YW1wbGUgaWYgdGhlIHNsb3QgY29udGFpbnMgZHluYW1pYyBuYW1lcywgaGFzIHYtaWYgb3Igdi1mb3Igb24gdGhlbS4uLlxuICAgIHZhciBuZWVkc0ZvcmNlVXBkYXRlID0gT2JqZWN0LmtleXMoc2xvdHMpLnNvbWUoZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIHNsb3QgPSBzbG90c1trZXldO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgc2xvdC5zbG90VGFyZ2V0RHluYW1pYyB8fFxuICAgICAgICBzbG90LmlmIHx8XG4gICAgICAgIHNsb3QuZm9yIHx8XG4gICAgICAgIGNvbnRhaW5zU2xvdENoaWxkKHNsb3QpIC8vIGlzIHBhc3NpbmcgZG93biBzbG90IGZyb20gcGFyZW50IHdoaWNoIG1heSBiZSBkeW5hbWljXG4gICAgICApXG4gICAgfSk7XG5cbiAgICAvLyAjOTUzNDogaWYgYSBjb21wb25lbnQgd2l0aCBzY29wZWQgc2xvdHMgaXMgaW5zaWRlIGEgY29uZGl0aW9uYWwgYnJhbmNoLFxuICAgIC8vIGl0J3MgcG9zc2libGUgZm9yIHRoZSBzYW1lIGNvbXBvbmVudCB0byBiZSByZXVzZWQgYnV0IHdpdGggZGlmZmVyZW50XG4gICAgLy8gY29tcGlsZWQgc2xvdCBjb250ZW50LiBUbyBhdm9pZCB0aGF0LCB3ZSBnZW5lcmF0ZSBhIHVuaXF1ZSBrZXkgYmFzZWQgb25cbiAgICAvLyB0aGUgZ2VuZXJhdGVkIGNvZGUgb2YgYWxsIHRoZSBzbG90IGNvbnRlbnRzLlxuICAgIHZhciBuZWVkc0tleSA9ICEhZWwuaWY7XG5cbiAgICAvLyBPUiB3aGVuIGl0IGlzIGluc2lkZSBhbm90aGVyIHNjb3BlZCBzbG90IG9yIHYtZm9yICh0aGUgcmVhY3Rpdml0eSBtYXkgYmVcbiAgICAvLyBkaXNjb25uZWN0ZWQgZHVlIHRvIHRoZSBpbnRlcm1lZGlhdGUgc2NvcGUgdmFyaWFibGUpXG4gICAgLy8gIzk0MzgsICM5NTA2XG4gICAgLy8gVE9ETzogdGhpcyBjYW4gYmUgZnVydGhlciBvcHRpbWl6ZWQgYnkgcHJvcGVybHkgYW5hbHl6aW5nIGluLXNjb3BlIGJpbmRpbmdzXG4gICAgLy8gYW5kIHNraXAgZm9yY2UgdXBkYXRpbmcgb25lcyB0aGF0IGRvIG5vdCBhY3R1YWxseSB1c2Ugc2NvcGUgdmFyaWFibGVzLlxuICAgIGlmICghbmVlZHNGb3JjZVVwZGF0ZSkge1xuICAgICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudDtcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwYXJlbnQuc2xvdFNjb3BlICYmIHBhcmVudC5zbG90U2NvcGUgIT09IGVtcHR5U2xvdFNjb3BlVG9rZW4pIHx8XG4gICAgICAgICAgcGFyZW50LmZvclxuICAgICAgICApIHtcbiAgICAgICAgICBuZWVkc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQuaWYpIHtcbiAgICAgICAgICBuZWVkc0tleSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZ2VuZXJhdGVkU2xvdHMgPSBPYmplY3Qua2V5cyhzbG90cylcbiAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZ2VuU2NvcGVkU2xvdChzbG90c1trZXldLCBzdGF0ZSk7IH0pXG4gICAgICAuam9pbignLCcpO1xuXG4gICAgcmV0dXJuIChcInNjb3BlZFNsb3RzOl91KFtcIiArIGdlbmVyYXRlZFNsb3RzICsgXCJdXCIgKyAobmVlZHNGb3JjZVVwZGF0ZSA/IFwiLG51bGwsdHJ1ZVwiIDogXCJcIikgKyAoIW5lZWRzRm9yY2VVcGRhdGUgJiYgbmVlZHNLZXkgPyAoXCIsbnVsbCxmYWxzZSxcIiArIChoYXNoKGdlbmVyYXRlZFNsb3RzKSkpIDogXCJcIikgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgdmFyIGhhc2ggPSA1MzgxO1xuICAgIHZhciBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZShpKSB7XG4gICAgICBoYXNoID0gKGhhc2ggKiAzMykgXiBzdHIuY2hhckNvZGVBdCgtLWkpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaCA+Pj4gMFxuICB9XG5cbiAgZnVuY3Rpb24gY29udGFpbnNTbG90Q2hpbGQgKGVsKSB7XG4gICAgaWYgKGVsLnR5cGUgPT09IDEpIHtcbiAgICAgIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsLmNoaWxkcmVuLnNvbWUoY29udGFpbnNTbG90Q2hpbGQpXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuU2NvcGVkU2xvdCAoXG4gICAgZWwsXG4gICAgc3RhdGVcbiAgKSB7XG4gICAgdmFyIGlzTGVnYWN5U3ludGF4ID0gZWwuYXR0cnNNYXBbJ3Nsb3Qtc2NvcGUnXTtcbiAgICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkICYmICFpc0xlZ2FjeVN5bnRheCkge1xuICAgICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSwgZ2VuU2NvcGVkU2xvdCwgXCJudWxsXCIpXG4gICAgfVxuICAgIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgICAgcmV0dXJuIGdlbkZvcihlbCwgc3RhdGUsIGdlblNjb3BlZFNsb3QpXG4gICAgfVxuICAgIHZhciBzbG90U2NvcGUgPSBlbC5zbG90U2NvcGUgPT09IGVtcHR5U2xvdFNjb3BlVG9rZW5cbiAgICAgID8gXCJcIlxuICAgICAgOiBTdHJpbmcoZWwuc2xvdFNjb3BlKTtcbiAgICB2YXIgZm4gPSBcImZ1bmN0aW9uKFwiICsgc2xvdFNjb3BlICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJ1xuICAgICAgICA/IGVsLmlmICYmIGlzTGVnYWN5U3ludGF4XG4gICAgICAgICAgPyAoXCIoXCIgKyAoZWwuaWYpICsgXCIpP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgICAgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd1bmRlZmluZWQnXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiO1xuICAgIC8vIHJldmVyc2UgcHJveHkgdi1zbG90IHdpdGhvdXQgc2NvcGUgb24gdGhpcy4kc2xvdHNcbiAgICB2YXIgcmV2ZXJzZVByb3h5ID0gc2xvdFNjb3BlID8gXCJcIiA6IFwiLHByb3h5OnRydWVcIjtcbiAgICByZXR1cm4gKFwie2tleTpcIiArIChlbC5zbG90VGFyZ2V0IHx8IFwiXFxcImRlZmF1bHRcXFwiXCIpICsgXCIsZm46XCIgKyBmbiArIHJldmVyc2VQcm94eSArIFwifVwiKVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICAgIGVsLFxuICAgIHN0YXRlLFxuICAgIGNoZWNrU2tpcCxcbiAgICBhbHRHZW5FbGVtZW50LFxuICAgIGFsdEdlbk5vZGVcbiAgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAgIC8vIG9wdGltaXplIHNpbmdsZSB2LWZvclxuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICBlbCQxLmZvciAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3RlbXBsYXRlJyAmJlxuICAgICAgICBlbCQxLnRhZyAhPT0gJ3Nsb3QnXG4gICAgICApIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICAgICAgPyBzdGF0ZS5tYXliZUNvbXBvbmVudChlbCQxKSA/IFwiLDFcIiA6IFwiLDBcIlxuICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgcmV0dXJuIChcIlwiICsgKChhbHRHZW5FbGVtZW50IHx8IGdlbkVsZW1lbnQpKGVsJDEsIHN0YXRlKSkgKyBub3JtYWxpemF0aW9uVHlwZSlcbiAgICAgIH1cbiAgICAgIHZhciBub3JtYWxpemF0aW9uVHlwZSQxID0gY2hlY2tTa2lwXG4gICAgICAgID8gZ2V0Tm9ybWFsaXphdGlvblR5cGUoY2hpbGRyZW4sIHN0YXRlLm1heWJlQ29tcG9uZW50KVxuICAgICAgICA6IDA7XG4gICAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgICAgcmV0dXJuIChcIltcIiArIChjaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGdlbihjLCBzdGF0ZSk7IH0pLmpvaW4oJywnKSkgKyBcIl1cIiArIChub3JtYWxpemF0aW9uVHlwZSQxID8gKFwiLFwiICsgbm9ybWFsaXphdGlvblR5cGUkMSkgOiAnJykpXG4gICAgfVxuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuICAvLyAwOiBubyBub3JtYWxpemF0aW9uIG5lZWRlZFxuICAvLyAxOiBzaW1wbGUgbm9ybWFsaXphdGlvbiBuZWVkZWQgKHBvc3NpYmxlIDEtbGV2ZWwgZGVlcCBuZXN0ZWQgYXJyYXkpXG4gIC8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbiAgZnVuY3Rpb24gZ2V0Tm9ybWFsaXphdGlvblR5cGUgKFxuICAgIGNoaWxkcmVuLFxuICAgIG1heWJlQ29tcG9uZW50XG4gICkge1xuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGVsLnR5cGUgIT09IDEpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkc05vcm1hbGl6YXRpb24oZWwpIHx8XG4gICAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgICAgcmVzID0gMjtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChtYXliZUNvbXBvbmVudChlbCkgfHxcbiAgICAgICAgICAoZWwuaWZDb25kaXRpb25zICYmIGVsLmlmQ29uZGl0aW9ucy5zb21lKGZ1bmN0aW9uIChjKSB7IHJldHVybiBtYXliZUNvbXBvbmVudChjLmJsb2NrKTsgfSkpKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIG5lZWRzTm9ybWFsaXphdGlvbiAoZWwpIHtcbiAgICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG4gIH1cblxuICBmdW5jdGlvbiBnZW5Ob2RlIChub2RlLCBzdGF0ZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KG5vZGUsIHN0YXRlKVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgICByZXR1cm4gZ2VuQ29tbWVudChub2RlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgICByZXR1cm4gKFwiX3YoXCIgKyAodGV4dC50eXBlID09PSAyXG4gICAgICA/IHRleHQuZXhwcmVzc2lvbiAvLyBubyBuZWVkIGZvciAoKSBiZWNhdXNlIGFscmVhZHkgd3JhcHBlZCBpbiBfcygpXG4gICAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbkNvbW1lbnQgKGNvbW1lbnQpIHtcbiAgICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlblNsb3QgKGVsLCBzdGF0ZSkge1xuICAgIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gICAgdmFyIGNoaWxkcmVuID0gZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKTtcbiAgICB2YXIgcmVzID0gXCJfdChcIiArIHNsb3ROYW1lICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpO1xuICAgIHZhciBhdHRycyA9IGVsLmF0dHJzIHx8IGVsLmR5bmFtaWNBdHRyc1xuICAgICAgPyBnZW5Qcm9wcygoZWwuYXR0cnMgfHwgW10pLmNvbmNhdChlbC5keW5hbWljQXR0cnMgfHwgW10pLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgICAvLyBzbG90IHByb3BzIGFyZSBjYW1lbGl6ZWRcbiAgICAgICAgICBuYW1lOiBjYW1lbGl6ZShhdHRyLm5hbWUpLFxuICAgICAgICAgIHZhbHVlOiBhdHRyLnZhbHVlLFxuICAgICAgICAgIGR5bmFtaWM6IGF0dHIuZHluYW1pY1xuICAgICAgICB9KTsgfSkpXG4gICAgICA6IG51bGw7XG4gICAgdmFyIGJpbmQkJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kJ107XG4gICAgaWYgKChhdHRycyB8fCBiaW5kJCQxKSAmJiAhY2hpbGRyZW4pIHtcbiAgICAgIHJlcyArPSBcIixudWxsXCI7XG4gICAgfVxuICAgIGlmIChhdHRycykge1xuICAgICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gICAgfVxuICAgIGlmIChiaW5kJCQxKSB7XG4gICAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcyArICcpJ1xuICB9XG5cbiAgLy8gY29tcG9uZW50TmFtZSBpcyBlbC5jb21wb25lbnQsIHRha2UgaXQgYXMgYXJndW1lbnQgdG8gc2h1biBmbG93J3MgcGVzc2ltaXN0aWMgcmVmaW5lbWVudFxuICBmdW5jdGlvbiBnZW5Db21wb25lbnQgKFxuICAgIGNvbXBvbmVudE5hbWUsXG4gICAgZWwsXG4gICAgc3RhdGVcbiAgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gZWwuaW5saW5lVGVtcGxhdGUgPyBudWxsIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlLCB0cnVlKTtcbiAgICByZXR1cm4gKFwiX2MoXCIgKyBjb21wb25lbnROYW1lICsgXCIsXCIgKyAoZ2VuRGF0YSQyKGVsLCBzdGF0ZSkpICsgKGNoaWxkcmVuID8gKFwiLFwiICsgY2hpbGRyZW4pIDogJycpICsgXCIpXCIpXG4gIH1cblxuICBmdW5jdGlvbiBnZW5Qcm9wcyAocHJvcHMpIHtcbiAgICB2YXIgc3RhdGljUHJvcHMgPSBcIlwiO1xuICAgIHZhciBkeW5hbWljUHJvcHMgPSBcIlwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1TcGVjaWFsTmV3bGluZXMocHJvcC52YWx1ZSk7XG4gICAgICBpZiAocHJvcC5keW5hbWljKSB7XG4gICAgICAgIGR5bmFtaWNQcm9wcyArPSAocHJvcC5uYW1lKSArIFwiLFwiICsgdmFsdWUgKyBcIixcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRpY1Byb3BzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyB2YWx1ZSArIFwiLFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWNQcm9wcyA9IFwie1wiICsgKHN0YXRpY1Byb3BzLnNsaWNlKDAsIC0xKSkgKyBcIn1cIjtcbiAgICBpZiAoZHluYW1pY1Byb3BzKSB7XG4gICAgICByZXR1cm4gKFwiX2QoXCIgKyBzdGF0aWNQcm9wcyArIFwiLFtcIiArIChkeW5hbWljUHJvcHMuc2xpY2UoMCwgLTEpKSArIFwiXSlcIilcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRpY1Byb3BzXG4gICAgfVxuICB9XG5cbiAgLy8gIzM4OTUsICM0MjY4XG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyAodGV4dCkge1xuICAgIHJldHVybiB0ZXh0XG4gICAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCAnXFxcXHUyMDI4JylcbiAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csICdcXFxcdTIwMjknKVxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIC8vIHRoZXNlIGtleXdvcmRzIHNob3VsZCBub3QgYXBwZWFyIGluc2lkZSBleHByZXNzaW9ucywgYnV0IG9wZXJhdG9ycyBsaWtlXG4gIC8vIHR5cGVvZiwgaW5zdGFuY2VvZiBhbmQgaW4gYXJlIGFsbG93ZWRcbiAgdmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICAgJ2RvLGlmLGZvcixsZXQsbmV3LHRyeSx2YXIsY2FzZSxlbHNlLHdpdGgsYXdhaXQsYnJlYWssY2F0Y2gsY2xhc3MsY29uc3QsJyArXG4gICAgJ3N1cGVyLHRocm93LHdoaWxlLHlpZWxkLGRlbGV0ZSxleHBvcnQsaW1wb3J0LHJldHVybixzd2l0Y2gsZGVmYXVsdCwnICtcbiAgICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbiAgKS5zcGxpdCgnLCcpLmpvaW4oJ1xcXFxifFxcXFxiJykgKyAnXFxcXGInKTtcblxuICAvLyB0aGVzZSB1bmFyeSBvcGVyYXRvcnMgc2hvdWxkIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5L21ldGhvZCBuYW1lc1xuICB2YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgICAnZGVsZXRlLHR5cGVvZix2b2lkJ1xuICApLnNwbGl0KCcsJykuam9pbignXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKXxcXFxcYicpICsgJ1xcXFxzKlxcXFwoW15cXFxcKV0qXFxcXCknKTtcblxuICAvLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG4gIHZhciBzdHJpcFN0cmluZ1JFID0gLycoPzpbXidcXFxcXXxcXFxcLikqJ3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCJ8YCg/OlteYFxcXFxdfFxcXFwuKSpcXCRcXHt8XFx9KD86W15gXFxcXF18XFxcXC4pKmB8YCg/OlteYFxcXFxdfFxcXFwuKSpgL2c7XG5cbiAgLy8gZGV0ZWN0IHByb2JsZW1hdGljIGV4cHJlc3Npb25zIGluIGEgdGVtcGxhdGVcbiAgZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QsIHdhcm4pIHtcbiAgICBpZiAoYXN0KSB7XG4gICAgICBjaGVja05vZGUoYXN0LCB3YXJuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja05vZGUgKG5vZGUsIHdhcm4pIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmF0dHJzTWFwW25hbWVdO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gbm9kZS5yYXdBdHRyc01hcFtuYW1lXTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICAgIGNoZWNrRm9yKG5vZGUsIChcInYtZm9yPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICBjaGVja0V2ZW50KHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCB3YXJuLCByYW5nZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGVja0V4cHJlc3Npb24odmFsdWUsIChuYW1lICsgXCI9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksIHdhcm4sIHJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCB3YXJuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAyKSB7XG4gICAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIHdhcm4sIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrRXZlbnQgKGV4cCwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICB2YXIgc3RpcHBlZCA9IGV4cC5yZXBsYWNlKHN0cmlwU3RyaW5nUkUsICcnKTtcbiAgICB2YXIga2V5d29yZE1hdGNoID0gc3RpcHBlZC5tYXRjaCh1bmFyeU9wZXJhdG9yc1JFKTtcbiAgICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICAgIFwiXFxcIlwiICsgKGtleXdvcmRNYXRjaFswXSkgKyBcIlxcXCIgaW4gZXhwcmVzc2lvbiBcIiArICh0ZXh0LnRyaW0oKSksXG4gICAgICAgIHJhbmdlXG4gICAgICApO1xuICAgIH1cbiAgICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCB3YXJuLCByYW5nZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgd2FybiwgcmFuZ2UpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5mb3IgfHwgJycsIHRleHQsIHdhcm4sIHJhbmdlKTtcbiAgICBjaGVja0lkZW50aWZpZXIobm9kZS5hbGlhcywgJ3YtZm9yIGFsaWFzJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICAgIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMiwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgd2FybiwgcmFuZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tJZGVudGlmaWVyIChcbiAgICBpZGVudCxcbiAgICB0eXBlLFxuICAgIHRleHQsXG4gICAgd2FybixcbiAgICByYW5nZVxuICApIHtcbiAgICBpZiAodHlwZW9mIGlkZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHdhcm4oKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpLCByYW5nZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIHdhcm4sIHJhbmdlKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB2YXIga2V5d29yZE1hdGNoID0gZXhwLnJlcGxhY2Uoc3RyaXBTdHJpbmdSRSwgJycpLm1hdGNoKHByb2hpYml0ZWRLZXl3b3JkUkUpO1xuICAgICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiXFxuICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpLFxuICAgICAgICAgIHJhbmdlXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgICAgXCIgICAgXCIgKyBleHAgKyBcIlxcblxcblwiICtcbiAgICAgICAgICBcIiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKSArIFwiXFxuXCIsXG4gICAgICAgICAgcmFuZ2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICB2YXIgcmFuZ2UgPSAyO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlQ29kZUZyYW1lIChcbiAgICBzb3VyY2UsXG4gICAgc3RhcnQsXG4gICAgZW5kXG4gICkge1xuICAgIGlmICggc3RhcnQgPT09IHZvaWQgMCApIHN0YXJ0ID0gMDtcbiAgICBpZiAoIGVuZCA9PT0gdm9pZCAwICkgZW5kID0gc291cmNlLmxlbmd0aDtcblxuICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvdW50ICs9IGxpbmVzW2ldLmxlbmd0aCArIDE7XG4gICAgICBpZiAoY291bnQgPj0gc3RhcnQpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IGkgLSByYW5nZTsgaiA8PSBpICsgcmFuZ2UgfHwgZW5kID4gY291bnQ7IGorKykge1xuICAgICAgICAgIGlmIChqIDwgMCB8fCBqID49IGxpbmVzLmxlbmd0aCkgeyBjb250aW51ZSB9XG4gICAgICAgICAgcmVzLnB1c2goKFwiXCIgKyAoaiArIDEpICsgKHJlcGVhdCQxKFwiIFwiLCAzIC0gU3RyaW5nKGogKyAxKS5sZW5ndGgpKSArIFwifCAgXCIgKyAobGluZXNbal0pKSk7XG4gICAgICAgICAgdmFyIGxpbmVMZW5ndGggPSBsaW5lc1tqXS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGogPT09IGkpIHtcbiAgICAgICAgICAgIC8vIHB1c2ggdW5kZXJsaW5lXG4gICAgICAgICAgICB2YXIgcGFkID0gc3RhcnQgLSAoY291bnQgLSBsaW5lTGVuZ3RoKSArIDE7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gZW5kID4gY291bnQgPyBsaW5lTGVuZ3RoIC0gcGFkIDogZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICByZXMucHVzaChcIiAgIHwgIFwiICsgcmVwZWF0JDEoXCIgXCIsIHBhZCkgKyByZXBlYXQkMShcIl5cIiwgbGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChqID4gaSkge1xuICAgICAgICAgICAgaWYgKGVuZCA+IGNvdW50KSB7XG4gICAgICAgICAgICAgIHZhciBsZW5ndGgkMSA9IE1hdGgubWluKGVuZCAtIGNvdW50LCBsaW5lTGVuZ3RoKTtcbiAgICAgICAgICAgICAgcmVzLnB1c2goXCIgICB8ICBcIiArIHJlcGVhdCQxKFwiXlwiLCBsZW5ndGgkMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgKz0gbGluZUxlbmd0aCArIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuam9pbignXFxuJylcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGVhdCQxIChzdHIsIG4pIHtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgaWYgKG4gPiAwKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIGlmIChuICYgMSkgeyByZXN1bHQgKz0gc3RyOyB9XG4gICAgICAgIG4gPj4+PSAxO1xuICAgICAgICBpZiAobiA8PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgc3RyICs9IHN0cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyogICovXG5cblxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3JzLnB1c2goeyBlcnI6IGVyciwgY29kZTogY29kZSB9KTtcbiAgICAgIHJldHVybiBub29wXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tcGlsZVRvRnVuY3Rpb25GbiAoY29tcGlsZSkge1xuICAgIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGlsZVRvRnVuY3Rpb25zIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHZtXG4gICAgKSB7XG4gICAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICAgIHZhciB3YXJuJCQxID0gb3B0aW9ucy53YXJuIHx8IHdhcm47XG4gICAgICBkZWxldGUgb3B0aW9ucy53YXJuO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIHtcbiAgICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuIDEnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlLnRvU3RyaW5nKCkubWF0Y2goL3Vuc2FmZS1ldmFsfENTUC8pKSB7XG4gICAgICAgICAgICB3YXJuJCQxKFxuICAgICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAgICdlbnZpcm9ubWVudCB3aXRoIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IHRoYXQgcHJvaGliaXRzIHVuc2FmZS1ldmFsLiAnICtcbiAgICAgICAgICAgICAgJ1RoZSB0ZW1wbGF0ZSBjb21waWxlciBjYW5ub3Qgd29yayBpbiB0aGlzIGVudmlyb25tZW50LiBDb25zaWRlciAnICtcbiAgICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgICAndGVtcGxhdGVzIGludG8gcmVuZGVyIGZ1bmN0aW9ucy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBjYWNoZVxuICAgICAgdmFyIGtleSA9IG9wdGlvbnMuZGVsaW1pdGVyc1xuICAgICAgICA/IFN0cmluZyhvcHRpb25zLmRlbGltaXRlcnMpICsgdGVtcGxhdGVcbiAgICAgICAgOiB0ZW1wbGF0ZTtcbiAgICAgIGlmIChjYWNoZVtrZXldKSB7XG4gICAgICAgIHJldHVybiBjYWNoZVtrZXldXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbXBpbGVcbiAgICAgIHZhciBjb21waWxlZCA9IGNvbXBpbGUodGVtcGxhdGUsIG9wdGlvbnMpO1xuXG4gICAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgICAge1xuICAgICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5vdXRwdXRTb3VyY2VSYW5nZSkge1xuICAgICAgICAgICAgY29tcGlsZWQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIChlLm1zZykgKyBcIlxcblxcblwiICtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZUNvZGVGcmFtZSh0ZW1wbGF0ZSwgZS5zdGFydCwgZS5lbmQpLFxuICAgICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgICAgXCJFcnJvciBjb21waWxpbmcgdGVtcGxhdGU6XFxuXFxuXCIgKyB0ZW1wbGF0ZSArIFwiXFxuXFxuXCIgK1xuICAgICAgICAgICAgICBjb21waWxlZC5lcnJvcnMubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoXCItIFwiICsgZSk7IH0pLmpvaW4oJ1xcbicpICsgJ1xcbicsXG4gICAgICAgICAgICAgIHZtXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRpcChlLm1zZywgdm0pOyB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGlsZWQudGlwcy5mb3JFYWNoKGZ1bmN0aW9uIChtc2cpIHsgcmV0dXJuIHRpcChtc2csIHZtKTsgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHR1cm4gY29kZSBpbnRvIGZ1bmN0aW9uc1xuICAgICAgdmFyIHJlcyA9IHt9O1xuICAgICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgICByZXMucmVuZGVyID0gY3JlYXRlRnVuY3Rpb24oY29tcGlsZWQucmVuZGVyLCBmbkdlbkVycm9ycyk7XG4gICAgICByZXMuc3RhdGljUmVuZGVyRm5zID0gY29tcGlsZWQuc3RhdGljUmVuZGVyRm5zLm1hcChmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgICB9KTtcblxuICAgICAgLy8gY2hlY2sgZnVuY3Rpb24gZ2VuZXJhdGlvbiBlcnJvcnMuXG4gICAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgICAgLy8gbW9zdGx5IGZvciBjb2RlZ2VuIGRldmVsb3BtZW50IHVzZVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGlmICgoIWNvbXBpbGVkLmVycm9ycyB8fCAhY29tcGlsZWQuZXJyb3JzLmxlbmd0aCkgJiYgZm5HZW5FcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2FybiQkMShcbiAgICAgICAgICAgIFwiRmFpbGVkIHRvIGdlbmVyYXRlIHJlbmRlciBmdW5jdGlvbjpcXG5cXG5cIiArXG4gICAgICAgICAgICBmbkdlbkVycm9ycy5tYXAoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgICAgdmFyIGNvZGUgPSByZWYuY29kZTtcblxuICAgICAgICAgICAgICByZXR1cm4gKChlcnIudG9TdHJpbmcoKSkgKyBcIiBpblxcblxcblwiICsgY29kZSArIFwiXFxuXCIpO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoY2FjaGVba2V5XSA9IHJlcylcbiAgICB9XG4gIH1cblxuICAvKiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXBpbGVyIChiYXNlT3B0aW9ucykge1xuICAgICAgZnVuY3Rpb24gY29tcGlsZSAoXG4gICAgICAgIHRlbXBsYXRlLFxuICAgICAgICBvcHRpb25zXG4gICAgICApIHtcbiAgICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgIHZhciB0aXBzID0gW107XG5cbiAgICAgICAgdmFyIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgKHRpcCA/IHRpcHMgOiBlcnJvcnMpLnB1c2gobXNnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgIGlmIChvcHRpb25zLm91dHB1dFNvdXJjZVJhbmdlKSB7XG4gICAgICAgICAgICAvLyAkZmxvdy1kaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIHZhciBsZWFkaW5nU3BhY2VMZW5ndGggPSB0ZW1wbGF0ZS5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdhcm4gPSBmdW5jdGlvbiAobXNnLCByYW5nZSwgdGlwKSB7XG4gICAgICAgICAgICAgIHZhciBkYXRhID0geyBtc2c6IG1zZyB9O1xuICAgICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGF0YS5zdGFydCA9IHJhbmdlLnN0YXJ0ICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGEuZW5kID0gcmFuZ2UuZW5kICsgbGVhZGluZ1NwYWNlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAodGlwID8gdGlwcyA6IGVycm9ycykucHVzaChkYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBtb2R1bGVzXG4gICAgICAgICAgaWYgKG9wdGlvbnMubW9kdWxlcykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgICAoYmFzZU9wdGlvbnMubW9kdWxlcyB8fCBbXSkuY29uY2F0KG9wdGlvbnMubW9kdWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zLmRpcmVjdGl2ZXMgPSBleHRlbmQoXG4gICAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyB8fCBudWxsKSxcbiAgICAgICAgICAgICAgb3B0aW9ucy5kaXJlY3RpdmVzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb3B5IG90aGVyIG9wdGlvbnNcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ21vZHVsZXMnICYmIGtleSAhPT0gJ2RpcmVjdGl2ZXMnKSB7XG4gICAgICAgICAgICAgIGZpbmFsT3B0aW9uc1trZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gd2FybjtcblxuICAgICAgICB2YXIgY29tcGlsZWQgPSBiYXNlQ29tcGlsZSh0ZW1wbGF0ZS50cmltKCksIGZpbmFsT3B0aW9ucyk7XG4gICAgICAgIHtcbiAgICAgICAgICBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0LCB3YXJuKTtcbiAgICAgICAgfVxuICAgICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgIGNvbXBpbGVkLnRpcHMgPSB0aXBzO1xuICAgICAgICByZXR1cm4gY29tcGlsZWRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZTogY29tcGlsZSxcbiAgICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyogICovXG5cbiAgLy8gYGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcmAgYWxsb3dzIGNyZWF0aW5nIGNvbXBpbGVycyB0aGF0IHVzZSBhbHRlcm5hdGl2ZVxuICAvLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4gIC8vIEhlcmUgd2UganVzdCBleHBvcnQgYSBkZWZhdWx0IGNvbXBpbGVyIHVzaW5nIHRoZSBkZWZhdWx0IHBhcnRzLlxuICB2YXIgY3JlYXRlQ29tcGlsZXIgPSBjcmVhdGVDb21waWxlckNyZWF0b3IoZnVuY3Rpb24gYmFzZUNvbXBpbGUgKFxuICAgIHRlbXBsYXRlLFxuICAgIG9wdGlvbnNcbiAgKSB7XG4gICAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub3B0aW1pemUgIT09IGZhbHNlKSB7XG4gICAgICBvcHRpbWl6ZShhc3QsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB2YXIgY29kZSA9IGdlbmVyYXRlKGFzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzdDogYXN0LFxuICAgICAgcmVuZGVyOiBjb2RlLnJlbmRlcixcbiAgICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgICB9XG4gIH0pO1xuXG4gIC8qICAqL1xuXG4gIHZhciByZWYkMSA9IGNyZWF0ZUNvbXBpbGVyKGJhc2VPcHRpb25zKTtcbiAgdmFyIGNvbXBpbGUgPSByZWYkMS5jb21waWxlO1xuICB2YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4gIC8qICAqL1xuXG4gIC8vIGNoZWNrIHdoZXRoZXIgY3VycmVudCBicm93c2VyIGVuY29kZXMgYSBjaGFyIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzXG4gIHZhciBkaXY7XG4gIGZ1bmN0aW9uIGdldFNob3VsZERlY29kZSAoaHJlZikge1xuICAgIGRpdiA9IGRpdiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gICAgcmV0dXJuIGRpdi5pbm5lckhUTUwuaW5kZXhPZignJiMxMDsnKSA+IDBcbiAgfVxuXG4gIC8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG4gIHZhciBzaG91bGREZWNvZGVOZXdsaW5lcyA9IGluQnJvd3NlciA/IGdldFNob3VsZERlY29kZShmYWxzZSkgOiBmYWxzZTtcbiAgLy8gIzY4Mjg6IGNocm9tZSBlbmNvZGVzIGNvbnRlbnQgaW4gYVtocmVmXVxuICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbiAgLyogICovXG5cbiAgdmFyIGlkVG9UZW1wbGF0ZSA9IGNhY2hlZChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gICAgcmV0dXJuIGVsICYmIGVsLmlubmVySFRNTFxuICB9KTtcblxuICB2YXIgbW91bnQgPSBWdWUucHJvdG90eXBlLiRtb3VudDtcbiAgVnVlLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgZWwsXG4gICAgaHlkcmF0aW5nXG4gICkge1xuICAgIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGVsID09PSBkb2N1bWVudC5ib2R5IHx8IGVsID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gdGhpcy4kb3B0aW9ucztcbiAgICAvLyByZXNvbHZlIHRlbXBsYXRlL2VsIGFuZCBjb252ZXJ0IHRvIHJlbmRlciBmdW5jdGlvblxuICAgIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG4gICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodGVtcGxhdGUuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gaWRUb1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgIChcIlRlbXBsYXRlIGVsZW1lbnQgbm90IGZvdW5kIG9yIGlzIGVtcHR5OiBcIiArIChvcHRpb25zLnRlbXBsYXRlKSksXG4gICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZS5ub2RlVHlwZSkge1xuICAgICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuaW5uZXJIVE1MO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZWwpIHtcbiAgICAgICAgdGVtcGxhdGUgPSBnZXRPdXRlckhUTUwoZWwpO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmID0gY29tcGlsZVRvRnVuY3Rpb25zKHRlbXBsYXRlLCB7XG4gICAgICAgICAgb3V0cHV0U291cmNlUmFuZ2U6IFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nLFxuICAgICAgICAgIHNob3VsZERlY29kZU5ld2xpbmVzOiBzaG91bGREZWNvZGVOZXdsaW5lcyxcbiAgICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgICBkZWxpbWl0ZXJzOiBvcHRpb25zLmRlbGltaXRlcnMsXG4gICAgICAgICAgY29tbWVudHM6IG9wdGlvbnMuY29tbWVudHNcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgICAgICB2YXIgc3RhdGljUmVuZGVyRm5zID0gcmVmLnN0YXRpY1JlbmRlckZucztcbiAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICAgIG1lYXN1cmUoKFwidnVlIFwiICsgKHRoaXMuX25hbWUpICsgXCIgY29tcGlsZVwiKSwgJ2NvbXBpbGUnLCAnY29tcGlsZSBlbmQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW91bnQuY2FsbCh0aGlzLCBlbCwgaHlkcmF0aW5nKVxuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgb3V0ZXJIVE1MIG9mIGVsZW1lbnRzLCB0YWtpbmcgY2FyZVxuICAgKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldE91dGVySFRNTCAoZWwpIHtcbiAgICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgICByZXR1cm4gZWwub3V0ZXJIVE1MXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbC5jbG9uZU5vZGUodHJ1ZSkpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUxcbiAgICB9XG4gIH1cblxuICBWdWUuY29tcGlsZSA9IGNvbXBpbGVUb0Z1bmN0aW9ucztcblxuICByZXR1cm4gVnVlO1xuXG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(7);\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(1)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLENBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n')},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(1), __webpack_require__(8)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports){eval('\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function "fixes" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== "undefined" && window.location;\n\n  if (!location) {\n    throw new Error("fixUrls requires window.location");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== "string") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + "//" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, "/");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word "url" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn\'t a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn\'t a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn\'t a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^"(.*)"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^\'(.*)\'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf("//") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf("/") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with \'/\'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, ""); // Strip leading \'./\'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn "url(" + JSON.stringify(newUrl) + ")";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzP2Y2ZDMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC98XFxzKiQpL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL2FydGljbGVGaWx0ZXIudnVlPzhmZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUwsQ0FBZ0Isc1BBQUcsRUFBQyIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL2FydGljbGVGaWx0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9hcnRpY2xlRmlsdGVyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\n__webpack_require__(17);\n\nvar _dataSave = __webpack_require__(12);\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nfunction filter(a, b) {\n    var exist = false;\n    for (var i = 0; i < a.length; i++) {\n        var index = b.indexOf(a[i]);\n        if (index >= 0) {\n            exist = true;\n        }\n    }\n    return exist;\n}\n\nexports.default = {\n    name: \"app\",\n    data: function data() {\n        return {\n            article: _dataSave.articleFilter,\n            label: [{\n                labelName: '标签一',\n                labelId: 1,\n                choose: false\n            }, {\n                labelName: '标签二',\n                labelId: 2,\n                choose: false\n            }]\n        };\n    },\n\n    methods: {\n        choose: function choose(label) {\n            var chooseLabel = [];\n\n            label.choose = !label.choose;\n            for (var i = 0; i < this.label.length; i++) {\n                if (this.label[i].choose) {\n                    chooseLabel.push(this.label[i].labelId);\n                }\n            }\n            for (var k = 0; k < this.article.length; k++) {\n                var ifExist = filter(this.article[k].articleLabel, chooseLabel);\n                if (ifExist) {\n                    this.article[k].show = true;\n                } else {\n                    this.article[k].show = false;\n                }\n            }\n        },\n        getLabelName: function getLabelName(labelId) {\n            var _this = this;\n\n            var labelName = [];\n            labelId.forEach(function (label) {\n                _this.label.forEach(function (labelCName) {\n                    if (label == labelCName.labelId) {\n                        labelName.push(labelCName.labelName);\n                    }\n                });\n            });\n            var labelNameList = '';\n            labelName.forEach(function (ar) {\n                labelNameList = labelNameList + \" \" + ar;\n            });\n            return labelNameList;\n        }\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvY29tcG9uZW50cy9hcnRpY2xlRmlsdGVyLnZ1ZT9iNDk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQWlCQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrQkFHQTtBQUNBLGVBREE7QUFFQSxRQUZBLGtCQUVBO0FBQ0E7QUFDQSw0Q0FEQTtBQUVBLG9CQUNBO0FBQ0EsZ0NBREE7QUFFQSwwQkFGQTtBQUdBO0FBSEEsYUFEQSxFQUtBO0FBQ0EsZ0NBREE7QUFFQSwwQkFGQTtBQUdBO0FBSEEsYUFMQTtBQUZBO0FBY0EsS0FqQkE7O0FBa0JBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUZBLE1BRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQWxCQTtBQW1CQSxvQkFuQkEsd0JBbUJBLE9BbkJBLEVBbUJBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBSkE7QUFLQSxhQU5BO0FBT0E7QUFDQTtBQUNBO0FBQ0EsYUFGQTtBQUdBO0FBQ0E7QUFqQ0E7QUFsQkEsQyIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwiYXJ0aWNsZUZpbHRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibGFiZWxDb250YWluZXJcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsYWJlbEJsb2NrXCIgdi1mb3I9XCJsYWJlbCBpbiBsYWJlbFwiIHYtb246Y2xpY2s9XCJjaG9vc2UobGFiZWwpXCIgdi1iaW5kOmNsYXNzPVwieydhY3RpdmUnOmxhYmVsLmNob29zZX1cIj5cbiAgICAgICAgICAgICAgICB7eyBsYWJlbC5sYWJlbE5hbWUgfX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFydGljbGVQYXJ0XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYXJ0aWNsZVwiIHYtZm9yPVwiYXJ0aWNsZSBpbiBhcnRpY2xlXCIgdi1pZj1cImFydGljbGUuc2hvd1wiPlxuICAgICAgICAgICAgICAgIHt7IGFydGljbGUuYXJ0aWNsZU5hbWUgfX0gPHNwYW4gY2xhc3M9XCJhcnRpY2xlTGFiZWxcIj57eyBnZXRMYWJlbE5hbWUoYXJ0aWNsZS5hcnRpY2xlTGFiZWwpIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJhcnRpY2xlQ29udGVudFwiIHYtaWY9XCJhcnRpY2xlLnNjcm9sbFwiPnt7IGFydGljbGUuYXJ0aWNsZUNvbnRlbnQgfX08L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0ICcuLi8uLi9jc3MvYXJ0aWNsZUZpbHRlci5jc3MnXG4gICAgaW1wb3J0IHthcnRpY2xlRmlsdGVyIGFzIGFmfSBmcm9tICcuLi9kYXRhU2F2ZS9kYXRhU2F2ZS5qcydcblxuICAgIGZ1bmN0aW9uIGZpbHRlcihhLGIpIHtcbiAgICAgICAgdmFyIGV4aXN0ID0gZmFsc2U7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7aSA8IGEubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBiLmluZGV4T2YoYVtpXSk7XG4gICAgICAgICAgICBpZihpbmRleCA+PSAwKXtcbiAgICAgICAgICAgICAgICBleGlzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4aXN0O1xuICAgIH1cblxuXG4gICAgZXhwb3J0IGRlZmF1bHQge1xuICAgICAgICBuYW1lOiBcImFwcFwiLFxuICAgICAgICBkYXRhKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFydGljbGU6YWYsXG4gICAgICAgICAgICAgICAgbGFiZWw6W1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbE5hbWU6J+agh+etvuS4gCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbElkOjEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaG9vc2U6ZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0se1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxOYW1lOifmoIfnrb7kuownLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxJZDoyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hvb3NlOmZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZHM6e1xuICAgICAgICAgICAgY2hvb3NlOmZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNob29zZUxhYmVsID0gW107XG5cbiAgICAgICAgICAgICAgICBsYWJlbC5jaG9vc2UgPSAhbGFiZWwuY2hvb3NlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwO2kgPCB0aGlzLmxhYmVsLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmxhYmVsW2ldLmNob29zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hvb3NlTGFiZWwucHVzaCh0aGlzLmxhYmVsW2ldLmxhYmVsSWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcih2YXIgayA9IDA7ayA8IHRoaXMuYXJ0aWNsZS5sZW5ndGg7aysrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlmRXhpc3QgPSBmaWx0ZXIodGhpcy5hcnRpY2xlW2tdLmFydGljbGVMYWJlbCxjaG9vc2VMYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGlmRXhpc3Qpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcnRpY2xlW2tdLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXJ0aWNsZVtrXS5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0TGFiZWxOYW1lKGxhYmVsSWQpe1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsTmFtZSA9IFtdO1xuICAgICAgICAgICAgICAgIGxhYmVsSWQuZm9yRWFjaChsYWJlbD0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVsLmZvckVhY2gobGFiZWxDTmFtZT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobGFiZWw9PWxhYmVsQ05hbWUubGFiZWxJZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxOYW1lLnB1c2gobGFiZWxDTmFtZS5sYWJlbE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgdmFyIGxhYmVsTmFtZUxpc3QgPSAnJztcbiAgICAgICAgICAgICAgICBsYWJlbE5hbWUuZm9yRWFjaChhcj0+e1xuICAgICAgICAgICAgICAgICAgICBsYWJlbE5hbWVMaXN0ID0gbGFiZWxOYW1lTGlzdCArIFwiIFwiICsgYXI7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxOYW1lTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n//笔记本数据集\nvar notebook = exports.notebook = [{\n    name: '这里是笔记名称',\n    content: '这是里笔记内容',\n    time: '0000年0月0号0点00分',\n    sit: 'left',\n    show: false\n}, {\n    name: '万叶集',\n    content: '鸣神の少しとよみてさし昙り雨も降らんか君を留めん 鸣神の少しとよみて降らずとも我は止まらん妹し留めば',\n    time: \"0000年0月0号0点00分\",\n    sit: 'right',\n    show: false\n}];\n\n//购物车数据集\nvar shopCar = exports.shopCar = [{\n    name: '330ml红罐可乐',\n    price: 3.0,\n    stock: 100,\n    id: '000001',\n    inCar: 0,\n    allP: 0,\n    addNum: 1,\n    img: __webpack_require__(0)\n}, {\n    name: '芝士蛋糕',\n    price: 28.0,\n    stock: 50,\n    id: '000002',\n    inCar: 0,\n    allP: 0,\n    addNum: 1,\n    img: __webpack_require__(0)\n}, {\n    name: '大理石面包',\n    price: 10.0,\n    stock: 200,\n    id: '000003',\n    inCar: 0,\n    allP: 0,\n    addNum: 1,\n    img: __webpack_require__(0)\n}, {\n    name: 'macbook Pro',\n    price: 18888.0,\n    stock: 5,\n    id: '000004',\n    inCar: 0,\n    allP: 0,\n    addNum: 1,\n    img: __webpack_require__(0)\n}, {\n    name: '猪肉脯',\n    price: 5.0,\n    stock: 500,\n    id: '000005',\n    inCar: 0,\n    allP: 0,\n    addNum: 1,\n    img: __webpack_require__(0)\n}, {\n    name: '餐巾纸',\n    price: 2.0,\n    stock: 2000,\n    id: '000006',\n    inCar: 0,\n    allP: 0,\n    addNum: 1,\n    img: __webpack_require__(0)\n}];\n\n//选择答案数据集\nvar questionAndAnswer = exports.questionAndAnswer = [{\n    knowledge: ['javaScript'],\n    questionId: 1,\n    questionType: 'single',\n    question: '关于javascript的原始类型（primitive type），错误的是',\n    answer: ['A.有5种primitive type，分别是Undefined、Null、Boolean、Number 和 String', 'B.var sTemp = \"test string\";alert (typeof sTemp);结果为string', 'C.var oTemp;alert(oTemp == undefined)为true', 'D.alert(null == undefined);结果为false'],\n    right: [3],\n    userChoose: [4]\n}, {\n    knowledge: ['javaScript'],\n    questionId: 1,\n    questionType: 'mul',\n    question: '关于javascript的原始类型（primitive type），错误的是',\n    answer: ['A.有5种primitive type，分别是Undefined、Null、Boolean、Number 和 String', 'B.var sTemp = \"test string\";alert (typeof sTemp);结果为string', 'C.var oTemp;alert(oTemp == undefined)为true', 'D.alert(null == undefined);结果为false'],\n    right: [1, 2, 3],\n    userChoose: [1, 2, 3]\n}, {\n    knowledge: ['javaScript'],\n    questionId: 1,\n    questionType: 'single',\n    question: '关于javascript的原始类型（primitive type），错误的是',\n    answer: ['A.有5种primitive type，分别是Undefined、Null、Boolean、Number 和 String', 'B.var sTemp = \"test string\";alert (typeof sTemp);结果为string', 'C.var oTemp;alert(oTemp == undefined)为true', 'D.alert(null == undefined);结果为false'],\n    right: [3],\n    userChoose: [4]\n}, {\n    knowledge: ['javaScript'],\n    questionId: 1,\n    questionType: 'mul',\n    question: '关于javascript的原始类型（primitive type），错误的是',\n    answer: ['A.有5种primitive type，分别是Undefined、Null、Boolean、Number 和 String', 'B.var sTemp = \"test string\";alert (typeof sTemp);结果为string', 'C.var oTemp;alert(oTemp == undefined)为true', 'D.alert(null == undefined);结果为false'],\n    right: [1, 2, 3],\n    userChoose: [1, 2, 3]\n}];\n\n//文章按标签筛选数据集\nvar articleFilter = exports.articleFilter = [{\n    articleName: '建御雷神',\n    articleContent: '建御雷神（タケミカヅチ）是日本神话中的一位神祇，被奉为雷神、刀剑之神、弓术之神、武神和军神。在《古事记》里写作建御雷之男神、建御雷神，在《日本书纪》里写作武瓮槌、武瓮雷男神。别名建布都神、丰布都神，在鹿岛神宫的祭祀中则以鹿岛神的名字出现。',\n    articleLabel: [1],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '建御雷神',\n    articleContent: '建御雷神（《日本书纪》）或称天照大御神（《古事记》）、天照皇大神、皇大御神、天照坐皇大御神、大日孁贵、大日女尊、大日灵，天照是日本神话里三贵子之一、高天原的统治者与太阳的神格化。她被奉为日本天皇的始祖（皇祖神），也是神道教最高神。 [1] ',\n    articleLabel: [2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '月读',\n    articleContent: '月读（ツクヨミ、ツキヨミ），别称月夜见（ツクヨミノミコト）、月余美、月弓尊（ツクユミノミコト）、月读壮士（ツキヨミオトコ）、月神以及月人。他是日本神话和神道的一位神祇，是月的神格化，“三贵子（月读、天照大神、素戋呜尊）”之一，伊邪那岐之子，掌管黑夜的神明。 [1-3] ',\n    articleLabel: [1, 2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '建御雷神',\n    articleContent: '建御雷神（タケミカヅチ）是日本神话中的一位神祇，被奉为雷神、刀剑之神、弓术之神、武神和军神。在《古事记》里写作建御雷之男神、建御雷神，在《日本书纪》里写作武瓮槌、武瓮雷男神。别名建布都神、丰布都神，在鹿岛神宫的祭祀中则以鹿岛神的名字出现。',\n    articleLabel: [1],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '建御雷神',\n    articleContent: '建御雷神（《日本书纪》）或称天照大御神（《古事记》）、天照皇大神、皇大御神、天照坐皇大御神、大日孁贵、大日女尊、大日灵，天照是日本神话里三贵子之一、高天原的统治者与太阳的神格化。她被奉为日本天皇的始祖（皇祖神），也是神道教最高神。 [1] ',\n    articleLabel: [2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '月读',\n    articleContent: '月读（ツクヨミ、ツキヨミ），别称月夜见（ツクヨミノミコト）、月余美、月弓尊（ツクユミノミコト）、月读壮士（ツキヨミオトコ）、月神以及月人。他是日本神话和神道的一位神祇，是月的神格化，“三贵子（月读、天照大神、素戋呜尊）”之一，伊邪那岐之子，掌管黑夜的神明。 [1-3] ',\n    articleLabel: [1, 2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '月读',\n    articleContent: '月读（ツクヨミ、ツキヨミ），别称月夜见（ツクヨミノミコト）、月余美、月弓尊（ツクユミノミコト）、月读壮士（ツキヨミオトコ）、月神以及月人。他是日本神话和神道的一位神祇，是月的神格化，“三贵子（月读、天照大神、素戋呜尊）”之一，伊邪那岐之子，掌管黑夜的神明。 [1-3] ',\n    articleLabel: [1, 2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '建御雷神',\n    articleContent: '建御雷神（《日本书纪》）或称天照大御神（《古事记》）、天照皇大神、皇大御神、天照坐皇大御神、大日孁贵、大日女尊、大日灵，天照是日本神话里三贵子之一、高天原的统治者与太阳的神格化。她被奉为日本天皇的始祖（皇祖神），也是神道教最高神。 [1] ',\n    articleLabel: [2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '月读',\n    articleContent: '月读（ツクヨミ、ツキヨミ），别称月夜见（ツクヨミノミコト）、月余美、月弓尊（ツクユミノミコト）、月读壮士（ツキヨミオトコ）、月神以及月人。他是日本神话和神道的一位神祇，是月的神格化，“三贵子（月读、天照大神、素戋呜尊）”之一，伊邪那岐之子，掌管黑夜的神明。 [1-3] ',\n    articleLabel: [1, 2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}, {\n    articleName: '月读',\n    articleContent: '月读（ツクヨミ、ツキヨミ），别称月夜见（ツクヨミノミコト）、月余美、月弓尊（ツクユミノミコト）、月读壮士（ツキヨミオトコ）、月神以及月人。他是日本神话和神道的一位神祇，是月的神格化，“三贵子（月读、天照大神、素戋呜尊）”之一，伊邪那岐之子，掌管黑夜的神明。 [1-3] ',\n    articleLabel: [1, 2],\n    show: true, //是否显示\n    scroll: true //是否展开\n}];\n\n//好友列表数据\nvar firends = exports.firends = [{\n    name: 'jiahui shao',\n    phone: 18758580501,\n    sex: true\n}, {\n    name: 'fuyu',\n    phone: 13276800787,\n    sex: false\n}];\n\n//文章数据\nvar article = exports.article = [{\n    name: '我是猫',\n    scroll: true,\n    author: '夏目漱石',\n    remark: '长篇小说',\n    content: '小说围绕金田小姐的婚事引起的风波，有力地揭露了资产阶级，批判了社会拜金主义风气。金田老爷是靠高利贷起家的、“穷凶极恶，又贪又狠”的大资本家，拥有大量的财产。他的“堂皇富丽的公馆”，与苦沙弥的“暗黑的洞窟”恰成鲜明对比。他发财致富的“秘诀”是“要精通三缺”，即缺义理、缺人情、缺廉耻。“把鼻子、眼睛都盯在钞票上”，“只要能赚钱，什么事也干得出来”，把金钱看得比生命还重要。金田依仗自己的财势，成为社会上赫赫有名的人物。他财大气粗，仗势压人。主人公苦沙弥安贫、正直，教书十年与他素不相识，只是慢待了他的老婆，他便兴师动众三番四次进行打击，致使苦沙弥的身心受到严重摧残。买通的落云馆的顽童搞得苦沙弥坐卧不宁，他却得意洋洋地说：“……这个家伙……不久将来，总会投降的呢。”一副奸诈、凶狠可憎的面目暴露无遗了。所以，连“猫”也觉得金田是“最坏的人类”。'\n}, {\n    name: '心',\n    scroll: false,\n    author: '夏目漱石',\n    time: '1914年',\n    remark: '长篇小说',\n    content: '《心》讲述的是“先生”结识并爱上了房东家的小姐，同时也赢得了房东太太的好感，但却因年少时曾受到叔父的欺诈而对他人时存戒心，迟迟不能表白自己的心意。后来，“先生”的好友K住进了房东家里，也爱上了小姐，直率的K向好友“先生\"表白了自己的心事，“先生”在表面上批评K“不求上进”，背地里却偷偷地向房东太太提出要和小姐结婚。知道了这一切真相之后的K在绝望中自杀了，同时K的死也留给“先生”一生的不安和自责，婚后的“先生”一直无法忘却K，他的内心无比的寂寞，终于也走上了自杀的道路。'\n}, {\n    name: '人间失格',\n    scroll: false,\n    author: '太宰治',\n    remark: '中篇小说',\n    content: '全书由作者的序言、后记，以及主角大庭叶藏的三个手札组成，描写主角从青少年到中年，为了逃避现实而不断沉沦，经历自我放逐、酗酒、自杀、用药物麻痹自己，终于一步步走向自我毁灭的悲剧，在自我否定的过程中，抒发自己内心深处的苦闷，以及渴望被爱的情愫…… 透过主角叶藏的人生遭遇，可以说太宰治巧妙地将自己一生的经历与思想表达出来，并藉此提出身为人最真切的痛苦问题。从滞涩的文中更可体会其内心深切的苦楚，在完成本篇作品之后，太宰治终归还是选择了投水的方式，为他自己划下最后的句点。因此，《人间失格》算是太宰治半自传性作品。'\n}, {\n    name: '斜阳',\n    scroll: false,\n    author: '太宰治',\n    remark: '中篇小说',\n    content: '故事通过和子的第一人称叙述和弟弟直治的日记与遗书的形式展开。主要讲的是与丈夫离婚六年的和子在伊豆山中的别墅和母亲同住，母亲又患上了肺结核。应征服役的弟弟下落不明，终于弟弟复员归来，但他生活放荡不羁还沾染上毒品。和子恋上了已婚的不良作家上原，并梦想生下上原的孩子。最后母亲病亡，弟弟直治留下遗书自杀，和子表示即使会被遗弃也要生下并抚养上原的私生子，实现道德革命。'\n}, {\n    name: '我是猫',\n    scroll: false,\n    author: '夏目漱石',\n    remark: '长篇小说',\n    content: '小说围绕金田小姐的婚事引起的风波，有力地揭露了资产阶级，批判了社会拜金主义风气。金田老爷是靠高利贷起家的、“穷凶极恶，又贪又狠”的大资本家，拥有大量的财产。他的“堂皇富丽的公馆”，与苦沙弥的“暗黑的洞窟”恰成鲜明对比。他发财致富的“秘诀”是“要精通三缺”，即缺义理、缺人情、缺廉耻。“把鼻子、眼睛都盯在钞票上”，“只要能赚钱，什么事也干得出来”，把金钱看得比生命还重要。金田依仗自己的财势，成为社会上赫赫有名的人物。他财大气粗，仗势压人。主人公苦沙弥安贫、正直，教书十年与他素不相识，只是慢待了他的老婆，他便兴师动众三番四次进行打击，致使苦沙弥的身心受到严重摧残。买通的落云馆的顽童搞得苦沙弥坐卧不宁，他却得意洋洋地说：“……这个家伙……不久将来，总会投降的呢。”一副奸诈、凶狠可憎的面目暴露无遗了。所以，连“猫”也觉得金田是“最坏的人类”。'\n}, {\n    name: '心',\n    scroll: false,\n    author: '夏目漱石',\n    time: '1914年',\n    remark: '长篇小说',\n    content: '《心》讲述的是“先生”结识并爱上了房东家的小姐，同时也赢得了房东太太的好感，但却因年少时曾受到叔父的欺诈而对他人时存戒心，迟迟不能表白自己的心意。后来，“先生”的好友K住进了房东家里，也爱上了小姐，直率的K向好友“先生\"表白了自己的心事，“先生”在表面上批评K“不求上进”，背地里却偷偷地向房东太太提出要和小姐结婚。知道了这一切真相之后的K在绝望中自杀了，同时K的死也留给“先生”一生的不安和自责，婚后的“先生”一直无法忘却K，他的内心无比的寂寞，终于也走上了自杀的道路。'\n}, {\n    name: '人间失格',\n    scroll: false,\n    author: '太宰治',\n    remark: '中篇小说',\n    content: '全书由作者的序言、后记，以及主角大庭叶藏的三个手札组成，描写主角从青少年到中年，为了逃避现实而不断沉沦，经历自我放逐、酗酒、自杀、用药物麻痹自己，终于一步步走向自我毁灭的悲剧，在自我否定的过程中，抒发自己内心深处的苦闷，以及渴望被爱的情愫…… 透过主角叶藏的人生遭遇，可以说太宰治巧妙地将自己一生的经历与思想表达出来，并藉此提出身为人最真切的痛苦问题。从滞涩的文中更可体会其内心深切的苦楚，在完成本篇作品之后，太宰治终归还是选择了投水的方式，为他自己划下最后的句点。因此，《人间失格》算是太宰治半自传性作品。'\n}, {\n    name: '斜阳',\n    scroll: false,\n    author: '太宰治',\n    remark: '中篇小说',\n    content: '故事通过和子的第一人称叙述和弟弟直治的日记与遗书的形式展开。主要讲的是与丈夫离婚六年的和子在伊豆山中的别墅和母亲同住，母亲又患上了肺结核。应征服役的弟弟下落不明，终于弟弟复员归来，但他生活放荡不羁还沾染上毒品。和子恋上了已婚的不良作家上原，并梦想生下上原的孩子。最后母亲病亡，弟弟直治留下遗书自杀，和子表示即使会被遗弃也要生下并抚养上原的私生子，实现道德革命。'\n}, {\n    name: '我是猫',\n    scroll: false,\n    author: '夏目漱石',\n    remark: '长篇小说',\n    content: '小说围绕金田小姐的婚事引起的风波，有力地揭露了资产阶级，批判了社会拜金主义风气。金田老爷是靠高利贷起家的、“穷凶极恶，又贪又狠”的大资本家，拥有大量的财产。他的“堂皇富丽的公馆”，与苦沙弥的“暗黑的洞窟”恰成鲜明对比。他发财致富的“秘诀”是“要精通三缺”，即缺义理、缺人情、缺廉耻。“把鼻子、眼睛都盯在钞票上”，“只要能赚钱，什么事也干得出来”，把金钱看得比生命还重要。金田依仗自己的财势，成为社会上赫赫有名的人物。他财大气粗，仗势压人。主人公苦沙弥安贫、正直，教书十年与他素不相识，只是慢待了他的老婆，他便兴师动众三番四次进行打击，致使苦沙弥的身心受到严重摧残。买通的落云馆的顽童搞得苦沙弥坐卧不宁，他却得意洋洋地说：“……这个家伙……不久将来，总会投降的呢。”一副奸诈、凶狠可憎的面目暴露无遗了。所以，连“猫”也觉得金田是“最坏的人类”。'\n}, {\n    name: '心',\n    scroll: false,\n    author: '夏目漱石',\n    time: '1914年',\n    remark: '长篇小说',\n    content: '《心》讲述的是“先生”结识并爱上了房东家的小姐，同时也赢得了房东太太的好感，但却因年少时曾受到叔父的欺诈而对他人时存戒心，迟迟不能表白自己的心意。后来，“先生”的好友K住进了房东家里，也爱上了小姐，直率的K向好友“先生\"表白了自己的心事，“先生”在表面上批评K“不求上进”，背地里却偷偷地向房东太太提出要和小姐结婚。知道了这一切真相之后的K在绝望中自杀了，同时K的死也留给“先生”一生的不安和自责，婚后的“先生”一直无法忘却K，他的内心无比的寂寞，终于也走上了自杀的道路。'\n}, {\n    name: '人间失格',\n    scroll: false,\n    author: '太宰治',\n    remark: '中篇小说',\n    content: '全书由作者的序言、后记，以及主角大庭叶藏的三个手札组成，描写主角从青少年到中年，为了逃避现实而不断沉沦，经历自我放逐、酗酒、自杀、用药物麻痹自己，终于一步步走向自我毁灭的悲剧，在自我否定的过程中，抒发自己内心深处的苦闷，以及渴望被爱的情愫…… 透过主角叶藏的人生遭遇，可以说太宰治巧妙地将自己一生的经历与思想表达出来，并藉此提出身为人最真切的痛苦问题。从滞涩的文中更可体会其内心深切的苦楚，在完成本篇作品之后，太宰治终归还是选择了投水的方式，为他自己划下最后的句点。因此，《人间失格》算是太宰治半自传性作品。'\n}, {\n    name: '斜阳',\n    scroll: false,\n    author: '太宰治',\n    remark: '中篇小说',\n    content: '故事通过和子的第一人称叙述和弟弟直治的日记与遗书的形式展开。主要讲的是与丈夫离婚六年的和子在伊豆山中的别墅和母亲同住，母亲又患上了肺结核。应征服役的弟弟下落不明，终于弟弟复员归来，但他生活放荡不羁还沾染上毒品。和子恋上了已婚的不良作家上原，并梦想生下上原的孩子。最后母亲病亡，弟弟直治留下遗书自杀，和子表示即使会被遗弃也要生下并抚养上原的私生子，实现道德革命。'\n}];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9kYXRhU2F2ZS9kYXRhU2F2ZS5qcz85MTI1Il0sIm5hbWVzIjpbIm5vdGVib29rIiwibmFtZSIsImNvbnRlbnQiLCJ0aW1lIiwic2l0Iiwic2hvdyIsInNob3BDYXIiLCJwcmljZSIsInN0b2NrIiwiaWQiLCJpbkNhciIsImFsbFAiLCJhZGROdW0iLCJpbWciLCJyZXF1aXJlIiwicXVlc3Rpb25BbmRBbnN3ZXIiLCJrbm93bGVkZ2UiLCJxdWVzdGlvbklkIiwicXVlc3Rpb25UeXBlIiwicXVlc3Rpb24iLCJhbnN3ZXIiLCJyaWdodCIsInVzZXJDaG9vc2UiLCJhcnRpY2xlRmlsdGVyIiwiYXJ0aWNsZU5hbWUiLCJhcnRpY2xlQ29udGVudCIsImFydGljbGVMYWJlbCIsInNjcm9sbCIsImZpcmVuZHMiLCJwaG9uZSIsInNleCIsImFydGljbGUiLCJhdXRob3IiLCJyZW1hcmsiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDTyxJQUFJQSw4QkFBVyxDQUNsQjtBQUNJQyxVQUFLLFNBRFQ7QUFFSUMsYUFBUSxTQUZaO0FBR0lDLFVBQUssZ0JBSFQ7QUFJSUMsU0FBSSxNQUpSO0FBS0lDLFVBQUs7QUFMVCxDQURrQixFQU9oQjtBQUNFSixVQUFLLEtBRFA7QUFFRUMsYUFBUSxvREFGVjtBQUdFQyxVQUFLLGdCQUhQO0FBSUVDLFNBQUksT0FKTjtBQUtFQyxVQUFLO0FBTFAsQ0FQZ0IsQ0FBZjs7QUFnQlA7QUFDTyxJQUFJQyw0QkFBVSxDQUNqQjtBQUNJTCxVQUFLLFdBRFQ7QUFFSU0sV0FBTSxHQUZWO0FBR0lDLFdBQU0sR0FIVjtBQUlJQyxRQUFHLFFBSlA7QUFLSUMsV0FBTSxDQUxWO0FBTUlDLFVBQUssQ0FOVDtBQU9JQyxZQUFPLENBUFg7QUFRSUMsU0FBSUMsbUJBQU9BLENBQUMsQ0FBUjtBQVJSLENBRGlCLEVBV2pCO0FBQ0liLFVBQUssTUFEVDtBQUVJTSxXQUFNLElBRlY7QUFHSUMsV0FBTSxFQUhWO0FBSUlDLFFBQUcs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QVE7QUFMWixDQXZCaUIsRUE4QmpCO0FBQ0lELFVBQUssS0FEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sTUFIWDtBQUlJQyxZQUFPLE1BSlg7QUFLSS9CLGFBQVE7QUFMWixDQTlCaUIsRUFxQ2pCO0FBQ0lELFVBQUssR0FEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sTUFIWDtBQUlJN0IsVUFBSyxPQUpUO0FBS0k4QixZQUFPLE1BTFg7QUFNSS9CLGFBQVE7QUFOWixDQXJDaUIsRUE2Q2pCO0FBQ0lELFVBQUssTUFEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sS0FIWDtBQUlJQyxZQUFPLE1BSlg7QUFLSS9CLGFBQVE7QUFMWixDQTdDaUIsRUFvRGpCO0FBQ0lELFVBQUssSUFEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sS0FIWDtBQUlJQyxZQUFPLE1BSlg7QUFLSS9CLGFBQVE7QUFMWixDQXBEaUIsRUEyRGpCO0FBQ0lELFVBQUssS0FEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sTUFIWDtBQUlJQyxZQUFPLE1BSlg7QUFLSS9CLGFBQVE7QUFMWixDQTNEaUIsRUFrRWpCO0FBQ0lELFVBQUssR0FEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sTUFIWDtBQUlJN0IsVUFBSyxPQUpUO0FBS0k4QixZQUFPLE1BTFg7QUFNSS9CLGFBQVE7QUFOWixDQWxFaUIsRUEwRWpCO0FBQ0lELFVBQUssTUFEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sS0FIWDtBQUlJQyxZQUFPLE1BSlg7QUFLSS9CLGFBQVE7QUFMWixDQTFFaUIsRUFpRmpCO0FBQ0lELFVBQUssSUFEVDtBQUVJMEIsWUFBTyxLQUZYO0FBR0lLLFlBQU8sS0FIWDtBQUlJQyxZQUFPLE1BSlg7QUFLSS9CLGFBQVE7QUFMWixDQWpGaUIsQ0FBZCIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8v56yU6K6w5pys5pWw5o2u6ZuGXG5leHBvcnQgdmFyIG5vdGVib29rID0gW1xuICAgIHtcbiAgICAgICAgbmFtZTon6L+Z6YeM5piv56yU6K6w5ZCN56ewJyxcbiAgICAgICAgY29udGVudDon6L+Z5piv6YeM56yU6K6w5YaF5a65JyxcbiAgICAgICAgdGltZTonMDAwMOW5tDDmnIgw5Y+3MOeCuTAw5YiGJyxcbiAgICAgICAgc2l0OidsZWZ0JyxcbiAgICAgICAgc2hvdzpmYWxzZSxcbiAgICB9LHtcbiAgICAgICAgbmFtZTon5LiH5Y+26ZuGJyxcbiAgICAgICAgY29udGVudDon6bij56We44Gu5bCR44GX44Go44KI44G/44Gm44GV44GX5piZ44KK6Zuo44KC6ZmN44KJ44KT44GL5ZCb44KS55WZ44KB44KTIOm4o+elnuOBruWwkeOBl+OBqOOCiOOBv+OBpumZjeOCieOBmuOBqOOCguaIkeOBr+atouOBvuOCieOCk+WmueOBl+eVmeOCgeOBsCcsXG4gICAgICAgIHRpbWU6XCIwMDAw5bm0MOaciDDlj7cw54K5MDDliIZcIixcbiAgICAgICAgc2l0OidyaWdodCcsXG4gICAgICAgIHNob3c6ZmFsc2UsXG4gICAgfVxuXVxuXG4vL+i0reeJqei9puaVsOaNrumbhlxuZXhwb3J0IHZhciBzaG9wQ2FyID0gW1xuICAgIHtcbiAgICAgICAgbmFtZTonMzMwbWznuqLnvZDlj6/kuZAnLFxuICAgICAgICBwcmljZTozLjAsXG4gICAgICAgIHN0b2NrOjEwMCxcbiAgICAgICAgaWQ6JzAwMDAwMScsXG4gICAgICAgIGluQ2FyOjAsXG4gICAgICAgIGFsbFA6MCxcbiAgICAgICAgYWRkTnVtOjEsXG4gICAgICAgIGltZzpyZXF1aXJlKCcuLi8uLi9pbWFnZS90aW1nLXB4ejAyLmpwZWcnKVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOifoip3lo6vom4vns5UnLFxuICAgICAgICBwcmljZToyOC4wLFxuICAgICAgICBzdG9jazo1MCxcbiAgICAgICAgaWQ6JzAwMDAwMicsXG4gICAgICAgIGluQ2FyOjAsXG4gICAgICAgIGFsbFA6MCxcbiAgICAgICAgYWRkTnVtOjEsXG4gICAgICAgIGltZzpyZXF1aXJlKCcuLi8uLi9pbWFnZS90aW1nLXB4ejAyLmpwZWcnKVxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiflpKfnkIbnn7PpnaLljIUnLFxuICAgICAgICBwcmljZToxMC4wLFxuICAgICAgICBzdG9jazoyMDAsXG4gICAgICAgIGlkOicwMDAwMDMnLFxuICAgICAgICBpbkNhcjowLFxuICAgICAgICBhbGxQOjAsXG4gICAgICAgIGFkZE51bToxLFxuICAgICAgICBpbWc6cmVxdWlyZSgnLi4vLi4vaW1hZ2UvdGltZy1weHowMi5qcGVnJylcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTonbWFjYm9vayBQcm8nLFxuICAgICAgICBwcmljZToxODg4OC4wLFxuICAgICAgICBzdG9jazo1LFxuICAgICAgICBpZDonMDAwMDA0JyxcbiAgICAgICAgaW5DYXI6MCxcbiAgICAgICAgYWxsUDowLFxuICAgICAgICBhZGROdW06MSxcbiAgICAgICAgaW1nOnJlcXVpcmUoJy4uLy4uL2ltYWdlL3RpbWctcHh6MDIuanBlZycpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+eMquiCieiErycsXG4gICAgICAgIHByaWNlOjUuMCxcbiAgICAgICAgc3RvY2s6NTAwLFxuICAgICAgICBpZDonMDAwMDA1JyxcbiAgICAgICAgaW5DYXI6MCxcbiAgICAgICAgYWxsUDowLFxuICAgICAgICBhZGROdW06MSxcbiAgICAgICAgaW1nOnJlcXVpcmUoJy4uLy4uL2ltYWdlL3RpbWctcHh6MDIuanBlZycpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+mkkOW3vue6uCcsXG4gICAgICAgIHByaWNlOjIuMCxcbiAgICAgICAgc3RvY2s6MjAwMCxcbiAgICAgICAgaWQ6JzAwMDAwNicsXG4gICAgICAgIGluQ2FyOjAsXG4gICAgICAgIGFsbFA6MCxcbiAgICAgICAgYWRkTnVtOjEsXG4gICAgICAgIGltZzpyZXF1aXJlKCcuLi8uLi9pbWFnZS90aW1nLXB4ejAyLmpwZWcnKVxuICAgIH0sXG5dXG5cbi8v6YCJ5oup562U5qGI5pWw5o2u6ZuGXG5leHBvcnQgdmFyIHF1ZXN0aW9uQW5kQW5zd2VyID0gW1xuICAgIHtcbiAgICAgICAga25vd2xlZGdlOlsnamF2YVNjcmlwdCddLFxuICAgICAgICBxdWVzdGlvbklkOjEsXG4gICAgICAgIHF1ZXN0aW9uVHlwZTonc2luZ2xlJyxcbiAgICAgICAgcXVlc3Rpb246J+WFs+S6jmphdmFzY3JpcHTnmoTljp/lp4vnsbvlnovvvIhwcmltaXRpdmUgdHlwZe+8ie+8jOmUmeivr+eahOaYrycsXG4gICAgICAgIGFuc3dlcjpbXG4gICAgICAgICAgICAnQS7mnIk156eNcHJpbWl0aXZlIHR5cGXvvIzliIbliKvmmK9VbmRlZmluZWTjgIFOdWxs44CBQm9vbGVhbuOAgU51bWJlciDlkowgU3RyaW5nJyxcbiAgICAgICAgICAgICdCLnZhciBzVGVtcCA9IFwidGVzdCBzdHJpbmdcIjthbGVydCAodHlwZW9mIHNUZW1wKTvnu5PmnpzkuLpzdHJpbmcnLFxuICAgICAgICAgICAgJ0MudmFyIG9UZW1wO2FsZXJ0KG9UZW1wID09IHVuZGVmaW5lZCnkuLp0cnVlJyxcbiAgICAgICAgICAgICdELmFsZXJ0KG51bGwgPT0gdW5kZWZpbmVkKTvnu5PmnpzkuLpmYWxzZScsXG4gICAgICAgIF0sXG4gICAgICAgIHJpZ2h0OlszXSxcbiAgICAgICAgdXNlckNob29zZTpbNF1cbiAgICB9LFxuICAgIHtcbiAgICAgICAga25vd2xlZGdlOlsnamF2YVNjcmlwdCddLFxuICAgICAgICBxdWVzdGlvbklkOjEsXG4gICAgICAgIHF1ZXN0aW9uVHlwZTonbXVsJyxcbiAgICAgICAgcXVlc3Rpb246J+WFs+S6jmphdmFzY3JpcHTnmoTljp/lp4vnsbvlnovvvIhwcmltaXRpdmUgdHlwZe+8ie+8jOmUmeivr+eahOaYrycsXG4gICAgICAgIGFuc3dlcjpbXG4gICAgICAgICAgICAnQS7mnIk156eNcHJpbWl0aXZlIHR5cGXvvIzliIbliKvmmK9VbmRlZmluZWTjgIFOdWxs44CBQm9vbGVhbuOAgU51bWJlciDlkowgU3RyaW5nJyxcbiAgICAgICAgICAgICdCLnZhciBzVGVtcCA9IFwidGVzdCBzdHJpbmdcIjthbGVydCAodHlwZW9mIHNUZW1wKTvnu5PmnpzkuLpzdHJpbmcnLFxuICAgICAgICAgICAgJ0MudmFyIG9UZW1wO2FsZXJ0KG9UZW1wID09IHVuZGVmaW5lZCnkuLp0cnVlJyxcbiAgICAgICAgICAgICdELmFsZXJ0KG51bGwgPT0gdW5kZWZpbmVkKTvnu5PmnpzkuLpmYWxzZScsXG4gICAgICAgIF0sXG4gICAgICAgIHJpZ2h0OlsxLDIsM10sXG4gICAgICAgIHVzZXJDaG9vc2U6WzEsMiwzXVxuICAgIH0sXG4gICAge1xuICAgICAgICBrbm93bGVkZ2U6WydqYXZhU2NyaXB0J10sXG4gICAgICAgIHF1ZXN0aW9uSWQ6MSxcbiAgICAgICAgcXVlc3Rpb25UeXBlOidzaW5nbGUnLFxuICAgICAgICBxdWVzdGlvbjon5YWz5LqOamF2YXNjcmlwdOeahOWOn+Wni+exu+Wei++8iHByaW1pdGl2ZSB0eXBl77yJ77yM6ZSZ6K+v55qE5pivJyxcbiAgICAgICAgYW5zd2VyOltcbiAgICAgICAgICAgICdBLuaciTXnp41wcmltaXRpdmUgdHlwZe+8jOWIhuWIq+aYr1VuZGVmaW5lZOOAgU51bGzjgIFCb29sZWFu44CBTnVtYmVyIOWSjCBTdHJpbmcnLFxuICAgICAgICAgICAgJ0IudmFyIHNUZW1wID0gXCJ0ZXN0IHN0cmluZ1wiO2FsZXJ0ICh0eXBlb2Ygc1RlbXApO+e7k+aenOS4unN0cmluZycsXG4gICAgICAgICAgICAnQy52YXIgb1RlbXA7YWxlcnQob1RlbXAgPT0gdW5kZWZpbmVkKeS4unRydWUnLFxuICAgICAgICAgICAgJ0QuYWxlcnQobnVsbCA9PSB1bmRlZmluZWQpO+e7k+aenOS4umZhbHNlJyxcbiAgICAgICAgXSxcbiAgICAgICAgcmlnaHQ6WzNdLFxuICAgICAgICB1c2VyQ2hvb3NlOls0XVxuICAgIH0sXG4gICAge1xuICAgICAgICBrbm93bGVkZ2U6WydqYXZhU2NyaXB0J10sXG4gICAgICAgIHF1ZXN0aW9uSWQ6MSxcbiAgICAgICAgcXVlc3Rpb25UeXBlOidtdWwnLFxuICAgICAgICBxdWVzdGlvbjon5YWz5LqOamF2YXNjcmlwdOeahOWOn+Wni+exu+Wei++8iHByaW1pdGl2ZSB0eXBl77yJ77yM6ZSZ6K+v55qE5pivJyxcbiAgICAgICAgYW5zd2VyOltcbiAgICAgICAgICAgICdBLuaciTXnp41wcmltaXRpdmUgdHlwZe+8jOWIhuWIq+aYr1VuZGVmaW5lZOOAgU51bGzjgIFCb29sZWFu44CBTnVtYmVyIOWSjCBTdHJpbmcnLFxuICAgICAgICAgICAgJ0IudmFyIHNUZW1wID0gXCJ0ZXN0IHN0cmluZ1wiO2FsZXJ0ICh0eXBlb2Ygc1RlbXApO+e7k+aenOS4unN0cmluZycsXG4gICAgICAgICAgICAnQy52YXIgb1RlbXA7YWxlcnQob1RlbXAgPT0gdW5kZWZpbmVkKeS4unRydWUnLFxuICAgICAgICAgICAgJ0QuYWxlcnQobnVsbCA9PSB1bmRlZmluZWQpO+e7k+aenOS4umZhbHNlJyxcbiAgICAgICAgXSxcbiAgICAgICAgcmlnaHQ6WzEsMiwzXSxcbiAgICAgICAgdXNlckNob29zZTpbMSwyLDNdXG4gICAgfSxcbl1cblxuLy/mlofnq6DmjInmoIfnrb7nrZvpgInmlbDmja7pm4ZcbmV4cG9ydCB2YXIgYXJ0aWNsZUZpbHRlciA9IFtcbiAgICB7XG4gICAgICAgIGFydGljbGVOYW1lOiflu7rlvqHpm7fnpZ4nLFxuICAgICAgICBhcnRpY2xlQ29udGVudDon5bu65b6h6Zu356We77yI44K/44Kx44Of44Kr44OF44OB77yJ5piv5pel5pys56We6K+d5Lit55qE5LiA5L2N56We56WH77yM6KKr5aWJ5Li66Zu356We44CB5YiA5YmR5LmL56We44CB5byT5pyv5LmL56We44CB5q2m56We5ZKM5Yab56We44CC5Zyo44CK5Y+k5LqL6K6w44CL6YeM5YaZ5L2c5bu65b6h6Zu35LmL55S356We44CB5bu65b6h6Zu356We77yM5Zyo44CK5pel5pys5Lmm57qq44CL6YeM5YaZ5L2c5q2m55Ou5qeM44CB5q2m55Ou6Zu355S356We44CC5Yir5ZCN5bu65biD6YO956We44CB5Liw5biD6YO956We77yM5Zyo6bm/5bKb56We5a6r55qE56Wt56WA5Lit5YiZ5Lul6bm/5bKb56We55qE5ZCN5a2X5Ye6546w44CCJyxcbiAgICAgICAgYXJ0aWNsZUxhYmVsOlsxXSxcbiAgICAgICAgc2hvdzp0cnVlLCAvL+aYr+WQpuaYvuekulxuICAgICAgICBzY3JvbGw6dHJ1ZSwgLy/mmK/lkKblsZXlvIBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXJ0aWNsZU5hbWU6J+W7uuW+oembt+elnicsXG4gICAgICAgIGFydGljbGVDb250ZW50Oiflu7rlvqHpm7fnpZ7vvIjjgIrml6XmnKzkuabnuqrjgIvvvInmiJbnp7DlpKnnhaflpKflvqHnpZ7vvIjjgIrlj6TkuovorrDjgIvvvInjgIHlpKnnhafnmoflpKfnpZ7jgIHnmoflpKflvqHnpZ7jgIHlpKnnhaflnZDnmoflpKflvqHnpZ7jgIHlpKfml6XlrYHotLXjgIHlpKfml6XlpbPlsIrjgIHlpKfml6XngbXvvIzlpKnnhafmmK/ml6XmnKznpZ7or53ph4zkuInotLXlrZDkuYvkuIDjgIHpq5jlpKnljp/nmoTnu5/msrvogIXkuI7lpKrpmLPnmoTnpZ7moLzljJbjgILlpbnooqvlpYnkuLrml6XmnKzlpKnnmofnmoTlp4vnpZbvvIjnmofnpZbnpZ7vvInvvIzkuZ/mmK/npZ7pgZPmlZnmnIDpq5jnpZ7jgIIgWzFdICcsXG4gICAgICAgIGFydGljbGVMYWJlbDpbMl0sXG4gICAgICAgIHNob3c6dHJ1ZSwgLy/mmK/lkKbmmL7npLpcbiAgICAgICAgc2Nyb2xsOnRydWUsIC8v5piv5ZCm5bGV5byAXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFydGljbGVOYW1lOifmnIjor7snLFxuICAgICAgICBhcnRpY2xlQ29udGVudDon5pyI6K+777yI44OE44Kv44Oo44Of44CB44OE44Kt44Oo44Of77yJ77yM5Yir56ew5pyI5aSc6KeB77yI44OE44Kv44Oo44Of44OO44Of44Kz44OI77yJ44CB5pyI5L2Z576O44CB5pyI5byT5bCK77yI44OE44Kv44Om44Of44OO44Of44Kz44OI77yJ44CB5pyI6K+75aOu5aOr77yI44OE44Kt44Oo44Of44Kq44OI44Kz77yJ44CB5pyI56We5Lul5Y+K5pyI5Lq644CC5LuW5piv5pel5pys56We6K+d5ZKM56We6YGT55qE5LiA5L2N56We56WH77yM5piv5pyI55qE56We5qC85YyW77yM4oCc5LiJ6LS15a2Q77yI5pyI6K+744CB5aSp54Wn5aSn56We44CB57Sg5oiL5ZGc5bCK77yJ4oCd5LmL5LiA77yM5LyK6YKq6YKj5bKQ5LmL5a2Q77yM5o6M566h6buR5aSc55qE56We5piO44CCIFsxLTNdICcsXG4gICAgICAgIGFydGljbGVMYWJlbDpbMSwyXSxcbiAgICAgICAgc2hvdzp0cnVlLCAvL+aYr+WQpuaYvuekulxuICAgICAgICBzY3JvbGw6dHJ1ZSwgLy/mmK/lkKblsZXlvIBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXJ0aWNsZU5hbWU6J+W7uuW+oembt+elnicsXG4gICAgICAgIGFydGljbGVDb250ZW50Oiflu7rlvqHpm7fnpZ7vvIjjgr/jgrHjg5/jgqvjg4Xjg4HvvInmmK/ml6XmnKznpZ7or53kuK3nmoTkuIDkvY3npZ7npYfvvIzooqvlpYnkuLrpm7fnpZ7jgIHliIDliZHkuYvnpZ7jgIHlvJPmnK/kuYvnpZ7jgIHmrabnpZ7lkozlhpvnpZ7jgILlnKjjgIrlj6TkuovorrDjgIvph4zlhpnkvZzlu7rlvqHpm7fkuYvnlLfnpZ7jgIHlu7rlvqHpm7fnpZ7vvIzlnKjjgIrml6XmnKzkuabnuqrjgIvph4zlhpnkvZzmrabnk67mp4zjgIHmrabnk67pm7fnlLfnpZ7jgILliKvlkI3lu7rluIPpg73npZ7jgIHkuLDluIPpg73npZ7vvIzlnKjpub/lspvnpZ7lrqvnmoTnpa3npYDkuK3liJnku6Xpub/lspvnpZ7nmoTlkI3lrZflh7rnjrDjgIInLFxuICAgICAgICBhcnRpY2xlTGFiZWw6WzFdLFxuICAgICAgICBzaG93OnRydWUsIC8v5piv5ZCm5pi+56S6XG4gICAgICAgIHNjcm9sbDp0cnVlLCAvL+aYr+WQpuWxleW8gFxuICAgIH0sXG4gICAge1xuICAgICAgICBhcnRpY2xlTmFtZTon5bu65b6h6Zu356WeJyxcbiAgICAgICAgYXJ0aWNsZUNvbnRlbnQ6J+W7uuW+oembt+elnu+8iOOAiuaXpeacrOS5pue6quOAi++8ieaIluensOWkqeeFp+Wkp+W+oeelnu+8iOOAiuWPpOS6i+iusOOAi++8ieOAgeWkqeeFp+eah+Wkp+elnuOAgeeah+Wkp+W+oeelnuOAgeWkqeeFp+WdkOeah+Wkp+W+oeelnuOAgeWkp+aXpeWtgei0teOAgeWkp+aXpeWls+WwiuOAgeWkp+aXpeeBte+8jOWkqeeFp+aYr+aXpeacrOelnuivnemHjOS4iei0teWtkOS5i+S4gOOAgemrmOWkqeWOn+eahOe7n+ayu+iAheS4juWkqumYs+eahOelnuagvOWMluOAguWlueiiq+WlieS4uuaXpeacrOWkqeeah+eahOWni+ellu+8iOeah+elluelnu+8ie+8jOS5n+aYr+elnumBk+aVmeacgOmrmOelnuOAgiBbMV0gJyxcbiAgICAgICAgYXJ0aWNsZUxhYmVsOlsyXSxcbiAgICAgICAgc2hvdzp0cnVlLCAvL+aYr+WQpuaYvuekulxuICAgICAgICBzY3JvbGw6dHJ1ZSwgLy/mmK/lkKblsZXlvIBcbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXJ0aWNsZU5hbWU6J+aciOivuycsXG4gICAgICAgIGFydGljbGVDb250ZW50OifmnIjor7vvvIjjg4Tjgq/jg6jjg5/jgIHjg4Tjgq3jg6jjg5/vvInvvIzliKvnp7DmnIjlpJzop4HvvIjjg4Tjgq/jg6jjg5/jg47jg5/jgrPjg4jvvInjgIHmnIjkvZnnvo7jgIHmnIjlvJPlsIrvvIjjg4Tjgq/jg6bjg5/jg47jg5/jgrPjg4jvvInjgIHmnIjor7vlo67lo6vvvIjjg4Tjgq3jg6jjg5/jgqrjg4jjgrPvvInjgIHmnIjnpZ7ku6Xlj4rmnIjkurrjgILku5bmmK/ml6XmnKznpZ7or53lkoznpZ7pgZPnmoTkuIDkvY3npZ7npYfvvIzmmK/mnIjnmoTnpZ7moLzljJbvvIzigJzkuInotLXlrZDvvIjmnIjor7vjgIHlpKnnhaflpKfnpZ7jgIHntKDmiIvlkZzlsIrvvInigJ3kuYvkuIDvvIzkvIrpgqrpgqPlspDkuYvlrZDvvIzmjoznrqHpu5HlpJznmoTnpZ7mmI7jgIIgWzEtM10gJyxcbiAgICAgICAgYXJ0aWNsZUxhYmVsOlsxLDJdLFxuICAgICAgICBzaG93OnRydWUsIC8v5piv5ZCm5pi+56S6XG4gICAgICAgIHNjcm9sbDp0cnVlLCAvL+aYr+WQpuWxleW8gFxuICAgIH0sXG4gICAge1xuICAgICAgICBhcnRpY2xlTmFtZTon5pyI6K+7JyxcbiAgICAgICAgYXJ0aWNsZUNvbnRlbnQ6J+aciOivu++8iOODhOOCr+ODqOODn+OAgeODhOOCreODqOODn++8ie+8jOWIq+ensOaciOWknOinge+8iOODhOOCr+ODqOODn+ODjuODn+OCs+ODiO+8ieOAgeaciOS9mee+juOAgeaciOW8k+Wwiu+8iOODhOOCr+ODpuODn+ODjuODn+OCs+ODiO+8ieOAgeaciOivu+WjruWjq++8iOODhOOCreODqOODn+OCquODiOOCs++8ieOAgeaciOelnuS7peWPiuaciOS6uuOAguS7luaYr+aXpeacrOelnuivneWSjOelnumBk+eahOS4gOS9jeelnuelh++8jOaYr+aciOeahOelnuagvOWMlu+8jOKAnOS4iei0teWtkO+8iOaciOivu+OAgeWkqeeFp+Wkp+elnuOAgee0oOaIi+WRnOWwiu+8ieKAneS5i+S4gO+8jOS8iumCqumCo+WykOS5i+WtkO+8jOaOjOeuoem7keWknOeahOelnuaYjuOAgiBbMS0zXSAnLFxuICAgICAgICBhcnRpY2xlTGFiZWw6WzEsMl0sXG4gICAgICAgIHNob3c6dHJ1ZSwgLy/mmK/lkKbmmL7npLpcbiAgICAgICAgc2Nyb2xsOnRydWUsIC8v5piv5ZCm5bGV5byAXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFydGljbGVOYW1lOiflu7rlvqHpm7fnpZ4nLFxuICAgICAgICBhcnRpY2xlQ29udGVudDon5bu65b6h6Zu356We77yI44CK5pel5pys5Lmm57qq44CL77yJ5oiW56ew5aSp54Wn5aSn5b6h56We77yI44CK5Y+k5LqL6K6w44CL77yJ44CB5aSp54Wn55qH5aSn56We44CB55qH5aSn5b6h56We44CB5aSp54Wn5Z2Q55qH5aSn5b6h56We44CB5aSn5pel5a2B6LS144CB5aSn5pel5aWz5bCK44CB5aSn5pel54G177yM5aSp54Wn5piv5pel5pys56We6K+d6YeM5LiJ6LS15a2Q5LmL5LiA44CB6auY5aSp5Y6f55qE57uf5rK76ICF5LiO5aSq6Ziz55qE56We5qC85YyW44CC5aW56KKr5aWJ5Li65pel5pys5aSp55qH55qE5aeL56WW77yI55qH56WW56We77yJ77yM5Lmf5piv56We6YGT5pWZ5pyA6auY56We44CCIFsxXSAnLFxuICAgICAgICBhcnRpY2xlTGFiZWw6WzJdLFxuICAgICAgICBzaG93OnRydWUsIC8v5piv5ZCm5pi+56S6XG4gICAgICAgIHNjcm9sbDp0cnVlLCAvL+aYr+WQpuWxleW8gFxuICAgIH0sXG4gICAge1xuICAgICAgICBhcnRpY2xlTmFtZTon5pyI6K+7JyxcbiAgICAgICAgYXJ0aWNsZUNvbnRlbnQ6J+aciOivu++8iOODhOOCr+ODqOODn+OAgeODhOOCreODqOODn++8ie+8jOWIq+ensOaciOWknOinge+8iOODhOOCr+ODqOODn+ODjuODn+OCs+ODiO+8ieOAgeaciOS9mee+juOAgeaciOW8k+Wwiu+8iOODhOOCr+ODpuODn+ODjuODn+OCs+ODiO+8ieOAgeaciOivu+WjruWjq++8iOODhOOCreODqOODn+OCquODiOOCs++8ieOAgeaciOelnuS7peWPiuaciOS6uuOAguS7luaYr+aXpeacrOelnuivneWSjOelnumBk+eahOS4gOS9jeelnuelh++8jOaYr+aciOeahOelnuagvOWMlu+8jOKAnOS4iei0teWtkO+8iOaciOivu+OAgeWkqeeFp+Wkp+elnuOAgee0oOaIi+WRnOWwiu+8ieKAneS5i+S4gO+8jOS8iumCqumCo+WykOS5i+WtkO+8jOaOjOeuoem7keWknOeahOelnuaYjuOAgiBbMS0zXSAnLFxuICAgICAgICBhcnRpY2xlTGFiZWw6WzEsMl0sXG4gICAgICAgIHNob3c6dHJ1ZSwgLy/mmK/lkKbmmL7npLpcbiAgICAgICAgc2Nyb2xsOnRydWUsIC8v5piv5ZCm5bGV5byAXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFydGljbGVOYW1lOifmnIjor7snLFxuICAgICAgICBhcnRpY2xlQ29udGVudDon5pyI6K+777yI44OE44Kv44Oo44Of44CB44OE44Kt44Oo44Of77yJ77yM5Yir56ew5pyI5aSc6KeB77yI44OE44Kv44Oo44Of44OO44Of44Kz44OI77yJ44CB5pyI5L2Z576O44CB5pyI5byT5bCK77yI44OE44Kv44Om44Of44OO44Of44Kz44OI77yJ44CB5pyI6K+75aOu5aOr77yI44OE44Kt44Oo44Of44Kq44OI44Kz77yJ44CB5pyI56We5Lul5Y+K5pyI5Lq644CC5LuW5piv5pel5pys56We6K+d5ZKM56We6YGT55qE5LiA5L2N56We56WH77yM5piv5pyI55qE56We5qC85YyW77yM4oCc5LiJ6LS15a2Q77yI5pyI6K+744CB5aSp54Wn5aSn56We44CB57Sg5oiL5ZGc5bCK77yJ4oCd5LmL5LiA77yM5LyK6YKq6YKj5bKQ5LmL5a2Q77yM5o6M566h6buR5aSc55qE56We5piO44CCIFsxLTNdICcsXG4gICAgICAgIGFydGljbGVMYWJlbDpbMSwyXSxcbiAgICAgICAgc2hvdzp0cnVlLCAvL+aYr+WQpuaYvuekulxuICAgICAgICBzY3JvbGw6dHJ1ZSwgLy/mmK/lkKblsZXlvIBcbiAgICB9LFxuXVxuXG4vL+WlveWPi+WIl+ihqOaVsOaNrlxuZXhwb3J0IGxldCBmaXJlbmRzID0gW1xuICAgIHtcbiAgICAgICAgbmFtZTonamlhaHVpIHNoYW8nLFxuICAgICAgICBwaG9uZToxODc1ODU4MDUwMSxcbiAgICAgICAgc2V4OnRydWVcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTonZnV5dScsXG4gICAgICAgIHBob25lOjEzMjc2ODAwNzg3LFxuICAgICAgICBzZXg6ZmFsc2VcbiAgICB9XG5dXG5cbi8v5paH56ug5pWw5o2uXG5leHBvcnQgbGV0IGFydGljbGUgPSBbXG4gICAge1xuICAgICAgICBuYW1lOifmiJHmmK/njKsnLFxuICAgICAgICBzY3JvbGw6dHJ1ZSxcbiAgICAgICAgYXV0aG9yOiflpI/nm67mvLHnn7MnLFxuICAgICAgICByZW1hcms6J+mVv+evh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+Wwj+ivtOWbtOe7lemHkeeUsOWwj+WnkOeahOWpmuS6i+W8lei1t+eahOmjjuazou+8jOacieWKm+WcsOaPremcsuS6hui1hOS6p+mYtue6p++8jOaJueWIpOS6huekvuS8muaLnOmHkeS4u+S5iemjjuawlOOAgumHkeeUsOiAgeeIt+aYr+mdoOmrmOWIqei0t+i1t+WutueahOOAgeKAnOept+WHtuaegeaBtu+8jOWPiOi0quWPiOeLoOKAneeahOWkp+i1hOacrOWutu+8jOaLpeacieWkp+mHj+eahOi0ouS6p+OAguS7lueahOKAnOWggueah+WvjOS4veeahOWFrOmmhuKAne+8jOS4juiLpuaymeW8peeahOKAnOaal+m7keeahOa0nueqn+KAneaBsOaIkOmynOaYjuWvueavlOOAguS7luWPkei0ouiHtOWvjOeahOKAnOenmOivgOKAneaYr+KAnOimgeeyvumAmuS4iee8uuKAne+8jOWNs+e8uuS5ieeQhuOAgee8uuS6uuaDheOAgee8uuW7ieiAu+OAguKAnOaKium8u+WtkOOAgeecvOedm+mDveebr+WcqOmSnuelqOS4iuKAne+8jOKAnOWPquimgeiDvei1mumSse+8jOS7gOS5iOS6i+S5n+W5suW+l+WHuuadpeKAne+8jOaKiumHkemSseeci+W+l+avlOeUn+WRvei/mOmHjeimgeOAgumHkeeUsOS+neS7l+iHquW3seeahOi0ouWKv++8jOaIkOS4uuekvuS8muS4iui1q+i1q+acieWQjeeahOS6uueJqeOAguS7lui0ouWkp+awlOeyl++8jOS7l+WKv+WOi+S6uuOAguS4u+S6uuWFrOiLpuaymeW8peWuiei0q+OAgeato+ebtO+8jOaVmeS5puWNgeW5tOS4juS7lue0oOS4jeebuOivhu+8jOWPquaYr+aFouW+heS6huS7lueahOiAgeWphu+8jOS7luS+v+WFtOW4iOWKqOS8l+S4ieeVquWbm+asoei/m+ihjOaJk+WHu++8jOiHtOS9v+iLpuaymeW8peeahOi6q+W/g+WPl+WIsOS4pemHjeaRp+aui+OAguS5sOmAmueahOiQveS6kemmhueahOmhveerpeaQnuW+l+iLpuaymeW8peWdkOWNp+S4jeWuge+8jOS7luWNtOW+l+aEj+a0i+a0i+WcsOivtO+8muKAnOKApuKApui/meS4quWutuS8meKApuKApuS4jeS5heWwhuadpe+8jOaAu+S8muaKlemZjeeahOWRouOAguKAneS4gOWJr+WluOiviOOAgeWHtueLoOWPr+aGjueahOmdouebruaatOmcsuaXoOmBl+S6huOAguaJgOS7pe+8jOi/nuKAnOeMq+KAneS5n+inieW+l+mHkeeUsOaYr+KAnOacgOWdj+eahOS6uuexu+KAneOAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+W/gycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpI/nm67mvLHnn7MnLFxuICAgICAgICB0aW1lOicxOTE05bm0JyxcbiAgICAgICAgcmVtYXJrOifplb/nr4flsI/or7QnLFxuICAgICAgICBjb250ZW50OifjgIrlv4PjgIvorrLov7DnmoTmmK/igJzlhYjnlJ/igJ3nu5Por4blubbniLHkuIrkuobmiL/kuJzlrrbnmoTlsI/lp5DvvIzlkIzml7bkuZ/otaLlvpfkuobmiL/kuJzlpKrlpKrnmoTlpb3mhJ/vvIzkvYbljbTlm6DlubTlsJHml7bmm77lj5fliLDlj5TniLbnmoTmrLror4jogIzlr7nku5bkurrml7blrZjmiJLlv4PvvIzov5/ov5/kuI3og73ooajnmb3oh6rlt7HnmoTlv4PmhI/jgILlkI7mnaXvvIzigJzlhYjnlJ/igJ3nmoTlpb3lj4tL5L2P6L+b5LqG5oi/5Lic5a626YeM77yM5Lmf54ix5LiK5LqG5bCP5aeQ77yM55u0546H55qES+WQkeWlveWPi+KAnOWFiOeUn1wi6KGo55m95LqG6Ieq5bex55qE5b+D5LqL77yM4oCc5YWI55Sf4oCd5Zyo6KGo6Z2i5LiK5om56K+ES+KAnOS4jeaxguS4iui/m+KAne+8jOiDjOWcsOmHjOWNtOWBt+WBt+WcsOWQkeaIv+S4nOWkquWkquaPkOWHuuimgeWSjOWwj+WnkOe7k+WpmuOAguefpemBk+S6hui/meS4gOWIh+ecn+ebuOS5i+WQjueahEvlnKjnu53mnJvkuK3oh6rmnYDkuobvvIzlkIzml7ZL55qE5q275Lmf55WZ57uZ4oCc5YWI55Sf4oCd5LiA55Sf55qE5LiN5a6J5ZKM6Ieq6LSj77yM5ama5ZCO55qE4oCc5YWI55Sf4oCd5LiA55u05peg5rOV5b+Y5Y20S++8jOS7lueahOWGheW/g+aXoOavlOeahOWvguWvnu+8jOe7iOS6juS5n+i1sOS4iuS6huiHquadgOeahOmBk+i3r+OAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+S6uumXtOWkseagvCcsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpKrlrrDmsrsnLFxuICAgICAgICByZW1hcms6J+S4reevh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+WFqOS5pueUseS9nOiAheeahOW6j+iogOOAgeWQjuiusO+8jOS7peWPiuS4u+inkuWkp+W6reWPtuiXj+eahOS4ieS4quaJi+acree7hOaIkO+8jOaPj+WGmeS4u+inkuS7jumdkuWwkeW5tOWIsOS4reW5tO+8jOS4uuS6humAg+mBv+eOsOWunuiAjOS4jeaWreayieaypu+8jOe7j+WOhuiHquaIkeaUvumAkOOAgemFl+mFkuOAgeiHquadgOOAgeeUqOiNr+eJqem6u+eXueiHquW3se+8jOe7iOS6juS4gOatpeatpei1sOWQkeiHquaIkeavgeeBreeahOaCsuWJp++8jOWcqOiHquaIkeWQpuWumueahOi/h+eoi+S4re+8jOaKkuWPkeiHquW3seWGheW/g+a3seWkhOeahOiLpumXt++8jOS7peWPiua4tOacm+iiq+eIseeahOaDheaEq+KApuKApiDpgI/ov4fkuLvop5Llj7bol4/nmoTkurrnlJ/pga3pgYfvvIzlj6/ku6Xor7TlpKrlrrDmsrvlt6flppnlnLDlsIboh6rlt7HkuIDnlJ/nmoTnu4/ljobkuI7mgJ3mg7Pooajovr7lh7rmnaXvvIzlubbol4nmraTmj5Dlh7rouqvkuLrkurrmnIDnnJ/liIfnmoTnl5voi6bpl67popjjgILku47mu57mtqnnmoTmlofkuK3mm7Tlj6/kvZPkvJrlhbblhoXlv4Pmt7HliIfnmoToi6bmpZrvvIzlnKjlrozmiJDmnKznr4fkvZzlk4HkuYvlkI7vvIzlpKrlrrDmsrvnu4jlvZLov5jmmK/pgInmi6nkuobmipXmsLTnmoTmlrnlvI/vvIzkuLrku5boh6rlt7HliJLkuIvmnIDlkI7nmoTlj6XngrnjgILlm6DmraTvvIzjgIrkurrpl7TlpLHmoLzjgIvnrpfmmK/lpKrlrrDmsrvljYroh6rkvKDmgKfkvZzlk4HjgIInXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+aWnOmYsycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpKrlrrDmsrsnLFxuICAgICAgICByZW1hcms6J+S4reevh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+aVheS6i+mAmui/h+WSjOWtkOeahOesrOS4gOS6uuensOWPmei/sOWSjOW8n+W8n+ebtOayu+eahOaXpeiusOS4jumBl+S5pueahOW9ouW8j+WxleW8gOOAguS4u+imgeiusueahOaYr+S4juS4iOWkq+emu+WpmuWFreW5tOeahOWSjOWtkOWcqOS8iuixhuWxseS4reeahOWIq+WiheWSjOavjeS6suWQjOS9j++8jOavjeS6suWPiOaCo+S4iuS6huiCuue7k+aguOOAguW6lOW+geacjeW9ueeahOW8n+W8n+S4i+iQveS4jeaYju+8jOe7iOS6juW8n+W8n+WkjeWRmOW9kuadpe+8jOS9huS7lueUn+a0u+aUvuiNoeS4jee+gei/mOayvuafk+S4iuavkuWTgeOAguWSjOWtkOaBi+S4iuS6huW3suWpmueahOS4jeiJr+S9nOWutuS4iuWOn++8jOW5tuaipuaDs+eUn+S4i+S4iuWOn+eahOWtqeWtkOOAguacgOWQjuavjeS6sueXheS6oe+8jOW8n+W8n+ebtOayu+eVmeS4i+mBl+S5puiHquadgO+8jOWSjOWtkOihqOekuuWNs+S9v+S8muiiq+mBl+W8g+S5n+imgeeUn+S4i+W5tuaKmuWFu+S4iuWOn+eahOengeeUn+WtkO+8jOWunueOsOmBk+W+t+mdqeWRveOAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+aIkeaYr+eMqycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpI/nm67mvLHnn7MnLFxuICAgICAgICByZW1hcms6J+mVv+evh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+Wwj+ivtOWbtOe7lemHkeeUsOWwj+WnkOeahOWpmuS6i+W8lei1t+eahOmjjuazou+8jOacieWKm+WcsOaPremcsuS6hui1hOS6p+mYtue6p++8jOaJueWIpOS6huekvuS8muaLnOmHkeS4u+S5iemjjuawlOOAgumHkeeUsOiAgeeIt+aYr+mdoOmrmOWIqei0t+i1t+WutueahOOAgeKAnOept+WHtuaegeaBtu+8jOWPiOi0quWPiOeLoOKAneeahOWkp+i1hOacrOWutu+8jOaLpeacieWkp+mHj+eahOi0ouS6p+OAguS7lueahOKAnOWggueah+WvjOS4veeahOWFrOmmhuKAne+8jOS4juiLpuaymeW8peeahOKAnOaal+m7keeahOa0nueqn+KAneaBsOaIkOmynOaYjuWvueavlOOAguS7luWPkei0ouiHtOWvjOeahOKAnOenmOivgOKAneaYr+KAnOimgeeyvumAmuS4iee8uuKAne+8jOWNs+e8uuS5ieeQhuOAgee8uuS6uuaDheOAgee8uuW7ieiAu+OAguKAnOaKium8u+WtkOOAgeecvOedm+mDveebr+WcqOmSnuelqOS4iuKAne+8jOKAnOWPquimgeiDvei1mumSse+8jOS7gOS5iOS6i+S5n+W5suW+l+WHuuadpeKAne+8jOaKiumHkemSseeci+W+l+avlOeUn+WRvei/mOmHjeimgeOAgumHkeeUsOS+neS7l+iHquW3seeahOi0ouWKv++8jOaIkOS4uuekvuS8muS4iui1q+i1q+acieWQjeeahOS6uueJqeOAguS7lui0ouWkp+awlOeyl++8jOS7l+WKv+WOi+S6uuOAguS4u+S6uuWFrOiLpuaymeW8peWuiei0q+OAgeato+ebtO+8jOaVmeS5puWNgeW5tOS4juS7lue0oOS4jeebuOivhu+8jOWPquaYr+aFouW+heS6huS7lueahOiAgeWphu+8jOS7luS+v+WFtOW4iOWKqOS8l+S4ieeVquWbm+asoei/m+ihjOaJk+WHu++8jOiHtOS9v+iLpuaymeW8peeahOi6q+W/g+WPl+WIsOS4pemHjeaRp+aui+OAguS5sOmAmueahOiQveS6kemmhueahOmhveerpeaQnuW+l+iLpuaymeW8peWdkOWNp+S4jeWuge+8jOS7luWNtOW+l+aEj+a0i+a0i+WcsOivtO+8muKAnOKApuKApui/meS4quWutuS8meKApuKApuS4jeS5heWwhuadpe+8jOaAu+S8muaKlemZjeeahOWRouOAguKAneS4gOWJr+WluOiviOOAgeWHtueLoOWPr+aGjueahOmdouebruaatOmcsuaXoOmBl+S6huOAguaJgOS7pe+8jOi/nuKAnOeMq+KAneS5n+inieW+l+mHkeeUsOaYr+KAnOacgOWdj+eahOS6uuexu+KAneOAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+W/gycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpI/nm67mvLHnn7MnLFxuICAgICAgICB0aW1lOicxOTE05bm0JyxcbiAgICAgICAgcmVtYXJrOifplb/nr4flsI/or7QnLFxuICAgICAgICBjb250ZW50OifjgIrlv4PjgIvorrLov7DnmoTmmK/igJzlhYjnlJ/igJ3nu5Por4blubbniLHkuIrkuobmiL/kuJzlrrbnmoTlsI/lp5DvvIzlkIzml7bkuZ/otaLlvpfkuobmiL/kuJzlpKrlpKrnmoTlpb3mhJ/vvIzkvYbljbTlm6DlubTlsJHml7bmm77lj5fliLDlj5TniLbnmoTmrLror4jogIzlr7nku5bkurrml7blrZjmiJLlv4PvvIzov5/ov5/kuI3og73ooajnmb3oh6rlt7HnmoTlv4PmhI/jgILlkI7mnaXvvIzigJzlhYjnlJ/igJ3nmoTlpb3lj4tL5L2P6L+b5LqG5oi/5Lic5a626YeM77yM5Lmf54ix5LiK5LqG5bCP5aeQ77yM55u0546H55qES+WQkeWlveWPi+KAnOWFiOeUn1wi6KGo55m95LqG6Ieq5bex55qE5b+D5LqL77yM4oCc5YWI55Sf4oCd5Zyo6KGo6Z2i5LiK5om56K+ES+KAnOS4jeaxguS4iui/m+KAne+8jOiDjOWcsOmHjOWNtOWBt+WBt+WcsOWQkeaIv+S4nOWkquWkquaPkOWHuuimgeWSjOWwj+WnkOe7k+WpmuOAguefpemBk+S6hui/meS4gOWIh+ecn+ebuOS5i+WQjueahEvlnKjnu53mnJvkuK3oh6rmnYDkuobvvIzlkIzml7ZL55qE5q275Lmf55WZ57uZ4oCc5YWI55Sf4oCd5LiA55Sf55qE5LiN5a6J5ZKM6Ieq6LSj77yM5ama5ZCO55qE4oCc5YWI55Sf4oCd5LiA55u05peg5rOV5b+Y5Y20S++8jOS7lueahOWGheW/g+aXoOavlOeahOWvguWvnu+8jOe7iOS6juS5n+i1sOS4iuS6huiHquadgOeahOmBk+i3r+OAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+S6uumXtOWkseagvCcsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpKrlrrDmsrsnLFxuICAgICAgICByZW1hcms6J+S4reevh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+WFqOS5pueUseS9nOiAheeahOW6j+iogOOAgeWQjuiusO+8jOS7peWPiuS4u+inkuWkp+W6reWPtuiXj+eahOS4ieS4quaJi+acree7hOaIkO+8jOaPj+WGmeS4u+inkuS7jumdkuWwkeW5tOWIsOS4reW5tO+8jOS4uuS6humAg+mBv+eOsOWunuiAjOS4jeaWreayieaypu+8jOe7j+WOhuiHquaIkeaUvumAkOOAgemFl+mFkuOAgeiHquadgOOAgeeUqOiNr+eJqem6u+eXueiHquW3se+8jOe7iOS6juS4gOatpeatpei1sOWQkeiHquaIkeavgeeBreeahOaCsuWJp++8jOWcqOiHquaIkeWQpuWumueahOi/h+eoi+S4re+8jOaKkuWPkeiHquW3seWGheW/g+a3seWkhOeahOiLpumXt++8jOS7peWPiua4tOacm+iiq+eIseeahOaDheaEq+KApuKApiDpgI/ov4fkuLvop5Llj7bol4/nmoTkurrnlJ/pga3pgYfvvIzlj6/ku6Xor7TlpKrlrrDmsrvlt6flppnlnLDlsIboh6rlt7HkuIDnlJ/nmoTnu4/ljobkuI7mgJ3mg7Pooajovr7lh7rmnaXvvIzlubbol4nmraTmj5Dlh7rouqvkuLrkurrmnIDnnJ/liIfnmoTnl5voi6bpl67popjjgILku47mu57mtqnnmoTmlofkuK3mm7Tlj6/kvZPkvJrlhbblhoXlv4Pmt7HliIfnmoToi6bmpZrvvIzlnKjlrozmiJDmnKznr4fkvZzlk4HkuYvlkI7vvIzlpKrlrrDmsrvnu4jlvZLov5jmmK/pgInmi6nkuobmipXmsLTnmoTmlrnlvI/vvIzkuLrku5boh6rlt7HliJLkuIvmnIDlkI7nmoTlj6XngrnjgILlm6DmraTvvIzjgIrkurrpl7TlpLHmoLzjgIvnrpfmmK/lpKrlrrDmsrvljYroh6rkvKDmgKfkvZzlk4HjgIInXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+aWnOmYsycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpKrlrrDmsrsnLFxuICAgICAgICByZW1hcms6J+S4reevh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+aVheS6i+mAmui/h+WSjOWtkOeahOesrOS4gOS6uuensOWPmei/sOWSjOW8n+W8n+ebtOayu+eahOaXpeiusOS4jumBl+S5pueahOW9ouW8j+WxleW8gOOAguS4u+imgeiusueahOaYr+S4juS4iOWkq+emu+WpmuWFreW5tOeahOWSjOWtkOWcqOS8iuixhuWxseS4reeahOWIq+WiheWSjOavjeS6suWQjOS9j++8jOavjeS6suWPiOaCo+S4iuS6huiCuue7k+aguOOAguW6lOW+geacjeW9ueeahOW8n+W8n+S4i+iQveS4jeaYju+8jOe7iOS6juW8n+W8n+WkjeWRmOW9kuadpe+8jOS9huS7lueUn+a0u+aUvuiNoeS4jee+gei/mOayvuafk+S4iuavkuWTgeOAguWSjOWtkOaBi+S4iuS6huW3suWpmueahOS4jeiJr+S9nOWutuS4iuWOn++8jOW5tuaipuaDs+eUn+S4i+S4iuWOn+eahOWtqeWtkOOAguacgOWQjuavjeS6sueXheS6oe+8jOW8n+W8n+ebtOayu+eVmeS4i+mBl+S5puiHquadgO+8jOWSjOWtkOihqOekuuWNs+S9v+S8muiiq+mBl+W8g+S5n+imgeeUn+S4i+W5tuaKmuWFu+S4iuWOn+eahOengeeUn+WtkO+8jOWunueOsOmBk+W+t+mdqeWRveOAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+aIkeaYr+eMqycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpI/nm67mvLHnn7MnLFxuICAgICAgICByZW1hcms6J+mVv+evh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+Wwj+ivtOWbtOe7lemHkeeUsOWwj+WnkOeahOWpmuS6i+W8lei1t+eahOmjjuazou+8jOacieWKm+WcsOaPremcsuS6hui1hOS6p+mYtue6p++8jOaJueWIpOS6huekvuS8muaLnOmHkeS4u+S5iemjjuawlOOAgumHkeeUsOiAgeeIt+aYr+mdoOmrmOWIqei0t+i1t+WutueahOOAgeKAnOept+WHtuaegeaBtu+8jOWPiOi0quWPiOeLoOKAneeahOWkp+i1hOacrOWutu+8jOaLpeacieWkp+mHj+eahOi0ouS6p+OAguS7lueahOKAnOWggueah+WvjOS4veeahOWFrOmmhuKAne+8jOS4juiLpuaymeW8peeahOKAnOaal+m7keeahOa0nueqn+KAneaBsOaIkOmynOaYjuWvueavlOOAguS7luWPkei0ouiHtOWvjOeahOKAnOenmOivgOKAneaYr+KAnOimgeeyvumAmuS4iee8uuKAne+8jOWNs+e8uuS5ieeQhuOAgee8uuS6uuaDheOAgee8uuW7ieiAu+OAguKAnOaKium8u+WtkOOAgeecvOedm+mDveebr+WcqOmSnuelqOS4iuKAne+8jOKAnOWPquimgeiDvei1mumSse+8jOS7gOS5iOS6i+S5n+W5suW+l+WHuuadpeKAne+8jOaKiumHkemSseeci+W+l+avlOeUn+WRvei/mOmHjeimgeOAgumHkeeUsOS+neS7l+iHquW3seeahOi0ouWKv++8jOaIkOS4uuekvuS8muS4iui1q+i1q+acieWQjeeahOS6uueJqeOAguS7lui0ouWkp+awlOeyl++8jOS7l+WKv+WOi+S6uuOAguS4u+S6uuWFrOiLpuaymeW8peWuiei0q+OAgeato+ebtO+8jOaVmeS5puWNgeW5tOS4juS7lue0oOS4jeebuOivhu+8jOWPquaYr+aFouW+heS6huS7lueahOiAgeWphu+8jOS7luS+v+WFtOW4iOWKqOS8l+S4ieeVquWbm+asoei/m+ihjOaJk+WHu++8jOiHtOS9v+iLpuaymeW8peeahOi6q+W/g+WPl+WIsOS4pemHjeaRp+aui+OAguS5sOmAmueahOiQveS6kemmhueahOmhveerpeaQnuW+l+iLpuaymeW8peWdkOWNp+S4jeWuge+8jOS7luWNtOW+l+aEj+a0i+a0i+WcsOivtO+8muKAnOKApuKApui/meS4quWutuS8meKApuKApuS4jeS5heWwhuadpe+8jOaAu+S8muaKlemZjeeahOWRouOAguKAneS4gOWJr+WluOiviOOAgeWHtueLoOWPr+aGjueahOmdouebruaatOmcsuaXoOmBl+S6huOAguaJgOS7pe+8jOi/nuKAnOeMq+KAneS5n+inieW+l+mHkeeUsOaYr+KAnOacgOWdj+eahOS6uuexu+KAneOAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+W/gycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpI/nm67mvLHnn7MnLFxuICAgICAgICB0aW1lOicxOTE05bm0JyxcbiAgICAgICAgcmVtYXJrOifplb/nr4flsI/or7QnLFxuICAgICAgICBjb250ZW50OifjgIrlv4PjgIvorrLov7DnmoTmmK/igJzlhYjnlJ/igJ3nu5Por4blubbniLHkuIrkuobmiL/kuJzlrrbnmoTlsI/lp5DvvIzlkIzml7bkuZ/otaLlvpfkuobmiL/kuJzlpKrlpKrnmoTlpb3mhJ/vvIzkvYbljbTlm6DlubTlsJHml7bmm77lj5fliLDlj5TniLbnmoTmrLror4jogIzlr7nku5bkurrml7blrZjmiJLlv4PvvIzov5/ov5/kuI3og73ooajnmb3oh6rlt7HnmoTlv4PmhI/jgILlkI7mnaXvvIzigJzlhYjnlJ/igJ3nmoTlpb3lj4tL5L2P6L+b5LqG5oi/5Lic5a626YeM77yM5Lmf54ix5LiK5LqG5bCP5aeQ77yM55u0546H55qES+WQkeWlveWPi+KAnOWFiOeUn1wi6KGo55m95LqG6Ieq5bex55qE5b+D5LqL77yM4oCc5YWI55Sf4oCd5Zyo6KGo6Z2i5LiK5om56K+ES+KAnOS4jeaxguS4iui/m+KAne+8jOiDjOWcsOmHjOWNtOWBt+WBt+WcsOWQkeaIv+S4nOWkquWkquaPkOWHuuimgeWSjOWwj+WnkOe7k+WpmuOAguefpemBk+S6hui/meS4gOWIh+ecn+ebuOS5i+WQjueahEvlnKjnu53mnJvkuK3oh6rmnYDkuobvvIzlkIzml7ZL55qE5q275Lmf55WZ57uZ4oCc5YWI55Sf4oCd5LiA55Sf55qE5LiN5a6J5ZKM6Ieq6LSj77yM5ama5ZCO55qE4oCc5YWI55Sf4oCd5LiA55u05peg5rOV5b+Y5Y20S++8jOS7lueahOWGheW/g+aXoOavlOeahOWvguWvnu+8jOe7iOS6juS5n+i1sOS4iuS6huiHquadgOeahOmBk+i3r+OAgicsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+S6uumXtOWkseagvCcsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpKrlrrDmsrsnLFxuICAgICAgICByZW1hcms6J+S4reevh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+WFqOS5pueUseS9nOiAheeahOW6j+iogOOAgeWQjuiusO+8jOS7peWPiuS4u+inkuWkp+W6reWPtuiXj+eahOS4ieS4quaJi+acree7hOaIkO+8jOaPj+WGmeS4u+inkuS7jumdkuWwkeW5tOWIsOS4reW5tO+8jOS4uuS6humAg+mBv+eOsOWunuiAjOS4jeaWreayieaypu+8jOe7j+WOhuiHquaIkeaUvumAkOOAgemFl+mFkuOAgeiHquadgOOAgeeUqOiNr+eJqem6u+eXueiHquW3se+8jOe7iOS6juS4gOatpeatpei1sOWQkeiHquaIkeavgeeBreeahOaCsuWJp++8jOWcqOiHquaIkeWQpuWumueahOi/h+eoi+S4re+8jOaKkuWPkeiHquW3seWGheW/g+a3seWkhOeahOiLpumXt++8jOS7peWPiua4tOacm+iiq+eIseeahOaDheaEq+KApuKApiDpgI/ov4fkuLvop5Llj7bol4/nmoTkurrnlJ/pga3pgYfvvIzlj6/ku6Xor7TlpKrlrrDmsrvlt6flppnlnLDlsIboh6rlt7HkuIDnlJ/nmoTnu4/ljobkuI7mgJ3mg7Pooajovr7lh7rmnaXvvIzlubbol4nmraTmj5Dlh7rouqvkuLrkurrmnIDnnJ/liIfnmoTnl5voi6bpl67popjjgILku47mu57mtqnnmoTmlofkuK3mm7Tlj6/kvZPkvJrlhbblhoXlv4Pmt7HliIfnmoToi6bmpZrvvIzlnKjlrozmiJDmnKznr4fkvZzlk4HkuYvlkI7vvIzlpKrlrrDmsrvnu4jlvZLov5jmmK/pgInmi6nkuobmipXmsLTnmoTmlrnlvI/vvIzkuLrku5boh6rlt7HliJLkuIvmnIDlkI7nmoTlj6XngrnjgILlm6DmraTvvIzjgIrkurrpl7TlpLHmoLzjgIvnrpfmmK/lpKrlrrDmsrvljYroh6rkvKDmgKfkvZzlk4HjgIInXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6J+aWnOmYsycsXG4gICAgICAgIHNjcm9sbDpmYWxzZSxcbiAgICAgICAgYXV0aG9yOiflpKrlrrDmsrsnLFxuICAgICAgICByZW1hcms6J+S4reevh+Wwj+ivtCcsXG4gICAgICAgIGNvbnRlbnQ6J+aVheS6i+mAmui/h+WSjOWtkOeahOesrOS4gOS6uuensOWPmei/sOWSjOW8n+W8n+ebtOayu+eahOaXpeiusOS4jumBl+S5pueahOW9ouW8j+WxleW8gOOAguS4u+imgeiusueahOaYr+S4juS4iOWkq+emu+WpmuWFreW5tOeahOWSjOWtkOWcqOS8iuixhuWxseS4reeahOWIq+WiheWSjOavjeS6suWQjOS9j++8jOavjeS6suWPiOaCo+S4iuS6huiCuue7k+aguOOAguW6lOW+geacjeW9ueeahOW8n+W8n+S4i+iQveS4jeaYju+8jOe7iOS6juW8n+W8n+WkjeWRmOW9kuadpe+8jOS9huS7lueUn+a0u+aUvuiNoeS4jee+gei/mOayvuafk+S4iuavkuWTgeOAguWSjOWtkOaBi+S4iuS6huW3suWpmueahOS4jeiJr+S9nOWutuS4iuWOn++8jOW5tuaipuaDs+eUn+S4i+S4iuWOn+eahOWtqeWtkOOAguacgOWQjuavjeS6sueXheS6oe+8jOW8n+W8n+ebtOayu+eVmeS4i+mBl+S5puiHquadgO+8jOWSjOWtkOihqOekuuWNs+S9v+S8muiiq+mBl+W8g+S5n+imgeeUn+S4i+W5tuaKmuWFu+S4iuWOn+eahOengeeUn+WtkO+8jOWunueOsOmBk+W+t+mdqeWRveOAgicsXG4gICAgfVxuXSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(14);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(4)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvZ2xvYmVsLmNzcz9kNGFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxjQUFjLG1CQUFPLENBQUMsRUFBdUQ7O0FBRTdFLDRDQUE0QyxRQUFTOztBQUVyRDtBQUNBOzs7O0FBSUEsZUFBZTs7QUFFZjtBQUNBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxDQUFnRDs7QUFFckU7O0FBRUEsR0FBRyxLQUFVLEVBQUUiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9nbG9iZWwuY3NzXCIpO1xuXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcblxudmFyIHRyYW5zZm9ybTtcbnZhciBpbnNlcnRJbnRvO1xuXG5cblxudmFyIG9wdGlvbnMgPSB7XCJobXJcIjp0cnVlfVxuXG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxub3B0aW9ucy5pbnNlcnRJbnRvID0gdW5kZWZpbmVkO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanNcIikoY29udGVudCwgb3B0aW9ucyk7XG5cbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuXG5pZihtb2R1bGUuaG90KSB7XG5cdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JlbC5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2dsb2JlbC5jc3NcIik7XG5cblx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblxuXHRcdHZhciBsb2NhbHMgPSAoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0dmFyIGtleSwgaWR4ID0gMDtcblxuXHRcdFx0Zm9yKGtleSBpbiBhKSB7XG5cdFx0XHRcdGlmKCFiIHx8IGFba2V5XSAhPT0gYltrZXldKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlkeCsrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3Ioa2V5IGluIGIpIGlkeC0tO1xuXG5cdFx0XHRyZXR1cm4gaWR4ID09PSAwO1xuXHRcdH0oY29udGVudC5sb2NhbHMsIG5ld0NvbnRlbnQubG9jYWxzKSk7XG5cblx0XHRpZighbG9jYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0Fib3J0aW5nIENTUyBITVIgZHVlIHRvIGNoYW5nZWQgY3NzLW1vZHVsZXMgbG9jYWxzLicpO1xuXG5cdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHR9KTtcblxuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)(false);\n// Module\nexports.push([module.i, "/*vue披风*/\\n[v-cloak] {\\n    display: none;\\n}\\n\\nhtml,body{\\n    height: 100%;\\n}\\n\\ninput::-webkit-outer-spin-button,\\ninput::-webkit-inner-spin-button {\\n    -webkit-appearance: none;\\n}\\n\\n\\ninput[type=\\"number\\"] {\\n    -webkit-appearance: none;\\n    -moz-appearance: none;\\n    appearance: none;\\n}\\n\\n*{\\n    margin: 0;\\n    padding: 0;\\n    box-sizing: border-box;\\n}\\nul,li{\\n    cursor: pointer;\\n    margin: 0;\\n    padding: 0;\\n    list-style: none;\\n}", ""]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvZ2xvYmVsLmNzcz9iNDBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQixtQkFBTyxDQUFDLENBQWdEO0FBQ25GO0FBQ0EsY0FBYyxRQUFTLHlCQUF5QixvQkFBb0IsR0FBRyxjQUFjLG1CQUFtQixHQUFHLHlFQUF5RSwrQkFBK0IsR0FBRyw4QkFBOEIsK0JBQStCLDRCQUE0Qix1QkFBdUIsR0FBRyxNQUFNLGdCQUFnQixpQkFBaUIsNkJBQTZCLEdBQUcsUUFBUSxzQkFBc0IsZ0JBQWdCLGlCQUFpQix1QkFBdUIsR0FBRyIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyp2dWXmiqvpo44qL1xcblt2LWNsb2FrXSB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbmh0bWwsYm9keXtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbn1cXG5cXG5pbnB1dDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcXG5pbnB1dDo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiB7XFxuICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuXFxuaW5wdXRbdHlwZT1cXFwibnVtYmVyXFxcIl0ge1xcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxuICAgIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gICAgYXBwZWFyYW5jZTogbm9uZTtcXG59XFxuXFxuKntcXG4gICAgbWFyZ2luOiAwO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbn1cXG51bCxsaXtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBtYXJnaW46IDA7XFxuICAgIHBhZGRpbmc6IDA7XFxuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XFxufVwiLCBcIlwiXSk7XG5cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./js/components/articleFilter.vue?vue&type=template&id=4ac7893d&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "articleFilter" }, [\n    _c(\n      "div",\n      { staticClass: "labelContainer" },\n      _vm._l(_vm.label, function(label) {\n        return _c(\n          "div",\n          {\n            staticClass: "labelBlock",\n            class: { active: label.choose },\n            on: {\n              click: function($event) {\n                return _vm.choose(label)\n              }\n            }\n          },\n          [_vm._v("\\n            " + _vm._s(label.labelName) + "\\n        ")]\n        )\n      }),\n      0\n    ),\n    _vm._v(" "),\n    _c(\n      "div",\n      { staticClass: "articlePart" },\n      _vm._l(_vm.article, function(article) {\n        return article.show\n          ? _c("div", { staticClass: "article" }, [\n              _vm._v("\\n            " + _vm._s(article.articleName) + " "),\n              _c("span", { staticClass: "articleLabel" }, [\n                _vm._v(_vm._s(_vm.getLabelName(article.articleLabel)))\n              ]),\n              _vm._v(" "),\n              article.scroll\n                ? _c("div", { staticClass: "articleContent" }, [\n                    _vm._v(_vm._s(article.articleContent))\n                  ])\n                : _vm._e()\n            ])\n          : _vm._e()\n      }),\n      0\n    )\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./js/components/articleFilter.vue?vue&type=template&id=4ac7893d&scoped=true&\n/* concated harmony reexport render */__webpack_require__.d(__webpack_exports__, "a", function() { return render; });\n/* concated harmony reexport staticRenderFns */__webpack_require__.d(__webpack_exports__, "b", function() { return staticRenderFns; });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL2FydGljbGVGaWx0ZXIudnVlPzY4YjIiLCJ3ZWJwYWNrOi8vLy4vanMvY29tcG9uZW50cy9hcnRpY2xlRmlsdGVyLnZ1ZT9hYTBkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQSxPQUFPLGdDQUFnQztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sNkJBQTZCO0FBQ3BDO0FBQ0E7QUFDQSx1QkFBdUIseUJBQXlCO0FBQ2hEO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsREE7QUFBQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJhcnRpY2xlRmlsdGVyXCIgfSwgW1xuICAgIF9jKFxuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3RhdGljQ2xhc3M6IFwibGFiZWxDb250YWluZXJcIiB9LFxuICAgICAgX3ZtLl9sKF92bS5sYWJlbCwgZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwibGFiZWxCbG9ja1wiLFxuICAgICAgICAgICAgY2xhc3M6IHsgYWN0aXZlOiBsYWJlbC5jaG9vc2UgfSxcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmNob29zZShsYWJlbClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgW192bS5fdihcIlxcbiAgICAgICAgICAgIFwiICsgX3ZtLl9zKGxhYmVsLmxhYmVsTmFtZSkgKyBcIlxcbiAgICAgICAgXCIpXVxuICAgICAgICApXG4gICAgICB9KSxcbiAgICAgIDBcbiAgICApLFxuICAgIF92bS5fdihcIiBcIiksXG4gICAgX2MoXG4gICAgICBcImRpdlwiLFxuICAgICAgeyBzdGF0aWNDbGFzczogXCJhcnRpY2xlUGFydFwiIH0sXG4gICAgICBfdm0uX2woX3ZtLmFydGljbGUsIGZ1bmN0aW9uKGFydGljbGUpIHtcbiAgICAgICAgcmV0dXJuIGFydGljbGUuc2hvd1xuICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJhcnRpY2xlXCIgfSwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXCJcXG4gICAgICAgICAgICBcIiArIF92bS5fcyhhcnRpY2xlLmFydGljbGVOYW1lKSArIFwiIFwiKSxcbiAgICAgICAgICAgICAgX2MoXCJzcGFuXCIsIHsgc3RhdGljQ2xhc3M6IFwiYXJ0aWNsZUxhYmVsXCIgfSwgW1xuICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLmdldExhYmVsTmFtZShhcnRpY2xlLmFydGljbGVMYWJlbCkpKVxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgYXJ0aWNsZS5zY3JvbGxcbiAgICAgICAgICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiYXJ0aWNsZUNvbnRlbnRcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoYXJ0aWNsZS5hcnRpY2xlQ29udGVudCkpXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgfSksXG4gICAgICAwXG4gICAgKVxuICBdKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsImV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9hcnRpY2xlRmlsdGVyLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD00YWM3ODkzZCZzY29wZWQ9dHJ1ZSZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _articleFilter_vue_vue_type_template_id_4ac7893d_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);\n/* harmony import */ var _articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \'default\') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(\n  _articleFilter_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],\n  _articleFilter_vue_vue_type_template_id_4ac7893d_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* render */ "a"],\n  _articleFilter_vue_vue_type_template_id_4ac7893d_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* staticRenderFns */ "b"],\n  false,\n  null,\n  "4ac7893d",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "js/components/articleFilter.vue"\n/* harmony default export */ __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL2FydGljbGVGaWx0ZXIudnVlP2Y4ZTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUF3RztBQUN2QztBQUNMOzs7QUFHNUQ7QUFDMEY7QUFDMUYsZ0JBQWdCLG1IQUFVO0FBQzFCLEVBQUUsbUZBQU07QUFDUixFQUFFLDRHQUFNO0FBQ1IsRUFBRSxxSEFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBVSxFQUFFLFlBaUJmO0FBQ0Q7QUFDZSxnRiIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vYXJ0aWNsZUZpbHRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NGFjNzg5M2Qmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vYXJ0aWNsZUZpbHRlci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL2FydGljbGVGaWx0ZXIudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI0YWM3ODkzZFwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIi9Vc2Vycy9zaGFvamlhaHVpL0Rlc2t0b3Avc2hhb2ppYWh1aeWtpuS5oOW3peS9nOaWh+S7tuWkuS93ZWJzYXZlL3JlLWRhaWx5L25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc0YWM3ODkzZCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc0YWM3ODkzZCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vYXJ0aWNsZUZpbHRlci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NGFjNzg5M2Qmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNGFjNzg5M2QnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcImpzL2NvbXBvbmVudHMvYXJ0aWNsZUZpbHRlci52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n')},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(18);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(4)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXJ0aWNsZUZpbHRlci5jc3M/NmM1NyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQThEOztBQUVwRiw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsQ0FBZ0Q7O0FBRXJFOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYXJ0aWNsZUZpbHRlci5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYXJ0aWNsZUZpbHRlci5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2FydGljbGVGaWx0ZXIuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)(false);\n// Module\nexports.push([module.i, ".articleFilter{\\n    padding: 15px;\\n}\\n\\n.labelContainer{\\n    display: flex;\\n    justify-content: left;\\n    width: 50%;\\n    margin: 0 auto;\\n}\\n\\n.labelBlock{\\n    padding: 5px 15px;\\n    margin: 0 5px;\\n    border-radius: 15px;\\n    border: 1px solid cornflowerblue;\\n    background-color: #fff;\\n    color: cornflowerblue;\\n    font-size: 14px;\\n    cursor: pointer;\\n}\\n\\n.labelBlockadd{\\n    padding: 5px 10px;\\n    border-radius: 50%;\\n}\\n\\n.active{\\n    border: 1px solid cornflowerblue;\\n    color: #fff;\\n    background-color: cornflowerblue;\\n}\\n\\n.articlePart{\\n    margin-top: 30px;\\n}\\n\\n.article{\\n    width: 49%;\\n    margin: 10px auto;\\n    padding: 15px;\\n    border: 1px solid cornflowerblue;\\n    border-radius: 10px;\\n    font-size: 14px;\\n    font-weight: bold;\\n}\\n\\n.articleLabel{\\n    float: right;\\n    font-size: 10px;\\n    color: cornflowerblue;\\n    font-weight: lighter;\\n}\\n\\n.articleContent{\\n    margin-top: 10px;\\n    font-size: 12px;\\n    font-weight: normal;\\n    color: #333333;\\n}", ""]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3MvYXJ0aWNsZUZpbHRlci5jc3M/NDFhYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFnRDtBQUNuRjtBQUNBLGNBQWMsUUFBUyxrQkFBa0Isb0JBQW9CLEdBQUcsb0JBQW9CLG9CQUFvQiw0QkFBNEIsaUJBQWlCLHFCQUFxQixHQUFHLGdCQUFnQix3QkFBd0Isb0JBQW9CLDBCQUEwQix1Q0FBdUMsNkJBQTZCLDRCQUE0QixzQkFBc0Isc0JBQXNCLEdBQUcsbUJBQW1CLHdCQUF3Qix5QkFBeUIsR0FBRyxZQUFZLHVDQUF1QyxrQkFBa0IsdUNBQXVDLEdBQUcsaUJBQWlCLHVCQUF1QixHQUFHLGFBQWEsaUJBQWlCLHdCQUF3QixvQkFBb0IsdUNBQXVDLDBCQUEwQixzQkFBc0Isd0JBQXdCLEdBQUcsa0JBQWtCLG1CQUFtQixzQkFBc0IsNEJBQTRCLDJCQUEyQixHQUFHLG9CQUFvQix1QkFBdUIsc0JBQXNCLDBCQUEwQixxQkFBcUIsR0FBRyIsImZpbGUiOiIxOC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLmFydGljbGVGaWx0ZXJ7XFxuICAgIHBhZGRpbmc6IDE1cHg7XFxufVxcblxcbi5sYWJlbENvbnRhaW5lcntcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBsZWZ0O1xcbiAgICB3aWR0aDogNTAlO1xcbiAgICBtYXJnaW46IDAgYXV0bztcXG59XFxuXFxuLmxhYmVsQmxvY2t7XFxuICAgIHBhZGRpbmc6IDVweCAxNXB4O1xcbiAgICBtYXJnaW46IDAgNXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCBjb3JuZmxvd2VyYmx1ZTtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgY29sb3I6IGNvcm5mbG93ZXJibHVlO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmxhYmVsQmxvY2thZGR7XFxuICAgIHBhZGRpbmc6IDVweCAxMHB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA1MCU7XFxufVxcblxcbi5hY3RpdmV7XFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIGNvcm5mbG93ZXJibHVlO1xcbiAgICBjb2xvcjogI2ZmZjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29ybmZsb3dlcmJsdWU7XFxufVxcblxcbi5hcnRpY2xlUGFydHtcXG4gICAgbWFyZ2luLXRvcDogMzBweDtcXG59XFxuXFxuLmFydGljbGV7XFxuICAgIHdpZHRoOiA0OSU7XFxuICAgIG1hcmdpbjogMTBweCBhdXRvO1xcbiAgICBwYWRkaW5nOiAxNXB4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCBjb3JuZmxvd2VyYmx1ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLmFydGljbGVMYWJlbHtcXG4gICAgZmxvYXQ6IHJpZ2h0O1xcbiAgICBmb250LXNpemU6IDEwcHg7XFxuICAgIGNvbG9yOiBjb3JuZmxvd2VyYmx1ZTtcXG4gICAgZm9udC13ZWlnaHQ6IGxpZ2h0ZXI7XFxufVxcblxcbi5hcnRpY2xlQ29udGVudHtcXG4gICAgbWFyZ2luLXRvcDogMTBweDtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xcbiAgICBjb2xvcjogIzMzMzMzMztcXG59XCIsIFwiXCJdKTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n')},,,,,,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2UudnVlP2E2ZGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBa0wsQ0FBZ0IsbVBBQUcsRUFBQyIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NpbmdsZVBhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zaW5nbGVQYWdlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _singlePageArticle = __webpack_require__(64);\n\nvar _singlePageArticle2 = _interopRequireDefault(_singlePageArticle);\n\nvar _singlePageFans = __webpack_require__(67);\n\nvar _singlePageFans2 = _interopRequireDefault(_singlePageFans);\n\nvar _articleFilter = __webpack_require__(16);\n\nvar _articleFilter2 = _interopRequireDefault(_articleFilter);\n\n__webpack_require__(13);\n\n__webpack_require__(68);\n\nvar _dataSave = __webpack_require__(12);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar array = [_dataSave.article, _dataSave.firends]; //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n    name: \"singlePage\",\n    data: function data() {\n        return {\n            compList: [{ compName: 'singlePageFans' }, { compName: 'singlePageArticle' }, { compName: 'articleFilter' }],\n            showComp: '',\n            commData: array\n        };\n    },\n\n    components: { singlePageFans: _singlePageFans2.default, singlePageArticle: _singlePageArticle2.default, articleFilter: _articleFilter2.default },\n    methods: {\n        changeComp: function changeComp(a) {\n            this.showComp = a;\n        }\n    }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvY29tcG9uZW50cy9zaW5nbGVQYWdlLnZ1ZT9iMzdjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQXdDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7QUFDQTs7QUFFQTs7OztBQUdBLG1EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQUVBO0FBQ0Esc0JBREE7QUFFQSxRQUZBLGtCQUVBO0FBQ0E7QUFDQSx1QkFDQSw4QkFEQSxFQUNBLGlDQURBLEVBQ0EsNkJBREEsQ0FEQTtBQUlBLHdCQUpBO0FBS0E7QUFMQTtBQU9BLEtBVkE7O0FBV0Esb0pBWEE7QUFZQTtBQUNBLGtCQURBLHNCQUNBLENBREEsRUFDQTtBQUNBO0FBQ0E7QUFIQTtBQVpBLEMiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gICAgPGRpdiBjbGFzcz1cImNvblwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiaGVscFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidGFiR3JvdXBcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiXCIgdi1vbjpjbGljaz1cImNoYW5nZUNvbXAoJ3NpbmdsZVBhZ2VBcnRpY2xlJylcIj5cbiAgICAgICAgICAgICAgICAgICAgPHJ1Ynk+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBjb21tRGF0YVswXS5sZW5ndGggfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxydD7ml6XmnKzmloflraY8L3J0PlxuICAgICAgICAgICAgICAgICAgICA8L3J1Ynk+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhYlwiIHYtb246Y2xpY2s9XCJjaGFuZ2VDb21wKCdzaW5nbGVQYWdlRmFucycpXCI+XG4gICAgICAgICAgICAgICAgICAgIDxydWJ5PlxuICAgICAgICAgICAgICAgICAgICAgICAge3sgY29tbURhdGFbMV0ubGVuZ3RoIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8cnQ+57KJ5Lid5pWw6YePPC9ydD5cbiAgICAgICAgICAgICAgICAgICAgPC9ydWJ5PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0YWJcIiB2LW9uOmNsaWNrPVwiY2hhbmdlQ29tcCgnc2luZ2xlUGFnZUZhbnMnKVwiPlxuICAgICAgICAgICAgICAgICAgICA8cnVieT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHt7IGNvbW1EYXRhWzFdLmxlbmd0aCB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPHJ0PuaWh+eroOivhOiuujwvcnQ+XG4gICAgICAgICAgICAgICAgICAgIDwvcnVieT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidGFiXCIgdi1vbjpjbGljaz1cImNoYW5nZUNvbXAoJ3NpbmdsZVBhZ2VGYW5zJylcIj5cbiAgICAgICAgICAgICAgICAgICAgPHJ1Ynk+XG4gICAgICAgICAgICAgICAgICAgICAgICB7eyBjb21tRGF0YVsxXS5sZW5ndGggfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDxydD7llpzmrKLmlofnq6A8L3J0PlxuICAgICAgICAgICAgICAgICAgICA8L3J1Ynk+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1haW5cIj5cbiAgICAgICAgICAgIDxrZWVwLWFsaXZlPlxuICAgICAgICAgICAgICAgIDxjb21wb25lbnQgdi1iaW5kOmlzPVwic2hvd0NvbXBcIiA6ZGF0YT1cImNvbW1EYXRhXCI+PC9jb21wb25lbnQ+XG4gICAgICAgICAgICA8L2tlZXAtYWxpdmU+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAgIGltcG9ydCBzaW5nbGVQYWdlQXJ0aWNsZSBmcm9tICcuLi9jb21wb25lbnRzL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZSdcbiAgICBpbXBvcnQgc2luZ2xlUGFnZUZhbnMgZnJvbSAnLi4vY29tcG9uZW50cy9zaW5nbGVQYWdlRmFucy52dWUnXG4gICAgaW1wb3J0IGFydGljbGVGaWx0ZXIgZnJvbSAnLi4vY29tcG9uZW50cy9hcnRpY2xlRmlsdGVyLnZ1ZSdcblxuICAgIGltcG9ydCAnLi4vLi4vY3NzL2dsb2JlbC5jc3MnXG4gICAgaW1wb3J0ICcuLi8uLi9jc3Mvc2luZ2xlUGFnZS5jc3MnXG5cbiAgICBpbXBvcnQge2FydGljbGUgYXMgYWZ9IGZyb20gJy4uL2RhdGFTYXZlL2RhdGFTYXZlLmpzJ1xuICAgIGltcG9ydCB7ZmlyZW5kcyBhcyBmcmR9IGZyb20gJy4uL2RhdGFTYXZlL2RhdGFTYXZlLmpzJ1xuXG4gICAgbGV0IGFycmF5ID0gW2FmLGZyZF07XG5cbiAgICBleHBvcnQgZGVmYXVsdCB7XG4gICAgICAgIG5hbWU6IFwic2luZ2xlUGFnZVwiLFxuICAgICAgICBkYXRhKCl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbXBMaXN0OltcbiAgICAgICAgICAgICAgICAgICAge2NvbXBOYW1lOidzaW5nbGVQYWdlRmFucyd9LHtjb21wTmFtZTonc2luZ2xlUGFnZUFydGljbGUnfSx7Y29tcE5hbWU6J2FydGljbGVGaWx0ZXInfVxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgc2hvd0NvbXA6JycsXG4gICAgICAgICAgICAgICAgY29tbURhdGE6YXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9uZW50czp7c2luZ2xlUGFnZUZhbnMsc2luZ2xlUGFnZUFydGljbGUsYXJ0aWNsZUZpbHRlcn0sXG4gICAgICAgIG1ldGhvZHM6e1xuICAgICAgICAgICAgY2hhbmdlQ29tcChhKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dDb21wID0gYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT8zMzY4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXlMLENBQWdCLDBQQUFHLEVBQUMiLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zaW5nbGVQYWdlQXJ0aWNsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n\n__webpack_require__(65);\n\nexports.default = {\n    name: "singlePageArticle",\n    props: [\'data\']\n}; //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n////# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvY29tcG9uZW50cy9zaW5nbGVQYWdlQXJ0aWNsZS52dWU/MjNmYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFnQkE7O2tCQUVBO0FBQ0EsNkJBREE7QUFFQTtBQUZBLEMiLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImFydGljbGVCbG9ja1wiIHYtZm9yPVwiZGF0YSBpbiBkYXRhWzBdXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibmFtZVwiPnt7ZGF0YS5uYW1lfX08L2Rpdj5cbiAgICAgICAgICAgIDx0cmFuc2l0aW9uPlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiY29udGVudFwiPnt7IGRhdGEuY29udGVudCB9fTwvcD5cbiAgICAgICAgICAgIDwvdHJhbnNpdGlvbj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJib29rTWVzc2FnZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYXV0aG9yXCI+e3sgZGF0YS5hdXRob3IgfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJyZW1hcmtcIj57eyBkYXRhLnJlbWFyayB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0ICcuLi8uLi9jc3Mvc2luZ2xlUGFnZUFydGljbGUuY3NzJ1xuXG4gICAgZXhwb3J0IGRlZmF1bHQge1xuICAgICAgICBuYW1lOiBcInNpbmdsZVBhZ2VBcnRpY2xlXCIsXG4gICAgICAgIHByb3BzOlsnZGF0YSddLFxuICAgIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXG48L3N0eWxlPiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_ref_0_node_modules_vue_loader_lib_index_js_vue_loader_options_singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2VGYW5zLnZ1ZT9kMDYwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXNMLENBQWdCLHVQQUFHLEVBQUMiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9yZWYtLTAhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9zaW5nbGVQYWdlRmFucy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P3JlZi0tMCEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NpbmdsZVBhZ2VGYW5zLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///29\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nexports.default = {\n    name: "singlePageFans",\n    props: [\'data\']\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvY29tcG9uZW50cy9zaW5nbGVQYWdlRmFucy52dWU/ZjllMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tCQWNBO0FBQ0EsMEJBREE7QUFFQTtBQUZBLEMiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPGRpdiB2LWZvcj1cImRhdGEgaW4gZGF0YVsxXVwiPlxuICAgICAgICAgICAgPGgzPlxuICAgICAgICAgICAgICAgIHt7IGRhdGEubmFtZSB9fVxuICAgICAgICAgICAgICAgIDxzbWFsbCB2LWlmPVwiZGF0YS5zZXhcIj5ib3k8L3NtYWxsPlxuICAgICAgICAgICAgICAgIDxzbWFsbCB2LWVsc2U+Z2lybDwvc21hbGw+XG4gICAgICAgICAgICA8L2gzPlxuICAgICAgICAgICAgPHA+e3sgZGF0YS5waG9uZSB9fTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgICAgbmFtZTogXCJzaW5nbGVQYWdlRmFuc1wiLFxuICAgICAgICBwcm9wczpbJ2RhdGEnXSxcbiAgICB9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblxuPC9zdHlsZT4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n')},,,,,,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./js/components/singlePage.vue?vue&type=template&id=5b997bd8&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c("div", { staticClass: "con" }, [\n    _c("div", { staticClass: "help" }, [\n      _c("div", { staticClass: "tabGroup" }, [\n        _c(\n          "div",\n          {\n            staticClass: "tab",\n            on: {\n              click: function($event) {\n                return _vm.changeComp("singlePageArticle")\n              }\n            }\n          },\n          [\n            _c("ruby", [\n              _vm._v(\n                "\\n                    " +\n                  _vm._s(_vm.commData[0].length) +\n                  "\\n                    "\n              ),\n              _c("rt", [_vm._v("日本文学")])\n            ])\n          ]\n        ),\n        _vm._v(" "),\n        _c(\n          "div",\n          {\n            staticClass: "tab",\n            on: {\n              click: function($event) {\n                return _vm.changeComp("singlePageFans")\n              }\n            }\n          },\n          [\n            _c("ruby", [\n              _vm._v(\n                "\\n                    " +\n                  _vm._s(_vm.commData[1].length) +\n                  "\\n                    "\n              ),\n              _c("rt", [_vm._v("粉丝数量")])\n            ])\n          ]\n        ),\n        _vm._v(" "),\n        _c(\n          "div",\n          {\n            staticClass: "tab",\n            on: {\n              click: function($event) {\n                return _vm.changeComp("singlePageFans")\n              }\n            }\n          },\n          [\n            _c("ruby", [\n              _vm._v(\n                "\\n                    " +\n                  _vm._s(_vm.commData[1].length) +\n                  "\\n                    "\n              ),\n              _c("rt", [_vm._v("文章评论")])\n            ])\n          ]\n        ),\n        _vm._v(" "),\n        _c(\n          "div",\n          {\n            staticClass: "tab",\n            on: {\n              click: function($event) {\n                return _vm.changeComp("singlePageFans")\n              }\n            }\n          },\n          [\n            _c("ruby", [\n              _vm._v(\n                "\\n                    " +\n                  _vm._s(_vm.commData[1].length) +\n                  "\\n                    "\n              ),\n              _c("rt", [_vm._v("喜欢文章")])\n            ])\n          ]\n        )\n      ])\n    ]),\n    _vm._v(" "),\n    _c(\n      "div",\n      { staticClass: "main" },\n      [\n        _c(\n          "keep-alive",\n          [\n            _c(_vm.showComp, {\n              tag: "component",\n              attrs: { data: _vm.commData }\n            })\n          ],\n          1\n        )\n      ],\n      1\n    )\n  ])\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./js/components/singlePage.vue?vue&type=template&id=5b997bd8&scoped=true&\n/* concated harmony reexport render */__webpack_require__.d(__webpack_exports__, "a", function() { return render; });\n/* concated harmony reexport staticRenderFns */__webpack_require__.d(__webpack_exports__, "b", function() { return staticRenderFns; });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2UudnVlPzJhMmYiLCJ3ZWJwYWNrOi8vLy4vanMvY29tcG9uZW50cy9zaW5nbGVQYWdlLnZ1ZT8yMmRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDLGVBQWUsc0JBQXNCO0FBQ3JDLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxzQkFBc0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JIQTtBQUFBIiwiZmlsZSI6IjM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvblwiIH0sIFtcbiAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImhlbHBcIiB9LCBbXG4gICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInRhYkdyb3VwXCIgfSwgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYlwiLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uY2hhbmdlQ29tcChcInNpbmdsZVBhZ2VBcnRpY2xlXCIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwicnVieVwiLCBbXG4gICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS5jb21tRGF0YVswXS5sZW5ndGgpICtcbiAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfYyhcInJ0XCIsIFtfdm0uX3YoXCLml6XmnKzmloflraZcIildKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdXG4gICAgICAgICksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFxuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwidGFiXCIsXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF92bS5jaGFuZ2VDb21wKFwic2luZ2xlUGFnZUZhbnNcIilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgW1xuICAgICAgICAgICAgX2MoXCJydWJ5XCIsIFtcbiAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICBfdm0uX3MoX3ZtLmNvbW1EYXRhWzFdLmxlbmd0aCkgK1xuICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIF9jKFwicnRcIiwgW192bS5fdihcIueyieS4neaVsOmHj1wiKV0pXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIF1cbiAgICAgICAgKSxcbiAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgX2MoXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0YWJcIixcbiAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3ZtLmNoYW5nZUNvbXAoXCJzaW5nbGVQYWdlRmFuc1wiKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhcInJ1YnlcIiwgW1xuICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0uY29tbURhdGFbMV0ubGVuZ3RoKSArXG4gICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgX2MoXCJydFwiLCBbX3ZtLl92KFwi5paH56ug6K+E6K66XCIpXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXVxuICAgICAgICApLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfYyhcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcInRhYlwiLFxuICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdm0uY2hhbmdlQ29tcChcInNpbmdsZVBhZ2VGYW5zXCIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIF9jKFwicnVieVwiLCBbXG4gICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS5jb21tRGF0YVsxXS5sZW5ndGgpICtcbiAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBfYyhcInJ0XCIsIFtfdm0uX3YoXCLllpzmrKLmlofnq6BcIildKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICBdXG4gICAgICAgIClcbiAgICAgIF0pXG4gICAgXSksXG4gICAgX3ZtLl92KFwiIFwiKSxcbiAgICBfYyhcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IHN0YXRpY0NsYXNzOiBcIm1haW5cIiB9LFxuICAgICAgW1xuICAgICAgICBfYyhcbiAgICAgICAgICBcImtlZXAtYWxpdmVcIixcbiAgICAgICAgICBbXG4gICAgICAgICAgICBfYyhfdm0uc2hvd0NvbXAsIHtcbiAgICAgICAgICAgICAgdGFnOiBcImNvbXBvbmVudFwiLFxuICAgICAgICAgICAgICBhdHRyczogeyBkYXRhOiBfdm0uY29tbURhdGEgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICBdLFxuICAgICAgICAgIDFcbiAgICAgICAgKVxuICAgICAgXSxcbiAgICAgIDFcbiAgICApXG4gIF0pXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NpbmdsZVBhZ2UudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTViOTk3YmQ4JnNjb3BlZD10cnVlJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n')},,function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./js/components/singlePageFans.vue?vue&type=template&id=136b37b8&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "div",\n    _vm._l(_vm.data[1], function(data) {\n      return _c("div", [\n        _c("h3", [\n          _vm._v("\\n            " + _vm._s(data.name) + "\\n            "),\n          data.sex\n            ? _c("small", [_vm._v("boy")])\n            : _c("small", [_vm._v("girl")])\n        ]),\n        _vm._v(" "),\n        _c("p", [_vm._v(_vm._s(data.phone))])\n      ])\n    }),\n    0\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./js/components/singlePageFans.vue?vue&type=template&id=136b37b8&scoped=true&\n/* concated harmony reexport render */__webpack_require__.d(__webpack_exports__, "a", function() { return render; });\n/* concated harmony reexport staticRenderFns */__webpack_require__.d(__webpack_exports__, "b", function() { return staticRenderFns; });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2VGYW5zLnZ1ZT84NWYwIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvc2luZ2xlUGFnZUZhbnMudnVlPzI4ZDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0QkE7QUFBQSIsImZpbGUiOiIzOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICBfdm0uX2woX3ZtLmRhdGFbMV0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBfYyhcImRpdlwiLCBbXG4gICAgICAgIF9jKFwiaDNcIiwgW1xuICAgICAgICAgIF92bS5fdihcIlxcbiAgICAgICAgICAgIFwiICsgX3ZtLl9zKGRhdGEubmFtZSkgKyBcIlxcbiAgICAgICAgICAgIFwiKSxcbiAgICAgICAgICBkYXRhLnNleFxuICAgICAgICAgICAgPyBfYyhcInNtYWxsXCIsIFtfdm0uX3YoXCJib3lcIildKVxuICAgICAgICAgICAgOiBfYyhcInNtYWxsXCIsIFtfdm0uX3YoXCJnaXJsXCIpXSlcbiAgICAgICAgXSksXG4gICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgIF9jKFwicFwiLCBbX3ZtLl92KF92bS5fcyhkYXRhLnBob25lKSldKVxuICAgICAgXSlcbiAgICB9KSxcbiAgICAwXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCJleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vc2luZ2xlUGFnZUZhbnMudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTEzNmIzN2I4JnNjb3BlZD10cnVlJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./js/components/singlePageArticle.vue?vue&type=template&id=66e20b2e&scoped=true&\nvar render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    "div",\n    _vm._l(_vm.data[0], function(data) {\n      return _c(\n        "div",\n        { staticClass: "articleBlock" },\n        [\n          _c("div", { staticClass: "name" }, [_vm._v(_vm._s(data.name))]),\n          _vm._v(" "),\n          _c("transition", [\n            _c("p", { staticClass: "content" }, [_vm._v(_vm._s(data.content))])\n          ]),\n          _vm._v(" "),\n          _c("div", { staticClass: "bookMessage" }, [\n            _c("span", { staticClass: "author" }, [\n              _vm._v(_vm._s(data.author))\n            ]),\n            _vm._v(" "),\n            _c("span", { staticClass: "remark" }, [_vm._v(_vm._s(data.remark))])\n          ])\n        ],\n        1\n      )\n    }),\n    0\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n\n// CONCATENATED MODULE: ./js/components/singlePageArticle.vue?vue&type=template&id=66e20b2e&scoped=true&\n/* concated harmony reexport render */__webpack_require__.d(__webpack_exports__, "a", function() { return render; });\n/* concated harmony reexport staticRenderFns */__webpack_require__.d(__webpack_exports__, "b", function() { return staticRenderFns; });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT9jMTBhIiwid2VicGFjazovLy8uL2pzL2NvbXBvbmVudHMvc2luZ2xlUGFnZUFydGljbGUudnVlPzM4NjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhCQUE4QjtBQUN2QztBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7QUFDQTtBQUNBLHFCQUFxQix5QkFBeUI7QUFDOUM7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQsd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7QUFBQSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICBfdm0uX2woX3ZtLmRhdGFbMF0sIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBfYyhcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAgeyBzdGF0aWNDbGFzczogXCJhcnRpY2xlQmxvY2tcIiB9LFxuICAgICAgICBbXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJuYW1lXCIgfSwgW192bS5fdihfdm0uX3MoZGF0YS5uYW1lKSldKSxcbiAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgIF9jKFwidHJhbnNpdGlvblwiLCBbXG4gICAgICAgICAgICBfYyhcInBcIiwgeyBzdGF0aWNDbGFzczogXCJjb250ZW50XCIgfSwgW192bS5fdihfdm0uX3MoZGF0YS5jb250ZW50KSldKVxuICAgICAgICAgIF0pLFxuICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJib29rTWVzc2FnZVwiIH0sIFtcbiAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImF1dGhvclwiIH0sIFtcbiAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhkYXRhLmF1dGhvcikpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICBfYyhcInNwYW5cIiwgeyBzdGF0aWNDbGFzczogXCJyZW1hcmtcIiB9LCBbX3ZtLl92KF92bS5fcyhkYXRhLnJlbWFyaykpXSlcbiAgICAgICAgICBdKVxuICAgICAgICBdLFxuICAgICAgICAxXG4gICAgICApXG4gICAgfSksXG4gICAgMFxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IiwiZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02NmUyMGIyZSZzY29wZWQ9dHJ1ZSZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n')},,,,,,,,,,,,,,,,,,,,,,function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _vue = __webpack_require__(5);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _singlePage = __webpack_require__(63);\n\nvar _singlePage2 = _interopRequireDefault(_singlePage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar singlePageL = new _vue2.default({\n    el: '#singlePage',\n    components: { singlePage: _singlePage2.default }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9tYWluU2luZ2xlUGFnZS5qcz9jMTIzIl0sIm5hbWVzIjpbInNpbmdsZVBhZ2VMIiwiVnVlIiwiZWwiLCJjb21wb25lbnRzIiwic2luZ2xlUGFnZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7OztBQUNBOzs7Ozs7QUFFQSxJQUFJQSxjQUFjLElBQUlDLGFBQUosQ0FBUTtBQUN0QkMsUUFBRyxhQURtQjtBQUV0QkMsZ0JBQVcsRUFBQ0MsZ0NBQUQ7QUFGVyxDQUFSLENBQWxCIiwiZmlsZSI6IjYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFZ1ZSBmcm9tICd2dWUnXG5pbXBvcnQgc2luZ2xlUGFnZSBmcm9tICcuLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2UudnVlJ1xuXG5sZXQgc2luZ2xlUGFnZUwgPSBuZXcgVnVlKHtcbiAgICBlbDonI3NpbmdsZVBhZ2UnLFxuICAgIGNvbXBvbmVudHM6e3NpbmdsZVBhZ2V9XG59KSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _singlePage_vue_vue_type_template_id_5b997bd8_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37);\n/* harmony import */ var _singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \'default\') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(\n  _singlePage_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],\n  _singlePage_vue_vue_type_template_id_5b997bd8_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* render */ "a"],\n  _singlePage_vue_vue_type_template_id_5b997bd8_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* staticRenderFns */ "b"],\n  false,\n  null,\n  "5b997bd8",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "js/components/singlePage.vue"\n/* harmony default export */ __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2UudnVlP2JlYzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFxRztBQUN2QztBQUNMOzs7QUFHekQ7QUFDMEY7QUFDMUYsZ0JBQWdCLG1IQUFVO0FBQzFCLEVBQUUsZ0ZBQU07QUFDUixFQUFFLHlHQUFNO0FBQ1IsRUFBRSxrSEFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUksS0FBVSxFQUFFLFlBaUJmO0FBQ0Q7QUFDZSxnRiIsImZpbGUiOiI2My5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vc2luZ2xlUGFnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWI5OTdiZDgmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vc2luZ2xlUGFnZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL3NpbmdsZVBhZ2UudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI1Yjk5N2JkOFwiLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkge1xuICB2YXIgYXBpID0gcmVxdWlyZShcIi9Vc2Vycy9zaGFvamlhaHVpL0Rlc2t0b3Avc2hhb2ppYWh1aeWtpuS5oOW3peS9nOaWh+S7tuWkuS93ZWJzYXZlL3JlLWRhaWx5L25vZGVfbW9kdWxlcy92dWUtaG90LXJlbG9hZC1hcGkvZGlzdC9pbmRleC5qc1wiKVxuICBhcGkuaW5zdGFsbChyZXF1aXJlKCd2dWUnKSlcbiAgaWYgKGFwaS5jb21wYXRpYmxlKSB7XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICAgIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCc1Yjk5N2JkOCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCc1Yjk5N2JkOCcsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vc2luZ2xlUGFnZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NWI5OTdiZDgmc2NvcGVkPXRydWUmXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFwaS5yZXJlbmRlcignNWI5OTdiZDgnLCB7XG4gICAgICAgIHJlbmRlcjogcmVuZGVyLFxuICAgICAgICBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZuc1xuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcImpzL2NvbXBvbmVudHMvc2luZ2xlUGFnZS52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///63\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _singlePageArticle_vue_vue_type_template_id_66e20b2e_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);\n/* harmony import */ var _singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \'default\') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(\n  _singlePageArticle_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],\n  _singlePageArticle_vue_vue_type_template_id_66e20b2e_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* render */ "a"],\n  _singlePageArticle_vue_vue_type_template_id_66e20b2e_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* staticRenderFns */ "b"],\n  false,\n  null,\n  "66e20b2e",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "js/components/singlePageArticle.vue"\n/* harmony default export */ __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT80YmI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNEc7QUFDdkM7QUFDTDs7O0FBR2hFO0FBQzBGO0FBQzFGLGdCQUFnQixtSEFBVTtBQUMxQixFQUFFLHVGQUFNO0FBQ1IsRUFBRSxnSEFBTTtBQUNSLEVBQUUseUhBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLEtBQVUsRUFBRSxZQWlCZjtBQUNEO0FBQ2UsZ0YiLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02NmUyMGIyZSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9zaW5nbGVQYWdlQXJ0aWNsZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNjZlMjBiMmVcIixcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvVXNlcnMvc2hhb2ppYWh1aS9EZXNrdG9wL3NoYW9qaWFodWnlrabkuaDlt6XkvZzmlofku7blpLkvd2Vic2F2ZS9yZS1kYWlseS9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnNjZlMjBiMmUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnNjZlMjBiMmUnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NpbmdsZVBhZ2VBcnRpY2xlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02NmUyMGIyZSZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc2NmUyMGIyZScsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwianMvY29tcG9uZW50cy9zaW5nbGVQYWdlQXJ0aWNsZS52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///64\n')},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(66);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(4)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3Mvc2luZ2xlUGFnZUFydGljbGUuY3NzPzdkOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFrRTs7QUFFeEYsNENBQTRDLFFBQVM7O0FBRXJEO0FBQ0E7Ozs7QUFJQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLENBQWdEOztBQUVyRTs7QUFFQSxHQUFHLEtBQVUsRUFBRSIsImZpbGUiOiI2NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NpbmdsZVBhZ2VBcnRpY2xlLmNzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zaW5nbGVQYWdlQXJ0aWNsZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NpbmdsZVBhZ2VBcnRpY2xlLmNzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///65\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)(false);\n// Module\nexports.push([module.i, ".articleBlock{\\n    margin: 5px auto;\\n    padding: 5px;\\n    border-bottom: 1px solid #333333;\\n}\\n.name{\\n    font-size: 18px;\\n}\\n.bookMessage{\\n    display: flex;\\n    flex-wrap: wrap;\\n}\\n.remark,.author{\\n    font-size: 12px;\\n    color: #333333;\\n    display: block;\\n    padding: 5px 5px 5px 0;\\n}\\n.content{\\n    width: 100%;\\n    font-size: 14px;\\n    font-weight: normal;\\n    color: #333333;\\n    padding: 10px 0;\\n    text-overflow: ellipsis;\\n    white-space: nowrap;\\n    overflow: hidden;\\n}\\n\\n.scroll-enter-active{\\n    animation: scroll .5s;\\n}\\n\\n.scroll-leave-active{\\n    animation: scroll 1s reverse;\\n}\\n\\n@keyframes scroll {\\n    0% {\\n        height: 300px;\\n    }\\n    100% {\\n        height: 0;\\n    }\\n}\\n", ""]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3Mvc2luZ2xlUGFnZUFydGljbGUuY3NzPzkxN2EiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsQ0FBZ0Q7QUFDbkY7QUFDQSxjQUFjLFFBQVMsaUJBQWlCLHVCQUF1QixtQkFBbUIsdUNBQXVDLEdBQUcsUUFBUSxzQkFBc0IsR0FBRyxlQUFlLG9CQUFvQixzQkFBc0IsR0FBRyxrQkFBa0Isc0JBQXNCLHFCQUFxQixxQkFBcUIsNkJBQTZCLEdBQUcsV0FBVyxrQkFBa0Isc0JBQXNCLDBCQUEwQixxQkFBcUIsc0JBQXNCLDhCQUE4QiwwQkFBMEIsdUJBQXVCLEdBQUcseUJBQXlCLDRCQUE0QixHQUFHLHlCQUF5QixtQ0FBbUMsR0FBRyx1QkFBdUIsVUFBVSx3QkFBd0IsT0FBTyxZQUFZLG9CQUFvQixPQUFPLEdBQUciLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5hcnRpY2xlQmxvY2t7XFxuICAgIG1hcmdpbjogNXB4IGF1dG87XFxuICAgIHBhZGRpbmc6IDVweDtcXG4gICAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICMzMzMzMzM7XFxufVxcbi5uYW1le1xcbiAgICBmb250LXNpemU6IDE4cHg7XFxufVxcbi5ib29rTWVzc2FnZXtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC13cmFwOiB3cmFwO1xcbn1cXG4ucmVtYXJrLC5hdXRob3J7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbiAgICBwYWRkaW5nOiA1cHggNXB4IDVweCAwO1xcbn1cXG4uY29udGVudHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gICAgY29sb3I6ICMzMzMzMzM7XFxuICAgIHBhZGRpbmc6IDEwcHggMDtcXG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XFxuICAgIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbi5zY3JvbGwtZW50ZXItYWN0aXZle1xcbiAgICBhbmltYXRpb246IHNjcm9sbCAuNXM7XFxufVxcblxcbi5zY3JvbGwtbGVhdmUtYWN0aXZle1xcbiAgICBhbmltYXRpb246IHNjcm9sbCAxcyByZXZlcnNlO1xcbn1cXG5cXG5Aa2V5ZnJhbWVzIHNjcm9sbCB7XFxuICAgIDAlIHtcXG4gICAgICAgIGhlaWdodDogMzAwcHg7XFxuICAgIH1cXG4gICAgMTAwJSB7XFxuICAgICAgICBoZWlnaHQ6IDA7XFxuICAgIH1cXG59XFxuXCIsIFwiXCJdKTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _singlePageFans_vue_vue_type_template_id_136b37b8_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);\n/* harmony import */ var _singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== \'default\') (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(\n  _singlePageFans_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__["default"],\n  _singlePageFans_vue_vue_type_template_id_136b37b8_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* render */ "a"],\n  _singlePageFans_vue_vue_type_template_id_136b37b8_scoped_true___WEBPACK_IMPORTED_MODULE_0__[/* staticRenderFns */ "b"],\n  false,\n  null,\n  "136b37b8",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = "js/components/singlePageFans.vue"\n/* harmony default export */ __webpack_exports__["default"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9jb21wb25lbnRzL3NpbmdsZVBhZ2VGYW5zLnZ1ZT9iM2ExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBeUc7QUFDdkM7QUFDTDs7O0FBRzdEO0FBQzBGO0FBQzFGLGdCQUFnQixtSEFBVTtBQUMxQixFQUFFLG9GQUFNO0FBQ1IsRUFBRSw2R0FBTTtBQUNSLEVBQUUsc0hBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJLEtBQVUsRUFBRSxZQWlCZjtBQUNEO0FBQ2UsZ0YiLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL3NpbmdsZVBhZ2VGYW5zLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xMzZiMzdiOCZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9zaW5nbGVQYWdlRmFucy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL3NpbmdsZVBhZ2VGYW5zLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMTM2YjM3YjhcIixcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvVXNlcnMvc2hhb2ppYWh1aS9EZXNrdG9wL3NoYW9qaWFodWnlrabkuaDlt6XkvZzmlofku7blpLkvd2Vic2F2ZS9yZS1kYWlseS9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnMTM2YjM3YjgnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnMTM2YjM3YjgnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL3NpbmdsZVBhZ2VGYW5zLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0xMzZiMzdiOCZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCcxMzZiMzdiOCcsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwianMvY29tcG9uZW50cy9zaW5nbGVQYWdlRmFucy52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///67\n')},function(module,exports,__webpack_require__){eval("\nvar content = __webpack_require__(69);\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(4)(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3Mvc2luZ2xlUGFnZS5jc3M/OTZlYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQTJEOztBQUVqRiw0Q0FBNEMsUUFBUzs7QUFFckQ7QUFDQTs7OztBQUlBLGVBQWU7O0FBRWY7QUFDQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsQ0FBZ0Q7O0FBRXJFOztBQUVBLEdBQUcsS0FBVSxFQUFFIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc2luZ2xlUGFnZS5jc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc2luZ2xlUGFnZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3NpbmdsZVBhZ2UuY3NzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68\n")},function(module,exports,__webpack_require__){eval('exports = module.exports = __webpack_require__(3)(false);\n// Module\nexports.push([module.i, "*{\\n    /*border: 1px solid #000000;*/\\n}\\n.con{\\n    padding: 5px 5px 0 5px;\\n    display: flex;\\n    flex-wrap: wrap;\\n    justify-content: center;\\n}\\n.user{\\n    width: 40%;\\n    height: auto;\\n    margin: 5px auto;\\n}\\n.userHead{\\n    width: 100px;\\n    height: 100px;\\n    margin-left: 5%;\\n    border: 1px solid #000000;\\n    border-radius: 50%;\\n}\\n.tabGroup,.adv{\\n    width: 200px;\\n    min-height: 200px;\\n    max-height: 200px;\\n    display: flex;\\n    padding: 10px;\\n    flex-wrap: wrap;\\n    flex-direction: column;\\n    box-shadow: 0px 0px 2px #333333;\\n}\\n.tabGroup{\\n    position: fixed;\\n}\\n.help{\\n    width: 200px;\\n    height: 200px;\\n}\\n.tab{\\n    width: 100%;\\n    padding: 5px 20px;\\n    float: left;\\n    cursor: pointer;\\n    text-align: center;\\n}\\n.tab:not(:last-child){\\n    border-bottom: 1px solid #333333;\\n}\\n.main{\\n    width: 60%;\\n    margin: 0 5px;\\n    box-shadow: 0px 0px 2px #333333;\\n}", ""]);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9jc3Mvc2luZ2xlUGFnZS5jc3M/NWI5NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsbUJBQU8sQ0FBQyxDQUFnRDtBQUNuRjtBQUNBLGNBQWMsUUFBUyxLQUFLLGtDQUFrQyxLQUFLLE9BQU8sNkJBQTZCLG9CQUFvQixzQkFBc0IsOEJBQThCLEdBQUcsUUFBUSxpQkFBaUIsbUJBQW1CLHVCQUF1QixHQUFHLFlBQVksbUJBQW1CLG9CQUFvQixzQkFBc0IsZ0NBQWdDLHlCQUF5QixHQUFHLGlCQUFpQixtQkFBbUIsd0JBQXdCLHdCQUF3QixvQkFBb0Isb0JBQW9CLHNCQUFzQiw2QkFBNkIsc0NBQXNDLEdBQUcsWUFBWSxzQkFBc0IsR0FBRyxRQUFRLG1CQUFtQixvQkFBb0IsR0FBRyxPQUFPLGtCQUFrQix3QkFBd0Isa0JBQWtCLHNCQUFzQix5QkFBeUIsR0FBRyx3QkFBd0IsdUNBQXVDLEdBQUcsUUFBUSxpQkFBaUIsb0JBQW9CLHNDQUFzQyxHQUFHIiwiZmlsZSI6IjY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIqe1xcbiAgICAvKmJvcmRlcjogMXB4IHNvbGlkICMwMDAwMDA7Ki9cXG59XFxuLmNvbntcXG4gICAgcGFkZGluZzogNXB4IDVweCAwIDVweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC13cmFwOiB3cmFwO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuLnVzZXJ7XFxuICAgIHdpZHRoOiA0MCU7XFxuICAgIGhlaWdodDogYXV0bztcXG4gICAgbWFyZ2luOiA1cHggYXV0bztcXG59XFxuLnVzZXJIZWFke1xcbiAgICB3aWR0aDogMTAwcHg7XFxuICAgIGhlaWdodDogMTAwcHg7XFxuICAgIG1hcmdpbi1sZWZ0OiA1JTtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgIzAwMDAwMDtcXG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xcbn1cXG4udGFiR3JvdXAsLmFkdntcXG4gICAgd2lkdGg6IDIwMHB4O1xcbiAgICBtaW4taGVpZ2h0OiAyMDBweDtcXG4gICAgbWF4LWhlaWdodDogMjAwcHg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIHBhZGRpbmc6IDEwcHg7XFxuICAgIGZsZXgtd3JhcDogd3JhcDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAycHggIzMzMzMzMztcXG59XFxuLnRhYkdyb3Vwe1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxufVxcbi5oZWxwe1xcbiAgICB3aWR0aDogMjAwcHg7XFxuICAgIGhlaWdodDogMjAwcHg7XFxufVxcbi50YWJ7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBwYWRkaW5nOiA1cHggMjBweDtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbn1cXG4udGFiOm5vdCg6bGFzdC1jaGlsZCl7XFxuICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjMzMzMzMzO1xcbn1cXG4ubWFpbntcXG4gICAgd2lkdGg6IDYwJTtcXG4gICAgbWFyZ2luOiAwIDVweDtcXG4gICAgYm94LXNoYWRvdzogMHB4IDBweCAycHggIzMzMzMzMztcXG59XCIsIFwiXCJdKTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///69\n')}]);